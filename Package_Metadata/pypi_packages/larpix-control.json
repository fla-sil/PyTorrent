{"info": {"author": "Peter Madigan and Sam Kohn", "author_email": "pmadigan@lbl.gov", "bugtrack_url": null, "classifiers": ["Development Status :: 4 - Beta", "Intended Audience :: Science/Research", "Programming Language :: Python :: 2", "Programming Language :: Python :: 3"], "description": "# larpix-control\n\nControl the LArPix chip\n\n[![Documentation Status](https://readthedocs.org/projects/larpix-control/badge/?version=stable)](https://larpix-control.readthedocs.io/en/stable/?badge=stable)\n[![Build Status](https://travis-ci.com/larpix/larpix-control.svg?branch=master)](https://travis-ci.com/larpix/larpix-control)\n\n## Setup and installation\n\nThis code is intended to work on both Python 2.7+ and Python 3.6+.\n\nInstall larpix-control from pip with\n\n```\npip install larpix-control\n```\n\nTo return your namespace to the pre-larpix state, just\nrun `pip uninstall larpix-control`. If you'd prefer to download the code\nyourself, you can. Just run `pip install .` from the root directory of\nthe repository.\n\n### Tests\n\nYou can run tests to convince yourself that the software works as\nexpected. After `pip install`ing this package, you can run the tests\nfrom the repository root directory with the simple command `pytest`.\n\nYou can read the tests to see examples of how to call all of the common\nfunctions.\n\n## File structure\n\nThe larpix package contains:\n```\nlarpix\n\u251c\u2500\u2500 __init__.py\n\u251c\u2500\u2500 bitarrayhelper.py\n\u251c\u2500\u2500 chip.py\n\u251c\u2500\u2500 configs\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 __init__.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 chip\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 __init__.py\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 csa_bypass.json\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 default.json\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 default_v2.json\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 physics.json\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 quiet.json\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 controller\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 __init__.py\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 pcb-10_chip_info.json\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 pcb-1_chip_info.json\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 pcb-2_chip_info.json\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 pcb-3_chip_info.json\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 pcb-4_chip_info.json\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 pcb-5_chip_info.json\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 pcb-6_chip_info.json\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 v2_example.json\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 io\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 __init__.py\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 daq-srv1.json\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 daq-srv2.json\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 daq-srv3.json\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 daq-srv4.json\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 daq-srv5.json\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 daq-srv6.json\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 daq-srv7.json\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 default.json\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 loopback.json\n\u251c\u2500\u2500 configuration\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 __init__.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 configuration.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 configuration_v1.py\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 configuration_v2.py\n\u251c\u2500\u2500 controller.py\n\u251c\u2500\u2500 example.py\n\u251c\u2500\u2500 format\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 __init__.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 hdf5format.py\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 message_format.py\n\u251c\u2500\u2500 io\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 __init__.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 fakeio.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 io.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 multizmq_io.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 serialport.py\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 zmq_io.py\n\u251c\u2500\u2500 key.py\n\u251c\u2500\u2500 larpix.py\n\u251c\u2500\u2500 logger\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 __init__.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 h5_logger.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 logger.py\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 stdout_logger.py\n\u251c\u2500\u2500 packet\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 __init__.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 message_packet.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 packet_collection.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 packet_v1.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 packet_v2.py\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 timestamp_packet.py\n\u251c\u2500\u2500 quickstart.py\n\u251c\u2500\u2500 serial_helpers\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 __init__.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 analyzers.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 dataformatter.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 dataloader.py\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 datalogger.py\n\u2514\u2500\u2500 timestamp.py\n```\n\n## Minimal working example\n\nSo you're not a tutorials kind of person. Here's a minimal working\nexample for you to play around with:\n\n```python\n>>> from larpix import Controller, Packet_v2\n>>> from larpix.io import FakeIO\n>>> from larpix.logger import StdoutLogger\n>>> controller = Controller()\n>>> controller.io = FakeIO()\n>>> controller.logger = StdoutLogger(buffer_length=0)\n>>> controller.logger.enable()\n>>> chip1 = controller.add_chip('1-1-2', version=2)  # (access key)\n>>> chip1.config.threshold_global = 25\n>>> controller.write_configuration('1-1-2', chip1.config.register_map['threshold_global']) # chip key, register 64\n[ Key: 1-1-2 | Chip: 2 | Upstream | Write | Register: 64 | Value: 25 | Parity: 1 (valid: True) ]\nRecord: [ Key: 1-1-2 | Chip: 2 | Upstream | Write | Register: 64 | Value: 25 | Parity: 1 (valid: True) ]\n>>> packet = Packet_v2(b'\\x02\\x91\\x15\\xcd[\\x07\\x85\\x00')\n>>> packet_bytes = packet.bytes()\n>>> pretend_input = ([packet], packet_bytes)\n>>> controller.io.queue.append(pretend_input)\n>>> controller.run(0.05, 'test run')\nRecord: [ Key: None | Chip: 2 | Downstream | Data | Channel: 5 | Timestamp: 123456789 | First packet: 0 | Dataword: 145 | Trigger: normal | Local FIFO ok | Shared FIFO ok | Parity: 0 (valid: True) ]\n>>> print(controller.reads[0])\n[ Key: None | Chip: 2 | Downstream | Data | Channel: 5 | Timstamp: 123456789 | Dataword: 145 | Trigger: normal | Local FIFO ok | Shared FIFO ok | Parity: 0 (valid: True) ]\n```\n\n## Tutorial\n\nThis tutorial runs through how to use all of the main functionality of\nlarpix-control.\n\nTo access the package contents, use one of the two following `import`\nstatements:\n\n```python\nimport larpix  # use the larpix namespace\n# or ...\nfrom larpix import *  # import all core larpix classes into the current namespace\n```\n\nThe rest of the tutorial will assume you've imported all of the core larpix\nclasses via a ``from larpix import *`` command.\n\n### Create a LArPix Controller\n\nThe LArPix Controller translates high-level ideas like \"read\nconfiguration register 10\" into communications to and from LArPix ASICs,\nand interprets the received data into a usable format.\n\nController objects communicate with LArPix ASICs via an IO interface.\nCurrently available IO interfaces are ``SerialPort``, ``ZMQ_IO`` and\n``FakeIO``. We'll work with ``FakeIO`` in this tutorial, but all the\ncode will still work with properly initialized versions of the other IO\ninterfaces.\n\nSet things up with\n\n```python\nfrom larpix.io import FakeIO\nfrom larpix.logger import StdoutLogger\ncontroller = Controller()\ncontroller.io = FakeIO()\ncontroller.logger = StdoutLogger(buffer_length=0)\ncontroller.logger.enable()\n```\n\nThe ``FakeIO`` object imitates a real IO interface for testing purposes.\nIt directs its output to stdout (i.e. it prints the output), and it\ntakes its input from a manually-updated queue. At the end of each\nrelevant section of the tutorial will be code for adding the expected\noutput to the queue. You'll have to refill the queue each time you run\nthe code.\n\nSimilarly, the ``StdoutLogger`` mimics the real logger interface for testing. It\nprints nicely formatted records of read / write commands to stdout every\n``buffer_length`` packets. The logger interface requires enabling the\nlogger before messages will be stored. Before ending the python session, every\nlogger should be disabled to flush any remaining packets stored in the buffer.\n\n### Set up LArPix Chips\n\nChip objects represent actual LArPix ASICs. For each ASIC you want to\ncommunicate with, create a LArPix Chip object and add it to the\nController.\n\n```python\nchipid = 5\nchip_key = '1-1-5'\nchip5 = controller.add_chip(chip_key, version=2)\n\nchip5 = controller[chip_key] # get chip object\nchip5 = controller[1,1,5] # gets same chip object\n```\n\nThe `chip_key` field specifies the necessary information for the `controller.io`\nobject to route packets to/from the chip. The details of how this key maps to a\nphysical chip is implemented separately for each `larpix.io` class.\n\nThe key itself consists of 3 1-byte integer values that represent the 3\nlow-level layers in larpix readout:\n\n  - the io group: this is the highest layer and represents a control system that\n  communicates with multiple IO channels\n\n  - the io channel: this is the middle layer and represents a single MOSI/MISO\n  pair\n\n  - the chip id: this is the lowest layer and represents a single chip on a\n  MOSI/MISO network\n\nIf you want to interact with chip keys directly, you can instantiate one using\na valid keystring (three 1-byte integers separated by dashes, e.g. ``'1-1-2'``).\nPlease note that the ids of 0, 1, and 255 are reserved for special functions.\n\n```python\nfrom larpix import Key\nexample_key = Key(1,2,3)\n```\n\nYou can grab relevant information from the key via a number of useful methods\nand attributes:\n\n```python\nexample_key.io_group  # 1\nexample_key.io_channel  # 2\nexample_key.chip_id  # 3\nexample_key.to_dict() # returns a dict with the above keys / values\n```\n\nIf you are using a ``Key`` in a script, we recommend that you generate the keys\nvia the ``Key(<io_group>,<io_channel>,<chip_id>)`` method which will protect against updates to the keystring\nformatting.\n\nYou can read the docs to learn more about ``Key`` functionality.\n\n### Set up LArPix Hydra network\n\nThe controller object contains an internal structure representing the Hydra\nnetworks on each of the io channels. This structure can be accessed via\n``controller.network`` and modified using the ``controller.add_network_node``\nand ``controller.add_network_link`` methods. However, it can be a tedious\nand error-prone process to add each link to the network representation. So,\nthere exists a friendlier [configuration file](https://larpix-control.readthedocs.io/en/stable/api/configs/controller.html) that is used to generate these network links.\n\nTo load a network configuration into the controller:\n\n```python\ncontroller.load('controller/v2_example.json')\nprint(controller.chips) # chips that have been loaded into controller\nlist(controller.network[1][1]['miso_ds'].edges) # all links contained in the miso_ds graph\nlist(controller.network[1][1]['miso_us'].nodes) # all nodes within the miso_us graph\nlist(controller.network[1][1]['mosi'].edges) # all links within the mosi graph\n```\n\nEach graph is represented by a networkx directed graph and can be examined and\nqueried in that way. All edges point in the direction of data flow.\n\n```python\nlist(controller.network[1][1]['mosi'].in_edges(2)) # all links pointing to chip 2 in mosi graph\nlist(controller.network[1][1]['miso_ds'].successors(3)) # all chips receiving downstream data packets from chip 3\ncontroller.network[1][1]['mosi'].edges[(3,2)]['uart'] # check the physical uart channel that chip 2 listens to chip 3 via\ncontroller.network[1][1]['mosi'].nodes[2]['root'] # check if designated root chip\n```\n\nAfter loading the network into the controller, the ``init_network`` command\nautomates the process of bringing up individual chips in the network.\n\n```python\ncontroller.init_network(1,1) # issues packets required to initialize the 1,1 hydra network\nprint(controller['1-1-2'].config.chip_id)\nprint(controller['1-1-3'].config.enable_miso_downstream)\n```\n\nThis issues configuration commands in the proper order so that upstream chips\nare configured before downstream chips. If you'd like to reset the network\nconfiguration\n\n```python\ncontroller.reset_network(1,1)\n```\n\ncan be used to reverse the configuration commands issued with ``init_network``.\nThese processes are not \"smart\" in that they blindly issue config commands\nassuming the network is either fully configured or in a default state, so buyer\nbeware.\n\nThe network initialization can be broken down into single steps by also passing\nalong the chip id:\n\n```python\ncontroller.init_network(1,1,2) # configures only chip 2\ncontroller.init_network(1,1,3) # configures only chip 3\n```\n\nBut this requires initializing the chips in the proper order. You can get the\nchip keys in order of their depth within the network via\n\n```python\ncontroller.get_network_keys(1,1) # gets a list of chip keys starting at the root node and descending\ncontroller.get_network_keys(1,1,root_first_traversal=False) # get list of chip keys starting at deepest chips and ascending\n```\n\n\n### Adjust the configuration of the LArPix Chips\n\nEach Chip object manages its own configuration in software.\nConfigurations can be adjusted by name using attributes of the Chip's\nconfiguration:\n\n```python\nchip5.config.threshold_global = 35  # entire register = 1 number\nchip5.config.enable_periodic_reset = 1  # one bit as part of a register\nchip5.config.channel_mask[20] = 1  # one bit per channel\n```\n\nValues are validated, and invalid values will raise exceptions.\n\nNote: Changing the configuration of a Chip object does *not* change the\nconfiguration on the ASIC.\n\nOnce the configuration is set, the new values must be sent to the LArPix\nASICs. There is an appropriate Controller method for that:\n\n```python\ncontroller.write_configuration(chip_key)  # send all registers\ncontroller.write_configuration(chip_key, 32)  # send only register 32\ncontroller.write_configuration(chip_key, [32, 50])  # send registers 32 and 50\n```\n\nRegister addresses can be looked up using the configuration object:\n\n```python\nthreshold_global_reg = chip5.config.register_map['threshold_global']\n```\n\nAnd register names:\n\n```python\nthreshold_global_name = chip.5.config.register_map_inv[64]\n```\n\nFor configurations which extend over multiple registers, the relevant\nattribute will end in ``_addresses``. Certain configurations share a\nsingle register, whose attribute has all of the names in it. View the\ndocumentation or source code to find the name to look up. (Or look at\nthe LArPix data sheet.)\n\n### Reading the configuration from LArPix ASICs\n\nThe current configuration state of the LArPix ASICs can be requested by\nsending out \"configuration read\" requests using the Controller:\n\n```python\ncontroller.read_configuration(chip_key)\n```\n\nThe same variations to read only certain registers are implemented for\nreading as for writing.\n\nThe responses from the LArPix ASICs are stored for inspection. See the\nsection on \"Inspecting received data\" for more.\n\nFakeIO queue code:\n\n```python\npackets = chip5.get_configuration_read_packets()\nbytestream = b'bytes for the config read packets'\ncontroller.io.queue.append((packets, bytestream))\n```\n\n### Receiving data from LArPix ASICs\n\nWhen it is first initialized, the LArPix Controller ignores and discards\nall data that it receives from LArPix. The Controller must be activated\nby calling ``start_listening()``. All received data will then be\naccumulated in an implementation-dependent queue or buffer, depending\non the IO interface used. To read the data from the buffer, call the\ncontroller's ``read()`` method, which returns both the raw bytestream\nreceived as well as a list of LArPix Packet objects which have been\nextracted from the bytestream. To stop listening for new data, call\n``stop_listening()``. Finally, to store the data in the controller\nobject, call the ``store_packets`` method. All together:\n\n```python\ncontroller.start_listening()\n# Data arrives...\npackets, bytestream = controller.read()\n# More data arrives...\npackets2, bytestream2 = controller.read()\ncontroller.stop_listening()\nmessage = 'First data arrived!'\nmessage2 = 'More data arrived!'\ncontroller.store_packets(packets, bytestream, message)\ncontroller.store_packets(packets, bytestream2, message2)\n```\n\nThere is a common pattern for reading data, namely to start listening,\nthen check in periodically for new data, and then after a certain amount\nof time has passed, stop listening and store all the data as one\ncollection. The method ``run(timelimit, message)`` accomplishes just this.\n\n```python\nduration = 10  # seconds\nmessage = '10-second data run'\ncontroller.run(duration, message)\n```\n\nFakeIO queue code for the first code block:\n\n```python\npackets = [Packet_v2()] * 40\nbytestream = b'bytes from the first set of packets'\ncontroller.io.queue.append((packets, bytestream))\npackets2 = [Packet_v2()] * 30\nbytestream2 = b'bytes from the second set of packets'\ncontroller.io.queue.append((packets2, bytestream2))\n```\n\nfakeIO queue code for the second code block:\n\n```python\npackets = [Packet_v2()] * 5\nbytestream = b'[bytes from read #%d] '\nfor i in range(100):\n    controller.io.queue.append((packets, bytestream%i))\n```\n\n### Inspecting received data\n\nOnce data is stored in the controller, it is available in the ``reads``\nattribute as a list of all data runs. Each element of the list is a\nPacketCollection object, which functions like a list of Packet objects\neach representing one LArPix packet.\n\nPacketCollection objects can be indexed like a list:\n\n```python\nrun1 = controller.reads[0]\nfirst_packet = run1[0]  # Packet object\nfirst_ten_packets = run1[0:10]  # smaller PacketCollection object\n\nfirst_packet_bits = run1[0, 'bits']  # string representation of bits in packet\nfirst_ten_packet_bits = run1[0:10, 'bits']  # list of strings\n```\n\nPacketCollections can be printed to display the contents of the Packets\nthey contain. To prevent endless scrolling, only the first ten and last ten\npackets are displayed, and the number of omitted packets is noted. To\nview the omitted packets, use a slice around the area of interest.\n\n```python\nprint(run1)  # prints the contents of the packets\nprint(run1[10:30])  # prints 20 packets from the middle of the run\n```\n\nIn interactive Python, returned objects are not printed, but rather\ntheir \"representation\" is printed (cf. the ``__repr__`` method). The\nrepresentation of PacketCollections is a listing of the number of\npackets, the \"read id\" (a.k.a. the run number), and the message\nassociated with the PacketCollection when it was created.\n\n### Individual LArPix Packets\n\nLArPix Packet objects represent individual LArPix UART packets. They\nhave attributes which can be used to inspect or modify the contents of\nthe packet.\n\n```python\npacket = run1[0]\n# all packets\npacket.packet_type  # unique in that it gives the bits representation\npacket.chip_id  # all other properties return Python numbers\npacket.chip_key # key for association to a unique chip (can be None)\npacket.parity\npacket.downstream_marker\n\n# data packets\npacket.channel_id\npacket.dataword\npacket.timestamp\npacket.trigger_type\npacket.local_fifo\npacket.shared_fifo\n# config packets\npacket.register_address\npacket.register_data\n\n```\n\nInternally, packets are represented as an array of bits, and the\ndifferent attributes use Python \"properties\" to seamlessly convert\nbetween the bits representation and a more intuitive integer\nrepresentation. The bits representation can be inspected with the\n``bits`` attribute.\n\nPacket objects do not restrict you from adjusting an attribute for an\ninappropriate packet type. For example, you can create a data packet and\nthen set ``packet.register_address = 5``. This will adjust the packet\nbits corresponding to a configuration packet's \"register\\_address\"\nregion, which is probably not what you want for your data packet.\n\nPackets have a parity bit which enforces odd parity, i.e. the sum of\nall the individual bits in a packet must be an odd number. The parity\nbit can be accessed as above using the ``parity`` attribute.\nThe correct parity bit can be computed using ``compute_parity()``,\nand the validity of a packet's parity can be checked using\n``has_valid_parity()``. When constructing a new packet, the correct\nparity bit can be assigned using ``assign_parity()``.\n\nIndividual packets can be printed to show a human-readable\ninterpretation of the packet contents. The printed version adjusts its\noutput based on the packet type, so a data packet will show the data\nword, timestamp, etc., while a configuration packet will show the register\naddress and register data.\n\nLike with PacketCollections, Packets also have a \"representation\" view\nbased on the bytes that make up the packet. This can be useful for\ncreating new packets since a Packet's representation is also a vaild\ncall to the Packet constructor. So the output from an interactive\nsession can be copied as input or into a script to create the same\npacket.\n\nWith the v2 chip, more information about the internal fifo can be gathered by\nrunning with fifo diagonstics enabled on a given asic. In this case, the bits of\neach packet are to be interpreted differently. Each packet object can be set to\nbe interpreted in this mode via the ``fifo_diagnostics_enabled`` flag. See the\nPacket_v2 [documentation](https://larpix-control.readthedocs.io/en/stable/) for\nmore details.\n\n### Logging communications with LArPix ASICs using the HDF5Logger\n\nTo create a permanent record of communications with the LArPix ASICs, an\n`HDF5Logger` is used. To create a new logger\n\n```python\nfrom larpix.logger import HDF5Logger\ncontroller.logger = HDF5Logger(filename=None, buffer_length=10000) # a filename of None uses the default filename formatting\ncontroller.logger.enable() # starts tracking all communications\n```\n\nYou can also initialize and enable the logger in one call by passing the\n``enabled`` keyword argument (which defaults to ``False``):\n\n```\ncontroller.logger = HDF5Logger(filename=None, enabled=True)\n```\n\nNow whenever you send or receive packets, they will be captured by the logger\nand added to the logger's buffer. Once `buffer_length` packets have been\ncaptured the packets will be written out to the file. You can force the logger\nto dump the currently held packets at any time using `HDF5Logger.flush()`\n\n```python\ncontroller.verify_configuration()\ncontroller.logger.flush()\n```\n\nIn the event that you want to temporarily stop tracking communications,\nthe `disable` and `enable` commands do exactly what you think they might.\n\n```python\ncontroller.logger.disable() # stop tracking\n# any communication here is ignored\ncontroller.logger.enable() # start tracking again\ncontroller.logger.is_enabled() # returns True if tracking\n```\n\nOnce you have finished your tests, be sure to disable the logger. If you do not,\nyou will lose any data still in the buffer of the logger object. We strongly recommend\nwrapping logger code with a `try, except` statement if you can. Any remaining\npackets in the buffer are flushed to the file upon disabling.\n\n```python\ncontroller.logger.disable()\n```\n\n### Viewing data from the HDF5Logger\n\nThe ``HDF5Logger`` uses a format called LArPix+HDF5v1.0 that is specified in\nthe ``larpix.format.hdf5format`` module (and\n[documentation](https://larpix-control.readthedocs.io/en/stable/)\nstarting in v2.3.0). That module contains a ``to_file`` method which is\nused internally by ``HDF5Logger`` and a ``from_file`` method that you\ncan use to load the file contents back into LArPix Control. The\nLArPix+HDF5 format is a \"plain HDF5\" format that can be inspected with\n``h5py`` or any language's HDF5 binding.\n\nTo open the HDF5 file from python\n\n```python\nimport h5py\ndatafile = h5py.File('<filename>')\n```\n\nWithin the datafile there is one group (`'_header'`) and two datasets\n(``'packets'`` and ``'messages'``). The header group contains some useful meta information about\nwhen the datafile was created and the file format version number, stored as\nattributes.\n\n```python\nlist(datafile.keys()) # ['_header', 'messages', 'packets']\nlist(datafile['_header'].attrs) # ['created', 'modified', version']\n```\n\nThe packets are stored sequentially as a `numpy` mixed-type arrays within the\nrows of the HDF5 dataset. The columns refer to the element of the numpy mixed\ntype array. The specifics of the data type and entries are set by the\n``larpix.format.hdf5format.dtype`` object - see the larpix-control docs for more information.\nYou can inspect a packet as a tuple simply by accessing its respective position within the\nHDF5 dataset.\n\n```python\nraw_value = datafile['packets'][0] # e.g. (b'0-246', 3, 246, 1, 1, -1, -1, -1, -1, -1, -1, 0, 0)\nraw_values = datafile['packets'][-100:] # last 100 packets in file\n```\n\nIf you want to make use of `numpy`'s mixed type arrays, you can convert the\nraw values to the proper encoding by retrieving it as a list (of length\n1, for example) via\n\n```python\npacket_repr = raw_values[0:1] # list with one element\npacket_repr['chip_id'] # chip key for packet, e.g. 246\npacket_repr['dataword'] # list of ADC values for each packet\npacket_repr.dtype # description of data type (with names of each column)\n```\n\nYou can also view entire \"columns\" of data:\n\n```python\n# all packets' ADC counts, including non-data packets\nraw_values['dataword']\n# Select based on data type using a numpy bool / \"mask\" array:\nraw_values['dataword'][raw_values['packet_type'] == 0] # all data packets' ADC counts\n```\n\n``h5py`` and ``numpy`` optimize the retrieval of data so you can read\ncertain columns or rows without loading the entire data file into memory.\n\nDon't forget to close the file when you are done. (Not necessary in\ninteractive python sessions if you are about to quit.)\n\n```python\ndatafile.close()\n```\n\n## Running with a Bern DAQ board (v1 asic)\n\nSince you have completed the tutorial with the `FakeIO` class, you are now ready\nto interface with some LArPix ASICs. If you have a Bern DAQ v2-3 setup you can\nfollow along with the rest of the tutorial.\n\nBefore you can configure the system, you will need to generate a configuration\nfile for the ZMQ_IO or MultiZMQ_IO interface. This provides the mapping from\nchip keys to physical devices. In the case of the ZMQ interface, it maps\nio group #s to the IP address of the DAQ board. A number of example\nconfigurations are provided in the installation under\n``larpix/configs/io/<config name>.json``, which may work for your purposes. We\nrecommend reading the docs about how to create one of these configuration files.\nBy default the system looks for configuration in the pwd, before looking for the\ninstallation files. If you only have one DAQ board on your network, likely\nyou will load the ``io/daq-srv<#>.json`` configuration.\n\nWith the DAQ system up and running\n```python\n>>> from larpix import Controller\n>>> from larpix.io import ZMQ_IO\n>>> controller = Controller()\n>>> controller.io = ZMQ_IO(config_filepath='<path to config>')\n>>> controller.load('controller/pcb-<#>_chip_info.json')\n>>> controller.io.ping()\n>>> for key,chip in controller.chips.items():\n...     chip.config.load('chip/quiet.json')\n...     print(key, chip.config)\n...     controller.write_configuration(key)\n>>> controller.run(1,'checking the data rate')\n>>> controller.reads[-1]\n<PacketCollection with 0 packets, read_id 0, 'checking the data rate'>\n```\nThis should give you a quiet state with no data packets. Occasionally, there can\nbe a few packets left in one of the system buffers (LArPix, FPGA, DAQ server). A\nsecond run command should return without any new packets.\n\nIf you are using the v1.5 anode, you may need to reconfigure the miso/mosi mapping (since the miso/mosi pair for a daisy chain is not necessarily on a single channel). To do this, pass a `miso_map` or `mosi_map` to the `ZMQ_IO` object on initialization:\n```python\n>>> controller.io = ZMQ_IO(config_filepath='<path to config>', miso_map={2:1}) # relabels packets received on channel 2 as packets from channel 1\n```\n\n### Check configurations\nIf you are still receiving data, you can check that the hardware chip configuration\nmatch the software chip configurations with\n```python\n>>> controller.verify_configuration()\n(True, {})\n```\nIf the configuration read packets don't match the software chip configuration, this\nwill return\n```python\n>>> controller.verify_configuration()\n(False, {<register>: (<expected>, <received>), ...})\n```\nMissing packets will show up as\n```python\n>>> controller.verify_configuration()\n(False, {<register>: (<expected>, None), ...})\n```\nIf your configurations match, and you still receive data then you are likely seeing\nsome pickup on the sensor from the environment -- *good luck!*\n\n### Enable a single channel\n```python\n>>> chip_key = '1-1-3'\n>>> controller.disable() # mask off all channel\n>>> controller.enable(chip_key, [0]) # enable channel 0 of chip\n```\n\n### Set the global threshold of a chip\n```python\n>>> controller.chips[chip_key].config.global_threshold = 40\n>>> controller.write_configuration(chip_key)\n>>> controller.verify_configuration(chip_key)\n(True, {})\n```\n\n### Inject a pulse into a specific channel\n```python\n>>> controller.enable_testpulse(chip_key, [0]) # connect channel 0 to the test pulse circuit and initialize the internal DAC to 255\n>>> controller.issue_testpulse(chip_key, 10) # inject a pulse of size 10DAC by stepping down the DAC\n<PacketCollection with XX packets, read_id XX, \"configuration write\">\n>>> controller.disable_testpulse(chip_key) # disconnect test pulse circuit from all channels on chip\n```\nYou will need to periodically reset the DAC to 255, otherwise you will receive a\n`ValueError` once the DAC reaches the minimum specified value.\n```python\n>>> controller.enable_testpulse(chip_key, [0], start_dac=255)\n>>> controller.issue_testpulse(chip_key, 50, min_dac=200) # the min_dac keyword sets the lower bound for the DAC (useful to avoid non-linearities at around 70-80DAC)\n<PacketCollection with XX packets, read_id XX, \"configuration write\">\n>>> controller.issue_testpulse(chip_key, 50, min_dac=200)\nValueError: Minimum DAC exceeded\n>>> controller.enable_testpulse(chip_key, [0], start_dac=255)\n>>> controller.issue_testpulse(chip_key, 50, min_dac=200)\n<PacketCollection with XX packets, read_id XX, \"configuration write\">\n\n```\n\n### Enable the analog monitor on a channel\n```python\n>>> controller.enable_analog_monitor(chip_key, 0) # drive buffer output of channel 0 out on analog monitor line\n>>> controller.disable_analog_monitor(chip_key) # disable the analog monitor on chip\n```\nWhile the software enforces that only one channel per chip is being driven out on\nthe analog monitor, you must disable the analog monitor if moving between chips.\n\n\n## Miscellaneous implementation details\n\n### Endian-ness\n\nWe use the convention that the LSB is sent out first and read in first.\nThe location of the LSB in arrays and lists changes from object to\nobject based on the conventions of the other packages we interact with.\n\nIn particular, pyserial sends out index 0 first, so for `bytes` objects,\nindex 0 will generally have the LSB. On the other hand, bitstrings\ntreats the _last_ index as the LSB, which is also how numbers are\nusually displayed on screen, e.g. `0100` in binary means 4 not 2. So for\n`BitArray` and `Bits` objects, the LSB will generally be last.\n\nNote that this combination leads to the slightly awkward convention that\nthe least significant bit of a bytestring is the *last bit* of the\n*first byte*. For example, if bits[15:0] of a packet are\n`0000 0010 0000 0001` ( = 0x0201 = 513), then the bytes will be sent out as\n`b'\\x01\\x02'`.\n\n### The Configuration object\n\nThe `Configuration` object represents all of the options in the LArPix\nconfiguration register. Each row in the configuration table in the LArPix datasheet\nhas a corresponding attribute in the `Configuration` object. Per-channel\nattributes are stored in a list, and all other attributes are stored as\na simple integer. (This includes everything from single bits to values\nsuch as \"reset cycles,\" which spans 3 bytes.)\n\n`Configuration` objects also have some helper methods for enabling and\ndisabling per-channel settings (such as `csa_testpulse_enable` or\n`channel_mask`). The relevant methods are listed here and should be\nprefixed with either `enable_` or `disable_`:\n\n - `channels` enables/disables the `channel_mask` register\n - `external_trigger` enables/disables the `external_trigger_mask`\n    register\n - `testpulse` enables/disables the `csa_testpulse_enable` register\n - `analog_monitor` enables/disables the `csa_monitor_select` register\n\nMost of these methods accept an optional list of channels to enable or\ndisable (and with no list specified acts on all channels). The exception\nis `enable_analog_monitor` (and its `disable` counterpart): the `enable`\nmethod requires a particular channel to be specified, and the `disable`\nmethod does not require any argument at all. This is because at most one\nchannel is allowed to have the analog monitor enabled.\n\nThe machinery of the `Configuration` object ensures that each value is\nconverted to the appropriate set of bits when it comes time to send\nactual commands to the physical chip. Although this is not transparent\nto you as a user of this library, you might want to know that two sets of\nconfiguration options are always sent together in the same configuration\npacket:\n\n - `csa_gain`, `csa_bypass`, and `internal_bypass` are combined into a\n   single byte, so even though they have their own attributes, they must\n   be written to the physical chip together\n\n - `test_mode`, `cross_trigger_mode`, `periodic_reset`, and\n   `fifo_diagnostic` work the same way\n\nSimilarly, all of the per-channel options (except for the pixel trim\nthresholds) are sent in 4 groups of 8 channels.\n\nConfigurations can be loaded by importing `larpix.configs` and running\nthe `load` function. This function searches for a configuration with the\ngiven filename relative to the current directory before searching the\n\"system\" location (secretly it's in the larpix/configs/ folder). This is\nsimilar to `#include \"header.h\"` behavior in C.\n\nConfigurations can be saved by calling `chip.config.write` with the\ndesired filename.\n\nOnce the Chip object has been configured, the configuration must be sent\nto the physical chip.\n\n\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/larpix/larpix-control", "keywords": "dune physics", "license": "", "maintainer": "", "maintainer_email": "", "name": "larpix-control", "package_url": "https://pypi.org/project/larpix-control/", "platform": "", "project_url": "https://pypi.org/project/larpix-control/", "project_urls": {"Homepage": "https://github.com/larpix/larpix-control"}, "release_url": "https://pypi.org/project/larpix-control/3.1.1/", "requires_dist": ["pyserial (~=3.4)", "pytest (~=4.2)", "bitarray (~=0.8)", "pyzmq (~=16.0)", "sphinx-rtd-theme (~=0.4.2)", "numpy (~=1.16)", "h5py (~=2.9)", "bidict (~=0.18.0)", "networkx (~=2.2)"], "requires_python": "", "summary": "Control the LArPix chip", "version": "3.1.1", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>larpix-control</h1>\n<p>Control the LArPix chip</p>\n<p><a href=\"https://larpix-control.readthedocs.io/en/stable/?badge=stable\" rel=\"nofollow\"><img alt=\"Documentation Status\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/e54a51567b34606ea904ca3a0ba7169f5551df8f/68747470733a2f2f72656164746865646f63732e6f72672f70726f6a656374732f6c61727069782d636f6e74726f6c2f62616467652f3f76657273696f6e3d737461626c65\"></a>\n<a href=\"https://travis-ci.com/larpix/larpix-control\" rel=\"nofollow\"><img alt=\"Build Status\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/8d2171f3a023a66c424eba4db471f95689d85708/68747470733a2f2f7472617669732d63692e636f6d2f6c61727069782f6c61727069782d636f6e74726f6c2e7376673f6272616e63683d6d6173746572\"></a></p>\n<h2>Setup and installation</h2>\n<p>This code is intended to work on both Python 2.7+ and Python 3.6+.</p>\n<p>Install larpix-control from pip with</p>\n<pre><code>pip install larpix-control\n</code></pre>\n<p>To return your namespace to the pre-larpix state, just\nrun <code>pip uninstall larpix-control</code>. If you'd prefer to download the code\nyourself, you can. Just run <code>pip install .</code> from the root directory of\nthe repository.</p>\n<h3>Tests</h3>\n<p>You can run tests to convince yourself that the software works as\nexpected. After <code>pip install</code>ing this package, you can run the tests\nfrom the repository root directory with the simple command <code>pytest</code>.</p>\n<p>You can read the tests to see examples of how to call all of the common\nfunctions.</p>\n<h2>File structure</h2>\n<p>The larpix package contains:</p>\n<pre><code>larpix\n\u251c\u2500\u2500 __init__.py\n\u251c\u2500\u2500 bitarrayhelper.py\n\u251c\u2500\u2500 chip.py\n\u251c\u2500\u2500 configs\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 __init__.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 chip\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 __init__.py\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 csa_bypass.json\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 default.json\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 default_v2.json\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 physics.json\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 quiet.json\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 controller\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 __init__.py\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 pcb-10_chip_info.json\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 pcb-1_chip_info.json\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 pcb-2_chip_info.json\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 pcb-3_chip_info.json\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 pcb-4_chip_info.json\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 pcb-5_chip_info.json\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 pcb-6_chip_info.json\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 v2_example.json\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 io\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 __init__.py\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 daq-srv1.json\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 daq-srv2.json\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 daq-srv3.json\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 daq-srv4.json\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 daq-srv5.json\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 daq-srv6.json\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 daq-srv7.json\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 default.json\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 loopback.json\n\u251c\u2500\u2500 configuration\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 __init__.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 configuration.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 configuration_v1.py\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 configuration_v2.py\n\u251c\u2500\u2500 controller.py\n\u251c\u2500\u2500 example.py\n\u251c\u2500\u2500 format\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 __init__.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 hdf5format.py\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 message_format.py\n\u251c\u2500\u2500 io\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 __init__.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 fakeio.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 io.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 multizmq_io.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 serialport.py\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 zmq_io.py\n\u251c\u2500\u2500 key.py\n\u251c\u2500\u2500 larpix.py\n\u251c\u2500\u2500 logger\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 __init__.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 h5_logger.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 logger.py\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 stdout_logger.py\n\u251c\u2500\u2500 packet\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 __init__.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 message_packet.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 packet_collection.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 packet_v1.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 packet_v2.py\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 timestamp_packet.py\n\u251c\u2500\u2500 quickstart.py\n\u251c\u2500\u2500 serial_helpers\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 __init__.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 analyzers.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 dataformatter.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 dataloader.py\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 datalogger.py\n\u2514\u2500\u2500 timestamp.py\n</code></pre>\n<h2>Minimal working example</h2>\n<p>So you're not a tutorials kind of person. Here's a minimal working\nexample for you to play around with:</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">from</span> <span class=\"nn\">larpix</span> <span class=\"kn\">import</span> <span class=\"n\">Controller</span><span class=\"p\">,</span> <span class=\"n\">Packet_v2</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">from</span> <span class=\"nn\">larpix.io</span> <span class=\"kn\">import</span> <span class=\"n\">FakeIO</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">from</span> <span class=\"nn\">larpix.logger</span> <span class=\"kn\">import</span> <span class=\"n\">StdoutLogger</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">controller</span> <span class=\"o\">=</span> <span class=\"n\">Controller</span><span class=\"p\">()</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">controller</span><span class=\"o\">.</span><span class=\"n\">io</span> <span class=\"o\">=</span> <span class=\"n\">FakeIO</span><span class=\"p\">()</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">controller</span><span class=\"o\">.</span><span class=\"n\">logger</span> <span class=\"o\">=</span> <span class=\"n\">StdoutLogger</span><span class=\"p\">(</span><span class=\"n\">buffer_length</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">controller</span><span class=\"o\">.</span><span class=\"n\">logger</span><span class=\"o\">.</span><span class=\"n\">enable</span><span class=\"p\">()</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">chip1</span> <span class=\"o\">=</span> <span class=\"n\">controller</span><span class=\"o\">.</span><span class=\"n\">add_chip</span><span class=\"p\">(</span><span class=\"s1\">'1-1-2'</span><span class=\"p\">,</span> <span class=\"n\">version</span><span class=\"o\">=</span><span class=\"mi\">2</span><span class=\"p\">)</span>  <span class=\"c1\"># (access key)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">chip1</span><span class=\"o\">.</span><span class=\"n\">config</span><span class=\"o\">.</span><span class=\"n\">threshold_global</span> <span class=\"o\">=</span> <span class=\"mi\">25</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">controller</span><span class=\"o\">.</span><span class=\"n\">write_configuration</span><span class=\"p\">(</span><span class=\"s1\">'1-1-2'</span><span class=\"p\">,</span> <span class=\"n\">chip1</span><span class=\"o\">.</span><span class=\"n\">config</span><span class=\"o\">.</span><span class=\"n\">register_map</span><span class=\"p\">[</span><span class=\"s1\">'threshold_global'</span><span class=\"p\">])</span> <span class=\"c1\"># chip key, register 64</span>\n<span class=\"p\">[</span> <span class=\"n\">Key</span><span class=\"p\">:</span> <span class=\"mi\">1</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"o\">-</span><span class=\"mi\">2</span> <span class=\"o\">|</span> <span class=\"n\">Chip</span><span class=\"p\">:</span> <span class=\"mi\">2</span> <span class=\"o\">|</span> <span class=\"n\">Upstream</span> <span class=\"o\">|</span> <span class=\"n\">Write</span> <span class=\"o\">|</span> <span class=\"n\">Register</span><span class=\"p\">:</span> <span class=\"mi\">64</span> <span class=\"o\">|</span> <span class=\"n\">Value</span><span class=\"p\">:</span> <span class=\"mi\">25</span> <span class=\"o\">|</span> <span class=\"n\">Parity</span><span class=\"p\">:</span> <span class=\"mi\">1</span> <span class=\"p\">(</span><span class=\"n\">valid</span><span class=\"p\">:</span> <span class=\"kc\">True</span><span class=\"p\">)</span> <span class=\"p\">]</span>\n<span class=\"n\">Record</span><span class=\"p\">:</span> <span class=\"p\">[</span> <span class=\"n\">Key</span><span class=\"p\">:</span> <span class=\"mi\">1</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"o\">-</span><span class=\"mi\">2</span> <span class=\"o\">|</span> <span class=\"n\">Chip</span><span class=\"p\">:</span> <span class=\"mi\">2</span> <span class=\"o\">|</span> <span class=\"n\">Upstream</span> <span class=\"o\">|</span> <span class=\"n\">Write</span> <span class=\"o\">|</span> <span class=\"n\">Register</span><span class=\"p\">:</span> <span class=\"mi\">64</span> <span class=\"o\">|</span> <span class=\"n\">Value</span><span class=\"p\">:</span> <span class=\"mi\">25</span> <span class=\"o\">|</span> <span class=\"n\">Parity</span><span class=\"p\">:</span> <span class=\"mi\">1</span> <span class=\"p\">(</span><span class=\"n\">valid</span><span class=\"p\">:</span> <span class=\"kc\">True</span><span class=\"p\">)</span> <span class=\"p\">]</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">packet</span> <span class=\"o\">=</span> <span class=\"n\">Packet_v2</span><span class=\"p\">(</span><span class=\"sa\">b</span><span class=\"s1\">'</span><span class=\"se\">\\x02\\x91\\x15\\xcd</span><span class=\"s1\">[</span><span class=\"se\">\\x07\\x85\\x00</span><span class=\"s1\">'</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">packet_bytes</span> <span class=\"o\">=</span> <span class=\"n\">packet</span><span class=\"o\">.</span><span class=\"n\">bytes</span><span class=\"p\">()</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">pretend_input</span> <span class=\"o\">=</span> <span class=\"p\">([</span><span class=\"n\">packet</span><span class=\"p\">],</span> <span class=\"n\">packet_bytes</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">controller</span><span class=\"o\">.</span><span class=\"n\">io</span><span class=\"o\">.</span><span class=\"n\">queue</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"n\">pretend_input</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">controller</span><span class=\"o\">.</span><span class=\"n\">run</span><span class=\"p\">(</span><span class=\"mf\">0.05</span><span class=\"p\">,</span> <span class=\"s1\">'test run'</span><span class=\"p\">)</span>\n<span class=\"n\">Record</span><span class=\"p\">:</span> <span class=\"p\">[</span> <span class=\"n\">Key</span><span class=\"p\">:</span> <span class=\"kc\">None</span> <span class=\"o\">|</span> <span class=\"n\">Chip</span><span class=\"p\">:</span> <span class=\"mi\">2</span> <span class=\"o\">|</span> <span class=\"n\">Downstream</span> <span class=\"o\">|</span> <span class=\"n\">Data</span> <span class=\"o\">|</span> <span class=\"n\">Channel</span><span class=\"p\">:</span> <span class=\"mi\">5</span> <span class=\"o\">|</span> <span class=\"n\">Timestamp</span><span class=\"p\">:</span> <span class=\"mi\">123456789</span> <span class=\"o\">|</span> <span class=\"n\">First</span> <span class=\"n\">packet</span><span class=\"p\">:</span> <span class=\"mi\">0</span> <span class=\"o\">|</span> <span class=\"n\">Dataword</span><span class=\"p\">:</span> <span class=\"mi\">145</span> <span class=\"o\">|</span> <span class=\"n\">Trigger</span><span class=\"p\">:</span> <span class=\"n\">normal</span> <span class=\"o\">|</span> <span class=\"n\">Local</span> <span class=\"n\">FIFO</span> <span class=\"n\">ok</span> <span class=\"o\">|</span> <span class=\"n\">Shared</span> <span class=\"n\">FIFO</span> <span class=\"n\">ok</span> <span class=\"o\">|</span> <span class=\"n\">Parity</span><span class=\"p\">:</span> <span class=\"mi\">0</span> <span class=\"p\">(</span><span class=\"n\">valid</span><span class=\"p\">:</span> <span class=\"kc\">True</span><span class=\"p\">)</span> <span class=\"p\">]</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">controller</span><span class=\"o\">.</span><span class=\"n\">reads</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">])</span>\n<span class=\"p\">[</span> <span class=\"n\">Key</span><span class=\"p\">:</span> <span class=\"kc\">None</span> <span class=\"o\">|</span> <span class=\"n\">Chip</span><span class=\"p\">:</span> <span class=\"mi\">2</span> <span class=\"o\">|</span> <span class=\"n\">Downstream</span> <span class=\"o\">|</span> <span class=\"n\">Data</span> <span class=\"o\">|</span> <span class=\"n\">Channel</span><span class=\"p\">:</span> <span class=\"mi\">5</span> <span class=\"o\">|</span> <span class=\"n\">Timstamp</span><span class=\"p\">:</span> <span class=\"mi\">123456789</span> <span class=\"o\">|</span> <span class=\"n\">Dataword</span><span class=\"p\">:</span> <span class=\"mi\">145</span> <span class=\"o\">|</span> <span class=\"n\">Trigger</span><span class=\"p\">:</span> <span class=\"n\">normal</span> <span class=\"o\">|</span> <span class=\"n\">Local</span> <span class=\"n\">FIFO</span> <span class=\"n\">ok</span> <span class=\"o\">|</span> <span class=\"n\">Shared</span> <span class=\"n\">FIFO</span> <span class=\"n\">ok</span> <span class=\"o\">|</span> <span class=\"n\">Parity</span><span class=\"p\">:</span> <span class=\"mi\">0</span> <span class=\"p\">(</span><span class=\"n\">valid</span><span class=\"p\">:</span> <span class=\"kc\">True</span><span class=\"p\">)</span> <span class=\"p\">]</span>\n</pre>\n<h2>Tutorial</h2>\n<p>This tutorial runs through how to use all of the main functionality of\nlarpix-control.</p>\n<p>To access the package contents, use one of the two following <code>import</code>\nstatements:</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">larpix</span>  <span class=\"c1\"># use the larpix namespace</span>\n<span class=\"c1\"># or ...</span>\n<span class=\"kn\">from</span> <span class=\"nn\">larpix</span> <span class=\"kn\">import</span> <span class=\"o\">*</span>  <span class=\"c1\"># import all core larpix classes into the current namespace</span>\n</pre>\n<p>The rest of the tutorial will assume you've imported all of the core larpix\nclasses via a <code>from larpix import *</code> command.</p>\n<h3>Create a LArPix Controller</h3>\n<p>The LArPix Controller translates high-level ideas like \"read\nconfiguration register 10\" into communications to and from LArPix ASICs,\nand interprets the received data into a usable format.</p>\n<p>Controller objects communicate with LArPix ASICs via an IO interface.\nCurrently available IO interfaces are <code>SerialPort</code>, <code>ZMQ_IO</code> and\n<code>FakeIO</code>. We'll work with <code>FakeIO</code> in this tutorial, but all the\ncode will still work with properly initialized versions of the other IO\ninterfaces.</p>\n<p>Set things up with</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">larpix.io</span> <span class=\"kn\">import</span> <span class=\"n\">FakeIO</span>\n<span class=\"kn\">from</span> <span class=\"nn\">larpix.logger</span> <span class=\"kn\">import</span> <span class=\"n\">StdoutLogger</span>\n<span class=\"n\">controller</span> <span class=\"o\">=</span> <span class=\"n\">Controller</span><span class=\"p\">()</span>\n<span class=\"n\">controller</span><span class=\"o\">.</span><span class=\"n\">io</span> <span class=\"o\">=</span> <span class=\"n\">FakeIO</span><span class=\"p\">()</span>\n<span class=\"n\">controller</span><span class=\"o\">.</span><span class=\"n\">logger</span> <span class=\"o\">=</span> <span class=\"n\">StdoutLogger</span><span class=\"p\">(</span><span class=\"n\">buffer_length</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">)</span>\n<span class=\"n\">controller</span><span class=\"o\">.</span><span class=\"n\">logger</span><span class=\"o\">.</span><span class=\"n\">enable</span><span class=\"p\">()</span>\n</pre>\n<p>The <code>FakeIO</code> object imitates a real IO interface for testing purposes.\nIt directs its output to stdout (i.e. it prints the output), and it\ntakes its input from a manually-updated queue. At the end of each\nrelevant section of the tutorial will be code for adding the expected\noutput to the queue. You'll have to refill the queue each time you run\nthe code.</p>\n<p>Similarly, the <code>StdoutLogger</code> mimics the real logger interface for testing. It\nprints nicely formatted records of read / write commands to stdout every\n<code>buffer_length</code> packets. The logger interface requires enabling the\nlogger before messages will be stored. Before ending the python session, every\nlogger should be disabled to flush any remaining packets stored in the buffer.</p>\n<h3>Set up LArPix Chips</h3>\n<p>Chip objects represent actual LArPix ASICs. For each ASIC you want to\ncommunicate with, create a LArPix Chip object and add it to the\nController.</p>\n<pre><span class=\"n\">chipid</span> <span class=\"o\">=</span> <span class=\"mi\">5</span>\n<span class=\"n\">chip_key</span> <span class=\"o\">=</span> <span class=\"s1\">'1-1-5'</span>\n<span class=\"n\">chip5</span> <span class=\"o\">=</span> <span class=\"n\">controller</span><span class=\"o\">.</span><span class=\"n\">add_chip</span><span class=\"p\">(</span><span class=\"n\">chip_key</span><span class=\"p\">,</span> <span class=\"n\">version</span><span class=\"o\">=</span><span class=\"mi\">2</span><span class=\"p\">)</span>\n\n<span class=\"n\">chip5</span> <span class=\"o\">=</span> <span class=\"n\">controller</span><span class=\"p\">[</span><span class=\"n\">chip_key</span><span class=\"p\">]</span> <span class=\"c1\"># get chip object</span>\n<span class=\"n\">chip5</span> <span class=\"o\">=</span> <span class=\"n\">controller</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">5</span><span class=\"p\">]</span> <span class=\"c1\"># gets same chip object</span>\n</pre>\n<p>The <code>chip_key</code> field specifies the necessary information for the <code>controller.io</code>\nobject to route packets to/from the chip. The details of how this key maps to a\nphysical chip is implemented separately for each <code>larpix.io</code> class.</p>\n<p>The key itself consists of 3 1-byte integer values that represent the 3\nlow-level layers in larpix readout:</p>\n<ul>\n<li>\n<p>the io group: this is the highest layer and represents a control system that\ncommunicates with multiple IO channels</p>\n</li>\n<li>\n<p>the io channel: this is the middle layer and represents a single MOSI/MISO\npair</p>\n</li>\n<li>\n<p>the chip id: this is the lowest layer and represents a single chip on a\nMOSI/MISO network</p>\n</li>\n</ul>\n<p>If you want to interact with chip keys directly, you can instantiate one using\na valid keystring (three 1-byte integers separated by dashes, e.g. <code>'1-1-2'</code>).\nPlease note that the ids of 0, 1, and 255 are reserved for special functions.</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">larpix</span> <span class=\"kn\">import</span> <span class=\"n\">Key</span>\n<span class=\"n\">example_key</span> <span class=\"o\">=</span> <span class=\"n\">Key</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">2</span><span class=\"p\">,</span><span class=\"mi\">3</span><span class=\"p\">)</span>\n</pre>\n<p>You can grab relevant information from the key via a number of useful methods\nand attributes:</p>\n<pre><span class=\"n\">example_key</span><span class=\"o\">.</span><span class=\"n\">io_group</span>  <span class=\"c1\"># 1</span>\n<span class=\"n\">example_key</span><span class=\"o\">.</span><span class=\"n\">io_channel</span>  <span class=\"c1\"># 2</span>\n<span class=\"n\">example_key</span><span class=\"o\">.</span><span class=\"n\">chip_id</span>  <span class=\"c1\"># 3</span>\n<span class=\"n\">example_key</span><span class=\"o\">.</span><span class=\"n\">to_dict</span><span class=\"p\">()</span> <span class=\"c1\"># returns a dict with the above keys / values</span>\n</pre>\n<p>If you are using a <code>Key</code> in a script, we recommend that you generate the keys\nvia the <code>Key(&lt;io_group&gt;,&lt;io_channel&gt;,&lt;chip_id&gt;)</code> method which will protect against updates to the keystring\nformatting.</p>\n<p>You can read the docs to learn more about <code>Key</code> functionality.</p>\n<h3>Set up LArPix Hydra network</h3>\n<p>The controller object contains an internal structure representing the Hydra\nnetworks on each of the io channels. This structure can be accessed via\n<code>controller.network</code> and modified using the <code>controller.add_network_node</code>\nand <code>controller.add_network_link</code> methods. However, it can be a tedious\nand error-prone process to add each link to the network representation. So,\nthere exists a friendlier <a href=\"https://larpix-control.readthedocs.io/en/stable/api/configs/controller.html\" rel=\"nofollow\">configuration file</a> that is used to generate these network links.</p>\n<p>To load a network configuration into the controller:</p>\n<pre><span class=\"n\">controller</span><span class=\"o\">.</span><span class=\"n\">load</span><span class=\"p\">(</span><span class=\"s1\">'controller/v2_example.json'</span><span class=\"p\">)</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">controller</span><span class=\"o\">.</span><span class=\"n\">chips</span><span class=\"p\">)</span> <span class=\"c1\"># chips that have been loaded into controller</span>\n<span class=\"nb\">list</span><span class=\"p\">(</span><span class=\"n\">controller</span><span class=\"o\">.</span><span class=\"n\">network</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">][</span><span class=\"mi\">1</span><span class=\"p\">][</span><span class=\"s1\">'miso_ds'</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">edges</span><span class=\"p\">)</span> <span class=\"c1\"># all links contained in the miso_ds graph</span>\n<span class=\"nb\">list</span><span class=\"p\">(</span><span class=\"n\">controller</span><span class=\"o\">.</span><span class=\"n\">network</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">][</span><span class=\"mi\">1</span><span class=\"p\">][</span><span class=\"s1\">'miso_us'</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">nodes</span><span class=\"p\">)</span> <span class=\"c1\"># all nodes within the miso_us graph</span>\n<span class=\"nb\">list</span><span class=\"p\">(</span><span class=\"n\">controller</span><span class=\"o\">.</span><span class=\"n\">network</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">][</span><span class=\"mi\">1</span><span class=\"p\">][</span><span class=\"s1\">'mosi'</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">edges</span><span class=\"p\">)</span> <span class=\"c1\"># all links within the mosi graph</span>\n</pre>\n<p>Each graph is represented by a networkx directed graph and can be examined and\nqueried in that way. All edges point in the direction of data flow.</p>\n<pre><span class=\"nb\">list</span><span class=\"p\">(</span><span class=\"n\">controller</span><span class=\"o\">.</span><span class=\"n\">network</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">][</span><span class=\"mi\">1</span><span class=\"p\">][</span><span class=\"s1\">'mosi'</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">in_edges</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">))</span> <span class=\"c1\"># all links pointing to chip 2 in mosi graph</span>\n<span class=\"nb\">list</span><span class=\"p\">(</span><span class=\"n\">controller</span><span class=\"o\">.</span><span class=\"n\">network</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">][</span><span class=\"mi\">1</span><span class=\"p\">][</span><span class=\"s1\">'miso_ds'</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">successors</span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">))</span> <span class=\"c1\"># all chips receiving downstream data packets from chip 3</span>\n<span class=\"n\">controller</span><span class=\"o\">.</span><span class=\"n\">network</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">][</span><span class=\"mi\">1</span><span class=\"p\">][</span><span class=\"s1\">'mosi'</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">edges</span><span class=\"p\">[(</span><span class=\"mi\">3</span><span class=\"p\">,</span><span class=\"mi\">2</span><span class=\"p\">)][</span><span class=\"s1\">'uart'</span><span class=\"p\">]</span> <span class=\"c1\"># check the physical uart channel that chip 2 listens to chip 3 via</span>\n<span class=\"n\">controller</span><span class=\"o\">.</span><span class=\"n\">network</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">][</span><span class=\"mi\">1</span><span class=\"p\">][</span><span class=\"s1\">'mosi'</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">nodes</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">][</span><span class=\"s1\">'root'</span><span class=\"p\">]</span> <span class=\"c1\"># check if designated root chip</span>\n</pre>\n<p>After loading the network into the controller, the <code>init_network</code> command\nautomates the process of bringing up individual chips in the network.</p>\n<pre><span class=\"n\">controller</span><span class=\"o\">.</span><span class=\"n\">init_network</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"c1\"># issues packets required to initialize the 1,1 hydra network</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">controller</span><span class=\"p\">[</span><span class=\"s1\">'1-1-2'</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">config</span><span class=\"o\">.</span><span class=\"n\">chip_id</span><span class=\"p\">)</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">controller</span><span class=\"p\">[</span><span class=\"s1\">'1-1-3'</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">config</span><span class=\"o\">.</span><span class=\"n\">enable_miso_downstream</span><span class=\"p\">)</span>\n</pre>\n<p>This issues configuration commands in the proper order so that upstream chips\nare configured before downstream chips. If you'd like to reset the network\nconfiguration</p>\n<pre><span class=\"n\">controller</span><span class=\"o\">.</span><span class=\"n\">reset_network</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n</pre>\n<p>can be used to reverse the configuration commands issued with <code>init_network</code>.\nThese processes are not \"smart\" in that they blindly issue config commands\nassuming the network is either fully configured or in a default state, so buyer\nbeware.</p>\n<p>The network initialization can be broken down into single steps by also passing\nalong the chip id:</p>\n<pre><span class=\"n\">controller</span><span class=\"o\">.</span><span class=\"n\">init_network</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">2</span><span class=\"p\">)</span> <span class=\"c1\"># configures only chip 2</span>\n<span class=\"n\">controller</span><span class=\"o\">.</span><span class=\"n\">init_network</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">3</span><span class=\"p\">)</span> <span class=\"c1\"># configures only chip 3</span>\n</pre>\n<p>But this requires initializing the chips in the proper order. You can get the\nchip keys in order of their depth within the network via</p>\n<pre><span class=\"n\">controller</span><span class=\"o\">.</span><span class=\"n\">get_network_keys</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"c1\"># gets a list of chip keys starting at the root node and descending</span>\n<span class=\"n\">controller</span><span class=\"o\">.</span><span class=\"n\">get_network_keys</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"n\">root_first_traversal</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">)</span> <span class=\"c1\"># get list of chip keys starting at deepest chips and ascending</span>\n</pre>\n<h3>Adjust the configuration of the LArPix Chips</h3>\n<p>Each Chip object manages its own configuration in software.\nConfigurations can be adjusted by name using attributes of the Chip's\nconfiguration:</p>\n<pre><span class=\"n\">chip5</span><span class=\"o\">.</span><span class=\"n\">config</span><span class=\"o\">.</span><span class=\"n\">threshold_global</span> <span class=\"o\">=</span> <span class=\"mi\">35</span>  <span class=\"c1\"># entire register = 1 number</span>\n<span class=\"n\">chip5</span><span class=\"o\">.</span><span class=\"n\">config</span><span class=\"o\">.</span><span class=\"n\">enable_periodic_reset</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>  <span class=\"c1\"># one bit as part of a register</span>\n<span class=\"n\">chip5</span><span class=\"o\">.</span><span class=\"n\">config</span><span class=\"o\">.</span><span class=\"n\">channel_mask</span><span class=\"p\">[</span><span class=\"mi\">20</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>  <span class=\"c1\"># one bit per channel</span>\n</pre>\n<p>Values are validated, and invalid values will raise exceptions.</p>\n<p>Note: Changing the configuration of a Chip object does <em>not</em> change the\nconfiguration on the ASIC.</p>\n<p>Once the configuration is set, the new values must be sent to the LArPix\nASICs. There is an appropriate Controller method for that:</p>\n<pre><span class=\"n\">controller</span><span class=\"o\">.</span><span class=\"n\">write_configuration</span><span class=\"p\">(</span><span class=\"n\">chip_key</span><span class=\"p\">)</span>  <span class=\"c1\"># send all registers</span>\n<span class=\"n\">controller</span><span class=\"o\">.</span><span class=\"n\">write_configuration</span><span class=\"p\">(</span><span class=\"n\">chip_key</span><span class=\"p\">,</span> <span class=\"mi\">32</span><span class=\"p\">)</span>  <span class=\"c1\"># send only register 32</span>\n<span class=\"n\">controller</span><span class=\"o\">.</span><span class=\"n\">write_configuration</span><span class=\"p\">(</span><span class=\"n\">chip_key</span><span class=\"p\">,</span> <span class=\"p\">[</span><span class=\"mi\">32</span><span class=\"p\">,</span> <span class=\"mi\">50</span><span class=\"p\">])</span>  <span class=\"c1\"># send registers 32 and 50</span>\n</pre>\n<p>Register addresses can be looked up using the configuration object:</p>\n<pre><span class=\"n\">threshold_global_reg</span> <span class=\"o\">=</span> <span class=\"n\">chip5</span><span class=\"o\">.</span><span class=\"n\">config</span><span class=\"o\">.</span><span class=\"n\">register_map</span><span class=\"p\">[</span><span class=\"s1\">'threshold_global'</span><span class=\"p\">]</span>\n</pre>\n<p>And register names:</p>\n<pre><span class=\"n\">threshold_global_name</span> <span class=\"o\">=</span> <span class=\"n\">chip</span><span class=\"o\">.</span><span class=\"mf\">5.</span><span class=\"n\">config</span><span class=\"o\">.</span><span class=\"n\">register_map_inv</span><span class=\"p\">[</span><span class=\"mi\">64</span><span class=\"p\">]</span>\n</pre>\n<p>For configurations which extend over multiple registers, the relevant\nattribute will end in <code>_addresses</code>. Certain configurations share a\nsingle register, whose attribute has all of the names in it. View the\ndocumentation or source code to find the name to look up. (Or look at\nthe LArPix data sheet.)</p>\n<h3>Reading the configuration from LArPix ASICs</h3>\n<p>The current configuration state of the LArPix ASICs can be requested by\nsending out \"configuration read\" requests using the Controller:</p>\n<pre><span class=\"n\">controller</span><span class=\"o\">.</span><span class=\"n\">read_configuration</span><span class=\"p\">(</span><span class=\"n\">chip_key</span><span class=\"p\">)</span>\n</pre>\n<p>The same variations to read only certain registers are implemented for\nreading as for writing.</p>\n<p>The responses from the LArPix ASICs are stored for inspection. See the\nsection on \"Inspecting received data\" for more.</p>\n<p>FakeIO queue code:</p>\n<pre><span class=\"n\">packets</span> <span class=\"o\">=</span> <span class=\"n\">chip5</span><span class=\"o\">.</span><span class=\"n\">get_configuration_read_packets</span><span class=\"p\">()</span>\n<span class=\"n\">bytestream</span> <span class=\"o\">=</span> <span class=\"sa\">b</span><span class=\"s1\">'bytes for the config read packets'</span>\n<span class=\"n\">controller</span><span class=\"o\">.</span><span class=\"n\">io</span><span class=\"o\">.</span><span class=\"n\">queue</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">((</span><span class=\"n\">packets</span><span class=\"p\">,</span> <span class=\"n\">bytestream</span><span class=\"p\">))</span>\n</pre>\n<h3>Receiving data from LArPix ASICs</h3>\n<p>When it is first initialized, the LArPix Controller ignores and discards\nall data that it receives from LArPix. The Controller must be activated\nby calling <code>start_listening()</code>. All received data will then be\naccumulated in an implementation-dependent queue or buffer, depending\non the IO interface used. To read the data from the buffer, call the\ncontroller's <code>read()</code> method, which returns both the raw bytestream\nreceived as well as a list of LArPix Packet objects which have been\nextracted from the bytestream. To stop listening for new data, call\n<code>stop_listening()</code>. Finally, to store the data in the controller\nobject, call the <code>store_packets</code> method. All together:</p>\n<pre><span class=\"n\">controller</span><span class=\"o\">.</span><span class=\"n\">start_listening</span><span class=\"p\">()</span>\n<span class=\"c1\"># Data arrives...</span>\n<span class=\"n\">packets</span><span class=\"p\">,</span> <span class=\"n\">bytestream</span> <span class=\"o\">=</span> <span class=\"n\">controller</span><span class=\"o\">.</span><span class=\"n\">read</span><span class=\"p\">()</span>\n<span class=\"c1\"># More data arrives...</span>\n<span class=\"n\">packets2</span><span class=\"p\">,</span> <span class=\"n\">bytestream2</span> <span class=\"o\">=</span> <span class=\"n\">controller</span><span class=\"o\">.</span><span class=\"n\">read</span><span class=\"p\">()</span>\n<span class=\"n\">controller</span><span class=\"o\">.</span><span class=\"n\">stop_listening</span><span class=\"p\">()</span>\n<span class=\"n\">message</span> <span class=\"o\">=</span> <span class=\"s1\">'First data arrived!'</span>\n<span class=\"n\">message2</span> <span class=\"o\">=</span> <span class=\"s1\">'More data arrived!'</span>\n<span class=\"n\">controller</span><span class=\"o\">.</span><span class=\"n\">store_packets</span><span class=\"p\">(</span><span class=\"n\">packets</span><span class=\"p\">,</span> <span class=\"n\">bytestream</span><span class=\"p\">,</span> <span class=\"n\">message</span><span class=\"p\">)</span>\n<span class=\"n\">controller</span><span class=\"o\">.</span><span class=\"n\">store_packets</span><span class=\"p\">(</span><span class=\"n\">packets</span><span class=\"p\">,</span> <span class=\"n\">bytestream2</span><span class=\"p\">,</span> <span class=\"n\">message2</span><span class=\"p\">)</span>\n</pre>\n<p>There is a common pattern for reading data, namely to start listening,\nthen check in periodically for new data, and then after a certain amount\nof time has passed, stop listening and store all the data as one\ncollection. The method <code>run(timelimit, message)</code> accomplishes just this.</p>\n<pre><span class=\"n\">duration</span> <span class=\"o\">=</span> <span class=\"mi\">10</span>  <span class=\"c1\"># seconds</span>\n<span class=\"n\">message</span> <span class=\"o\">=</span> <span class=\"s1\">'10-second data run'</span>\n<span class=\"n\">controller</span><span class=\"o\">.</span><span class=\"n\">run</span><span class=\"p\">(</span><span class=\"n\">duration</span><span class=\"p\">,</span> <span class=\"n\">message</span><span class=\"p\">)</span>\n</pre>\n<p>FakeIO queue code for the first code block:</p>\n<pre><span class=\"n\">packets</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">Packet_v2</span><span class=\"p\">()]</span> <span class=\"o\">*</span> <span class=\"mi\">40</span>\n<span class=\"n\">bytestream</span> <span class=\"o\">=</span> <span class=\"sa\">b</span><span class=\"s1\">'bytes from the first set of packets'</span>\n<span class=\"n\">controller</span><span class=\"o\">.</span><span class=\"n\">io</span><span class=\"o\">.</span><span class=\"n\">queue</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">((</span><span class=\"n\">packets</span><span class=\"p\">,</span> <span class=\"n\">bytestream</span><span class=\"p\">))</span>\n<span class=\"n\">packets2</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">Packet_v2</span><span class=\"p\">()]</span> <span class=\"o\">*</span> <span class=\"mi\">30</span>\n<span class=\"n\">bytestream2</span> <span class=\"o\">=</span> <span class=\"sa\">b</span><span class=\"s1\">'bytes from the second set of packets'</span>\n<span class=\"n\">controller</span><span class=\"o\">.</span><span class=\"n\">io</span><span class=\"o\">.</span><span class=\"n\">queue</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">((</span><span class=\"n\">packets2</span><span class=\"p\">,</span> <span class=\"n\">bytestream2</span><span class=\"p\">))</span>\n</pre>\n<p>fakeIO queue code for the second code block:</p>\n<pre><span class=\"n\">packets</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">Packet_v2</span><span class=\"p\">()]</span> <span class=\"o\">*</span> <span class=\"mi\">5</span>\n<span class=\"n\">bytestream</span> <span class=\"o\">=</span> <span class=\"sa\">b</span><span class=\"s1\">'[bytes from read #</span><span class=\"si\">%d</span><span class=\"s1\">] '</span>\n<span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"mi\">100</span><span class=\"p\">):</span>\n    <span class=\"n\">controller</span><span class=\"o\">.</span><span class=\"n\">io</span><span class=\"o\">.</span><span class=\"n\">queue</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">((</span><span class=\"n\">packets</span><span class=\"p\">,</span> <span class=\"n\">bytestream</span><span class=\"o\">%</span><span class=\"n\">i</span><span class=\"p\">))</span>\n</pre>\n<h3>Inspecting received data</h3>\n<p>Once data is stored in the controller, it is available in the <code>reads</code>\nattribute as a list of all data runs. Each element of the list is a\nPacketCollection object, which functions like a list of Packet objects\neach representing one LArPix packet.</p>\n<p>PacketCollection objects can be indexed like a list:</p>\n<pre><span class=\"n\">run1</span> <span class=\"o\">=</span> <span class=\"n\">controller</span><span class=\"o\">.</span><span class=\"n\">reads</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span>\n<span class=\"n\">first_packet</span> <span class=\"o\">=</span> <span class=\"n\">run1</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span>  <span class=\"c1\"># Packet object</span>\n<span class=\"n\">first_ten_packets</span> <span class=\"o\">=</span> <span class=\"n\">run1</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">:</span><span class=\"mi\">10</span><span class=\"p\">]</span>  <span class=\"c1\"># smaller PacketCollection object</span>\n\n<span class=\"n\">first_packet_bits</span> <span class=\"o\">=</span> <span class=\"n\">run1</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"s1\">'bits'</span><span class=\"p\">]</span>  <span class=\"c1\"># string representation of bits in packet</span>\n<span class=\"n\">first_ten_packet_bits</span> <span class=\"o\">=</span> <span class=\"n\">run1</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">:</span><span class=\"mi\">10</span><span class=\"p\">,</span> <span class=\"s1\">'bits'</span><span class=\"p\">]</span>  <span class=\"c1\"># list of strings</span>\n</pre>\n<p>PacketCollections can be printed to display the contents of the Packets\nthey contain. To prevent endless scrolling, only the first ten and last ten\npackets are displayed, and the number of omitted packets is noted. To\nview the omitted packets, use a slice around the area of interest.</p>\n<pre><span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">run1</span><span class=\"p\">)</span>  <span class=\"c1\"># prints the contents of the packets</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">run1</span><span class=\"p\">[</span><span class=\"mi\">10</span><span class=\"p\">:</span><span class=\"mi\">30</span><span class=\"p\">])</span>  <span class=\"c1\"># prints 20 packets from the middle of the run</span>\n</pre>\n<p>In interactive Python, returned objects are not printed, but rather\ntheir \"representation\" is printed (cf. the <code>__repr__</code> method). The\nrepresentation of PacketCollections is a listing of the number of\npackets, the \"read id\" (a.k.a. the run number), and the message\nassociated with the PacketCollection when it was created.</p>\n<h3>Individual LArPix Packets</h3>\n<p>LArPix Packet objects represent individual LArPix UART packets. They\nhave attributes which can be used to inspect or modify the contents of\nthe packet.</p>\n<pre><span class=\"n\">packet</span> <span class=\"o\">=</span> <span class=\"n\">run1</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span>\n<span class=\"c1\"># all packets</span>\n<span class=\"n\">packet</span><span class=\"o\">.</span><span class=\"n\">packet_type</span>  <span class=\"c1\"># unique in that it gives the bits representation</span>\n<span class=\"n\">packet</span><span class=\"o\">.</span><span class=\"n\">chip_id</span>  <span class=\"c1\"># all other properties return Python numbers</span>\n<span class=\"n\">packet</span><span class=\"o\">.</span><span class=\"n\">chip_key</span> <span class=\"c1\"># key for association to a unique chip (can be None)</span>\n<span class=\"n\">packet</span><span class=\"o\">.</span><span class=\"n\">parity</span>\n<span class=\"n\">packet</span><span class=\"o\">.</span><span class=\"n\">downstream_marker</span>\n\n<span class=\"c1\"># data packets</span>\n<span class=\"n\">packet</span><span class=\"o\">.</span><span class=\"n\">channel_id</span>\n<span class=\"n\">packet</span><span class=\"o\">.</span><span class=\"n\">dataword</span>\n<span class=\"n\">packet</span><span class=\"o\">.</span><span class=\"n\">timestamp</span>\n<span class=\"n\">packet</span><span class=\"o\">.</span><span class=\"n\">trigger_type</span>\n<span class=\"n\">packet</span><span class=\"o\">.</span><span class=\"n\">local_fifo</span>\n<span class=\"n\">packet</span><span class=\"o\">.</span><span class=\"n\">shared_fifo</span>\n<span class=\"c1\"># config packets</span>\n<span class=\"n\">packet</span><span class=\"o\">.</span><span class=\"n\">register_address</span>\n<span class=\"n\">packet</span><span class=\"o\">.</span><span class=\"n\">register_data</span>\n</pre>\n<p>Internally, packets are represented as an array of bits, and the\ndifferent attributes use Python \"properties\" to seamlessly convert\nbetween the bits representation and a more intuitive integer\nrepresentation. The bits representation can be inspected with the\n<code>bits</code> attribute.</p>\n<p>Packet objects do not restrict you from adjusting an attribute for an\ninappropriate packet type. For example, you can create a data packet and\nthen set <code>packet.register_address = 5</code>. This will adjust the packet\nbits corresponding to a configuration packet's \"register_address\"\nregion, which is probably not what you want for your data packet.</p>\n<p>Packets have a parity bit which enforces odd parity, i.e. the sum of\nall the individual bits in a packet must be an odd number. The parity\nbit can be accessed as above using the <code>parity</code> attribute.\nThe correct parity bit can be computed using <code>compute_parity()</code>,\nand the validity of a packet's parity can be checked using\n<code>has_valid_parity()</code>. When constructing a new packet, the correct\nparity bit can be assigned using <code>assign_parity()</code>.</p>\n<p>Individual packets can be printed to show a human-readable\ninterpretation of the packet contents. The printed version adjusts its\noutput based on the packet type, so a data packet will show the data\nword, timestamp, etc., while a configuration packet will show the register\naddress and register data.</p>\n<p>Like with PacketCollections, Packets also have a \"representation\" view\nbased on the bytes that make up the packet. This can be useful for\ncreating new packets since a Packet's representation is also a vaild\ncall to the Packet constructor. So the output from an interactive\nsession can be copied as input or into a script to create the same\npacket.</p>\n<p>With the v2 chip, more information about the internal fifo can be gathered by\nrunning with fifo diagonstics enabled on a given asic. In this case, the bits of\neach packet are to be interpreted differently. Each packet object can be set to\nbe interpreted in this mode via the <code>fifo_diagnostics_enabled</code> flag. See the\nPacket_v2 <a href=\"https://larpix-control.readthedocs.io/en/stable/\" rel=\"nofollow\">documentation</a> for\nmore details.</p>\n<h3>Logging communications with LArPix ASICs using the HDF5Logger</h3>\n<p>To create a permanent record of communications with the LArPix ASICs, an\n<code>HDF5Logger</code> is used. To create a new logger</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">larpix.logger</span> <span class=\"kn\">import</span> <span class=\"n\">HDF5Logger</span>\n<span class=\"n\">controller</span><span class=\"o\">.</span><span class=\"n\">logger</span> <span class=\"o\">=</span> <span class=\"n\">HDF5Logger</span><span class=\"p\">(</span><span class=\"n\">filename</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"n\">buffer_length</span><span class=\"o\">=</span><span class=\"mi\">10000</span><span class=\"p\">)</span> <span class=\"c1\"># a filename of None uses the default filename formatting</span>\n<span class=\"n\">controller</span><span class=\"o\">.</span><span class=\"n\">logger</span><span class=\"o\">.</span><span class=\"n\">enable</span><span class=\"p\">()</span> <span class=\"c1\"># starts tracking all communications</span>\n</pre>\n<p>You can also initialize and enable the logger in one call by passing the\n<code>enabled</code> keyword argument (which defaults to <code>False</code>):</p>\n<pre><code>controller.logger = HDF5Logger(filename=None, enabled=True)\n</code></pre>\n<p>Now whenever you send or receive packets, they will be captured by the logger\nand added to the logger's buffer. Once <code>buffer_length</code> packets have been\ncaptured the packets will be written out to the file. You can force the logger\nto dump the currently held packets at any time using <code>HDF5Logger.flush()</code></p>\n<pre><span class=\"n\">controller</span><span class=\"o\">.</span><span class=\"n\">verify_configuration</span><span class=\"p\">()</span>\n<span class=\"n\">controller</span><span class=\"o\">.</span><span class=\"n\">logger</span><span class=\"o\">.</span><span class=\"n\">flush</span><span class=\"p\">()</span>\n</pre>\n<p>In the event that you want to temporarily stop tracking communications,\nthe <code>disable</code> and <code>enable</code> commands do exactly what you think they might.</p>\n<pre><span class=\"n\">controller</span><span class=\"o\">.</span><span class=\"n\">logger</span><span class=\"o\">.</span><span class=\"n\">disable</span><span class=\"p\">()</span> <span class=\"c1\"># stop tracking</span>\n<span class=\"c1\"># any communication here is ignored</span>\n<span class=\"n\">controller</span><span class=\"o\">.</span><span class=\"n\">logger</span><span class=\"o\">.</span><span class=\"n\">enable</span><span class=\"p\">()</span> <span class=\"c1\"># start tracking again</span>\n<span class=\"n\">controller</span><span class=\"o\">.</span><span class=\"n\">logger</span><span class=\"o\">.</span><span class=\"n\">is_enabled</span><span class=\"p\">()</span> <span class=\"c1\"># returns True if tracking</span>\n</pre>\n<p>Once you have finished your tests, be sure to disable the logger. If you do not,\nyou will lose any data still in the buffer of the logger object. We strongly recommend\nwrapping logger code with a <code>try, except</code> statement if you can. Any remaining\npackets in the buffer are flushed to the file upon disabling.</p>\n<pre><span class=\"n\">controller</span><span class=\"o\">.</span><span class=\"n\">logger</span><span class=\"o\">.</span><span class=\"n\">disable</span><span class=\"p\">()</span>\n</pre>\n<h3>Viewing data from the HDF5Logger</h3>\n<p>The <code>HDF5Logger</code> uses a format called LArPix+HDF5v1.0 that is specified in\nthe <code>larpix.format.hdf5format</code> module (and\n<a href=\"https://larpix-control.readthedocs.io/en/stable/\" rel=\"nofollow\">documentation</a>\nstarting in v2.3.0). That module contains a <code>to_file</code> method which is\nused internally by <code>HDF5Logger</code> and a <code>from_file</code> method that you\ncan use to load the file contents back into LArPix Control. The\nLArPix+HDF5 format is a \"plain HDF5\" format that can be inspected with\n<code>h5py</code> or any language's HDF5 binding.</p>\n<p>To open the HDF5 file from python</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">h5py</span>\n<span class=\"n\">datafile</span> <span class=\"o\">=</span> <span class=\"n\">h5py</span><span class=\"o\">.</span><span class=\"n\">File</span><span class=\"p\">(</span><span class=\"s1\">'&lt;filename&gt;'</span><span class=\"p\">)</span>\n</pre>\n<p>Within the datafile there is one group (<code>'_header'</code>) and two datasets\n(<code>'packets'</code> and <code>'messages'</code>). The header group contains some useful meta information about\nwhen the datafile was created and the file format version number, stored as\nattributes.</p>\n<pre><span class=\"nb\">list</span><span class=\"p\">(</span><span class=\"n\">datafile</span><span class=\"o\">.</span><span class=\"n\">keys</span><span class=\"p\">())</span> <span class=\"c1\"># ['_header', 'messages', 'packets']</span>\n<span class=\"nb\">list</span><span class=\"p\">(</span><span class=\"n\">datafile</span><span class=\"p\">[</span><span class=\"s1\">'_header'</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">attrs</span><span class=\"p\">)</span> <span class=\"c1\"># ['created', 'modified', version']</span>\n</pre>\n<p>The packets are stored sequentially as a <code>numpy</code> mixed-type arrays within the\nrows of the HDF5 dataset. The columns refer to the element of the numpy mixed\ntype array. The specifics of the data type and entries are set by the\n<code>larpix.format.hdf5format.dtype</code> object - see the larpix-control docs for more information.\nYou can inspect a packet as a tuple simply by accessing its respective position within the\nHDF5 dataset.</p>\n<pre><span class=\"n\">raw_value</span> <span class=\"o\">=</span> <span class=\"n\">datafile</span><span class=\"p\">[</span><span class=\"s1\">'packets'</span><span class=\"p\">][</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"c1\"># e.g. (b'0-246', 3, 246, 1, 1, -1, -1, -1, -1, -1, -1, 0, 0)</span>\n<span class=\"n\">raw_values</span> <span class=\"o\">=</span> <span class=\"n\">datafile</span><span class=\"p\">[</span><span class=\"s1\">'packets'</span><span class=\"p\">][</span><span class=\"o\">-</span><span class=\"mi\">100</span><span class=\"p\">:]</span> <span class=\"c1\"># last 100 packets in file</span>\n</pre>\n<p>If you want to make use of <code>numpy</code>'s mixed type arrays, you can convert the\nraw values to the proper encoding by retrieving it as a list (of length\n1, for example) via</p>\n<pre><span class=\"n\">packet_repr</span> <span class=\"o\">=</span> <span class=\"n\">raw_values</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">:</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"c1\"># list with one element</span>\n<span class=\"n\">packet_repr</span><span class=\"p\">[</span><span class=\"s1\">'chip_id'</span><span class=\"p\">]</span> <span class=\"c1\"># chip key for packet, e.g. 246</span>\n<span class=\"n\">packet_repr</span><span class=\"p\">[</span><span class=\"s1\">'dataword'</span><span class=\"p\">]</span> <span class=\"c1\"># list of ADC values for each packet</span>\n<span class=\"n\">packet_repr</span><span class=\"o\">.</span><span class=\"n\">dtype</span> <span class=\"c1\"># description of data type (with names of each column)</span>\n</pre>\n<p>You can also view entire \"columns\" of data:</p>\n<pre><span class=\"c1\"># all packets' ADC counts, including non-data packets</span>\n<span class=\"n\">raw_values</span><span class=\"p\">[</span><span class=\"s1\">'dataword'</span><span class=\"p\">]</span>\n<span class=\"c1\"># Select based on data type using a numpy bool / \"mask\" array:</span>\n<span class=\"n\">raw_values</span><span class=\"p\">[</span><span class=\"s1\">'dataword'</span><span class=\"p\">][</span><span class=\"n\">raw_values</span><span class=\"p\">[</span><span class=\"s1\">'packet_type'</span><span class=\"p\">]</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"c1\"># all data packets' ADC counts</span>\n</pre>\n<p><code>h5py</code> and <code>numpy</code> optimize the retrieval of data so you can read\ncertain columns or rows without loading the entire data file into memory.</p>\n<p>Don't forget to close the file when you are done. (Not necessary in\ninteractive python sessions if you are about to quit.)</p>\n<pre><span class=\"n\">datafile</span><span class=\"o\">.</span><span class=\"n\">close</span><span class=\"p\">()</span>\n</pre>\n<h2>Running with a Bern DAQ board (v1 asic)</h2>\n<p>Since you have completed the tutorial with the <code>FakeIO</code> class, you are now ready\nto interface with some LArPix ASICs. If you have a Bern DAQ v2-3 setup you can\nfollow along with the rest of the tutorial.</p>\n<p>Before you can configure the system, you will need to generate a configuration\nfile for the ZMQ_IO or MultiZMQ_IO interface. This provides the mapping from\nchip keys to physical devices. In the case of the ZMQ interface, it maps\nio group #s to the IP address of the DAQ board. A number of example\nconfigurations are provided in the installation under\n<code>larpix/configs/io/&lt;config name&gt;.json</code>, which may work for your purposes. We\nrecommend reading the docs about how to create one of these configuration files.\nBy default the system looks for configuration in the pwd, before looking for the\ninstallation files. If you only have one DAQ board on your network, likely\nyou will load the <code>io/daq-srv&lt;#&gt;.json</code> configuration.</p>\n<p>With the DAQ system up and running</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">from</span> <span class=\"nn\">larpix</span> <span class=\"kn\">import</span> <span class=\"n\">Controller</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">from</span> <span class=\"nn\">larpix.io</span> <span class=\"kn\">import</span> <span class=\"n\">ZMQ_IO</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">controller</span> <span class=\"o\">=</span> <span class=\"n\">Controller</span><span class=\"p\">()</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">controller</span><span class=\"o\">.</span><span class=\"n\">io</span> <span class=\"o\">=</span> <span class=\"n\">ZMQ_IO</span><span class=\"p\">(</span><span class=\"n\">config_filepath</span><span class=\"o\">=</span><span class=\"s1\">'&lt;path to config&gt;'</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">controller</span><span class=\"o\">.</span><span class=\"n\">load</span><span class=\"p\">(</span><span class=\"s1\">'controller/pcb-&lt;#&gt;_chip_info.json'</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">controller</span><span class=\"o\">.</span><span class=\"n\">io</span><span class=\"o\">.</span><span class=\"n\">ping</span><span class=\"p\">()</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"k\">for</span> <span class=\"n\">key</span><span class=\"p\">,</span><span class=\"n\">chip</span> <span class=\"ow\">in</span> <span class=\"n\">controller</span><span class=\"o\">.</span><span class=\"n\">chips</span><span class=\"o\">.</span><span class=\"n\">items</span><span class=\"p\">():</span>\n<span class=\"o\">...</span>     <span class=\"n\">chip</span><span class=\"o\">.</span><span class=\"n\">config</span><span class=\"o\">.</span><span class=\"n\">load</span><span class=\"p\">(</span><span class=\"s1\">'chip/quiet.json'</span><span class=\"p\">)</span>\n<span class=\"o\">...</span>     <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">key</span><span class=\"p\">,</span> <span class=\"n\">chip</span><span class=\"o\">.</span><span class=\"n\">config</span><span class=\"p\">)</span>\n<span class=\"o\">...</span>     <span class=\"n\">controller</span><span class=\"o\">.</span><span class=\"n\">write_configuration</span><span class=\"p\">(</span><span class=\"n\">key</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">controller</span><span class=\"o\">.</span><span class=\"n\">run</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"s1\">'checking the data rate'</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">controller</span><span class=\"o\">.</span><span class=\"n\">reads</span><span class=\"p\">[</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">]</span>\n<span class=\"o\">&lt;</span><span class=\"n\">PacketCollection</span> <span class=\"k\">with</span> <span class=\"mi\">0</span> <span class=\"n\">packets</span><span class=\"p\">,</span> <span class=\"n\">read_id</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"s1\">'checking the data rate'</span><span class=\"o\">&gt;</span>\n</pre>\n<p>This should give you a quiet state with no data packets. Occasionally, there can\nbe a few packets left in one of the system buffers (LArPix, FPGA, DAQ server). A\nsecond run command should return without any new packets.</p>\n<p>If you are using the v1.5 anode, you may need to reconfigure the miso/mosi mapping (since the miso/mosi pair for a daisy chain is not necessarily on a single channel). To do this, pass a <code>miso_map</code> or <code>mosi_map</code> to the <code>ZMQ_IO</code> object on initialization:</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">controller</span><span class=\"o\">.</span><span class=\"n\">io</span> <span class=\"o\">=</span> <span class=\"n\">ZMQ_IO</span><span class=\"p\">(</span><span class=\"n\">config_filepath</span><span class=\"o\">=</span><span class=\"s1\">'&lt;path to config&gt;'</span><span class=\"p\">,</span> <span class=\"n\">miso_map</span><span class=\"o\">=</span><span class=\"p\">{</span><span class=\"mi\">2</span><span class=\"p\">:</span><span class=\"mi\">1</span><span class=\"p\">})</span> <span class=\"c1\"># relabels packets received on channel 2 as packets from channel 1</span>\n</pre>\n<h3>Check configurations</h3>\n<p>If you are still receiving data, you can check that the hardware chip configuration\nmatch the software chip configurations with</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">controller</span><span class=\"o\">.</span><span class=\"n\">verify_configuration</span><span class=\"p\">()</span>\n<span class=\"p\">(</span><span class=\"kc\">True</span><span class=\"p\">,</span> <span class=\"p\">{})</span>\n</pre>\n<p>If the configuration read packets don't match the software chip configuration, this\nwill return</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">controller</span><span class=\"o\">.</span><span class=\"n\">verify_configuration</span><span class=\"p\">()</span>\n<span class=\"p\">(</span><span class=\"kc\">False</span><span class=\"p\">,</span> <span class=\"p\">{</span><span class=\"o\">&lt;</span><span class=\"n\">register</span><span class=\"o\">&gt;</span><span class=\"p\">:</span> <span class=\"p\">(</span><span class=\"o\">&lt;</span><span class=\"n\">expected</span><span class=\"o\">&gt;</span><span class=\"p\">,</span> <span class=\"o\">&lt;</span><span class=\"n\">received</span><span class=\"o\">&gt;</span><span class=\"p\">),</span> <span class=\"o\">...</span><span class=\"p\">})</span>\n</pre>\n<p>Missing packets will show up as</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">controller</span><span class=\"o\">.</span><span class=\"n\">verify_configuration</span><span class=\"p\">()</span>\n<span class=\"p\">(</span><span class=\"kc\">False</span><span class=\"p\">,</span> <span class=\"p\">{</span><span class=\"o\">&lt;</span><span class=\"n\">register</span><span class=\"o\">&gt;</span><span class=\"p\">:</span> <span class=\"p\">(</span><span class=\"o\">&lt;</span><span class=\"n\">expected</span><span class=\"o\">&gt;</span><span class=\"p\">,</span> <span class=\"kc\">None</span><span class=\"p\">),</span> <span class=\"o\">...</span><span class=\"p\">})</span>\n</pre>\n<p>If your configurations match, and you still receive data then you are likely seeing\nsome pickup on the sensor from the environment -- <em>good luck!</em></p>\n<h3>Enable a single channel</h3>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">chip_key</span> <span class=\"o\">=</span> <span class=\"s1\">'1-1-3'</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">controller</span><span class=\"o\">.</span><span class=\"n\">disable</span><span class=\"p\">()</span> <span class=\"c1\"># mask off all channel</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">controller</span><span class=\"o\">.</span><span class=\"n\">enable</span><span class=\"p\">(</span><span class=\"n\">chip_key</span><span class=\"p\">,</span> <span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">])</span> <span class=\"c1\"># enable channel 0 of chip</span>\n</pre>\n<h3>Set the global threshold of a chip</h3>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">controller</span><span class=\"o\">.</span><span class=\"n\">chips</span><span class=\"p\">[</span><span class=\"n\">chip_key</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">config</span><span class=\"o\">.</span><span class=\"n\">global_threshold</span> <span class=\"o\">=</span> <span class=\"mi\">40</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">controller</span><span class=\"o\">.</span><span class=\"n\">write_configuration</span><span class=\"p\">(</span><span class=\"n\">chip_key</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">controller</span><span class=\"o\">.</span><span class=\"n\">verify_configuration</span><span class=\"p\">(</span><span class=\"n\">chip_key</span><span class=\"p\">)</span>\n<span class=\"p\">(</span><span class=\"kc\">True</span><span class=\"p\">,</span> <span class=\"p\">{})</span>\n</pre>\n<h3>Inject a pulse into a specific channel</h3>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">controller</span><span class=\"o\">.</span><span class=\"n\">enable_testpulse</span><span class=\"p\">(</span><span class=\"n\">chip_key</span><span class=\"p\">,</span> <span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">])</span> <span class=\"c1\"># connect channel 0 to the test pulse circuit and initialize the internal DAC to 255</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">controller</span><span class=\"o\">.</span><span class=\"n\">issue_testpulse</span><span class=\"p\">(</span><span class=\"n\">chip_key</span><span class=\"p\">,</span> <span class=\"mi\">10</span><span class=\"p\">)</span> <span class=\"c1\"># inject a pulse of size 10DAC by stepping down the DAC</span>\n<span class=\"o\">&lt;</span><span class=\"n\">PacketCollection</span> <span class=\"k\">with</span> <span class=\"n\">XX</span> <span class=\"n\">packets</span><span class=\"p\">,</span> <span class=\"n\">read_id</span> <span class=\"n\">XX</span><span class=\"p\">,</span> <span class=\"s2\">\"configuration write\"</span><span class=\"o\">&gt;</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">controller</span><span class=\"o\">.</span><span class=\"n\">disable_testpulse</span><span class=\"p\">(</span><span class=\"n\">chip_key</span><span class=\"p\">)</span> <span class=\"c1\"># disconnect test pulse circuit from all channels on chip</span>\n</pre>\n<p>You will need to periodically reset the DAC to 255, otherwise you will receive a\n<code>ValueError</code> once the DAC reaches the minimum specified value.</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">controller</span><span class=\"o\">.</span><span class=\"n\">enable_testpulse</span><span class=\"p\">(</span><span class=\"n\">chip_key</span><span class=\"p\">,</span> <span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">],</span> <span class=\"n\">start_dac</span><span class=\"o\">=</span><span class=\"mi\">255</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">controller</span><span class=\"o\">.</span><span class=\"n\">issue_testpulse</span><span class=\"p\">(</span><span class=\"n\">chip_key</span><span class=\"p\">,</span> <span class=\"mi\">50</span><span class=\"p\">,</span> <span class=\"n\">min_dac</span><span class=\"o\">=</span><span class=\"mi\">200</span><span class=\"p\">)</span> <span class=\"c1\"># the min_dac keyword sets the lower bound for the DAC (useful to avoid non-linearities at around 70-80DAC)</span>\n<span class=\"o\">&lt;</span><span class=\"n\">PacketCollection</span> <span class=\"k\">with</span> <span class=\"n\">XX</span> <span class=\"n\">packets</span><span class=\"p\">,</span> <span class=\"n\">read_id</span> <span class=\"n\">XX</span><span class=\"p\">,</span> <span class=\"s2\">\"configuration write\"</span><span class=\"o\">&gt;</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">controller</span><span class=\"o\">.</span><span class=\"n\">issue_testpulse</span><span class=\"p\">(</span><span class=\"n\">chip_key</span><span class=\"p\">,</span> <span class=\"mi\">50</span><span class=\"p\">,</span> <span class=\"n\">min_dac</span><span class=\"o\">=</span><span class=\"mi\">200</span><span class=\"p\">)</span>\n<span class=\"ne\">ValueError</span><span class=\"p\">:</span> <span class=\"n\">Minimum</span> <span class=\"n\">DAC</span> <span class=\"n\">exceeded</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">controller</span><span class=\"o\">.</span><span class=\"n\">enable_testpulse</span><span class=\"p\">(</span><span class=\"n\">chip_key</span><span class=\"p\">,</span> <span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">],</span> <span class=\"n\">start_dac</span><span class=\"o\">=</span><span class=\"mi\">255</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">controller</span><span class=\"o\">.</span><span class=\"n\">issue_testpulse</span><span class=\"p\">(</span><span class=\"n\">chip_key</span><span class=\"p\">,</span> <span class=\"mi\">50</span><span class=\"p\">,</span> <span class=\"n\">min_dac</span><span class=\"o\">=</span><span class=\"mi\">200</span><span class=\"p\">)</span>\n<span class=\"o\">&lt;</span><span class=\"n\">PacketCollection</span> <span class=\"k\">with</span> <span class=\"n\">XX</span> <span class=\"n\">packets</span><span class=\"p\">,</span> <span class=\"n\">read_id</span> <span class=\"n\">XX</span><span class=\"p\">,</span> <span class=\"s2\">\"configuration write\"</span><span class=\"o\">&gt;</span>\n</pre>\n<h3>Enable the analog monitor on a channel</h3>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">controller</span><span class=\"o\">.</span><span class=\"n\">enable_analog_monitor</span><span class=\"p\">(</span><span class=\"n\">chip_key</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">)</span> <span class=\"c1\"># drive buffer output of channel 0 out on analog monitor line</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">controller</span><span class=\"o\">.</span><span class=\"n\">disable_analog_monitor</span><span class=\"p\">(</span><span class=\"n\">chip_key</span><span class=\"p\">)</span> <span class=\"c1\"># disable the analog monitor on chip</span>\n</pre>\n<p>While the software enforces that only one channel per chip is being driven out on\nthe analog monitor, you must disable the analog monitor if moving between chips.</p>\n<h2>Miscellaneous implementation details</h2>\n<h3>Endian-ness</h3>\n<p>We use the convention that the LSB is sent out first and read in first.\nThe location of the LSB in arrays and lists changes from object to\nobject based on the conventions of the other packages we interact with.</p>\n<p>In particular, pyserial sends out index 0 first, so for <code>bytes</code> objects,\nindex 0 will generally have the LSB. On the other hand, bitstrings\ntreats the <em>last</em> index as the LSB, which is also how numbers are\nusually displayed on screen, e.g. <code>0100</code> in binary means 4 not 2. So for\n<code>BitArray</code> and <code>Bits</code> objects, the LSB will generally be last.</p>\n<p>Note that this combination leads to the slightly awkward convention that\nthe least significant bit of a bytestring is the <em>last bit</em> of the\n<em>first byte</em>. For example, if bits[15:0] of a packet are\n<code>0000 0010 0000 0001</code> ( = 0x0201 = 513), then the bytes will be sent out as\n<code>b'\\x01\\x02'</code>.</p>\n<h3>The Configuration object</h3>\n<p>The <code>Configuration</code> object represents all of the options in the LArPix\nconfiguration register. Each row in the configuration table in the LArPix datasheet\nhas a corresponding attribute in the <code>Configuration</code> object. Per-channel\nattributes are stored in a list, and all other attributes are stored as\na simple integer. (This includes everything from single bits to values\nsuch as \"reset cycles,\" which spans 3 bytes.)</p>\n<p><code>Configuration</code> objects also have some helper methods for enabling and\ndisabling per-channel settings (such as <code>csa_testpulse_enable</code> or\n<code>channel_mask</code>). The relevant methods are listed here and should be\nprefixed with either <code>enable_</code> or <code>disable_</code>:</p>\n<ul>\n<li><code>channels</code> enables/disables the <code>channel_mask</code> register</li>\n<li><code>external_trigger</code> enables/disables the <code>external_trigger_mask</code>\nregister</li>\n<li><code>testpulse</code> enables/disables the <code>csa_testpulse_enable</code> register</li>\n<li><code>analog_monitor</code> enables/disables the <code>csa_monitor_select</code> register</li>\n</ul>\n<p>Most of these methods accept an optional list of channels to enable or\ndisable (and with no list specified acts on all channels). The exception\nis <code>enable_analog_monitor</code> (and its <code>disable</code> counterpart): the <code>enable</code>\nmethod requires a particular channel to be specified, and the <code>disable</code>\nmethod does not require any argument at all. This is because at most one\nchannel is allowed to have the analog monitor enabled.</p>\n<p>The machinery of the <code>Configuration</code> object ensures that each value is\nconverted to the appropriate set of bits when it comes time to send\nactual commands to the physical chip. Although this is not transparent\nto you as a user of this library, you might want to know that two sets of\nconfiguration options are always sent together in the same configuration\npacket:</p>\n<ul>\n<li>\n<p><code>csa_gain</code>, <code>csa_bypass</code>, and <code>internal_bypass</code> are combined into a\nsingle byte, so even though they have their own attributes, they must\nbe written to the physical chip together</p>\n</li>\n<li>\n<p><code>test_mode</code>, <code>cross_trigger_mode</code>, <code>periodic_reset</code>, and\n<code>fifo_diagnostic</code> work the same way</p>\n</li>\n</ul>\n<p>Similarly, all of the per-channel options (except for the pixel trim\nthresholds) are sent in 4 groups of 8 channels.</p>\n<p>Configurations can be loaded by importing <code>larpix.configs</code> and running\nthe <code>load</code> function. This function searches for a configuration with the\ngiven filename relative to the current directory before searching the\n\"system\" location (secretly it's in the larpix/configs/ folder). This is\nsimilar to <code>#include \"header.h\"</code> behavior in C.</p>\n<p>Configurations can be saved by calling <code>chip.config.write</code> with the\ndesired filename.</p>\n<p>Once the Chip object has been configured, the configuration must be sent\nto the physical chip.</p>\n\n          </div>"}, "last_serial": 6846131, "releases": {"0.3.0.dev0": [{"comment_text": "", "digests": {"md5": "56763f48ceb590fab0e5708a63f13269", "sha256": "ca4c3edd762c05300e6fa50059c4393a8ff566d83ba3a3fa82bb0d848165422b"}, "downloads": -1, "filename": "larpix_control-0.3.0.dev0-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "56763f48ceb590fab0e5708a63f13269", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 14531, "upload_time": "2017-10-19T07:34:48", "upload_time_iso_8601": "2017-10-19T07:34:48.725607Z", "url": "https://files.pythonhosted.org/packages/27/dd/b130258b0f15d85e5b4a0e8e953f1c4e61d1fcac3283c8099b29876109c6/larpix_control-0.3.0.dev0-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "1a1b9c2f1d034cc749c24981ed0eb8b4", "sha256": "790d9bc78a2431ec30adb385932a3fd0ae8bd540e7656569aa5fcf413054473c"}, "downloads": -1, "filename": "larpix-control-0.3.0.dev0.tar.gz", "has_sig": false, "md5_digest": "1a1b9c2f1d034cc749c24981ed0eb8b4", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 13857, "upload_time": "2017-10-19T07:34:51", "upload_time_iso_8601": "2017-10-19T07:34:51.953303Z", "url": "https://files.pythonhosted.org/packages/4d/11/4252d928592c66910822493fcd380eeef82924bc616efc9ef9f7db300431/larpix-control-0.3.0.dev0.tar.gz", "yanked": false}], "0.3.1.dev0": [{"comment_text": "", "digests": {"md5": "94288c6b238caac10a958bd92476f627", "sha256": "5c25657aa65e6624c7f5020b09409e860da8334853508dcf16f007d3cdeed5d6"}, "downloads": -1, "filename": "larpix_control-0.3.1.dev0-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "94288c6b238caac10a958bd92476f627", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 16352, "upload_time": "2017-10-19T07:34:50", "upload_time_iso_8601": "2017-10-19T07:34:50.016775Z", "url": "https://files.pythonhosted.org/packages/d3/4b/038afcaaf4e56932daed54d02228917ac1eae6385d1fdb2bc454eb22b00d/larpix_control-0.3.1.dev0-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "90f4ef4e9ff3f1a180f5ebe5eb58ac7b", "sha256": "0bb6a5a740f451d1752e21dbe9efc8a946f46a4a2bfb162459341f03d9a3aac2"}, "downloads": -1, "filename": "larpix-control-0.3.1.dev0.tar.gz", "has_sig": false, "md5_digest": "90f4ef4e9ff3f1a180f5ebe5eb58ac7b", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 17086, "upload_time": "2017-10-19T07:34:53", "upload_time_iso_8601": "2017-10-19T07:34:53.201920Z", "url": "https://files.pythonhosted.org/packages/36/67/3369e299914c57610162497063b784f7a7b67c4537f97a9b8f10913068ba/larpix-control-0.3.1.dev0.tar.gz", "yanked": false}], "0.4.1.dev1": [{"comment_text": "", "digests": {"md5": "10b0717dbf265745ae69c4ca71434448", "sha256": "6c950deadf4223a9949cc63b9ac93c84990790f058b806737e830c44ce1c1277"}, "downloads": -1, "filename": "larpix_control-0.4.1.dev1-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "10b0717dbf265745ae69c4ca71434448", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 21257, "upload_time": "2017-10-27T23:49:23", "upload_time_iso_8601": "2017-10-27T23:49:23.551978Z", "url": "https://files.pythonhosted.org/packages/21/06/1ad0ac0602b69407d33321c0882850b649504ee849c975d88cd007e73539/larpix_control-0.4.1.dev1-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "7762464be777f8f6cda41b41996c56cb", "sha256": "db0d73600bf89d92139a92e9c58b3fad66df4bd56c93a2944c630b8a1ccfb4cd"}, "downloads": -1, "filename": "larpix-control-0.4.1.dev1.tar.gz", "has_sig": false, "md5_digest": "7762464be777f8f6cda41b41996c56cb", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 23684, "upload_time": "2017-10-27T23:49:26", "upload_time_iso_8601": "2017-10-27T23:49:26.381052Z", "url": "https://files.pythonhosted.org/packages/f6/40/baf15118f2b514e1aba29d01f0fc22d42c8e04b212579555476c1126879f/larpix-control-0.4.1.dev1.tar.gz", "yanked": false}], "0.4.1.dev2": [{"comment_text": "", "digests": {"md5": "8bd942869bedb52489f885c3517a7672", "sha256": "a2c2d7a90d2d5965c9139b6738b91f4badb25474bcd3b02ce0d9d9e8da298dbb"}, "downloads": -1, "filename": "larpix_control-0.4.1.dev2-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "8bd942869bedb52489f885c3517a7672", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 21300, "upload_time": "2017-10-28T00:20:57", "upload_time_iso_8601": "2017-10-28T00:20:57.835152Z", "url": "https://files.pythonhosted.org/packages/df/d6/a07a22dc9763eff5a436bd0b29cb01cf1f00cc1da19492763b1ad3c2790b/larpix_control-0.4.1.dev2-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "48023698ecc9cd8f1d19e570ce2b4f70", "sha256": "d751cbfb01af198d813affe189151df9f590c7de3e3696d5f049d71d3689900c"}, "downloads": -1, "filename": "larpix-control-0.4.1.dev2.tar.gz", "has_sig": false, "md5_digest": "48023698ecc9cd8f1d19e570ce2b4f70", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 23733, "upload_time": "2017-10-28T00:21:00", "upload_time_iso_8601": "2017-10-28T00:21:00.501578Z", "url": "https://files.pythonhosted.org/packages/32/82/4a4111759bfb2309d186dec1b8a61d8a844df67d5b0036e46e63b32265d7/larpix-control-0.4.1.dev2.tar.gz", "yanked": false}], "0.4.1.dev3": [{"comment_text": "", "digests": {"md5": "2738179295207cfce17ff39ba4d06707", "sha256": "9c52f586a598207c5542d401a58355fcb8dd71e2d6add6330c0af04db6a826e7"}, "downloads": -1, "filename": "larpix_control-0.4.1.dev3-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "2738179295207cfce17ff39ba4d06707", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 21342, "upload_time": "2017-11-01T18:39:43", "upload_time_iso_8601": "2017-11-01T18:39:43.812786Z", "url": "https://files.pythonhosted.org/packages/81/e8/14d6f501cac48b9d30260900dec8551d973120c4f32b5584ed9ae5466995/larpix_control-0.4.1.dev3-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "edc947cb2ab49b5269166d879ec55fcd", "sha256": "f902660697fee053e8d008e9b1ff8b66d728c9ad812138bf89dcfcbfa8d0ee76"}, "downloads": -1, "filename": "larpix-control-0.4.1.dev3.tar.gz", "has_sig": false, "md5_digest": "edc947cb2ab49b5269166d879ec55fcd", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 23750, "upload_time": "2017-11-01T18:39:46", "upload_time_iso_8601": "2017-11-01T18:39:46.359249Z", "url": "https://files.pythonhosted.org/packages/05/00/a1754819da1d1ae2a0adc08c813c7809ab2958721a4da4f070a57bf8238c/larpix-control-0.4.1.dev3.tar.gz", "yanked": false}], "0.5.0": [{"comment_text": "", "digests": {"md5": "37738c7c395a364512787301b48542eb", "sha256": "06dc741ac0570e5d03fd427ccfde583ec39d00382ddf9fe51b4503c28fdd847d"}, "downloads": -1, "filename": "larpix_control-0.5.0-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "37738c7c395a364512787301b48542eb", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 27213, "upload_time": "2017-11-14T18:34:45", "upload_time_iso_8601": "2017-11-14T18:34:45.296157Z", "url": "https://files.pythonhosted.org/packages/4f/a7/3fa00b88a17ad95f891e6103a16cc8613a13d4a50c1341465aab69960d12/larpix_control-0.5.0-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "e187cbe342e4a2b0aed1a83be939f995", "sha256": "4bbdac2321762b9bf6f17efc935fcec07a9c0f951b0e8a4debf005fda2c54b08"}, "downloads": -1, "filename": "larpix-control-0.5.0.tar.gz", "has_sig": false, "md5_digest": "e187cbe342e4a2b0aed1a83be939f995", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 29045, "upload_time": "2017-11-14T18:34:50", "upload_time_iso_8601": "2017-11-14T18:34:50.653857Z", "url": "https://files.pythonhosted.org/packages/ce/7e/5aa3fcca67d3b5d57f53e79149e08eef088e70465046bed2444a45e12ab3/larpix-control-0.5.0.tar.gz", "yanked": false}], "0.5.1": [{"comment_text": "", "digests": {"md5": "cb74806355492f35ab2f34c9a8fa15d4", "sha256": "28f28bd4ea2e2e445f66173568bdcb120d31279ed55945079ed28643eddb0d85"}, "downloads": -1, "filename": "larpix_control-0.5.1-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "cb74806355492f35ab2f34c9a8fa15d4", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 27773, "upload_time": "2017-11-14T22:37:26", "upload_time_iso_8601": "2017-11-14T22:37:26.692430Z", "url": "https://files.pythonhosted.org/packages/37/6b/0b5ecd8b775b3b64ccaca59539bc3cef847686ddc6e7e0ec03a8d260ed74/larpix_control-0.5.1-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "ffe17040b61fcedfdefff4018639971e", "sha256": "1f9d83e8e63b36d9bf7e30016b34e19964c5e15cdfe233f4017bdeb1bc750d00"}, "downloads": -1, "filename": "larpix-control-0.5.1.tar.gz", "has_sig": false, "md5_digest": "ffe17040b61fcedfdefff4018639971e", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 29396, "upload_time": "2017-11-14T22:37:32", "upload_time_iso_8601": "2017-11-14T22:37:32.401947Z", "url": "https://files.pythonhosted.org/packages/9b/e6/cccd0a164df63e2fba03bdb65b6619fc477ce9ee5402d4cea05ebef3321e/larpix-control-0.5.1.tar.gz", "yanked": false}], "0.5.2": [{"comment_text": "", "digests": {"md5": "69c97f9c08a27d42658cb266f205fd99", "sha256": "4fc7b217cf752bc1f00a8d39e906849b9bdceb82288f18453d10fc01aaf7679d"}, "downloads": -1, "filename": "larpix_control-0.5.2-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "69c97f9c08a27d42658cb266f205fd99", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 27772, "upload_time": "2017-11-14T22:43:27", "upload_time_iso_8601": "2017-11-14T22:43:27.757059Z", "url": "https://files.pythonhosted.org/packages/c6/ce/bc3b8e8a164ad46fa3f3ff2f3f598da70413e8ed35824f491a89592aef10/larpix_control-0.5.2-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "70574add7ba5ed1b3e59e8688fc862a8", "sha256": "d8ed43c608c5547626212f01ab52590025437744ff16764ea30474fb4f8d7330"}, "downloads": -1, "filename": "larpix-control-0.5.2.tar.gz", "has_sig": false, "md5_digest": "70574add7ba5ed1b3e59e8688fc862a8", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 29691, "upload_time": "2017-11-14T22:43:33", "upload_time_iso_8601": "2017-11-14T22:43:33.261206Z", "url": "https://files.pythonhosted.org/packages/dd/a4/c0847b88b9866a249e676278c4c400e9a0794297da1354a6beb565484c32/larpix-control-0.5.2.tar.gz", "yanked": false}], "0.6.0": [{"comment_text": "", "digests": {"md5": "1ff770a67ede9e024388556a5ac33966", "sha256": "5019d9e0dd53131029e97bb36d70eb1ca25b319b0af2f6b6131bf132ba75ebbd"}, "downloads": -1, "filename": "larpix_control-0.6.0-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "1ff770a67ede9e024388556a5ac33966", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 28327, "upload_time": "2017-11-15T22:42:40", "upload_time_iso_8601": "2017-11-15T22:42:40.023968Z", "url": "https://files.pythonhosted.org/packages/93/b0/b0296fdd128930f9776e3295d8b0084dc999b4a11a340de0a997712a0639/larpix_control-0.6.0-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "e00ff9ef2abbccee6aaf77024c157c02", "sha256": "575d2a997e366e9b28af0e83531b5e0da0ee58192ce3de313f1559f57ec4e02a"}, "downloads": -1, "filename": "larpix-control-0.6.0.tar.gz", "has_sig": false, "md5_digest": "e00ff9ef2abbccee6aaf77024c157c02", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 30234, "upload_time": "2017-11-15T22:42:46", "upload_time_iso_8601": "2017-11-15T22:42:46.265209Z", "url": "https://files.pythonhosted.org/packages/4c/94/1380177da21b450f81d60252b033091c8d89954cc96124c10333e31da1e1/larpix-control-0.6.0.tar.gz", "yanked": false}], "2.2.1": [{"comment_text": "", "digests": {"md5": "e769672a6a3577763cb12b584e8b0d21", "sha256": "eacff42b91038ea334cea7d7c1b2b73bb163ddd80ddc5eac12a57ffe3511e122"}, "downloads": -1, "filename": "larpix_control-2.2.1-py3-none-any.whl", "has_sig": false, "md5_digest": "e769672a6a3577763cb12b584e8b0d21", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 54151, "upload_time": "2019-06-11T00:25:41", "upload_time_iso_8601": "2019-06-11T00:25:41.206159Z", "url": "https://files.pythonhosted.org/packages/96/ac/4508431f6daaa27ae324574d17883aeb567d6dea9cff3ecc503c991fee27/larpix_control-2.2.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "cd73b3d093bd9fa87d9c5c6d3eb929ac", "sha256": "edd3b4ee1db3ad30b159ad4a8bcfe848af6f99baacac30015f57dc5bf9d23133"}, "downloads": -1, "filename": "larpix-control-2.2.1.tar.gz", "has_sig": false, "md5_digest": "cd73b3d093bd9fa87d9c5c6d3eb929ac", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 59701, "upload_time": "2019-06-11T00:25:42", "upload_time_iso_8601": "2019-06-11T00:25:42.920668Z", "url": "https://files.pythonhosted.org/packages/32/55/b1823995099b787fb97d1ffecb36c91fb969e3fac51514ab45de17c0effb/larpix-control-2.2.1.tar.gz", "yanked": false}], "2.2.1rc2": [{"comment_text": "", "digests": {"md5": "57de56cf2ad2e9e3f9ddee6fa119643a", "sha256": "fd21027e9c10c11b0aa560bb5ca106f8ba37c47280247f61a46922c7b03318b1"}, "downloads": -1, "filename": "larpix_control-2.2.1rc2-py3-none-any.whl", "has_sig": false, "md5_digest": "57de56cf2ad2e9e3f9ddee6fa119643a", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 69832, "upload_time": "2019-06-04T00:03:01", "upload_time_iso_8601": "2019-06-04T00:03:01.390814Z", "url": "https://files.pythonhosted.org/packages/ef/b2/06cf0af1e763547f44b7bf8adea58ff42c4a6517366fe863a8c85125195a/larpix_control-2.2.1rc2-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "6f6ec2840efc656687b153008fb73294", "sha256": "567573f1268ccdcc727d919b9fca3c78b06c11b1dff7b9fb94db3217cdc4c395"}, "downloads": -1, "filename": "larpix-control-2.2.1rc2.tar.gz", "has_sig": false, "md5_digest": "6f6ec2840efc656687b153008fb73294", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 62795, "upload_time": "2019-06-04T00:03:03", "upload_time_iso_8601": "2019-06-04T00:03:03.273340Z", "url": "https://files.pythonhosted.org/packages/72/bb/d7e4bd2c6cc74abc12e7b261e56fdd84633289f4e24815831bdecf54cdaa/larpix-control-2.2.1rc2.tar.gz", "yanked": false}], "2.2.1rc3": [{"comment_text": "", "digests": {"md5": "48c38cf42f53afeb41b64ea23797b3ad", "sha256": "76be45aa5d3d94084dacbe37c8a4a084886cca670eeac7786792965f42df8d61"}, "downloads": -1, "filename": "larpix_control-2.2.1rc3-py3-none-any.whl", "has_sig": false, "md5_digest": "48c38cf42f53afeb41b64ea23797b3ad", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 54174, "upload_time": "2019-06-10T23:39:37", "upload_time_iso_8601": "2019-06-10T23:39:37.191939Z", "url": "https://files.pythonhosted.org/packages/40/83/231943d2f2c34251abd16a0e90d619742a306bd4b5f084ec3e283036c0f8/larpix_control-2.2.1rc3-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "d4020ab8641c7cdb380bb7ccfca31e84", "sha256": "f0079b04fa150f523dbcf4ccb5e13a891caba9931375e255b298c98dfa8236a3"}, "downloads": -1, "filename": "larpix-control-2.2.1rc3.tar.gz", "has_sig": false, "md5_digest": "d4020ab8641c7cdb380bb7ccfca31e84", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 59595, "upload_time": "2019-06-10T23:39:38", "upload_time_iso_8601": "2019-06-10T23:39:38.962562Z", "url": "https://files.pythonhosted.org/packages/2f/5a/17c9dfd0c4ac85d66055a529898fe89baf2588b9e948ca4105456704008a/larpix-control-2.2.1rc3.tar.gz", "yanked": false}], "2.3.0": [{"comment_text": "", "digests": {"md5": "5650fdb3ec9919231a66dfb9853ff892", "sha256": "535921874ca57a17b00290d80eca6ad651251b634cdf193d221e7897b99e381f"}, "downloads": -1, "filename": "larpix_control-2.3.0-py2-none-any.whl", "has_sig": false, "md5_digest": "5650fdb3ec9919231a66dfb9853ff892", "packagetype": "bdist_wheel", "python_version": "py2", "requires_python": null, "size": 75356, "upload_time": "2019-07-24T01:25:34", "upload_time_iso_8601": "2019-07-24T01:25:34.916222Z", "url": "https://files.pythonhosted.org/packages/11/cf/e672275c0c7422e48f127d10f11df4c62321fa03e2bac3f03532fa861781/larpix_control-2.3.0-py2-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "f7b17a8e1fc8719ecb520974d621529d", "sha256": "fe8edd08169a05dc17566985f9c3bdeb4ef158409ba87c1bf8454d2347558b67"}, "downloads": -1, "filename": "larpix_control-2.3.0-py3-none-any.whl", "has_sig": false, "md5_digest": "f7b17a8e1fc8719ecb520974d621529d", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 75356, "upload_time": "2019-07-16T23:15:13", "upload_time_iso_8601": "2019-07-16T23:15:13.846905Z", "url": "https://files.pythonhosted.org/packages/77/b6/9e52f8fdb7b2a88795fb74f111181ba34ef8cc946dee11a15eaedbc23b62/larpix_control-2.3.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "c1ffa845d7892d15121ff97a674bd23c", "sha256": "e0f71e37a7b999d61886ed159b4c0f77bbec9805e2f8284134d35e703e1b1bac"}, "downloads": -1, "filename": "larpix-control-2.3.0.tar.gz", "has_sig": false, "md5_digest": "c1ffa845d7892d15121ff97a674bd23c", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 92433, "upload_time": "2019-07-16T23:15:15", "upload_time_iso_8601": "2019-07-16T23:15:15.823791Z", "url": "https://files.pythonhosted.org/packages/4c/12/e22b5b208aec807eace6cb4a6540d2f73937be2dcca299b534baa64f09b5/larpix-control-2.3.0.tar.gz", "yanked": false}], "2.3.0rc1": [{"comment_text": "", "digests": {"md5": "0fe9c8b5b62248e8c72fef5431f39edf", "sha256": "ee22727966d08f52899246adf7f0c60d1bd44d5a44f8cc3c36ea9bfdd5522251"}, "downloads": -1, "filename": "larpix_control-2.3.0rc1-py3-none-any.whl", "has_sig": false, "md5_digest": "0fe9c8b5b62248e8c72fef5431f39edf", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 75221, "upload_time": "2019-07-01T19:44:27", "upload_time_iso_8601": "2019-07-01T19:44:27.279525Z", "url": "https://files.pythonhosted.org/packages/e3/4a/0cb56b1c07a95925b06362c583dd071fa09de3d96fed33852e2aaeaa6362/larpix_control-2.3.0rc1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "71ae8518d0f5d1622b48f9b0f393d65f", "sha256": "468ab5c946e7bfa30154f5cf8a2874446ea3e6bf25791fb8269551f4836268f0"}, "downloads": -1, "filename": "larpix-control-2.3.0rc1.tar.gz", "has_sig": false, "md5_digest": "71ae8518d0f5d1622b48f9b0f393d65f", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 90903, "upload_time": "2019-07-01T19:44:35", "upload_time_iso_8601": "2019-07-01T19:44:35.436661Z", "url": "https://files.pythonhosted.org/packages/0d/72/67003859509a90b7f1d1a2da09142b3e8038ead4fe2750b7cc9ce3940114/larpix-control-2.3.0rc1.tar.gz", "yanked": false}], "3.0.0": [{"comment_text": "", "digests": {"md5": "4f2882fef464873c37aa6fe9547fd881", "sha256": "dee6b28bdca9f8302a2a8157f4e899d8fb380b2daf1be6bacba29e83a95f62c1"}, "downloads": -1, "filename": "larpix_control-3.0.0-py3-none-any.whl", "has_sig": false, "md5_digest": "4f2882fef464873c37aa6fe9547fd881", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 108528, "upload_time": "2020-01-10T00:27:23", "upload_time_iso_8601": "2020-01-10T00:27:23.815964Z", "url": "https://files.pythonhosted.org/packages/e1/41/5df62a5914d6b599070ca5e6ef28c60c9ce9b388f3e5512e33105b07db64/larpix_control-3.0.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "5847684d376ea82af2a3c546c5a82e8b", "sha256": "7a159826f30b8990b16425c970ec33d31e5165e5c3e6e3ce9f63c6f6b6f17bad"}, "downloads": -1, "filename": "larpix-control-3.0.0.tar.gz", "has_sig": false, "md5_digest": "5847684d376ea82af2a3c546c5a82e8b", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 124355, "upload_time": "2020-01-10T00:27:26", "upload_time_iso_8601": "2020-01-10T00:27:26.048877Z", "url": "https://files.pythonhosted.org/packages/f3/9e/df129f907ee99e49f1e4cbb15550d73aa44fbfe396f21f4c34523271f649/larpix-control-3.0.0.tar.gz", "yanked": false}], "3.0.1": [{"comment_text": "", "digests": {"md5": "1c52db37bf0de13c120434f22f0ccc24", "sha256": "086b6438672062bc74ac078ae7e03c1679ee3b9698943fb5719f3133a0c6cbf4"}, "downloads": -1, "filename": "larpix_control-3.0.1-py3-none-any.whl", "has_sig": false, "md5_digest": "1c52db37bf0de13c120434f22f0ccc24", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 109308, "upload_time": "2020-02-26T17:40:16", "upload_time_iso_8601": "2020-02-26T17:40:16.177793Z", "url": "https://files.pythonhosted.org/packages/c8/dc/8e65b0b637847698687cce83870f845bfa5323caaa2de8c6f092a1d97570/larpix_control-3.0.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "a22212d446f3079462a341d475154db0", "sha256": "42102d72b84d2455354835a7f978cc059e60d07551add23585ccd50a4cfb6db4"}, "downloads": -1, "filename": "larpix-control-3.0.1.tar.gz", "has_sig": false, "md5_digest": "a22212d446f3079462a341d475154db0", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 125101, "upload_time": "2020-02-26T17:40:18", "upload_time_iso_8601": "2020-02-26T17:40:18.256131Z", "url": "https://files.pythonhosted.org/packages/2b/6c/153c7dc04a1c8956c7cda063f3af2ad878e62d0f9d0880e7ce61ee151072/larpix-control-3.0.1.tar.gz", "yanked": false}], "3.1.1": [{"comment_text": "", "digests": {"md5": "01ffc4e2fdeb37a8d1e02093b55ea4f9", "sha256": "4197308d4cbbec0a432ccb23ea091b12d4887dec6413cee0964423f927b1d26f"}, "downloads": -1, "filename": "larpix_control-3.1.1-py3-none-any.whl", "has_sig": false, "md5_digest": "01ffc4e2fdeb37a8d1e02093b55ea4f9", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 112846, "upload_time": "2020-03-19T20:45:53", "upload_time_iso_8601": "2020-03-19T20:45:53.560570Z", "url": "https://files.pythonhosted.org/packages/bc/c2/c8514518b2dd4895900d819c08253f3136d8eb39b5e72768dcabb428365d/larpix_control-3.1.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "e0a4db1549d454a7856bbc6c545dfaae", "sha256": "5f37c88d52012024acae297789e2e5a55e34278edb6ef500a77135595d503389"}, "downloads": -1, "filename": "larpix-control-3.1.1.tar.gz", "has_sig": false, "md5_digest": "e0a4db1549d454a7856bbc6c545dfaae", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 127789, "upload_time": "2020-03-19T20:45:55", "upload_time_iso_8601": "2020-03-19T20:45:55.194007Z", "url": "https://files.pythonhosted.org/packages/c1/ee/133c7be7e9b3baa328e9126a93cf3cb4c4d307cb9ffc708e9bfdb4f5818a/larpix-control-3.1.1.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "01ffc4e2fdeb37a8d1e02093b55ea4f9", "sha256": "4197308d4cbbec0a432ccb23ea091b12d4887dec6413cee0964423f927b1d26f"}, "downloads": -1, "filename": "larpix_control-3.1.1-py3-none-any.whl", "has_sig": false, "md5_digest": "01ffc4e2fdeb37a8d1e02093b55ea4f9", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 112846, "upload_time": "2020-03-19T20:45:53", "upload_time_iso_8601": "2020-03-19T20:45:53.560570Z", "url": "https://files.pythonhosted.org/packages/bc/c2/c8514518b2dd4895900d819c08253f3136d8eb39b5e72768dcabb428365d/larpix_control-3.1.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "e0a4db1549d454a7856bbc6c545dfaae", "sha256": "5f37c88d52012024acae297789e2e5a55e34278edb6ef500a77135595d503389"}, "downloads": -1, "filename": "larpix-control-3.1.1.tar.gz", "has_sig": false, "md5_digest": "e0a4db1549d454a7856bbc6c545dfaae", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 127789, "upload_time": "2020-03-19T20:45:55", "upload_time_iso_8601": "2020-03-19T20:45:55.194007Z", "url": "https://files.pythonhosted.org/packages/c1/ee/133c7be7e9b3baa328e9126a93cf3cb4c4d307cb9ffc708e9bfdb4f5818a/larpix-control-3.1.1.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:47:50 2020"}