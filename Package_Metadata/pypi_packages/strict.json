{"info": {"author": "Jevgeni Tarassov", "author_email": "jevgeni@tarasov.ch", "bugtrack_url": null, "classifiers": [], "description": "=======================================\r\nStrict Functions & Structures in Python\r\n=======================================\r\n\r\n``strict`` is a module, that addresses the frequent need for type checking in\r\nPython.\r\n\r\n\r\nQuick Example\r\n=============\r\n\r\nFunction Constraints\r\n--------------------\r\n\r\nAdd type constraints to the function signature::\r\n\r\n    from __future__ import print_function\r\n    from strict.functions import *\r\n\r\n    @expects(arg(float), arg(float), message=arg(str))\r\n    def multiply_and_print(a, b, message=\"You've got {result}\"):\r\n        print(message.format(result=(a * b)))\r\n\r\n    # This works just fine\r\n    multiply_and_print(2.0, 3.0)\r\n\r\n    # This raises a TypeConstraintError\r\n    multiply_and_print(int(2.0), 3.0)\r\n\r\n\r\nAdd type constraint to a method::\r\n\r\n    from __future__ import print_function\r\n    from strict.functions import *\r\n\r\n    class Foo(object):\r\n\r\n        @expects(self, arg(str))\r\n        def __init__(self, name):\r\n            self.name = name\r\n        \r\n        def say_hello(self):\r\n            print(\", \".join([\"Hello\", self.name]))\r\n\r\n    # This works\r\n    f = Foo(\"Jim\")\r\n    f.say_hello()\r\n\r\n    # This doesn't\r\n    f = Foo(123)\r\n    f.say_hello()\r\n\r\n\r\nAdd a constraint on the return value of a function::\r\n\r\n    from strict.functions import *\r\n\r\n    @returns(int)\r\n    def return_two():\r\n        return 2\r\n\r\n    @returns(int)\r\n    def return_half():\r\n        return 0.5\r\n\r\n    # This works fine\r\n    return_two()\r\n\r\n    # This raises an exception\r\n    return_half()\r\n\r\n\r\nAdd a subject matter constraint, as well as a type constraint to a function::\r\n\r\n    @expects(arg(float), arg(float, lambda x: x != 0))\r\n    def divide(a, b):\r\n        \"We need to make sure, that b isn't zero...\"\r\n        return a / b\r\n\r\n    # This works\r\n    divide(4.0, 2.0)\r\n\r\n    # This all fails with a TypeConstraintError\r\n    divide(4, 2.0)\r\n    divide(4.0, \"poop\")\r\n\r\n    # This fails with a SubjectConstraintError\r\n    divide(4.0, 0.0)\r\n\r\n\r\nStructures\r\n----------\r\n\r\nDefine a structure::\r\n\r\n    from strict.structures import *\r\n\r\n    class Point(Structure):\r\n        \"\"\"\r\n        Let's have a point, that can fit only on a certain area.\r\n        \"\"\"\r\n        x = Field(float, lambda x: 0.0 < x < 1000.0)\r\n        y = Field(float, lambda y: 0.0 < y < 1000.0)\r\n\r\n        def __init__(self, x, y):\r\n            self.x = x\r\n            self.y = y\r\n\r\n    # This works\r\n    a = Point(10.0, 15.0)\r\n\r\n    # This all fails with the correct exception\r\n    Point(10, 15)\r\n    Point(10.0, 1001.0)\r\n    Point(-2.0, 50.0)\r\n\r\n\r\nSerialize your structure::\r\n\r\n    from strict.structures import *\r\n\r\n    class Point(Structure):\r\n        \"\"\"\r\n        Let's have a point, that can fit only on a certain area.\r\n        \"\"\"\r\n        x = Field(float, lambda x: 0.0 < x < 1000.0)\r\n        y = Field(float, lambda y: 0.0 < y < 1000.0)\r\n\r\n        def __init__(self, x, y):\r\n            self.x = x\r\n            self.y = y\r\n\r\n    a = Point(10.0, 15.0)\r\n\r\n    # This outputs a dictionary\r\n    a.to_dict()\r\n\r\n    # This outputs a list\r\n    a.to_list()\r\n\r\n\r\nWhy Would I Type Check?\r\n=======================\r\n\r\nAlthough, the common idiom to deal with type compatibility issues in Python is\r\nduck typing, in some cases it is not adequate.\r\n\r\nQuite often the information about the *usage context* is implicitly encoded in\r\nthe class name, which duck typing would usually fail to handle, unless you\r\nintroduce wildly differing class interfaces or just kludge.\r\n\r\nConsider the following class tree of a financial application::\r\n\r\n                        +--------------------------+                   \r\n                        |                          |                   \r\n                        |   BaseVolatilitySurface  |                   \r\n                        |                          |                   \r\n                        +-------------+------------+                   \r\n                                      |                                \r\n                                      |                                \r\n                                      |                                \r\n                                      |                                \r\n    +---------------------------+     |     +-------------------------+\r\n    |                           |     |     |                         |\r\n    |  EquityVolatilitySurface  <-----+----->  RateVolatilitySurface  |\r\n    |                           |           |                         |\r\n    +---------------------------+           +-------------------------+\r\n\r\nVolatility of some value (usually of an asset price) is the key input of\r\nvaluation models for financial derivatives. In this case, we try to model in our\r\napplication the volatility of equity and interest rates, implied by market\r\nprices.\r\n\r\nBoth classes would have mostly the same interface. If we rely on duck typing and\r\naccidentaly pass a ``RateVolatilitySurface`` to value an equity option, no\r\nexception would be raised, since **techically** the input would satisfy the\r\nconstraint expressed through duck typing. However, the result would be wrong and\r\nwe'd get a typical example of a SH*T IN, SH*T OUT program.\r\n\r\nThe obvious solution is to sprinkle your code with a liberal amount of\r\n``isinstance`` checks. This, however, quickly leads to your business code being\r\ndominated by boilerplate checks and error handling. To avoid this I tried to put\r\nthe most useful and simple patterns in a module:\r\n\r\n- Assigning constraints to function arguments and return values \r\n- Creating a class with strict type checking of its properties and the correctly \r\n  filled ``__slots__`` variable.\r\n\r\n\r\n2014, Jevgeni Tarasov (jevgeni@tarasov.ch)", "description_content_type": null, "docs_url": null, "download_url": "UNKNOWN", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://bitbucket.org/slenderboy/strict", "keywords": null, "license": "MIT", "maintainer": null, "maintainer_email": null, "name": "strict", "package_url": "https://pypi.org/project/strict/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/strict/", "project_urls": {"Download": "UNKNOWN", "Homepage": "https://bitbucket.org/slenderboy/strict"}, "release_url": "https://pypi.org/project/strict/0.1alpha/", "requires_dist": null, "requires_python": null, "summary": "Type and subject matter checks for functions and classes.", "version": "0.1alpha", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p><tt>strict</tt> is a module, that addresses the frequent need for type checking in\nPython.</p>\n<div id=\"quick-example\">\n<h2>Quick Example</h2>\n<div id=\"function-constraints\">\n<h3>Function Constraints</h3>\n<p>Add type constraints to the function signature:</p>\n<pre>from __future__ import print_function\nfrom strict.functions import *\n\n@expects(arg(float), arg(float), message=arg(str))\ndef multiply_and_print(a, b, message=\"You've got {result}\"):\n    print(message.format(result=(a * b)))\n\n# This works just fine\nmultiply_and_print(2.0, 3.0)\n\n# This raises a TypeConstraintError\nmultiply_and_print(int(2.0), 3.0)\n</pre>\n<p>Add type constraint to a method:</p>\n<pre>from __future__ import print_function\nfrom strict.functions import *\n\nclass Foo(object):\n\n    @expects(self, arg(str))\n    def __init__(self, name):\n        self.name = name\n\n    def say_hello(self):\n        print(\", \".join([\"Hello\", self.name]))\n\n# This works\nf = Foo(\"Jim\")\nf.say_hello()\n\n# This doesn't\nf = Foo(123)\nf.say_hello()\n</pre>\n<p>Add a constraint on the return value of a function:</p>\n<pre>from strict.functions import *\n\n@returns(int)\ndef return_two():\n    return 2\n\n@returns(int)\ndef return_half():\n    return 0.5\n\n# This works fine\nreturn_two()\n\n# This raises an exception\nreturn_half()\n</pre>\n<p>Add a subject matter constraint, as well as a type constraint to a function:</p>\n<pre>@expects(arg(float), arg(float, lambda x: x != 0))\ndef divide(a, b):\n    \"We need to make sure, that b isn't zero...\"\n    return a / b\n\n# This works\ndivide(4.0, 2.0)\n\n# This all fails with a TypeConstraintError\ndivide(4, 2.0)\ndivide(4.0, \"poop\")\n\n# This fails with a SubjectConstraintError\ndivide(4.0, 0.0)\n</pre>\n</div>\n<div id=\"structures\">\n<h3>Structures</h3>\n<p>Define a structure:</p>\n<pre>from strict.structures import *\n\nclass Point(Structure):\n    \"\"\"\n    Let's have a point, that can fit only on a certain area.\n    \"\"\"\n    x = Field(float, lambda x: 0.0 &lt; x &lt; 1000.0)\n    y = Field(float, lambda y: 0.0 &lt; y &lt; 1000.0)\n\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n# This works\na = Point(10.0, 15.0)\n\n# This all fails with the correct exception\nPoint(10, 15)\nPoint(10.0, 1001.0)\nPoint(-2.0, 50.0)\n</pre>\n<p>Serialize your structure:</p>\n<pre>from strict.structures import *\n\nclass Point(Structure):\n    \"\"\"\n    Let's have a point, that can fit only on a certain area.\n    \"\"\"\n    x = Field(float, lambda x: 0.0 &lt; x &lt; 1000.0)\n    y = Field(float, lambda y: 0.0 &lt; y &lt; 1000.0)\n\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\na = Point(10.0, 15.0)\n\n# This outputs a dictionary\na.to_dict()\n\n# This outputs a list\na.to_list()\n</pre>\n</div>\n</div>\n<div id=\"why-would-i-type-check\">\n<h2>Why Would I Type Check?</h2>\n<p>Although, the common idiom to deal with type compatibility issues in Python is\nduck typing, in some cases it is not adequate.</p>\n<p>Quite often the information about the <em>usage context</em> is implicitly encoded in\nthe class name, which duck typing would usually fail to handle, unless you\nintroduce wildly differing class interfaces or just kludge.</p>\n<p>Consider the following class tree of a financial application:</p>\n<pre>                    +--------------------------+\n                    |                          |\n                    |   BaseVolatilitySurface  |\n                    |                          |\n                    +-------------+------------+\n                                  |\n                                  |\n                                  |\n                                  |\n+---------------------------+     |     +-------------------------+\n|                           |     |     |                         |\n|  EquityVolatilitySurface  &lt;-----+-----&gt;  RateVolatilitySurface  |\n|                           |           |                         |\n+---------------------------+           +-------------------------+\n</pre>\n<p>Volatility of some value (usually of an asset price) is the key input of\nvaluation models for financial derivatives. In this case, we try to model in our\napplication the volatility of equity and interest rates, implied by market\nprices.</p>\n<p>Both classes would have mostly the same interface. If we rely on duck typing and\naccidentaly pass a <tt>RateVolatilitySurface</tt> to value an equity option, no\nexception would be raised, since <strong>techically</strong> the input would satisfy the\nconstraint expressed through duck typing. However, the result would be wrong and\nwe\u2019d get a typical example of a SH*T IN, SH*T OUT program.</p>\n<p>The obvious solution is to sprinkle your code with a liberal amount of\n<tt>isinstance</tt> checks. This, however, quickly leads to your business code being\ndominated by boilerplate checks and error handling. To avoid this I tried to put\nthe most useful and simple patterns in a module:</p>\n<ul>\n<li>Assigning constraints to function arguments and return values</li>\n<li>Creating a class with strict type checking of its properties and the correctly\nfilled <tt>__slots__</tt> variable.</li>\n</ul>\n<p>2014, Jevgeni Tarasov (<a href=\"mailto:jevgeni%40tarasov.ch\">jevgeni<span>@</span>tarasov<span>.</span>ch</a>)</p>\n</div>\n\n          </div>"}, "last_serial": 1187007, "releases": {"0.1alpha": [{"comment_text": "", "digests": {"md5": "db97084a405b90413fe3c77d6506e821", "sha256": "caad92ee5f9e825c5d9e0d0eab4b14051efa867987eefc44e52964337ccad1d4"}, "downloads": -1, "filename": "strict-0.1alpha.tar.gz", "has_sig": false, "md5_digest": "db97084a405b90413fe3c77d6506e821", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 7442, "upload_time": "2014-08-11T21:57:00", "upload_time_iso_8601": "2014-08-11T21:57:00.576398Z", "url": "https://files.pythonhosted.org/packages/1a/47/9e66c2e593abfce27dff7d97b593c7b9c55d37bcd5a02458553f1763ef59/strict-0.1alpha.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "db97084a405b90413fe3c77d6506e821", "sha256": "caad92ee5f9e825c5d9e0d0eab4b14051efa867987eefc44e52964337ccad1d4"}, "downloads": -1, "filename": "strict-0.1alpha.tar.gz", "has_sig": false, "md5_digest": "db97084a405b90413fe3c77d6506e821", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 7442, "upload_time": "2014-08-11T21:57:00", "upload_time_iso_8601": "2014-08-11T21:57:00.576398Z", "url": "https://files.pythonhosted.org/packages/1a/47/9e66c2e593abfce27dff7d97b593c7b9c55d37bcd5a02458553f1763ef59/strict-0.1alpha.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:01:14 2020"}