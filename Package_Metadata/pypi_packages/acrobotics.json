{"info": {"author": "Jeroen De Maeyer", "author_email": "jeroen.demaeyer@kuleuven.be", "bugtrack_url": null, "classifiers": ["License :: OSI Approved :: MIT License", "Operating System :: OS Independent", "Programming Language :: Python :: 3"], "description": "[![Build Status](https://travis-ci.org/JeroenDM/acrobotics.svg?branch=master)](https://travis-ci.org/JeroenDM/acrobotics) [![codecov](https://codecov.io/gh/JeroenDM/acrobotics/branch/master/graph/badge.svg)](https://codecov.io/gh/JeroenDM/acrobotics)\n\n# Acrobotics\n\nQuickly test motion planning ideas is the goal, and Python seems like a great language for rapid prototyping. There are great libraries for robot simulation and related task, but installing them is can be a hassle and very dependent on operating system and python version.\nThe drawback is that I have to write a lot of stuff myself. I'm not sure if it is useful to do this. But it will be fun and I will learn a bunch.\n\nThis library provides robot kinematics and collision checking for serial kinematic chains. The idea is that this library can be easily swapped by another one providing the same functionality.\n\nThe acro part comes from [ACRO](https://iiw.kuleuven.be/onderzoek/acro) a robotics research group at KU Leuven in Belgium.\n\n## Installation\n\n```bash\npip install acrobotics\n```\n\nOr for development\n\n```bash\ngit clone https://github.com/JeroenDM/acrobotics.git\ncd acrobotics\npython setup.py develop\n```\n\nNo Windows support for the moment because [python-fcl](https://pypi.org/project/python-fcl/) is not supported. :(\nIn the future I will possibly switch to [pybullet](https://pypi.org/project/pybullet/). In the meantime, use [windows subsystem for linux](https://docs.microsoft.com/en-us/windows/wsl/install-win10). MacOS is not tested yet.\n\n## Gettings started\n\n(Code for example below: [examples/getting_started.py](examples/getting_started.py))\n\nThis library has three main tricks.\n\n### Robot kinematics\n`T = robot.fk(joint_values)`\n`IKSolution = robot.ik(T)`\n\nForward kinematics are implemented in a generic `RobotKinematics` class.\n```python\nfrom acrobotics.robot_examples import Kuka\n\nrobot = Kuka()\n\njoint_values = [0.1, 0.2, 0.3, 0.4, 0.5, 0.6]\nT_fk = robot.fk(joint_values)\n```\n\nAnalytical inverse kinematics only for specific robots:\n```python\nik_solution = robot.ik(T_fk)  # T_fk is a numpy 4x4 array\n\nprint(f\"Inverse kinematics successful? {ik_solution.success}\")\nfor q in ik_solution.solutions:\n    print(q)\n```\n```bash\nInverse kinematics successful? True\n[ 0.1        -1.0949727   2.84159265  2.87778828  0.79803563 -1.99992985]\n[ 0.1        -1.0949727   2.84159265 -0.26380438 -0.79803563  1.1416628 ]\n[0.1 0.2 0.3 0.4 0.5 0.6]\n[ 0.1         0.2         0.3        -2.74159265 -0.5        -2.54159265]\n```\n\n### Collision checking\n`bool = robot.is_in_collision(joint_values, planning_scene)`\n\nFirst create a planning scene with obstacles the robot can collide with.\n```python\nfrom acrobotics.geometry import Scene\nfrom acrobotics.shapes import Box\n\ntable = Box(2, 2, 0.1)\nT_table = translation(0, 0, -0.2)\n\nobstacle = Box(0.2, 0.2, 1.5)\nT_obs = translation(0, 0.5, 0.55)\n\nscene = Scene([table, obstacle], [T_table, T_obs])\n```\n\nThen create a list of robot configurations for wich you want to check collision with the planning scene.\n```python\nimport numpy as np\n\nq_start = np.array([0.5, 1.5, -0.3, 0, 0, 0])\nq_goal = np.array([2.5, 1.5, 0.3, 0, 0, 0])\nq_path = np.linspace(q_start, q_goal, 10)\n```\n\nAnd then you could do:\n```python\nprint([robot.is_in_collision(q, scene) for q in q_path])\n```\n```bash\n[False, False, False, False, True, True, True, True, False, False]\n```\n\n### Visualization\n`robot.plot(axes_handle, joint_values)`\n`robot.animate_path(figure_handle, axes_handle, joint_path)`\n\n```python\nfrom acrobotics.util import get_default_axes3d\n\nfig, ax = get_default_axes3d()\n\nscene.plot(ax, c=\"green\")\nrobot.animate_path(fig, ax, q_path)\n```\n\n![animation](examples/robot_animation.gif)\n\n## More details\n\nThere's a more in depth explanation in the jupyter-notebooks in the examples folder.\n\n## And motion planning?\n\nComming soon.", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/JeroenDM/acrobotics", "keywords": "", "license": "", "maintainer": "", "maintainer_email": "", "name": "acrobotics", "package_url": "https://pypi.org/project/acrobotics/", "platform": "", "project_url": "https://pypi.org/project/acrobotics/", "project_urls": {"Homepage": "https://github.com/JeroenDM/acrobotics"}, "release_url": "https://pypi.org/project/acrobotics/0.0.3/", "requires_dist": null, "requires_python": ">=3.6", "summary": "Primitive robot kinematics and collision checking.", "version": "0.0.3", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p><a href=\"https://travis-ci.org/JeroenDM/acrobotics\" rel=\"nofollow\"><img alt=\"Build Status\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/439cf67f630de683cde194c986aaeb730be13aeb/68747470733a2f2f7472617669732d63692e6f72672f4a65726f656e444d2f6163726f626f746963732e7376673f6272616e63683d6d6173746572\"></a> <a href=\"https://codecov.io/gh/JeroenDM/acrobotics\" rel=\"nofollow\"><img alt=\"codecov\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/1dc394bc802c8ad6c5a2dcfabe6a1aa2df9660ea/68747470733a2f2f636f6465636f762e696f2f67682f4a65726f656e444d2f6163726f626f746963732f6272616e63682f6d61737465722f67726170682f62616467652e737667\"></a></p>\n<h1>Acrobotics</h1>\n<p>Quickly test motion planning ideas is the goal, and Python seems like a great language for rapid prototyping. There are great libraries for robot simulation and related task, but installing them is can be a hassle and very dependent on operating system and python version.\nThe drawback is that I have to write a lot of stuff myself. I'm not sure if it is useful to do this. But it will be fun and I will learn a bunch.</p>\n<p>This library provides robot kinematics and collision checking for serial kinematic chains. The idea is that this library can be easily swapped by another one providing the same functionality.</p>\n<p>The acro part comes from <a href=\"https://iiw.kuleuven.be/onderzoek/acro\" rel=\"nofollow\">ACRO</a> a robotics research group at KU Leuven in Belgium.</p>\n<h2>Installation</h2>\n<pre>pip install acrobotics\n</pre>\n<p>Or for development</p>\n<pre>git clone https://github.com/JeroenDM/acrobotics.git\n<span class=\"nb\">cd</span> acrobotics\npython setup.py develop\n</pre>\n<p>No Windows support for the moment because <a href=\"https://pypi.org/project/python-fcl/\" rel=\"nofollow\">python-fcl</a> is not supported. :(\nIn the future I will possibly switch to <a href=\"https://pypi.org/project/pybullet/\" rel=\"nofollow\">pybullet</a>. In the meantime, use <a href=\"https://docs.microsoft.com/en-us/windows/wsl/install-win10\" rel=\"nofollow\">windows subsystem for linux</a>. MacOS is not tested yet.</p>\n<h2>Gettings started</h2>\n<p>(Code for example below: <a href=\"examples/getting_started.py\" rel=\"nofollow\">examples/getting_started.py</a>)</p>\n<p>This library has three main tricks.</p>\n<h3>Robot kinematics</h3>\n<p><code>T = robot.fk(joint_values)</code>\n<code>IKSolution = robot.ik(T)</code></p>\n<p>Forward kinematics are implemented in a generic <code>RobotKinematics</code> class.</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">acrobotics.robot_examples</span> <span class=\"kn\">import</span> <span class=\"n\">Kuka</span>\n\n<span class=\"n\">robot</span> <span class=\"o\">=</span> <span class=\"n\">Kuka</span><span class=\"p\">()</span>\n\n<span class=\"n\">joint_values</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mf\">0.1</span><span class=\"p\">,</span> <span class=\"mf\">0.2</span><span class=\"p\">,</span> <span class=\"mf\">0.3</span><span class=\"p\">,</span> <span class=\"mf\">0.4</span><span class=\"p\">,</span> <span class=\"mf\">0.5</span><span class=\"p\">,</span> <span class=\"mf\">0.6</span><span class=\"p\">]</span>\n<span class=\"n\">T_fk</span> <span class=\"o\">=</span> <span class=\"n\">robot</span><span class=\"o\">.</span><span class=\"n\">fk</span><span class=\"p\">(</span><span class=\"n\">joint_values</span><span class=\"p\">)</span>\n</pre>\n<p>Analytical inverse kinematics only for specific robots:</p>\n<pre><span class=\"n\">ik_solution</span> <span class=\"o\">=</span> <span class=\"n\">robot</span><span class=\"o\">.</span><span class=\"n\">ik</span><span class=\"p\">(</span><span class=\"n\">T_fk</span><span class=\"p\">)</span>  <span class=\"c1\"># T_fk is a numpy 4x4 array</span>\n\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"sa\">f</span><span class=\"s2\">\"Inverse kinematics successful? </span><span class=\"si\">{</span><span class=\"n\">ik_solution</span><span class=\"o\">.</span><span class=\"n\">success</span><span class=\"si\">}</span><span class=\"s2\">\"</span><span class=\"p\">)</span>\n<span class=\"k\">for</span> <span class=\"n\">q</span> <span class=\"ow\">in</span> <span class=\"n\">ik_solution</span><span class=\"o\">.</span><span class=\"n\">solutions</span><span class=\"p\">:</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">q</span><span class=\"p\">)</span>\n</pre>\n<pre>Inverse kinematics successful? True\n<span class=\"o\">[</span> <span class=\"m\">0</span>.1        -1.0949727   <span class=\"m\">2</span>.84159265  <span class=\"m\">2</span>.87778828  <span class=\"m\">0</span>.79803563 -1.99992985<span class=\"o\">]</span>\n<span class=\"o\">[</span> <span class=\"m\">0</span>.1        -1.0949727   <span class=\"m\">2</span>.84159265 -0.26380438 -0.79803563  <span class=\"m\">1</span>.1416628 <span class=\"o\">]</span>\n<span class=\"o\">[</span><span class=\"m\">0</span>.1 <span class=\"m\">0</span>.2 <span class=\"m\">0</span>.3 <span class=\"m\">0</span>.4 <span class=\"m\">0</span>.5 <span class=\"m\">0</span>.6<span class=\"o\">]</span>\n<span class=\"o\">[</span> <span class=\"m\">0</span>.1         <span class=\"m\">0</span>.2         <span class=\"m\">0</span>.3        -2.74159265 -0.5        -2.54159265<span class=\"o\">]</span>\n</pre>\n<h3>Collision checking</h3>\n<p><code>bool = robot.is_in_collision(joint_values, planning_scene)</code></p>\n<p>First create a planning scene with obstacles the robot can collide with.</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">acrobotics.geometry</span> <span class=\"kn\">import</span> <span class=\"n\">Scene</span>\n<span class=\"kn\">from</span> <span class=\"nn\">acrobotics.shapes</span> <span class=\"kn\">import</span> <span class=\"n\">Box</span>\n\n<span class=\"n\">table</span> <span class=\"o\">=</span> <span class=\"n\">Box</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mf\">0.1</span><span class=\"p\">)</span>\n<span class=\"n\">T_table</span> <span class=\"o\">=</span> <span class=\"n\">translation</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mf\">0.2</span><span class=\"p\">)</span>\n\n<span class=\"n\">obstacle</span> <span class=\"o\">=</span> <span class=\"n\">Box</span><span class=\"p\">(</span><span class=\"mf\">0.2</span><span class=\"p\">,</span> <span class=\"mf\">0.2</span><span class=\"p\">,</span> <span class=\"mf\">1.5</span><span class=\"p\">)</span>\n<span class=\"n\">T_obs</span> <span class=\"o\">=</span> <span class=\"n\">translation</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mf\">0.5</span><span class=\"p\">,</span> <span class=\"mf\">0.55</span><span class=\"p\">)</span>\n\n<span class=\"n\">scene</span> <span class=\"o\">=</span> <span class=\"n\">Scene</span><span class=\"p\">([</span><span class=\"n\">table</span><span class=\"p\">,</span> <span class=\"n\">obstacle</span><span class=\"p\">],</span> <span class=\"p\">[</span><span class=\"n\">T_table</span><span class=\"p\">,</span> <span class=\"n\">T_obs</span><span class=\"p\">])</span>\n</pre>\n<p>Then create a list of robot configurations for wich you want to check collision with the planning scene.</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">numpy</span> <span class=\"k\">as</span> <span class=\"nn\">np</span>\n\n<span class=\"n\">q_start</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([</span><span class=\"mf\">0.5</span><span class=\"p\">,</span> <span class=\"mf\">1.5</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mf\">0.3</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">])</span>\n<span class=\"n\">q_goal</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([</span><span class=\"mf\">2.5</span><span class=\"p\">,</span> <span class=\"mf\">1.5</span><span class=\"p\">,</span> <span class=\"mf\">0.3</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">])</span>\n<span class=\"n\">q_path</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">linspace</span><span class=\"p\">(</span><span class=\"n\">q_start</span><span class=\"p\">,</span> <span class=\"n\">q_goal</span><span class=\"p\">,</span> <span class=\"mi\">10</span><span class=\"p\">)</span>\n</pre>\n<p>And then you could do:</p>\n<pre><span class=\"nb\">print</span><span class=\"p\">([</span><span class=\"n\">robot</span><span class=\"o\">.</span><span class=\"n\">is_in_collision</span><span class=\"p\">(</span><span class=\"n\">q</span><span class=\"p\">,</span> <span class=\"n\">scene</span><span class=\"p\">)</span> <span class=\"k\">for</span> <span class=\"n\">q</span> <span class=\"ow\">in</span> <span class=\"n\">q_path</span><span class=\"p\">])</span>\n</pre>\n<pre><span class=\"o\">[</span>False, False, False, False, True, True, True, True, False, False<span class=\"o\">]</span>\n</pre>\n<h3>Visualization</h3>\n<p><code>robot.plot(axes_handle, joint_values)</code>\n<code>robot.animate_path(figure_handle, axes_handle, joint_path)</code></p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">acrobotics.util</span> <span class=\"kn\">import</span> <span class=\"n\">get_default_axes3d</span>\n\n<span class=\"n\">fig</span><span class=\"p\">,</span> <span class=\"n\">ax</span> <span class=\"o\">=</span> <span class=\"n\">get_default_axes3d</span><span class=\"p\">()</span>\n\n<span class=\"n\">scene</span><span class=\"o\">.</span><span class=\"n\">plot</span><span class=\"p\">(</span><span class=\"n\">ax</span><span class=\"p\">,</span> <span class=\"n\">c</span><span class=\"o\">=</span><span class=\"s2\">\"green\"</span><span class=\"p\">)</span>\n<span class=\"n\">robot</span><span class=\"o\">.</span><span class=\"n\">animate_path</span><span class=\"p\">(</span><span class=\"n\">fig</span><span class=\"p\">,</span> <span class=\"n\">ax</span><span class=\"p\">,</span> <span class=\"n\">q_path</span><span class=\"p\">)</span>\n</pre>\n<p><img alt=\"animation\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/3cc9787615574cb3a4f7c147887882128a45e170/6578616d706c65732f726f626f745f616e696d6174696f6e2e676966\"></p>\n<h2>More details</h2>\n<p>There's a more in depth explanation in the jupyter-notebooks in the examples folder.</p>\n<h2>And motion planning?</h2>\n<p>Comming soon.</p>\n\n          </div>"}, "last_serial": 5841453, "releases": {"0.0.2": [{"comment_text": "", "digests": {"md5": "3298037b019ca53213434d4a2fbb2707", "sha256": "ed09b24f0cdd83f440eb76e0ca4ff2037c323c53362ab963c5b81efe6435f99e"}, "downloads": -1, "filename": "acrobotics-0.0.2.tar.gz", "has_sig": false, "md5_digest": "3298037b019ca53213434d4a2fbb2707", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 12467, "upload_time": "2019-09-06T09:08:12", "upload_time_iso_8601": "2019-09-06T09:08:12.569176Z", "url": "https://files.pythonhosted.org/packages/31/87/a09c22c52a3e92449add372ea7c7e1c1028da9d32372793144a66d7938b9/acrobotics-0.0.2.tar.gz", "yanked": false}], "0.0.3": [{"comment_text": "", "digests": {"md5": "2e75010867002b4e7272c5120a1bfcc8", "sha256": "dea21cb34d861d3af87995656debc69efb1746534f9bb25ca9a08d2a3f037f75"}, "downloads": -1, "filename": "acrobotics-0.0.3.tar.gz", "has_sig": false, "md5_digest": "2e75010867002b4e7272c5120a1bfcc8", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 25531, "upload_time": "2019-09-17T12:16:28", "upload_time_iso_8601": "2019-09-17T12:16:28.384711Z", "url": "https://files.pythonhosted.org/packages/92/39/abe34c507a9083421ca124446634f4fd286bd7a5f1921a7baa262658e37f/acrobotics-0.0.3.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "2e75010867002b4e7272c5120a1bfcc8", "sha256": "dea21cb34d861d3af87995656debc69efb1746534f9bb25ca9a08d2a3f037f75"}, "downloads": -1, "filename": "acrobotics-0.0.3.tar.gz", "has_sig": false, "md5_digest": "2e75010867002b4e7272c5120a1bfcc8", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 25531, "upload_time": "2019-09-17T12:16:28", "upload_time_iso_8601": "2019-09-17T12:16:28.384711Z", "url": "https://files.pythonhosted.org/packages/92/39/abe34c507a9083421ca124446634f4fd286bd7a5f1921a7baa262658e37f/acrobotics-0.0.3.tar.gz", "yanked": false}], "timestamp": "Thu May  7 16:24:26 2020"}