{"info": {"author": "SENAITE Foundation", "author_email": "hello@senaite.com", "bugtrack_url": null, "classifiers": ["Framework :: Plone", "Framework :: Zope2", "Programming Language :: Python"], "description": ".. image:: https://raw.githubusercontent.com/senaite/senaite.api/master/static/api-logo.png\n   :alt: senaite.api\n   :height: 64 px\n   :align: center\n\n- **SENAITE.API**: *The Swiss-Army-Knife for SENAITE Core and Add-on developers*\n\n.. image:: https://img.shields.io/pypi/v/senaite.api.svg?style=flat-square\n   :target: https://pypi.python.org/pypi/senaite.api\n\n.. image:: https://img.shields.io/github/issues-pr/senaite/senaite.api.svg?style=flat-square\n   :target: https://github.com/senaite/senaite.api/pulls\n\n.. image:: https://img.shields.io/github/issues/senaite/senaite.api.svg?style=flat-square\n   :target: https://github.com/senaite/senaite.api/issues\n\n.. image:: https://img.shields.io/badge/README-GitHub-blue.svg?style=flat-square\n   :target: https://github.com/senaite/senaite.api#readme\n\nAbout\n=====\n\nSENAITE API is the Swiss-Army-Knife for SENAITE Core and Add-on developers. It\nprovides a sane interface for common tasks in SENAITE, like e.g. object\ncreation, lookup by ID/UID, search etc.\n\nPlease see the doctests for further details and usage:\n\n-  `Core API Documentation`_\n-  `Analysis API Documentation`_\n\n\nInstallation\n============\n\nPlease follow the installations instructions for `Plone 4`_ and\n`senaite.lims`_.\n\nTo install SENAITE API, you have to add `senaite.api` into the\n`eggs` list inside the `[buildout]` section of your\n`buildout.cfg`::\n\n   [buildout]\n   parts =\n       instance\n   extends =\n       http://dist.plone.org/release/4.3.17/versions.cfg\n   find-links =\n       http://dist.plone.org/release/4.3.17\n       http://dist.plone.org/thirdparty\n   eggs =\n       Plone\n       Pillow\n       senaite.lims\n       senaite.api\n   zcml =\n   eggs-directory = ${buildout:directory}/eggs\n\n   [instance]\n   recipe = plone.recipe.zope2instance\n   user = admin:admin\n   http-address = 0.0.0.0:8080\n   eggs =\n       ${buildout:eggs}\n   zcml =\n       ${buildout:zcml}\n\n   [versions]\n   setuptools =\n   zc.buildout =\n\n\n**Note**\n\nThe above example works for the buildout created by the unified\ninstaller. If you however have a custom buildout you might need to add\nthe egg to the `eggs` list in the `[instance]` section rather than\nadding it in the `[buildout]` section.\n\nAlso see this section of the Plone documentation for further details:\nhttps://docs.plone.org/4/en/manage/installing/installing_addons.html\n\n**Important**\n\nFor the changes to take effect you need to re-run buildout from your\nconsole::\n\n   bin/buildout\n\n\n.. _Plone 4: https://docs.plone.org/4/en/manage/installing/index.html\n.. _senaite.lims: https://github.com/senaite/senaite.lims#installation\n.. _Core API Documentation: https://github.com/senaite/senaite.api/blob/master/src/senaite/api/docs/API.rst\n.. _Analysis API Documentation: https://github.com/senaite/senaite.api/blob/master/src/senaite/api/docs/API_analysis.rst\n\n\nSENAITE API DOCTEST\n===================\n\nThe SENAITE LIMS API provides single functions for single purposes.\nThis Test builds completely on the API without any further imports needed.\n\nRunning this test from the buildout directory::\n\n    bin/test test_doctests -t API\n\nIntroduction\n------------\n\nThe purpose of this API is to help coders to follow the DRY principle (Don't\nRepeat Yourself). It also ensures that the most effective and efficient method is\nused to achieve a task.\n\nImport it first::\n\n    >>> from senaite import api\n\n\nGetting the Portal\n------------------\n\nThe Portal is the SENAITE LIMS root object::\n\n    >>> portal = api.get_portal()\n    >>> portal\n    <PloneSite at /plone>\n\n\nGetting the Setup object\n------------------------\n\nThe Setup object gives access to all of the Bika configuration settings::\n\n    >>> bika_setup = api.get_setup()\n    >>> bika_setup\n    <BikaSetup at /plone/bika_setup>\n\n\nCreating new Content\n--------------------\n\nCreating new contents in Bika LIMS requires some special knowledge.\nThis function helps to do it right and creates a content for you.\n\nHere we create a new `Client` in the `plone/clients` folder::\n\n    >>> client = api.create(portal.clients, \"Client\", title=\"Test Client\")\n    >>> client\n    <Client at /plone/clients/client-1>\n\n     >>> client.Title()\n     'Test Client'\n\n\nGetting a Tool\n--------------\n\nThere are many ways to get a tool in Bika LIMS / Plone. This function\ncentralizes this functionality and makes it painless::\n\n    >>> api.get_tool(\"bika_setup_catalog\")\n    <BikaSetupCatalog at /plone/bika_setup_catalog>\n\nTrying to fetch an non-existing tool raises a custom `SenaiteAPIError`::\n\n    >>> api.get_tool(\"NotExistingTool\")\n    Traceback (most recent call last):\n    [...]\n    SenaiteAPIError: No tool named 'NotExistingTool' found.\n\nThis error can also be used for custom methods with the `fail` function::\n\n    >>> api.fail(\"This failed badly\")\n    Traceback (most recent call last):\n    [...]\n    SenaiteAPIError: This failed badly\n\n\nGetting an Object\n-----------------\n\nGetting a tool from a catalog brain is a common task in Bika LIMS. This function\nprovides an unified interface to portal objects **and** brains.\nFurthermore it is idempotent, so it can be called multiple times in a row.\n\nWe will demonstrate the usage on the client object we created above::\n\n    >>> api.get_object(client)\n    <Client at /plone/clients/client-1>\n\n    >>> api.get_object(api.get_object(client))\n    <Client at /plone/clients/client-1>\n\nNow we show it with catalog results::\n\n    >>> portal_catalog = api.get_tool(\"portal_catalog\")\n    >>> brains = portal_catalog(portal_type=\"Client\")\n    >>> brains\n    [<Products.ZCatalog.Catalog.mybrains object at 0x...>]\n\n    >>> brain = brains[0]\n\n    >>> api.get_object(brain)\n    <Client at /plone/clients/client-1>\n\n    >>> api.get_object(api.get_object(brain))\n    <Client at /plone/clients/client-1>\n\nNo supported objects raise an error::\n\n    >>> api.get_object(object())\n    Traceback (most recent call last):\n    [...]\n    SenaiteAPIError: <object object at 0x...> is not supported.\n\nTo check if an object is supported, e.g. is an ATCT, Dexterity, ZCatalog or\nPortal object, we can use the `is_object` function::\n\n    >>> api.is_object(client)\n    True\n\n    >>> api.is_object(brain)\n    True\n\n    >>> api.is_object(api.get_portal())\n    True\n\n    >>> api.is_object(None)\n    False\n\n  >>> api.is_object(object())\n    False\n\n\nChecking if an Object is the Portal\n-----------------------------------\n\nSometimes it can be handy to check if the current object is the portal::\n\n    >>> api.is_portal(portal)\n    True\n\n    >>> api.is_portal(client)\n    False\n\n    >>> api.is_portal(object())\n    False\n\n\nChecking if an Object is a Catalog Brain\n----------------------------------------\n\nKnowing if we have an object or a brain can be handy. This function checks this for you::\n\n    >>> api.is_brain(brain)\n    True\n\n    >>> api.is_brain(api.get_object(brain))\n    False\n\n    >>> api.is_brain(object())\n    False\n\n\nChecking if an Object is a Dexterity Content\n--------------------------------------------\n\nThis function checks if an object is a `Dexterity` content type::\n\n    >>> api.is_dexterity_content(client)\n    False\n\n    >>> api.is_dexterity_content(portal)\n    False\n\nWe currently have no `Dexterity` contents, so testing this comes later...\n\n\nChecking if an Object is an AT Content\n--------------------------------------\n\nThis function checks if an object is an `Archetypes` content type::\n\n    >>> api.is_at_content(client)\n    True\n\n    >>> api.is_at_content(portal)\n    False\n\n    >>> api.is_at_content(object())\n    False\n\n\nGetting the Schema of a Content\n-------------------------------\n\nThe schema contains the fields of a content object. Getting the schema is a\ncommon task, but differs between `ATContentType` based objects and `Dexterity`\nbased objects. This function brings it under one umbrella::\n\n    >>> schema = api.get_schema(client)\n    >>> schema\n    <Products.Archetypes.Schema.Schema object at 0x...>\n\nCatalog brains are also supported::\n\n    >>> api.get_schema(brain)\n    <Products.Archetypes.Schema.Schema object at 0x...>\n\n\nGetting the Fields of a Content\n-------------------------------\n\nThe fields contain all the values that an object holds and are therefore\nresponsible for getting and setting the information.\n\nThis function returns the fields as a dictionary mapping of `{\"key\": value}`::\n\n    >>> fields = api.get_fields(client)\n    >>> fields.get(\"ClientID\")\n    <Field ClientID(string:rw)>\n\nCatalog brains are also supported::\n\n    >>> api.get_fields(brain).get(\"ClientID\")\n    <Field ClientID(string:rw)>\n\n\nGetting the ID of a Content\n---------------------------\n\nGetting the ID is a common task in Bika LIMS.\nThis function takes care that catalog brains are not waked up for this task::\n\n    >>> api.get_id(portal)\n    'plone'\n\n    >>> api.get_id(client)\n    'client-1'\n\n    >>> api.get_id(brain)\n    'client-1'\n\n\nGetting the Title of a Content\n------------------------------\n\nGetting the Title is a common task in Bika LIMS.\nThis function takes care that catalog brains are not waked up for this task::\n\n    >>> api.get_title(portal)\n    u'Plone site'\n\n    >>> api.get_title(client)\n    'Test Client'\n\n    >>> api.get_title(brain)\n    'Test Client'\n\n\nGetting the Description of a Content\n------------------------------------\n\nGetting the Description is a common task in Bika LIMS.\nThis function takes care that catalog brains are not waked up for this task::\n\n    >>> api.get_description(portal)\n    ''\n\n    >>> api.get_description(client)\n    ''\n\n    >>> api.get_description(brain)\n    ''\n\n\nGetting the UID of a Content\n----------------------------\n\nGetting the UID is a common task in Bika LIMS.\nThis function takes care that catalog brains are not waked up for this task.\n\nThe portal object actually has no UID. This funciton defines it therfore to be `0`::\n\n    >>> api.get_uid(portal)\n    '0'\n\n    >>> uid_client = api.get_uid(client)\n    >>> uid_client_brain = api.get_uid(brain)\n    >>> uid_client is uid_client_brain\n    True\n\n\nGetting the URL of a Content\n----------------------------\n\nGetting the URL is a common task in Bika LIMS.\nThis function takes care that catalog brains are not waked up for this task::\n\n    >>> api.get_url(portal)\n    'http://nohost/plone'\n\n    >>> api.get_url(client)\n    'http://nohost/plone/clients/client-1'\n\n    >>> api.get_url(brain)\n    'http://nohost/plone/clients/client-1'\n\n\nGetting the Icon of a Content\n-----------------------------\n\n::\n\n    >>> api.get_icon(client)\n    '<img width=\"16\" height=\"16\" src=\"http://nohost/plone/++resource++bika.lims.images/client.png\" title=\"Test Client\" />'\n\n    >>> api.get_icon(brain)\n    '<img width=\"16\" height=\"16\" src=\"http://nohost/plone/++resource++bika.lims.images/client.png\" title=\"Test Client\" />'\n\n    >>> api.get_icon(client, html_tag=False)\n    'http://nohost/plone/++resource++bika.lims.images/client.png'\n\n    >>> api.get_icon(client, html_tag=False)\n    'http://nohost/plone/++resource++bika.lims.images/client.png'\n\n\nGetting an object by UID\n------------------------\n\nThis function finds an object by its uinique ID (UID).\nThe portal object with the defined UId of '0' is also supported::\n\n    >>> api.get_object_by_uid('0')\n    <PloneSite at /plone>\n\n    >>> api.get_object_by_uid(uid_client)\n    <Client at /plone/clients/client-1>\n\n    >>> api.get_object_by_uid(uid_client_brain)\n    <Client at /plone/clients/client-1>\n\nIf a default value is provided, the function will never fail.  Any exception\nor error will result in the default value being returned::\n\n    >>> api.get_object_by_uid('invalid uid', 'default')\n    'default'\n\n    >>> api.get_object_by_uid(None, 'default')\n    'default'\n\n\nGetting an object by Path\n-------------------------\n\nThis function finds an object by its physical path::\n\n    >>> api.get_object_by_path('/plone')\n    <PloneSite at /plone>\n\n    >>> api.get_object_by_path('/plone/clients/client-1')\n    <Client at /plone/clients/client-1>\n\nPaths outside the portal raise an error::\n\n    >>> api.get_object_by_path('/root')\n    Traceback (most recent call last):\n    [...]\n    SenaiteAPIError: Not a physical path inside the portal.\n\nAny exception returns default value::\n\n    >>> api.get_object_by_path('/invaid/path', 'default')\n    'default'\n\n    >>> api.get_object_by_path(None, 'default')\n    'default'\n\n\nGetting the Physical Path of an Object\n--------------------------------------\n\nThe physical path describes exactly where an object is located inside the portal.\nThis function unifies the different approaches to get the physical path and does\nso in the most efficient way::\n\n    >>> api.get_path(portal)\n    '/plone'\n\n    >>> api.get_path(client)\n    '/plone/clients/client-1'\n\n    >>> api.get_path(brain)\n    '/plone/clients/client-1'\n\n    >>> api.get_path(object())\n    Traceback (most recent call last):\n    [...]\n    SenaiteAPIError: <object object at 0x...> is not supported.\n\n\nGetting the Physical Parent Path of an Object\n---------------------------------------------\n\nThis function returns the physical path of the parent object::\n\n    >>> api.get_parent_path(client)\n    '/plone/clients'\n\n    >>> api.get_parent_path(brain)\n    '/plone/clients'\n\nHowever, this function goes only up to the portal object::\n\n    >>> api.get_parent_path(portal)\n    '/plone'\n\nLike with the other functions, only portal objects are supported::\n\n    >>> api.get_parent_path(object())\n    Traceback (most recent call last):\n    [...]\n    SenaiteAPIError: <object object at 0x...> is not supported.\n\n\nGetting the Parent Object\n-------------------------\n\nThis function returns the parent object::\n\n    >>> api.get_parent(client)\n    <ClientFolder at /plone/clients>\n\nBrains are also supported::\n\n    >>> api.get_parent(brain)\n    <ClientFolder at /plone/clients>\n\nThe function can also use a catalog query on the `portal_catalog` and return a\nbrain, if the passed parameter `catalog_search` was set to true. ::\n\n    >>> api.get_parent(client, catalog_search=True)\n    <Products.ZCatalog.Catalog.mybrains object at 0x...>\n\n    >>> api.get_parent(brain, catalog_search=True)\n    <Products.ZCatalog.Catalog.mybrains object at 0x...>\n\nHowever, this function goes only up to the portal object::\n\n    >>> api.get_parent(portal)\n    <PloneSite at /plone>\n\nLike with the other functions, only portal objects are supported::\n\n    >>> api.get_parent(object())\n    Traceback (most recent call last):\n    [...]\n    SenaiteAPIError: <object object at 0x...> is not supported.\n\n\nSearching Objects\n-----------------\n\nSearching in Bika LIMS requires knowledge in which catalog the object is indexed.\nThis function unifies all Bika LIMS catalog to a single search interface::\n\n    >>> results = api.search({'portal_type': 'Client'})\n    >>> results\n    [<Products.ZCatalog.Catalog.mybrains object at 0x...>]\n\nMultiple content types are also supported::\n\n    >>> results = api.search({'portal_type': ['Client', 'ClientFolder'], 'sort_on': 'getId'})\n    >>> map(api.get_id, results)\n    ['client-1', 'clients']\n\nNow we create some objects which are located in the `bika_setup_catalog`::\n\n    >>> instruments = bika_setup.bika_instruments\n    >>> instrument1 = api.create(instruments, \"Instrument\", title=\"Instrument-1\")\n    >>> instrument2 = api.create(instruments, \"Instrument\", title=\"Instrument-2\")\n    >>> instrument3 = api.create(instruments, \"Instrument\", title=\"Instrument-3\")\n\n    >>> results = api.search({'portal_type': 'Instrument', 'sort_on': 'getId'})\n    >>> len(results)\n    3\n\n    >>> map(api.get_id, results)\n    ['instrument-1', 'instrument-2', 'instrument-3']\n\nQueries which result in multiple catalogs will be refused, as it would require\nmanual merging and sorting of the results afterwards. Thus, we fail here::\n\n    >>> results = api.search({'portal_type': ['Client', 'ClientFolder', 'Instrument'], 'sort_on': 'getId'})\n    Traceback (most recent call last):\n    [...]\n    SenaiteAPIError: Multi Catalog Queries are not supported, please specify a catalog.\n\nCatalog queries w/o any `portal_type`, default to the `portal_catalog`, which\nwill not find the following items::\n\n    >>> analysiscategories = bika_setup.bika_analysiscategories\n    >>> analysiscategory1 = api.create(analysiscategories, \"AnalysisCategory\", title=\"AC-1\")\n    >>> analysiscategory2 = api.create(analysiscategories, \"AnalysisCategory\", title=\"AC-2\")\n    >>> analysiscategory3 = api.create(analysiscategories, \"AnalysisCategory\", title=\"AC-3\")\n\n    >>> results = api.search({\"id\": \"analysiscategory-1\"})\n    >>> len(results)\n    0\n\nWould we add the `portal_type`, the search function would ask the\n`archetype_tool` for the right catalog, and it would return a result::\n\n    >>> results = api.search({\"portal_type\": \"AnalysisCategory\", \"id\": \"analysiscategory-1\"})\n    >>> len(results)\n    1\n\nWe could also explicitly define a catalog to achieve the same::\n\n    >>> results = api.search({\"id\": \"analysiscategory-1\"}, catalog=\"bika_setup_catalog\")\n    >>> len(results)\n    1\n\nTo see inactive or dormant items, we must explicitly query them of filter them\nafterwars manually::\n\n    >>> results = api.search({\"portal_type\": \"AnalysisCategory\", \"id\": \"analysiscategory-1\"})\n    >>> len(results)\n    1\n\nNow we deactivate the item::\n\n    >>> analysiscategory1 = api.do_transition_for(analysiscategory1, 'deactivate')\n    >>> api.is_active(analysiscategory1)\n    False\n\nThe search will still find the item::\n\n    >>> results = api.search({\"portal_type\": \"AnalysisCategory\", \"id\": \"analysiscategory-1\"})\n    >>> len(results)\n    1\n\nUnless we filter it out manually::\n\n    >>> len(filter(api.is_active, results))\n    0\n\nOr provide a correct query::\n\n    >>> results = api.search({\"portal_type\": \"AnalysisCategory\", \"id\": \"analysiscategory-1\", \"inactive_status\": \"active\"})\n    >>> len(results)\n    1\n\n\nGetting the registered Catalogs\n-------------------------------\n\nBika LIMS uses multiple catalogs registered via the Archetype Tool. This\nfunction returns a list of registered catalogs for a brain or object::\n\n    >>> api.get_catalogs_for(client)\n    [<CatalogTool at /plone/portal_catalog>]\n\n    >>> api.get_catalogs_for(instrument1)\n    [<BikaSetupCatalog at /plone/bika_setup_catalog>, <CatalogTool at /plone/portal_catalog>]\n\n    >>> api.get_catalogs_for(analysiscategory1)\n    [<BikaSetupCatalog at /plone/bika_setup_catalog>]\n\n\nGetting an Attribute of an Object\n---------------------------------\n\nThis function handles attributes and methods the same and returns their value.\nIt also handles security and is able to return a default value instead of\nraising an `Unauthorized` error::\n\n    >>> uid_brain = api.safe_getattr(brain, \"UID\")\n    >>> uid_obj = api.safe_getattr(client, \"UID\")\n\n    >>> uid_brain == uid_obj\n    True\n\n    >>> api.safe_getattr(brain, \"review_state\")\n    'active'\n\n    >>> api.safe_getattr(brain, \"NONEXISTING\")\n    Traceback (most recent call last):\n    [...]\n    SenaiteAPIError: Attribute 'NONEXISTING' not found.\n\n    >>> api.safe_getattr(brain, \"NONEXISTING\", \"\")\n    ''\n\nGetting the Portal Catalog\n--------------------------\n\nThis tool is needed so often, that this function just returns it::\n\n    >>> api.get_portal_catalog()\n    <CatalogTool at /plone/portal_catalog>\n\n\nGetting the Review History of an Object\n---------------------------------------\n\nThe review history gives information about the objects' workflow changes::\n\n    >>> review_history = api.get_review_history(client)\n    >>> sorted(review_history[0].items())\n    [('action', None), ('actor', 'test_user_1_'), ('comments', ''), ('review_state', 'active'), ('time', DateTime('...'))]\n\n\nGetting the Revision History of an Object\n-----------------------------------------\n\nThe review history gives information about the objects' workflow changes::\n\n    >>> revision_history = api.get_revision_history(client)\n    >>> sorted(revision_history[0])\n    ['action', 'actor', 'actor_home', 'actorid', 'comments', 'review_state', 'state_title', 'time', 'transition_title', 'type']\n    >>> revision_history[0][\"transition_title\"]\n    u'Create'\n\n\nGetting the assigned Workflows of an Object\n-------------------------------------------\n\nThis function returns all assigned workflows for a given object::\n\n    >>> api.get_workflows_for(bika_setup)\n    ('bika_one_state_workflow',)\n\n    >>> api.get_workflows_for(client)\n    ('bika_client_workflow', 'bika_inactive_workflow')\n\nThis function also supports the portal_type as parameter::\n\n    >>> api.get_workflows_for(api.get_portal_type(client))\n    ('bika_client_workflow', 'bika_inactive_workflow')\n\n\nGetting the Workflow Status of an Object\n----------------------------------------\n\nThis function returns the state of a given object::\n\n    >>> api.get_workflow_status_of(client)\n    'active'\n\nIt is also capable to get the state of another state variable::\n\n    >>> api.get_workflow_status_of(client, \"inactive_state\")\n    'active'\n\nDeactivate the client::\n\n    >>> api.do_transition_for(client, \"deactivate\")\n    <Client at /plone/clients/client-1>\n\n    >>> api.get_workflow_status_of(client, \"inactive_state\")\n    'inactive'\n\n    >>> api.get_workflow_status_of(client)\n    'active'\n\nReactivate the client::\n\n    >>> api.do_transition_for(client, \"activate\")\n    <Client at /plone/clients/client-1>\n\n    >>> api.get_workflow_status_of(client, \"inactive_state\")\n    'active'\n\n\nGetting the available transitions for an object\n-----------------------------------------------\n\nThis function returns all possible transitions from all workflows in the\nobject's workflow chain.\n\nLet's create a Batch. It should allow us to invoke transitions from two\nworkflows; 'close' from the bika_batch_workflow, and 'cancel' from the\nbika_cancellation_workflow::\n\n    >>> batch1 = api.create(portal.batches, \"Batch\", title=\"Test Batch\")\n    >>> transitions = api.get_transitions_for(batch1)\n    >>> len(transitions)\n    2\n\nThe transitions are returned as a list of dictionaries. Since we cannot rely on\nthe order of dictionary keys, we will have to satisfy ourselves here with\nchecking that the two expected transitions are present in the return value::\n\n    >>> 'Close' in [t['title'] for t in transitions]\n    True\n    >>> 'Cancel' in [t['title'] for t in transitions]\n    True\n\n\nGetting the creation date of an object\n--------------------------------------\n\nThis function returns the creation date of a given object::\n\n    >>> created = api.get_creation_date(client)\n    >>> created\n    DateTime('...')\n\n\nGetting the modification date of an object\n------------------------------------------\n\nThis function returns the modification date of a given object::\n\n    >>> modified = api.get_modification_date(client)\n    >>> modified\n    DateTime('...')\n\n\nGetting the review state of an object\n-------------------------------------\n\nThis function returns the review state of a given object::\n\n    >>> review_state = api.get_review_status(client)\n    >>> review_state\n    'active'\n\nIt should also work for catalog brains::\n\n    >>> portal_catalog = api.get_tool(\"portal_catalog\")\n    >>> results = portal_catalog({\"portal_type\": \"Client\", \"UID\": api.get_uid(client)})\n    >>> len(results)\n    1\n    >>> api.get_review_status(results[0]) == review_state\n    True\n\n\nGetting the registered Catalogs of an Object\n--------------------------------------------\n\nThis function returns a list of all registered catalogs within the\n`archetype_tool` for a given portal_type or object::\n\n    >>> api.get_catalogs_for(client)\n    [<CatalogTool at /plone/portal_catalog>]\n\nIt also supports the `portal_type` as a parameter::\n\n    >>> api.get_catalogs_for(\"Analysis\")\n    [<BikaAnalysisCatalog at /plone/bika_analysis_catalog>]\n\n\nTransitioning an Object\n-----------------------\n\nThis function performs a workflow transition and returns the object::\n\n    >>> client = api.do_transition_for(client, \"deactivate\")\n    >>> api.is_active(client)\n    False\n\n    >>> client = api.do_transition_for(client, \"activate\")\n    >>> api.is_active(client)\n    True\n\n\nGetting inactive/cancellation state of different workflows\n----------------------------------------------------------\n\nThere are two workflows allowing an object to be set inactive.  We provide\nthe is_active function to return False if an item is set inactive with either\nof these workflows.\n\nIn the search() test above, the is_active function's handling of brain states\nis tested.  Here, I just want to test if object states are handled correctly.\n\nFor setup types, we use bika_inctive_workflow::\n\n    >>> method1 = api.create(portal.methods, \"Method\", title=\"Test Method\")\n    >>> api.is_active(method1)\n    True\n    >>> method1 = api.do_transition_for(method1, 'deactivate')\n    >>> api.is_active(method1)\n    False\n\nFor transactional types, bika_cancellation_workflow is used::\n\n    >>> batch1 = api.create(portal.batches, \"Batch\", title=\"Test Batch\")\n    >>> api.is_active(batch1)\n    True\n    >>> batch1 = api.do_transition_for(batch1, 'cancel')\n    >>> api.is_active(batch1)\n    False\n\n\nGetting the granted Roles for a certain Permission on an Object\n---------------------------------------------------------------\n\nThis function returns a list of Roles, which are granted the given Permission\nfor the passed in object::\n\n    >>> api.get_roles_for_permission(\"Modify portal content\", bika_setup)\n    ['LabManager', 'Manager']\n\n\n\nChecking if an Object is Versionable\n------------------------------------\n\nSome contents in Bika LIMS support versioning. This function checks this for you.\n\nInstruments are not versionable::\n\n    >>> api.is_versionable(instrument1)\n    False\n\nAnalysisservices are versionable::\n\n    >>> analysisservices = bika_setup.bika_analysisservices\n    >>> analysisservice1 = api.create(analysisservices, \"AnalysisService\", title=\"AnalysisService-1\")\n    >>> analysisservice2 = api.create(analysisservices, \"AnalysisService\", title=\"AnalysisService-2\")\n    >>> analysisservice3 = api.create(analysisservices, \"AnalysisService\", title=\"AnalysisService-3\")\n\n    >>> api.is_versionable(analysisservice1)\n    True\n\n\nGetting the Version of an Object\n--------------------------------\n\nThis function returns the version as an integer::\n\n    >>> api.get_version(analysisservice1)\n    0\n\nCalling `processForm` bumps the version::\n\n    >>> analysisservice1.processForm()\n    >>> api.get_version(analysisservice1)\n    1\n\n\nGetting a Browser View\n----------------------\n\nGetting a browser view is a common task in Bika LIMS::\n\n    >>> api.get_view(\"plone\")\n    <Products.Five.metaclass.Plone object at 0x...>\n\n    >>> api.get_view(\"workflow_action\")\n    <Products.Five.metaclass.WorkflowAction object at 0x...>\n\n\nGetting the Request\n-------------------\n\nThis function will return the global request object::\n\n    >>> api.get_request()\n    <HTTPRequest, URL=http://nohost>\n\n\nGetting a Group\n---------------\n\nUsers in Bika LIMS are managed in groups. A common group is the `Clients` group,\nwhere all users of client contacts are grouped.\nThis function gives easy access and is also idempotent::\n\n    >>> clients_group = api.get_group(\"Clients\")\n    >>> clients_group\n    <GroupData at /plone/portal_groupdata/Clients used for /plone/acl_users/source_groups>\n\n    >>> api.get_group(clients_group)\n    <GroupData at /plone/portal_groupdata/Clients used for /plone/acl_users/source_groups>\n\nNon-existing groups are not found::\n\n    >>> api.get_group(\"NonExistingGroup\")\n\n\nGetting a User\n--------------\n\nUsers can be fetched by their user id. The function is idempotent and handles\nuser objects as well::\n\n    >>> from plone.app.testing import TEST_USER_ID\n    >>> user = api.get_user(TEST_USER_ID)\n    >>> user\n    <MemberData at /plone/portal_memberdata/test_user_1_ used for /plone/acl_users>\n\n    >>> api.get_user(api.get_user(TEST_USER_ID))\n    <MemberData at /plone/portal_memberdata/test_user_1_ used for /plone/acl_users>\n\nNon-existing users are not found::\n\n    >>> api.get_user(\"NonExistingUser\")\n\n\nGetting User Properties\n-----------------------\n\nUser properties, like the email or full name, are stored as user properties.\nThis means that they are not on the user object. This function retrieves these\nproperties for you::\n\n    >>> properties = api.get_user_properties(TEST_USER_ID)\n    >>> sorted(properties.items())\n    [('description', ''), ('email', ''), ('error_log_update', 0.0), ('ext_editor', False), ...]\n\n    >>> sorted(api.get_user_properties(user).items())\n    [('description', ''), ('email', ''), ('error_log_update', 0.0), ('ext_editor', False), ...]\n\nAn empty property dict is returned if no user could be found::\n\n    >>> api.get_user_properties(\"NonExistingUser\")\n    {}\n\n    >>> api.get_user_properties(None)\n    {}\n\n\nGetting Users by their Roles\n----------------------------\n\n::\n\n    >>> from operator import methodcaller\n\nRoles in Bika LIMS are basically a name for one or more permissions. For\nexample, a `LabManager` describes a role which is granted the most permissions.\n\nTo see which users are granted a certain role, you can use this function::\n\n    >>> labmanagers = api.get_users_by_roles([\"LabManager\"])\n    >>> sorted(labmanagers, key=methodcaller('getId'))\n    [<PloneUser 'test_labmanager'>, <PloneUser 'test_labmanager1'>, <PloneUser 'test-user'>]\n\nA single value can also be passed into this function::\n\n    >>> sorted(api.get_users_by_roles(\"LabManager\"), key=methodcaller('getId'))\n    [<PloneUser 'test_labmanager'>, <PloneUser 'test_labmanager1'>, <PloneUser 'test-user'>]\n\n\nGetting the Current User\n------------------------\n\nGetting the current logged in user::\n\n    >>> api.get_current_user()\n    <MemberData at /plone/portal_memberdata/test_user_1_ used for /plone/acl_users>\n\n\nGetting the Contact associated to a Plone user\n----------------------------------------------\n\nGetting a Plone user previously registered with no contact assigned::\n\n    >>> user = api.get_user('test_labmanager1')\n    >>> contact = api.get_user_contact(user)\n    >>> contact is None\n    True\n\nAssign a new contact to this user::\n\n    >>> labcontacts = bika_setup.bika_labcontacts\n    >>> labcontact = api.create(labcontacts, \"LabContact\", Firstname=\"Lab\", Lastname=\"Manager\")\n    >>> labcontact.setUser(user)\n    True\n\nAnd get the contact associated to the user::\n\n    >>> api.get_user_contact(user)\n    <LabContact at /plone/bika_setup/bika_labcontacts/labcontact-1>\n\nAs well as if we specify only `LabContact` type::\n\n    >>> api.get_user_contact(user, ['LabContact'])\n    <LabContact at /plone/bika_setup/bika_labcontacts/labcontact-1>\n\nBut fails if we specify only `Contact` type::\n\n    >>> nuser = api.get_user_contact(user, ['Contact'])\n    >>> nuser is None\n    True\n\n\nCreating a Cache Key\n--------------------\n\nThis function creates a good cache key for a generic object or brain::\n\n    >>> key1 = api.get_cache_key(client)\n    >>> key1\n    'Client-client-1-...'\n\nThis can be also done for a catalog result brain::\n\n    >>> portal_catalog = api.get_tool(\"portal_catalog\")\n    >>> brains = portal_catalog({\"portal_type\": \"Client\", \"UID\": api.get_uid(client)})\n    >>> key2 = api.get_cache_key(brains[0])\n    >>> key2\n    'Client-client-1-...'\n\nThe two keys should be equal::\n\n    >>> key1 == key2\n    True\n\nThe key should change when the object get modified::\n\n    >>> from zope.lifecycleevent import modified\n    >>> client.setClientID(\"TESTCLIENT\")\n    >>> modified(client)\n    >>> portal.aq_parent._p_jar.sync()\n    >>> key3 = api.get_cache_key(client)\n    >>> key3 != key1\n    True\n\n.. important:: Workflow changes do not change the modification date!\n               A custom event subscriber will update it therefore.\n\nA workflow transition should also change the cache key::\n\n    >>> _ = api.do_transition_for(client, transition=\"deactivate\")\n    >>> api.get_inactive_status(client)\n    'inactive'\n    >>> key4 = api.get_cache_key(client)\n    >>> key4 != key3\n    True\n\n\nCache Key decorator\n-------------------\n\nThis decorator can be used for `plone.memoize` cache decorators in classes.\nThe decorator expects that the first argument is the class instance (`self`) and\nthe second argument a brain or object::\n\n    >>> from plone.memoize.volatile import cache\n\n    >>> class BikaClass(object):\n    ...     @cache(api.bika_cache_key_decorator)\n    ...     def get_very_expensive_calculation(self, obj):\n    ...         print \"very expensive calculation\"\n    ...         return \"calculation result\"\n\nCalling the (expensive) method of the class does the calculation just once::\n\n    >>> instance = BikaClass()\n    >>> instance.get_very_expensive_calculation(client)\n    very expensive calculation\n    'calculation result'\n    >>> instance.get_very_expensive_calculation(client)\n    'calculation result'\n\nThe decorator can also handle brains::\n\n    >>> instance = BikaClass()\n    >>> portal_catalog = api.get_tool(\"portal_catalog\")\n    >>> brain = portal_catalog(portal_type=\"Client\")[0]\n    >>> instance.get_very_expensive_calculation(brain)\n    very expensive calculation\n    'calculation result'\n    >>> instance.get_very_expensive_calculation(brain)\n    'calculation result'\n\n\nID Normalizer\n-------------\n\nNormalizes a string to be usable as a system ID::\n\n    >>> api.normalize_id(\"My new ID\")\n    'my-new-id'\n\n    >>> api.normalize_id(\"Really/Weird:Name;\")\n    'really-weird-name'\n\n    >>> api.normalize_id(None)\n    Traceback (most recent call last):\n    [...]\n    SenaiteAPIError: Type of argument must be string, found '<type 'NoneType'>'\n\n\nFile Normalizer\n---------------\n\nNormalizes a string to be usable as a file name::\n\n    >>> api.normalize_filename(\"My new ID\")\n    'My new ID'\n\n    >>> api.normalize_filename(\"Really/Weird:Name;\")\n    'Really-Weird-Name'\n\n    >>> api.normalize_filename(None)\n    Traceback (most recent call last):\n    [...]\n    SenaiteAPIError: Type of argument must be string, found '<type 'NoneType'>'\n\n\nCheck if an UID is valid\n------------------------\n\nChecks if an UID is a valid 23 alphanumeric uid::\n\n    >>> api.is_uid(\"ajw2uw9\")\n    False\n\n    >>> api.is_uid(None)\n    False\n\n    >>> api.is_uid(\"\")\n    False\n\n    >>> api.is_uid(\"0\")\n    False\n\n    >>> api.is_uid('0e1dfc3d10d747bf999948a071bc161e')\n    True\n\nChecks if an UID is a valid 23 alphanumeric uid and with a brain::\n\n    >>> api.is_uid(\"ajw2uw9\", validate=True)\n    False\n\n    >>> api.is_uid(None, validate=True)\n    False\n\n    >>> api.is_uid(\"\", validate=True)\n    False\n\n    >>> api.is_uid(\"0\", validate=True)\n    False\n\n    >>> api.is_uid('0e1dfc3d10d747bf999948a071bc161e', validate=True)\n    False\n\n    >>> asfolder = self.portal.bika_setup.bika_analysisservices\n    >>> serv = api.create(asfolder, \"AnalysisService\", title=\"AS test\")\n    >>> serv.setKeyword(\"as_test\")\n    >>> uid = serv.UID()\n    >>> api.is_uid(uid, validate=True)\n    True\n\n\nCheck if a Date is valid\n------------------------\n\nDo some imports first::\n\n    >>> from datetime import datetime\n    >>> from DateTime import DateTime\n\nChecks if a DateTime is valid::\n\n    >>> now = DateTime()\n    >>> api.is_date(now)\n    True\n\n    >>> now = datetime.now()\n    >>> api.is_date(now)\n    True\n\n    >>> now = DateTime(now)\n    >>> api.is_date(now)\n    True\n\n    >>> api.is_date(None)\n    False\n\n    >>> api.is_date('2018-04-23')\n    False\n\n\nTry conversions to Date\n-----------------------\n\nTry to convert to DateTime::\n\n    >>> now = DateTime()\n    >>> zpdt = api.to_date(now)\n    >>> zpdt.ISO8601() == now.ISO8601()\n    True\n\n    >>> now = datetime.now()\n    >>> zpdt = api.to_date(now)\n    >>> pydt = zpdt.asdatetime()\n\nNote that here, for the comparison between dates, we convert DateTime to python\ndatetime, cause DateTime.strftime() is broken for timezones (always looks at\nsystem time zone, ignores the timezone and offset of the DateTime instance\nitself)::\n\n    >>> pydt.strftime('%Y-%m-%dT%H:%M:%S') == now.strftime('%Y-%m-%dT%H:%M:%S')\n    True\n\nTry the same, but with utcnow() instead::\n\n    >>> now = datetime.utcnow()\n    >>> zpdt = api.to_date(now)\n    >>> pydt = zpdt.asdatetime()\n    >>> pydt.strftime('%Y-%m-%dT%H:%M:%S') == now.strftime('%Y-%m-%dT%H:%M:%S')\n    True\n\nNow we convert just a string formatted date::\n\n    >>> strd = \"2018-12-01 17:50:34\"\n    >>> zpdt = api.to_date(strd)\n    >>> zpdt.ISO8601()\n    '2018-12-01T17:50:34'\n\nNow we convert just a string formatted date, but with timezone::\n\n    >>> strd = \"2018-12-01 17:50:34 GMT+1\"\n    >>> zpdt = api.to_date(strd)\n    >>> zpdt.ISO8601()\n    '2018-12-01T17:50:34+01:00'\n\nWe also check a bad date here (note the month is 13)::\n\n    >>> strd = \"2018-13-01 17:50:34\"\n    >>> zpdt = api.to_date(strd)\n    >>> api.is_date(zpdt)\n    False\n\nAnd with European format::\n\n    >>> strd = \"01.12.2018 17:50:34\"\n    >>> zpdt = api.to_date(strd)\n    >>> zpdt.ISO8601()\n    '2018-12-01T17:50:34'\n\n    >>> zpdt = api.to_date(None)\n    >>> zpdt is None\n    True\n\nUse a string formatted date as fallback::\n\n    >>> strd = \"2018-13-01 17:50:34\"\n    >>> default_date = \"2018-01-01 19:30:30\"\n    >>> zpdt = api.to_date(strd, default_date)\n    >>> zpdt.ISO8601()\n    '2018-01-01T19:30:30'\n\nUse a DateTime object as fallback::\n\n    >>> strd = \"2018-13-01 17:50:34\"\n    >>> default_date = \"2018-01-01 19:30:30\"\n    >>> default_date = api.to_date(default_date)\n    >>> zpdt = api.to_date(strd, default_date)\n    >>> zpdt.ISO8601() == default_date.ISO8601()\n    True\n\nUse a datetime object as fallback::\n\n    >>> strd = \"2018-13-01 17:50:34\"\n    >>> default_date = datetime.now()\n    >>> zpdt = api.to_date(strd, default_date)\n    >>> dzpdt = api.to_date(default_date)\n    >>> zpdt.ISO8601() == dzpdt.ISO8601()\n    True\n\nUse a non-conversionable value as fallback::\n\n    >>> strd = \"2018-13-01 17:50:34\"\n    >>> default_date = \"something wrong here\"\n    >>> zpdt = api.to_date(strd, default_date)\n    >>> zpdt is None\n    True\n\n\nCheck if floatable\n------------------\n\n::\n\n    >>> api.is_floatable(None)\n    False\n\n    >>> api.is_floatable(\"\")\n    False\n\n    >>> api.is_floatable(\"31\")\n    True\n\n    >>> api.is_floatable(\"31.23\")\n    True\n\n    >>> api.is_floatable(\"-13\")\n    True\n\n    >>> api.is_floatable(\"12,35\")\n    False\n\n\nConvert to a float number\n-------------------------\n\n::\n\n    >>> api.to_float(\"2\")\n    2.0\n\n    >>> api.to_float(\"2.234\")\n    2.234\n\nWith default fallback::\n\n    >>> api.to_float(None, 2)\n    2.0\n\n    >>> api.to_float(None, \"2\")\n    2.0\n\n    >>> api.to_float(\"\", 2)\n    2.0\n\n    >>> api.to_float(\"\", \"2\")\n    2.0\n\n    >>> api.to_float(2.1, 2)\n    2.1\n\n    >>> api.to_float(\"2.1\", 2)\n    2.1\n\n    >>> api.to_float(\"2.1\", \"2\")\n    2.1\n\n\nAPI Analysis\n============\n\nThe api_analysis provides single functions for single purposes especifically\nrelated with analyses.\n\nRunning this test from the buildout directory::\n\n    bin/test test_textual_doctests -t API_analysis\n\n\nTest Setup\n----------\n\nNeeded Imports::\n\n    >>> import re\n    >>> from AccessControl.PermissionRole import rolesForPermissionOn\n    >>> from bika.lims import api\n    >>> from bika.lims.api.analysis import is_out_of_range\n    >>> from bika.lims.content.analysisrequest import AnalysisRequest\n    >>> from bika.lims.content.sample import Sample\n    >>> from bika.lims.content.samplepartition import SamplePartition\n    >>> from bika.lims.utils.analysisrequest import create_analysisrequest\n    >>> from bika.lims.utils.sample import create_sample\n    >>> from bika.lims.utils import tmpID\n    >>> from bika.lims.workflow import doActionFor\n    >>> from bika.lims.workflow import getCurrentState\n    >>> from bika.lims.workflow import getAllowedTransitions\n    >>> from DateTime import DateTime\n    >>> from plone.app.testing import TEST_USER_ID\n    >>> from plone.app.testing import TEST_USER_PASSWORD\n    >>> from plone.app.testing import setRoles\n\nFunctional Helpers::\n\n    >>> def start_server():\n    ...     from Testing.ZopeTestCase.utils import startZServer\n    ...     ip, port = startZServer()\n    ...     return \"http://{}:{}/{}\".format(ip, port, portal.id)\n\nVariables::\n\n    >>> portal = self.portal\n    >>> request = self.request\n    >>> bikasetup = portal.bika_setup\n\nWe need to create some basic objects for the test::\n\n    >>> setRoles(portal, TEST_USER_ID, ['LabManager',])\n    >>> date_now = DateTime().strftime(\"%Y-%m-%d\")\n    >>> date_future = (DateTime() + 5).strftime(\"%Y-%m-%d\")\n    >>> client = api.create(portal.clients, \"Client\", Name=\"Happy Hills\", ClientID=\"HH\", MemberDiscountApplies=True)\n    >>> contact = api.create(client, \"Contact\", Firstname=\"Rita\", Lastname=\"Mohale\")\n    >>> sampletype = api.create(bikasetup.bika_sampletypes, \"SampleType\", title=\"Water\", Prefix=\"W\")\n    >>> labcontact = api.create(bikasetup.bika_labcontacts, \"LabContact\", Firstname=\"Lab\", Lastname=\"Manager\")\n    >>> department = api.create(bikasetup.bika_departments, \"Department\", title=\"Chemistry\", Manager=labcontact)\n    >>> category = api.create(bikasetup.bika_analysiscategories, \"AnalysisCategory\", title=\"Metals\", Department=department)\n    >>> supplier = api.create(bikasetup.bika_suppliers, \"Supplier\", Name=\"Naralabs\")\n    >>> Cu = api.create(bikasetup.bika_analysisservices, \"AnalysisService\", title=\"Copper\", Keyword=\"Cu\", Price=\"15\", Category=category.UID(), DuplicateVariation=\"0.5\")\n    >>> Fe = api.create(bikasetup.bika_analysisservices, \"AnalysisService\", title=\"Iron\", Keyword=\"Fe\", Price=\"10\", Category=category.UID(), DuplicateVariation=\"0.5\")\n    >>> Au = api.create(bikasetup.bika_analysisservices, \"AnalysisService\", title=\"Gold\", Keyword=\"Au\", Price=\"20\", Category=category.UID(), DuplicateVariation=\"0.5\")\n    >>> Mg = api.create(bikasetup.bika_analysisservices, \"AnalysisService\", title=\"Magnesium\", Keyword=\"Mg\", Price=\"20\", Category=category.UID(), DuplicateVariation=\"0.5\")\n    >>> service_uids = [api.get_uid(an) for an in [Cu, Fe, Au, Mg]]\n\nCreate an Analysis Specification for `Water`::\n\n    >>> sampletype_uid = api.get_uid(sampletype)\n    >>> rr1 = {\"keyword\": \"Au\", \"min\": \"-5\", \"max\":  \"5\", \"warn_min\": \"-5.5\", \"warn_max\": \"5.5\"}\n    >>> rr2 = {\"keyword\": \"Cu\", \"min\": \"10\", \"max\": \"20\", \"warn_min\":  \"9.5\", \"warn_max\": \"20.5\"}\n    >>> rr3 = {\"keyword\": \"Fe\", \"min\":  \"0\", \"max\": \"10\", \"warn_min\": \"-0.5\", \"warn_max\": \"10.5\"}\n    >>> rr4 = {\"keyword\": \"Mg\", \"min\": \"10\", \"max\": \"10\"}\n    >>> rr = [rr1, rr2, rr3, rr4]\n    >>> specification = api.create(bikasetup.bika_analysisspecs, \"AnalysisSpec\", title=\"Lab Water Spec\", SampleType=sampletype_uid, ResultsRange=rr)\n    >>> spec_uid = api.get_uid(specification)\n\nCreate a Reference Definition for blank::\n\n    >>> blankdef = api.create(bikasetup.bika_referencedefinitions, \"ReferenceDefinition\", title=\"Blank definition\", Blank=True)\n    >>> blank_refs = [{'uid': Au.UID(), 'result': '0', 'min': '0', 'max': '0'},]\n    >>> blankdef.setReferenceResults(blank_refs)\n\nAnd for control::\n\n    >>> controldef = api.create(bikasetup.bika_referencedefinitions, \"ReferenceDefinition\", title=\"Control definition\")\n    >>> control_refs = [{'uid': Au.UID(), 'result': '10', 'min': '9.99', 'max': '10.01'},\n    ...                 {'uid': Cu.UID(), 'result': '-0.9','min': '-1.08', 'max': '-0.72'},]\n    >>> controldef.setReferenceResults(control_refs)\n\n    >>> blank = api.create(supplier, \"ReferenceSample\", title=\"Blank\",\n    ...                    ReferenceDefinition=blankdef,\n    ...                    Blank=True, ExpiryDate=date_future,\n    ...                    ReferenceResults=blank_refs)\n    >>> control = api.create(supplier, \"ReferenceSample\", title=\"Control\",\n    ...                      ReferenceDefinition=controldef,\n    ...                      Blank=False, ExpiryDate=date_future,\n    ...                      ReferenceResults=control_refs)\n\nCreate an Analysis Request::\n\n    >>> values = {\n    ...     'Client': api.get_uid(client),\n    ...     'Contact': api.get_uid(contact),\n    ...     'DateSampled': date_now,\n    ...     'SampleType': sampletype_uid,\n    ...     'Specification': spec_uid,\n    ...     'Priority': '1',\n    ... }\n\n    >>> ar = create_analysisrequest(client, request, values, service_uids)\n    >>> success = doActionFor(ar, 'receive')\n\nCreate a new Worksheet and add the analyses::\n\n    >>> worksheet = api.create(portal.worksheets, \"Worksheet\")\n    >>> analyses = map(api.get_object, ar.getAnalyses())\n    >>> for analysis in analyses:\n    ...     worksheet.addAnalysis(analysis)\n\nAdd a duplicate for `Cu`::\n\n    >>> position = worksheet.get_slot_position(ar, 'a')\n    >>> duplicates = worksheet.addDuplicateAnalyses(position)\n    >>> duplicates.sort(key=lambda analysis: analysis.getKeyword(), reverse=False)\n\nAdd a blank and a control::\n\n    >>> blanks = worksheet.addReferenceAnalyses(blank, service_uids)\n    >>> blanks.sort(key=lambda analysis: analysis.getKeyword(), reverse=False)\n    >>> controls = worksheet.addReferenceAnalyses(control, service_uids)\n    >>> controls.sort(key=lambda analysis: analysis.getKeyword(), reverse=False)\n\n\nCheck if results are out of range\n---------------------------------\n\nFirst, get the analyses from slot 1 and sort them asc::\n\n    >>> analyses = worksheet.get_analyses_at(1)\n    >>> analyses.sort(key=lambda analysis: analysis.getKeyword(), reverse=False)\n\nSet results for analysis `Au` (min: -5, max: 5, warn_min: -5.5, warn_max: 5.5)::\n\n    >>> au_analysis = analyses[0]\n    >>> au_analysis.setResult(2)\n    >>> is_out_of_range(au_analysis)\n    (False, False)\n\n    >>> au_analysis.setResult(-2)\n    >>> is_out_of_range(au_analysis)\n    (False, False)\n\n    >>> au_analysis.setResult(-5)\n    >>> is_out_of_range(au_analysis)\n    (False, False)\n\n    >>> au_analysis.setResult(5)\n    >>> is_out_of_range(au_analysis)\n    (False, False)\n\n    >>> au_analysis.setResult(10)\n    >>> is_out_of_range(au_analysis)\n    (True, True)\n\n    >>> au_analysis.setResult(-10)\n    >>> is_out_of_range(au_analysis)\n    (True, True)\n\nResults in shoulders?::\n\n    >>> au_analysis.setResult(-5.2)\n    >>> is_out_of_range(au_analysis)\n    (True, False)\n\n    >>> au_analysis.setResult(-5.5)\n    >>> is_out_of_range(au_analysis)\n    (True, False)\n\n    >>> au_analysis.setResult(-5.6)\n    >>> is_out_of_range(au_analysis)\n    (True, True)\n\n    >>> au_analysis.setResult(5.2)\n    >>> is_out_of_range(au_analysis)\n    (True, False)\n\n    >>> au_analysis.setResult(5.5)\n    >>> is_out_of_range(au_analysis)\n    (True, False)\n\n    >>> au_analysis.setResult(5.6)\n    >>> is_out_of_range(au_analysis)\n    (True, True)\n\n\nCheck if results for duplicates are out of range\n------------------------------------------------\n\nGet the first duplicate analysis that comes from `Au`::\n\n    >>> duplicate = duplicates[0]\n\nA Duplicate will be considered out of range if its result does not match with\nthe result set to the analysis that was duplicated from, with the Duplicate\nVariation in % as the margin error. The Duplicate Variation assigned in the\nAnalysis Service `Au` is 0.5%::\n\n    >>> dup_variation = au_analysis.getDuplicateVariation()\n    >>> dup_variation = api.to_float(dup_variation)\n    >>> dup_variation\n    0.5\n\nSet an in-range result (between -5 and 5) for routine analysis and check all\nvariants on it's duplicate. Given that the duplicate variation is 0.5, the\nvalid range for the duplicate must be `Au +-0.5%`::\n\n    >>> result = 2.0\n    >>> au_analysis.setResult(result)\n    >>> is_out_of_range(au_analysis)\n    (False, False)\n\n    >>> duplicate.setResult(result)\n    >>> is_out_of_range(duplicate)\n    (False, False)\n\n    >>> dup_min_range = result - (result*(dup_variation/100))\n    >>> duplicate.setResult(dup_min_range)\n    >>> is_out_of_range(duplicate)\n    (False, False)\n\n    >>> duplicate.setResult(dup_min_range - 0.5)\n    >>> is_out_of_range(duplicate)\n    (True, True)\n\n    >>> dup_max_range = result + (result*(dup_variation/100))\n    >>> duplicate.setResult(dup_max_range)\n    >>> is_out_of_range(duplicate)\n    (False, False)\n\n    >>> duplicate.setResult(dup_max_range + 0.5)\n    >>> is_out_of_range(duplicate)\n    (True, True)\n\nSet an out-of-range result, but within shoulders, for routine analysis and check\nall variants on it's duplicate. Given that the duplicate variation is 0.5, the\nvalid range for the duplicate must be `Au +-0.5%`::\n\n    >>> result = 5.5\n    >>> au_analysis.setResult(result)\n    >>> is_out_of_range(au_analysis)\n    (True, False)\n\n    >>> duplicate.setResult(result)\n    >>> is_out_of_range(duplicate)\n    (False, False)\n\n    >>> dup_min_range = result - (result*(dup_variation/100))\n    >>> duplicate.setResult(dup_min_range)\n    >>> is_out_of_range(duplicate)\n    (False, False)\n\n    >>> duplicate.setResult(dup_min_range - 0.5)\n    >>> is_out_of_range(duplicate)\n    (True, True)\n\n    >>> dup_max_range = result + (result*(dup_variation/100))\n    >>> duplicate.setResult(dup_max_range)\n    >>> is_out_of_range(duplicate)\n    (False, False)\n\n    >>> duplicate.setResult(dup_max_range + 0.5)\n    >>> is_out_of_range(duplicate)\n    (True, True)\n\nSet an out-of-range and out-of-shoulders result, for routine analysis and check\nall variants on it's duplicate. Given that the duplicate variation is 0.5, the\nvalid range for the duplicate must be `Au +-0.5%`::\n\n    >>> result = -7.0\n    >>> au_analysis.setResult(result)\n    >>> is_out_of_range(au_analysis)\n    (True, True)\n\n    >>> duplicate.setResult(result)\n    >>> is_out_of_range(duplicate)\n    (False, False)\n\n    >>> dup_min_range = result - (abs(result)*(dup_variation/100))\n    >>> duplicate.setResult(dup_min_range)\n    >>> is_out_of_range(duplicate)\n    (False, False)\n\n    >>> duplicate.setResult(dup_min_range - 0.5)\n    >>> is_out_of_range(duplicate)\n    (True, True)\n\n    >>> dup_max_range = result + (abs(result)*(dup_variation/100))\n    >>> duplicate.setResult(dup_max_range)\n    >>> is_out_of_range(duplicate)\n    (False, False)\n\n    >>> duplicate.setResult(dup_max_range + 0.5)\n    >>> is_out_of_range(duplicate)\n    (True, True)\n\n\nCheck if results for Reference Analyses (blanks + controls) are out of range\n----------------------------------------------------------------------------\n\nReference Analyses (controls and blanks) do not use the result ranges defined in\nthe specifications, rather they use the result range defined in the Reference\nSample they have been generated from. In turn, the result ranges defined in\nReference Samples can be set manually or acquired from the Reference Definition\nthey might be associated with. Another difference from routine analyses is that\nreference analyses don't expect a valid range, rather a discrete value, so\nshoulders are built based on % error.\n\nBlank Analyses\n..............\n\nThe first blank analysis corresponds to `Au`::\n\n    >>> au_blank = blanks[0]\n\nFor `Au` blank, as per the reference definition used above, the expected result\nis 0 +/- 0.1%. Since the expected result is 0, no shoulders will be considered\nregardless of the % of error. Thus, result will always be \"out-of-shoulders\"\nwhen out of range::\n\n    >>> au_blank.setResult(0.0)\n    >>> is_out_of_range(au_blank)\n    (False, False)\n\n    >>> au_blank.setResult(\"0\")\n    >>> is_out_of_range(au_blank)\n    (False, False)\n\n    >>> au_blank.setResult(0.0001)\n    >>> is_out_of_range(au_blank)\n    (True, True)\n\n    >>> au_blank.setResult(\"0.0001\")\n    >>> is_out_of_range(au_blank)\n    (True, True)\n\n    >>> au_blank.setResult(-0.0001)\n    >>> is_out_of_range(au_blank)\n    (True, True)\n\n    >>> au_blank.setResult(\"-0.0001\")\n    >>> is_out_of_range(au_blank)\n    (True, True)\n\nControl Analyses\n................\n\nThe first control analysis corresponds to `Au`::\n\n    >>> au_control = controls[0]\n\nFor `Au` control, as per the reference definition used above, the expected\nresult is 10 +/- 0.1% = 10 +/- 0.01\n\nFirst, check for in-range values::\n\n    >>> au_control.setResult(10)\n    >>> is_out_of_range(au_control)\n    (False, False)\n\n    >>> au_control.setResult(10.0)\n    >>> is_out_of_range(au_control)\n    (False, False)\n\n    >>> au_control.setResult(\"10\")\n    >>> is_out_of_range(au_control)\n    (False, False)\n\n    >>> au_control.setResult(\"10.0\")\n    >>> is_out_of_range(au_control)\n    (False, False)\n\n    >>> au_control.setResult(9.995)\n    >>> is_out_of_range(au_control)\n    (False, False)\n\n    >>> au_control.setResult(\"9.995\")\n    >>> is_out_of_range(au_control)\n    (False, False)\n\n    >>> au_control.setResult(10.005)\n    >>> is_out_of_range(au_control)\n    (False, False)\n\n    >>> au_control.setResult(\"10.005\")\n    >>> is_out_of_range(au_control)\n    (False, False)\n\n    >>> au_control.setResult(9.99)\n    >>> is_out_of_range(au_control)\n    (False, False)\n\n    >>> au_control.setResult(\"9.99\")\n    >>> is_out_of_range(au_control)\n    (False, False)\n\n    >>> au_control.setResult(10.01)\n    >>> is_out_of_range(au_control)\n    (False, False)\n\n    >>> au_control.setResult(\"10.01\")\n    >>> is_out_of_range(au_control)\n    (False, False)\n\nNow, check for out-of-range results::\n\n    >>> au_control.setResult(9.98)\n    >>> is_out_of_range(au_control)\n    (True, True)\n\n    >>> au_control.setResult(\"9.98\")\n    >>> is_out_of_range(au_control)\n    (True, True)\n\n    >>> au_control.setResult(10.011)\n    >>> is_out_of_range(au_control)\n    (True, True)\n\n    >>> au_control.setResult(\"10.011\")\n    >>> is_out_of_range(au_control)\n    (True, True)\n\nAnd do the same with the control for `Cu` that expects -0.9 +/- 20%::\n\n    >>> cu_control = controls[1]\n\nFirst, check for in-range values::\n\n    >>> cu_control.setResult(-0.9)\n    >>> is_out_of_range(cu_control)\n    (False, False)\n\n    >>> cu_control.setResult(\"-0.9\")\n    >>> is_out_of_range(cu_control)\n    (False, False)\n\n    >>> cu_control.setResult(-1.08)\n    >>> is_out_of_range(cu_control)\n    (False, False)\n\n    >>> cu_control.setResult(\"-1.08\")\n    >>> is_out_of_range(cu_control)\n    (False, False)\n\n    >>> cu_control.setResult(-1.07)\n    >>> is_out_of_range(cu_control)\n    (False, False)\n\n    >>> cu_control.setResult(\"-1.07\")\n    >>> is_out_of_range(cu_control)\n    (False, False)\n\n    >>> cu_control.setResult(-0.72)\n    >>> is_out_of_range(cu_control)\n    (False, False)\n\n    >>> cu_control.setResult(\"-0.72\")\n    >>> is_out_of_range(cu_control)\n    (False, False)\n\n    >>> cu_control.setResult(-0.73)\n    >>> is_out_of_range(cu_control)\n    (False, False)\n\n    >>> cu_control.setResult(\"-0.73\")\n    >>> is_out_of_range(cu_control)\n    (False, False)\n\nNow, check for out-of-range results::\n\n    >>> cu_control.setResult(0)\n    >>> is_out_of_range(cu_control)\n    (True, True)\n\n    >>> cu_control.setResult(\"0\")\n    >>> is_out_of_range(cu_control)\n    (True, True)\n\n    >>> cu_control.setResult(-0.71)\n    >>> is_out_of_range(cu_control)\n    (True, True)\n\n    >>> cu_control.setResult(\"-0.71\")\n    >>> is_out_of_range(cu_control)\n    (True, True)\n\n    >>> cu_control.setResult(-1.09)\n    >>> is_out_of_range(cu_control)\n    (True, True)\n\n    >>> cu_control.setResult(\"-1.09\")\n    >>> is_out_of_range(cu_control)\n    (True, True)\n\n\nChangelog\n=========\n1.2.3 (2018-06-23)\n------------------\n\n- More PyPI fixtures\n\n\n1.2.2 (2018-06-23)\n------------------\n\n- PyPI Documentation Page fixtures\n\n\n1.2.1 (2018-06-23)\n------------------\n\n- Better Documentation Page for PyPI\n- Fixed formatting of Doctests\n\n\n1.2.0 (2018-06-23)\n------------------\n\n**Added**\n\n- Added `is_uid` function\n\n**Removed**\n\n**Changed**\n\n- Added SENAITE CORE API functions\n\n**Fixed**\n\n- Fixed Tests\n\n**Security**\n\n\n1.1.0 (2018-01-03)\n------------------\n\n**Added**\n\n**Removed**\n\n**Changed**\n\n- License changed to GPLv2\n- Integration to SENAITE CORE\n\n**Fixed**\n\n- Fixed Tests\n\n**Security**\n\n\n1.0.2 (2017-11-24)\n------------------\n\n- #397(bika.lims) Fix Issue-396: AttributeError: uid_catalog on AR publication\n\n\n1.0.1 (2017-09-30)\n------------------\n\n- Fixed broken release (missing MANIFEST.in)\n\n\n1.0.0 (2017-09-30)\n------------------\n\n- First release\n\n\n", "description_content_type": "", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/senaite/senaite.api", "keywords": "", "license": "GPLv2", "maintainer": "", "maintainer_email": "", "name": "senaite.api", "package_url": "https://pypi.org/project/senaite.api/", "platform": "", "project_url": "https://pypi.org/project/senaite.api/", "project_urls": {"Homepage": "https://github.com/senaite/senaite.api"}, "release_url": "https://pypi.org/project/senaite.api/1.2.3.post2/", "requires_dist": ["setuptools", "plone.api", "senaite.core", "Products.PloneTestCase; extra == 'test'", "Products.SecureMailHost; extra == 'test'", "plone.app.robotframework; extra == 'test'", "plone.app.testing; extra == 'test'", "robotframework-debuglibrary; extra == 'test'", "robotframework-selenium2library; extra == 'test'", "robotsuite; extra == 'test'", "unittest2; extra == 'test'"], "requires_python": "", "summary": "SENAITE API", "version": "1.2.3.post2", "yanked": false, "html_description": "<div class=\"project-description\">\n            <img alt=\"senaite.api\" class=\"align-center\" height=\"64px\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/a7ef963d9e4aed9afd7af3f4ccb5a7e50537147e/68747470733a2f2f7261772e67697468756275736572636f6e74656e742e636f6d2f73656e616974652f73656e616974652e6170692f6d61737465722f7374617469632f6170692d6c6f676f2e706e67\">\n<ul>\n<li><strong>SENAITE.API</strong>: <em>The Swiss-Army-Knife for SENAITE Core and Add-on developers</em></li>\n</ul>\n<a href=\"https://pypi.python.org/pypi/senaite.api\" rel=\"nofollow\"><img alt=\"https://img.shields.io/pypi/v/senaite.api.svg?style=flat-square\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/91ab03d46d0c2ef7101aa6f775c635671c37cd00/68747470733a2f2f696d672e736869656c64732e696f2f707970692f762f73656e616974652e6170692e7376673f7374796c653d666c61742d737175617265\"></a>\n<a href=\"https://github.com/senaite/senaite.api/pulls\" rel=\"nofollow\"><img alt=\"https://img.shields.io/github/issues-pr/senaite/senaite.api.svg?style=flat-square\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/ea6e49a9febc62d20c5429ddb5b4591ca4f7223a/68747470733a2f2f696d672e736869656c64732e696f2f6769746875622f6973737565732d70722f73656e616974652f73656e616974652e6170692e7376673f7374796c653d666c61742d737175617265\"></a>\n<a href=\"https://github.com/senaite/senaite.api/issues\" rel=\"nofollow\"><img alt=\"https://img.shields.io/github/issues/senaite/senaite.api.svg?style=flat-square\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/f334597e2aadc5fcd081665bbdc21e328902279f/68747470733a2f2f696d672e736869656c64732e696f2f6769746875622f6973737565732f73656e616974652f73656e616974652e6170692e7376673f7374796c653d666c61742d737175617265\"></a>\n<a href=\"https://github.com/senaite/senaite.api#readme\" rel=\"nofollow\"><img alt=\"https://img.shields.io/badge/README-GitHub-blue.svg?style=flat-square\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/acb51262bb884abef4a4fd9982033dd214e1f955/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f524541444d452d4769744875622d626c75652e7376673f7374796c653d666c61742d737175617265\"></a>\n<div id=\"about\">\n<h2>About</h2>\n<p>SENAITE API is the Swiss-Army-Knife for SENAITE Core and Add-on developers. It\nprovides a sane interface for common tasks in SENAITE, like e.g. object\ncreation, lookup by ID/UID, search etc.</p>\n<p>Please see the doctests for further details and usage:</p>\n<ul>\n<li><a href=\"https://github.com/senaite/senaite.api/blob/master/src/senaite/api/docs/API.rst\" rel=\"nofollow\">Core API Documentation</a></li>\n<li><a href=\"https://github.com/senaite/senaite.api/blob/master/src/senaite/api/docs/API_analysis.rst\" rel=\"nofollow\">Analysis API Documentation</a></li>\n</ul>\n</div>\n<div id=\"installation\">\n<h2>Installation</h2>\n<p>Please follow the installations instructions for <a href=\"https://docs.plone.org/4/en/manage/installing/index.html\" rel=\"nofollow\">Plone 4</a> and\n<a href=\"https://github.com/senaite/senaite.lims#installation\" rel=\"nofollow\">senaite.lims</a>.</p>\n<p>To install SENAITE API, you have to add <cite>senaite.api</cite> into the\n<cite>eggs</cite> list inside the <cite>[buildout]</cite> section of your\n<cite>buildout.cfg</cite>:</p>\n<pre>[buildout]\nparts =\n    instance\nextends =\n    http://dist.plone.org/release/4.3.17/versions.cfg\nfind-links =\n    http://dist.plone.org/release/4.3.17\n    http://dist.plone.org/thirdparty\neggs =\n    Plone\n    Pillow\n    senaite.lims\n    senaite.api\nzcml =\neggs-directory = ${buildout:directory}/eggs\n\n[instance]\nrecipe = plone.recipe.zope2instance\nuser = admin:admin\nhttp-address = 0.0.0.0:8080\neggs =\n    ${buildout:eggs}\nzcml =\n    ${buildout:zcml}\n\n[versions]\nsetuptools =\nzc.buildout =\n</pre>\n<p><strong>Note</strong></p>\n<p>The above example works for the buildout created by the unified\ninstaller. If you however have a custom buildout you might need to add\nthe egg to the <cite>eggs</cite> list in the <cite>[instance]</cite> section rather than\nadding it in the <cite>[buildout]</cite> section.</p>\n<p>Also see this section of the Plone documentation for further details:\n<a href=\"https://docs.plone.org/4/en/manage/installing/installing_addons.html\" rel=\"nofollow\">https://docs.plone.org/4/en/manage/installing/installing_addons.html</a></p>\n<p><strong>Important</strong></p>\n<p>For the changes to take effect you need to re-run buildout from your\nconsole:</p>\n<pre>bin/buildout\n</pre>\n</div>\n<div id=\"senaite-api-doctest\">\n<h2>SENAITE API DOCTEST</h2>\n<p>The SENAITE LIMS API provides single functions for single purposes.\nThis Test builds completely on the API without any further imports needed.</p>\n<p>Running this test from the buildout directory:</p>\n<pre>bin/test test_doctests -t API\n</pre>\n<div id=\"introduction\">\n<h3>Introduction</h3>\n<p>The purpose of this API is to help coders to follow the DRY principle (Don\u2019t\nRepeat Yourself). It also ensures that the most effective and efficient method is\nused to achieve a task.</p>\n<p>Import it first:</p>\n<pre>&gt;&gt;&gt; from senaite import api\n</pre>\n</div>\n<div id=\"getting-the-portal\">\n<h3>Getting the Portal</h3>\n<p>The Portal is the SENAITE LIMS root object:</p>\n<pre>&gt;&gt;&gt; portal = api.get_portal()\n&gt;&gt;&gt; portal\n&lt;PloneSite at /plone&gt;\n</pre>\n</div>\n<div id=\"getting-the-setup-object\">\n<h3>Getting the Setup object</h3>\n<p>The Setup object gives access to all of the Bika configuration settings:</p>\n<pre>&gt;&gt;&gt; bika_setup = api.get_setup()\n&gt;&gt;&gt; bika_setup\n&lt;BikaSetup at /plone/bika_setup&gt;\n</pre>\n</div>\n<div id=\"creating-new-content\">\n<h3>Creating new Content</h3>\n<p>Creating new contents in Bika LIMS requires some special knowledge.\nThis function helps to do it right and creates a content for you.</p>\n<p>Here we create a new <cite>Client</cite> in the <cite>plone/clients</cite> folder:</p>\n<pre>&gt;&gt;&gt; client = api.create(portal.clients, \"Client\", title=\"Test Client\")\n&gt;&gt;&gt; client\n&lt;Client at /plone/clients/client-1&gt;\n\n &gt;&gt;&gt; client.Title()\n 'Test Client'\n</pre>\n</div>\n<div id=\"getting-a-tool\">\n<h3>Getting a Tool</h3>\n<p>There are many ways to get a tool in Bika LIMS / Plone. This function\ncentralizes this functionality and makes it painless:</p>\n<pre>&gt;&gt;&gt; api.get_tool(\"bika_setup_catalog\")\n&lt;BikaSetupCatalog at /plone/bika_setup_catalog&gt;\n</pre>\n<p>Trying to fetch an non-existing tool raises a custom <cite>SenaiteAPIError</cite>:</p>\n<pre>&gt;&gt;&gt; api.get_tool(\"NotExistingTool\")\nTraceback (most recent call last):\n[...]\nSenaiteAPIError: No tool named 'NotExistingTool' found.\n</pre>\n<p>This error can also be used for custom methods with the <cite>fail</cite> function:</p>\n<pre>&gt;&gt;&gt; api.fail(\"This failed badly\")\nTraceback (most recent call last):\n[...]\nSenaiteAPIError: This failed badly\n</pre>\n</div>\n<div id=\"getting-an-object\">\n<h3>Getting an Object</h3>\n<p>Getting a tool from a catalog brain is a common task in Bika LIMS. This function\nprovides an unified interface to portal objects <strong>and</strong> brains.\nFurthermore it is idempotent, so it can be called multiple times in a row.</p>\n<p>We will demonstrate the usage on the client object we created above:</p>\n<pre>&gt;&gt;&gt; api.get_object(client)\n&lt;Client at /plone/clients/client-1&gt;\n\n&gt;&gt;&gt; api.get_object(api.get_object(client))\n&lt;Client at /plone/clients/client-1&gt;\n</pre>\n<p>Now we show it with catalog results:</p>\n<pre>&gt;&gt;&gt; portal_catalog = api.get_tool(\"portal_catalog\")\n&gt;&gt;&gt; brains = portal_catalog(portal_type=\"Client\")\n&gt;&gt;&gt; brains\n[&lt;Products.ZCatalog.Catalog.mybrains object at 0x...&gt;]\n\n&gt;&gt;&gt; brain = brains[0]\n\n&gt;&gt;&gt; api.get_object(brain)\n&lt;Client at /plone/clients/client-1&gt;\n\n&gt;&gt;&gt; api.get_object(api.get_object(brain))\n&lt;Client at /plone/clients/client-1&gt;\n</pre>\n<p>No supported objects raise an error:</p>\n<pre>&gt;&gt;&gt; api.get_object(object())\nTraceback (most recent call last):\n[...]\nSenaiteAPIError: &lt;object object at 0x...&gt; is not supported.\n</pre>\n<p>To check if an object is supported, e.g. is an ATCT, Dexterity, ZCatalog or\nPortal object, we can use the <cite>is_object</cite> function:</p>\n<pre>  &gt;&gt;&gt; api.is_object(client)\n  True\n\n  &gt;&gt;&gt; api.is_object(brain)\n  True\n\n  &gt;&gt;&gt; api.is_object(api.get_portal())\n  True\n\n  &gt;&gt;&gt; api.is_object(None)\n  False\n\n&gt;&gt;&gt; api.is_object(object())\n  False\n</pre>\n</div>\n<div id=\"checking-if-an-object-is-the-portal\">\n<h3>Checking if an Object is the Portal</h3>\n<p>Sometimes it can be handy to check if the current object is the portal:</p>\n<pre>&gt;&gt;&gt; api.is_portal(portal)\nTrue\n\n&gt;&gt;&gt; api.is_portal(client)\nFalse\n\n&gt;&gt;&gt; api.is_portal(object())\nFalse\n</pre>\n</div>\n<div id=\"checking-if-an-object-is-a-catalog-brain\">\n<h3>Checking if an Object is a Catalog Brain</h3>\n<p>Knowing if we have an object or a brain can be handy. This function checks this for you:</p>\n<pre>&gt;&gt;&gt; api.is_brain(brain)\nTrue\n\n&gt;&gt;&gt; api.is_brain(api.get_object(brain))\nFalse\n\n&gt;&gt;&gt; api.is_brain(object())\nFalse\n</pre>\n</div>\n<div id=\"checking-if-an-object-is-a-dexterity-content\">\n<h3>Checking if an Object is a Dexterity Content</h3>\n<p>This function checks if an object is a <cite>Dexterity</cite> content type:</p>\n<pre>&gt;&gt;&gt; api.is_dexterity_content(client)\nFalse\n\n&gt;&gt;&gt; api.is_dexterity_content(portal)\nFalse\n</pre>\n<p>We currently have no <cite>Dexterity</cite> contents, so testing this comes later\u2026</p>\n</div>\n<div id=\"checking-if-an-object-is-an-at-content\">\n<h3>Checking if an Object is an AT Content</h3>\n<p>This function checks if an object is an <cite>Archetypes</cite> content type:</p>\n<pre>&gt;&gt;&gt; api.is_at_content(client)\nTrue\n\n&gt;&gt;&gt; api.is_at_content(portal)\nFalse\n\n&gt;&gt;&gt; api.is_at_content(object())\nFalse\n</pre>\n</div>\n<div id=\"getting-the-schema-of-a-content\">\n<h3>Getting the Schema of a Content</h3>\n<p>The schema contains the fields of a content object. Getting the schema is a\ncommon task, but differs between <cite>ATContentType</cite> based objects and <cite>Dexterity</cite>\nbased objects. This function brings it under one umbrella:</p>\n<pre>&gt;&gt;&gt; schema = api.get_schema(client)\n&gt;&gt;&gt; schema\n&lt;Products.Archetypes.Schema.Schema object at 0x...&gt;\n</pre>\n<p>Catalog brains are also supported:</p>\n<pre>&gt;&gt;&gt; api.get_schema(brain)\n&lt;Products.Archetypes.Schema.Schema object at 0x...&gt;\n</pre>\n</div>\n<div id=\"getting-the-fields-of-a-content\">\n<h3>Getting the Fields of a Content</h3>\n<p>The fields contain all the values that an object holds and are therefore\nresponsible for getting and setting the information.</p>\n<p>This function returns the fields as a dictionary mapping of <cite>{\u201ckey\u201d: value}</cite>:</p>\n<pre>&gt;&gt;&gt; fields = api.get_fields(client)\n&gt;&gt;&gt; fields.get(\"ClientID\")\n&lt;Field ClientID(string:rw)&gt;\n</pre>\n<p>Catalog brains are also supported:</p>\n<pre>&gt;&gt;&gt; api.get_fields(brain).get(\"ClientID\")\n&lt;Field ClientID(string:rw)&gt;\n</pre>\n</div>\n<div id=\"getting-the-id-of-a-content\">\n<h3>Getting the ID of a Content</h3>\n<p>Getting the ID is a common task in Bika LIMS.\nThis function takes care that catalog brains are not waked up for this task:</p>\n<pre>&gt;&gt;&gt; api.get_id(portal)\n'plone'\n\n&gt;&gt;&gt; api.get_id(client)\n'client-1'\n\n&gt;&gt;&gt; api.get_id(brain)\n'client-1'\n</pre>\n</div>\n<div id=\"getting-the-title-of-a-content\">\n<h3>Getting the Title of a Content</h3>\n<p>Getting the Title is a common task in Bika LIMS.\nThis function takes care that catalog brains are not waked up for this task:</p>\n<pre>&gt;&gt;&gt; api.get_title(portal)\nu'Plone site'\n\n&gt;&gt;&gt; api.get_title(client)\n'Test Client'\n\n&gt;&gt;&gt; api.get_title(brain)\n'Test Client'\n</pre>\n</div>\n<div id=\"getting-the-description-of-a-content\">\n<h3>Getting the Description of a Content</h3>\n<p>Getting the Description is a common task in Bika LIMS.\nThis function takes care that catalog brains are not waked up for this task:</p>\n<pre>&gt;&gt;&gt; api.get_description(portal)\n''\n\n&gt;&gt;&gt; api.get_description(client)\n''\n\n&gt;&gt;&gt; api.get_description(brain)\n''\n</pre>\n</div>\n<div id=\"getting-the-uid-of-a-content\">\n<h3>Getting the UID of a Content</h3>\n<p>Getting the UID is a common task in Bika LIMS.\nThis function takes care that catalog brains are not waked up for this task.</p>\n<p>The portal object actually has no UID. This funciton defines it therfore to be <cite>0</cite>:</p>\n<pre>&gt;&gt;&gt; api.get_uid(portal)\n'0'\n\n&gt;&gt;&gt; uid_client = api.get_uid(client)\n&gt;&gt;&gt; uid_client_brain = api.get_uid(brain)\n&gt;&gt;&gt; uid_client is uid_client_brain\nTrue\n</pre>\n</div>\n<div id=\"getting-the-url-of-a-content\">\n<h3>Getting the URL of a Content</h3>\n<p>Getting the URL is a common task in Bika LIMS.\nThis function takes care that catalog brains are not waked up for this task:</p>\n<pre>&gt;&gt;&gt; api.get_url(portal)\n'http://nohost/plone'\n\n&gt;&gt;&gt; api.get_url(client)\n'http://nohost/plone/clients/client-1'\n\n&gt;&gt;&gt; api.get_url(brain)\n'http://nohost/plone/clients/client-1'\n</pre>\n</div>\n<div id=\"getting-the-icon-of-a-content\">\n<h3>Getting the Icon of a Content</h3>\n<pre>&gt;&gt;&gt; api.get_icon(client)\n'&lt;img width=\"16\" height=\"16\" src=\"http://nohost/plone/++resource++bika.lims.images/client.png\" title=\"Test Client\" /&gt;'\n\n&gt;&gt;&gt; api.get_icon(brain)\n'&lt;img width=\"16\" height=\"16\" src=\"http://nohost/plone/++resource++bika.lims.images/client.png\" title=\"Test Client\" /&gt;'\n\n&gt;&gt;&gt; api.get_icon(client, html_tag=False)\n'http://nohost/plone/++resource++bika.lims.images/client.png'\n\n&gt;&gt;&gt; api.get_icon(client, html_tag=False)\n'http://nohost/plone/++resource++bika.lims.images/client.png'\n</pre>\n</div>\n<div id=\"getting-an-object-by-uid\">\n<h3>Getting an object by UID</h3>\n<p>This function finds an object by its uinique ID (UID).\nThe portal object with the defined UId of \u20180\u2019 is also supported:</p>\n<pre>&gt;&gt;&gt; api.get_object_by_uid('0')\n&lt;PloneSite at /plone&gt;\n\n&gt;&gt;&gt; api.get_object_by_uid(uid_client)\n&lt;Client at /plone/clients/client-1&gt;\n\n&gt;&gt;&gt; api.get_object_by_uid(uid_client_brain)\n&lt;Client at /plone/clients/client-1&gt;\n</pre>\n<p>If a default value is provided, the function will never fail.  Any exception\nor error will result in the default value being returned:</p>\n<pre>&gt;&gt;&gt; api.get_object_by_uid('invalid uid', 'default')\n'default'\n\n&gt;&gt;&gt; api.get_object_by_uid(None, 'default')\n'default'\n</pre>\n</div>\n<div id=\"getting-an-object-by-path\">\n<h3>Getting an object by Path</h3>\n<p>This function finds an object by its physical path:</p>\n<pre>&gt;&gt;&gt; api.get_object_by_path('/plone')\n&lt;PloneSite at /plone&gt;\n\n&gt;&gt;&gt; api.get_object_by_path('/plone/clients/client-1')\n&lt;Client at /plone/clients/client-1&gt;\n</pre>\n<p>Paths outside the portal raise an error:</p>\n<pre>&gt;&gt;&gt; api.get_object_by_path('/root')\nTraceback (most recent call last):\n[...]\nSenaiteAPIError: Not a physical path inside the portal.\n</pre>\n<p>Any exception returns default value:</p>\n<pre>&gt;&gt;&gt; api.get_object_by_path('/invaid/path', 'default')\n'default'\n\n&gt;&gt;&gt; api.get_object_by_path(None, 'default')\n'default'\n</pre>\n</div>\n<div id=\"getting-the-physical-path-of-an-object\">\n<h3>Getting the Physical Path of an Object</h3>\n<p>The physical path describes exactly where an object is located inside the portal.\nThis function unifies the different approaches to get the physical path and does\nso in the most efficient way:</p>\n<pre>&gt;&gt;&gt; api.get_path(portal)\n'/plone'\n\n&gt;&gt;&gt; api.get_path(client)\n'/plone/clients/client-1'\n\n&gt;&gt;&gt; api.get_path(brain)\n'/plone/clients/client-1'\n\n&gt;&gt;&gt; api.get_path(object())\nTraceback (most recent call last):\n[...]\nSenaiteAPIError: &lt;object object at 0x...&gt; is not supported.\n</pre>\n</div>\n<div id=\"getting-the-physical-parent-path-of-an-object\">\n<h3>Getting the Physical Parent Path of an Object</h3>\n<p>This function returns the physical path of the parent object:</p>\n<pre>&gt;&gt;&gt; api.get_parent_path(client)\n'/plone/clients'\n\n&gt;&gt;&gt; api.get_parent_path(brain)\n'/plone/clients'\n</pre>\n<p>However, this function goes only up to the portal object:</p>\n<pre>&gt;&gt;&gt; api.get_parent_path(portal)\n'/plone'\n</pre>\n<p>Like with the other functions, only portal objects are supported:</p>\n<pre>&gt;&gt;&gt; api.get_parent_path(object())\nTraceback (most recent call last):\n[...]\nSenaiteAPIError: &lt;object object at 0x...&gt; is not supported.\n</pre>\n</div>\n<div id=\"getting-the-parent-object\">\n<h3>Getting the Parent Object</h3>\n<p>This function returns the parent object:</p>\n<pre>&gt;&gt;&gt; api.get_parent(client)\n&lt;ClientFolder at /plone/clients&gt;\n</pre>\n<p>Brains are also supported:</p>\n<pre>&gt;&gt;&gt; api.get_parent(brain)\n&lt;ClientFolder at /plone/clients&gt;\n</pre>\n<p>The function can also use a catalog query on the <cite>portal_catalog</cite> and return a\nbrain, if the passed parameter <cite>catalog_search</cite> was set to true.</p>\n<pre>&gt;&gt;&gt; api.get_parent(client, catalog_search=True)\n&lt;Products.ZCatalog.Catalog.mybrains object at 0x...&gt;\n\n&gt;&gt;&gt; api.get_parent(brain, catalog_search=True)\n&lt;Products.ZCatalog.Catalog.mybrains object at 0x...&gt;\n</pre>\n<p>However, this function goes only up to the portal object:</p>\n<pre>&gt;&gt;&gt; api.get_parent(portal)\n&lt;PloneSite at /plone&gt;\n</pre>\n<p>Like with the other functions, only portal objects are supported:</p>\n<pre>&gt;&gt;&gt; api.get_parent(object())\nTraceback (most recent call last):\n[...]\nSenaiteAPIError: &lt;object object at 0x...&gt; is not supported.\n</pre>\n</div>\n<div id=\"searching-objects\">\n<h3>Searching Objects</h3>\n<p>Searching in Bika LIMS requires knowledge in which catalog the object is indexed.\nThis function unifies all Bika LIMS catalog to a single search interface:</p>\n<pre>&gt;&gt;&gt; results = api.search({'portal_type': 'Client'})\n&gt;&gt;&gt; results\n[&lt;Products.ZCatalog.Catalog.mybrains object at 0x...&gt;]\n</pre>\n<p>Multiple content types are also supported:</p>\n<pre>&gt;&gt;&gt; results = api.search({'portal_type': ['Client', 'ClientFolder'], 'sort_on': 'getId'})\n&gt;&gt;&gt; map(api.get_id, results)\n['client-1', 'clients']\n</pre>\n<p>Now we create some objects which are located in the <cite>bika_setup_catalog</cite>:</p>\n<pre>&gt;&gt;&gt; instruments = bika_setup.bika_instruments\n&gt;&gt;&gt; instrument1 = api.create(instruments, \"Instrument\", title=\"Instrument-1\")\n&gt;&gt;&gt; instrument2 = api.create(instruments, \"Instrument\", title=\"Instrument-2\")\n&gt;&gt;&gt; instrument3 = api.create(instruments, \"Instrument\", title=\"Instrument-3\")\n\n&gt;&gt;&gt; results = api.search({'portal_type': 'Instrument', 'sort_on': 'getId'})\n&gt;&gt;&gt; len(results)\n3\n\n&gt;&gt;&gt; map(api.get_id, results)\n['instrument-1', 'instrument-2', 'instrument-3']\n</pre>\n<p>Queries which result in multiple catalogs will be refused, as it would require\nmanual merging and sorting of the results afterwards. Thus, we fail here:</p>\n<pre>&gt;&gt;&gt; results = api.search({'portal_type': ['Client', 'ClientFolder', 'Instrument'], 'sort_on': 'getId'})\nTraceback (most recent call last):\n[...]\nSenaiteAPIError: Multi Catalog Queries are not supported, please specify a catalog.\n</pre>\n<p>Catalog queries w/o any <cite>portal_type</cite>, default to the <cite>portal_catalog</cite>, which\nwill not find the following items:</p>\n<pre>&gt;&gt;&gt; analysiscategories = bika_setup.bika_analysiscategories\n&gt;&gt;&gt; analysiscategory1 = api.create(analysiscategories, \"AnalysisCategory\", title=\"AC-1\")\n&gt;&gt;&gt; analysiscategory2 = api.create(analysiscategories, \"AnalysisCategory\", title=\"AC-2\")\n&gt;&gt;&gt; analysiscategory3 = api.create(analysiscategories, \"AnalysisCategory\", title=\"AC-3\")\n\n&gt;&gt;&gt; results = api.search({\"id\": \"analysiscategory-1\"})\n&gt;&gt;&gt; len(results)\n0\n</pre>\n<p>Would we add the <cite>portal_type</cite>, the search function would ask the\n<cite>archetype_tool</cite> for the right catalog, and it would return a result:</p>\n<pre>&gt;&gt;&gt; results = api.search({\"portal_type\": \"AnalysisCategory\", \"id\": \"analysiscategory-1\"})\n&gt;&gt;&gt; len(results)\n1\n</pre>\n<p>We could also explicitly define a catalog to achieve the same:</p>\n<pre>&gt;&gt;&gt; results = api.search({\"id\": \"analysiscategory-1\"}, catalog=\"bika_setup_catalog\")\n&gt;&gt;&gt; len(results)\n1\n</pre>\n<p>To see inactive or dormant items, we must explicitly query them of filter them\nafterwars manually:</p>\n<pre>&gt;&gt;&gt; results = api.search({\"portal_type\": \"AnalysisCategory\", \"id\": \"analysiscategory-1\"})\n&gt;&gt;&gt; len(results)\n1\n</pre>\n<p>Now we deactivate the item:</p>\n<pre>&gt;&gt;&gt; analysiscategory1 = api.do_transition_for(analysiscategory1, 'deactivate')\n&gt;&gt;&gt; api.is_active(analysiscategory1)\nFalse\n</pre>\n<p>The search will still find the item:</p>\n<pre>&gt;&gt;&gt; results = api.search({\"portal_type\": \"AnalysisCategory\", \"id\": \"analysiscategory-1\"})\n&gt;&gt;&gt; len(results)\n1\n</pre>\n<p>Unless we filter it out manually:</p>\n<pre>&gt;&gt;&gt; len(filter(api.is_active, results))\n0\n</pre>\n<p>Or provide a correct query:</p>\n<pre>&gt;&gt;&gt; results = api.search({\"portal_type\": \"AnalysisCategory\", \"id\": \"analysiscategory-1\", \"inactive_status\": \"active\"})\n&gt;&gt;&gt; len(results)\n1\n</pre>\n</div>\n<div id=\"getting-the-registered-catalogs\">\n<h3>Getting the registered Catalogs</h3>\n<p>Bika LIMS uses multiple catalogs registered via the Archetype Tool. This\nfunction returns a list of registered catalogs for a brain or object:</p>\n<pre>&gt;&gt;&gt; api.get_catalogs_for(client)\n[&lt;CatalogTool at /plone/portal_catalog&gt;]\n\n&gt;&gt;&gt; api.get_catalogs_for(instrument1)\n[&lt;BikaSetupCatalog at /plone/bika_setup_catalog&gt;, &lt;CatalogTool at /plone/portal_catalog&gt;]\n\n&gt;&gt;&gt; api.get_catalogs_for(analysiscategory1)\n[&lt;BikaSetupCatalog at /plone/bika_setup_catalog&gt;]\n</pre>\n</div>\n<div id=\"getting-an-attribute-of-an-object\">\n<h3>Getting an Attribute of an Object</h3>\n<p>This function handles attributes and methods the same and returns their value.\nIt also handles security and is able to return a default value instead of\nraising an <cite>Unauthorized</cite> error:</p>\n<pre>&gt;&gt;&gt; uid_brain = api.safe_getattr(brain, \"UID\")\n&gt;&gt;&gt; uid_obj = api.safe_getattr(client, \"UID\")\n\n&gt;&gt;&gt; uid_brain == uid_obj\nTrue\n\n&gt;&gt;&gt; api.safe_getattr(brain, \"review_state\")\n'active'\n\n&gt;&gt;&gt; api.safe_getattr(brain, \"NONEXISTING\")\nTraceback (most recent call last):\n[...]\nSenaiteAPIError: Attribute 'NONEXISTING' not found.\n\n&gt;&gt;&gt; api.safe_getattr(brain, \"NONEXISTING\", \"\")\n''\n</pre>\n</div>\n<div id=\"getting-the-portal-catalog\">\n<h3>Getting the Portal Catalog</h3>\n<p>This tool is needed so often, that this function just returns it:</p>\n<pre>&gt;&gt;&gt; api.get_portal_catalog()\n&lt;CatalogTool at /plone/portal_catalog&gt;\n</pre>\n</div>\n<div id=\"getting-the-review-history-of-an-object\">\n<h3>Getting the Review History of an Object</h3>\n<p>The review history gives information about the objects\u2019 workflow changes:</p>\n<pre>&gt;&gt;&gt; review_history = api.get_review_history(client)\n&gt;&gt;&gt; sorted(review_history[0].items())\n[('action', None), ('actor', 'test_user_1_'), ('comments', ''), ('review_state', 'active'), ('time', DateTime('...'))]\n</pre>\n</div>\n<div id=\"getting-the-revision-history-of-an-object\">\n<h3>Getting the Revision History of an Object</h3>\n<p>The review history gives information about the objects\u2019 workflow changes:</p>\n<pre>&gt;&gt;&gt; revision_history = api.get_revision_history(client)\n&gt;&gt;&gt; sorted(revision_history[0])\n['action', 'actor', 'actor_home', 'actorid', 'comments', 'review_state', 'state_title', 'time', 'transition_title', 'type']\n&gt;&gt;&gt; revision_history[0][\"transition_title\"]\nu'Create'\n</pre>\n</div>\n<div id=\"getting-the-assigned-workflows-of-an-object\">\n<h3>Getting the assigned Workflows of an Object</h3>\n<p>This function returns all assigned workflows for a given object:</p>\n<pre>&gt;&gt;&gt; api.get_workflows_for(bika_setup)\n('bika_one_state_workflow',)\n\n&gt;&gt;&gt; api.get_workflows_for(client)\n('bika_client_workflow', 'bika_inactive_workflow')\n</pre>\n<p>This function also supports the portal_type as parameter:</p>\n<pre>&gt;&gt;&gt; api.get_workflows_for(api.get_portal_type(client))\n('bika_client_workflow', 'bika_inactive_workflow')\n</pre>\n</div>\n<div id=\"getting-the-workflow-status-of-an-object\">\n<h3>Getting the Workflow Status of an Object</h3>\n<p>This function returns the state of a given object:</p>\n<pre>&gt;&gt;&gt; api.get_workflow_status_of(client)\n'active'\n</pre>\n<p>It is also capable to get the state of another state variable:</p>\n<pre>&gt;&gt;&gt; api.get_workflow_status_of(client, \"inactive_state\")\n'active'\n</pre>\n<p>Deactivate the client:</p>\n<pre>&gt;&gt;&gt; api.do_transition_for(client, \"deactivate\")\n&lt;Client at /plone/clients/client-1&gt;\n\n&gt;&gt;&gt; api.get_workflow_status_of(client, \"inactive_state\")\n'inactive'\n\n&gt;&gt;&gt; api.get_workflow_status_of(client)\n'active'\n</pre>\n<p>Reactivate the client:</p>\n<pre>&gt;&gt;&gt; api.do_transition_for(client, \"activate\")\n&lt;Client at /plone/clients/client-1&gt;\n\n&gt;&gt;&gt; api.get_workflow_status_of(client, \"inactive_state\")\n'active'\n</pre>\n</div>\n<div id=\"getting-the-available-transitions-for-an-object\">\n<h3>Getting the available transitions for an object</h3>\n<p>This function returns all possible transitions from all workflows in the\nobject\u2019s workflow chain.</p>\n<p>Let\u2019s create a Batch. It should allow us to invoke transitions from two\nworkflows; \u2018close\u2019 from the bika_batch_workflow, and \u2018cancel\u2019 from the\nbika_cancellation_workflow:</p>\n<pre>&gt;&gt;&gt; batch1 = api.create(portal.batches, \"Batch\", title=\"Test Batch\")\n&gt;&gt;&gt; transitions = api.get_transitions_for(batch1)\n&gt;&gt;&gt; len(transitions)\n2\n</pre>\n<p>The transitions are returned as a list of dictionaries. Since we cannot rely on\nthe order of dictionary keys, we will have to satisfy ourselves here with\nchecking that the two expected transitions are present in the return value:</p>\n<pre>&gt;&gt;&gt; 'Close' in [t['title'] for t in transitions]\nTrue\n&gt;&gt;&gt; 'Cancel' in [t['title'] for t in transitions]\nTrue\n</pre>\n</div>\n<div id=\"getting-the-creation-date-of-an-object\">\n<h3>Getting the creation date of an object</h3>\n<p>This function returns the creation date of a given object:</p>\n<pre>&gt;&gt;&gt; created = api.get_creation_date(client)\n&gt;&gt;&gt; created\nDateTime('...')\n</pre>\n</div>\n<div id=\"getting-the-modification-date-of-an-object\">\n<h3>Getting the modification date of an object</h3>\n<p>This function returns the modification date of a given object:</p>\n<pre>&gt;&gt;&gt; modified = api.get_modification_date(client)\n&gt;&gt;&gt; modified\nDateTime('...')\n</pre>\n</div>\n<div id=\"getting-the-review-state-of-an-object\">\n<h3>Getting the review state of an object</h3>\n<p>This function returns the review state of a given object:</p>\n<pre>&gt;&gt;&gt; review_state = api.get_review_status(client)\n&gt;&gt;&gt; review_state\n'active'\n</pre>\n<p>It should also work for catalog brains:</p>\n<pre>&gt;&gt;&gt; portal_catalog = api.get_tool(\"portal_catalog\")\n&gt;&gt;&gt; results = portal_catalog({\"portal_type\": \"Client\", \"UID\": api.get_uid(client)})\n&gt;&gt;&gt; len(results)\n1\n&gt;&gt;&gt; api.get_review_status(results[0]) == review_state\nTrue\n</pre>\n</div>\n<div id=\"getting-the-registered-catalogs-of-an-object\">\n<h3>Getting the registered Catalogs of an Object</h3>\n<p>This function returns a list of all registered catalogs within the\n<cite>archetype_tool</cite> for a given portal_type or object:</p>\n<pre>&gt;&gt;&gt; api.get_catalogs_for(client)\n[&lt;CatalogTool at /plone/portal_catalog&gt;]\n</pre>\n<p>It also supports the <cite>portal_type</cite> as a parameter:</p>\n<pre>&gt;&gt;&gt; api.get_catalogs_for(\"Analysis\")\n[&lt;BikaAnalysisCatalog at /plone/bika_analysis_catalog&gt;]\n</pre>\n</div>\n<div id=\"transitioning-an-object\">\n<h3>Transitioning an Object</h3>\n<p>This function performs a workflow transition and returns the object:</p>\n<pre>&gt;&gt;&gt; client = api.do_transition_for(client, \"deactivate\")\n&gt;&gt;&gt; api.is_active(client)\nFalse\n\n&gt;&gt;&gt; client = api.do_transition_for(client, \"activate\")\n&gt;&gt;&gt; api.is_active(client)\nTrue\n</pre>\n</div>\n<div id=\"getting-inactive-cancellation-state-of-different-workflows\">\n<h3>Getting inactive/cancellation state of different workflows</h3>\n<p>There are two workflows allowing an object to be set inactive.  We provide\nthe is_active function to return False if an item is set inactive with either\nof these workflows.</p>\n<p>In the search() test above, the is_active function\u2019s handling of brain states\nis tested.  Here, I just want to test if object states are handled correctly.</p>\n<p>For setup types, we use bika_inctive_workflow:</p>\n<pre>&gt;&gt;&gt; method1 = api.create(portal.methods, \"Method\", title=\"Test Method\")\n&gt;&gt;&gt; api.is_active(method1)\nTrue\n&gt;&gt;&gt; method1 = api.do_transition_for(method1, 'deactivate')\n&gt;&gt;&gt; api.is_active(method1)\nFalse\n</pre>\n<p>For transactional types, bika_cancellation_workflow is used:</p>\n<pre>&gt;&gt;&gt; batch1 = api.create(portal.batches, \"Batch\", title=\"Test Batch\")\n&gt;&gt;&gt; api.is_active(batch1)\nTrue\n&gt;&gt;&gt; batch1 = api.do_transition_for(batch1, 'cancel')\n&gt;&gt;&gt; api.is_active(batch1)\nFalse\n</pre>\n</div>\n<div id=\"getting-the-granted-roles-for-a-certain-permission-on-an-object\">\n<h3>Getting the granted Roles for a certain Permission on an Object</h3>\n<p>This function returns a list of Roles, which are granted the given Permission\nfor the passed in object:</p>\n<pre>&gt;&gt;&gt; api.get_roles_for_permission(\"Modify portal content\", bika_setup)\n['LabManager', 'Manager']\n</pre>\n</div>\n<div id=\"checking-if-an-object-is-versionable\">\n<h3>Checking if an Object is Versionable</h3>\n<p>Some contents in Bika LIMS support versioning. This function checks this for you.</p>\n<p>Instruments are not versionable:</p>\n<pre>&gt;&gt;&gt; api.is_versionable(instrument1)\nFalse\n</pre>\n<p>Analysisservices are versionable:</p>\n<pre>&gt;&gt;&gt; analysisservices = bika_setup.bika_analysisservices\n&gt;&gt;&gt; analysisservice1 = api.create(analysisservices, \"AnalysisService\", title=\"AnalysisService-1\")\n&gt;&gt;&gt; analysisservice2 = api.create(analysisservices, \"AnalysisService\", title=\"AnalysisService-2\")\n&gt;&gt;&gt; analysisservice3 = api.create(analysisservices, \"AnalysisService\", title=\"AnalysisService-3\")\n\n&gt;&gt;&gt; api.is_versionable(analysisservice1)\nTrue\n</pre>\n</div>\n<div id=\"getting-the-version-of-an-object\">\n<h3>Getting the Version of an Object</h3>\n<p>This function returns the version as an integer:</p>\n<pre>&gt;&gt;&gt; api.get_version(analysisservice1)\n0\n</pre>\n<p>Calling <cite>processForm</cite> bumps the version:</p>\n<pre>&gt;&gt;&gt; analysisservice1.processForm()\n&gt;&gt;&gt; api.get_version(analysisservice1)\n1\n</pre>\n</div>\n<div id=\"getting-a-browser-view\">\n<h3>Getting a Browser View</h3>\n<p>Getting a browser view is a common task in Bika LIMS:</p>\n<pre>&gt;&gt;&gt; api.get_view(\"plone\")\n&lt;Products.Five.metaclass.Plone object at 0x...&gt;\n\n&gt;&gt;&gt; api.get_view(\"workflow_action\")\n&lt;Products.Five.metaclass.WorkflowAction object at 0x...&gt;\n</pre>\n</div>\n<div id=\"getting-the-request\">\n<h3>Getting the Request</h3>\n<p>This function will return the global request object:</p>\n<pre>&gt;&gt;&gt; api.get_request()\n&lt;HTTPRequest, URL=http://nohost&gt;\n</pre>\n</div>\n<div id=\"getting-a-group\">\n<h3>Getting a Group</h3>\n<p>Users in Bika LIMS are managed in groups. A common group is the <cite>Clients</cite> group,\nwhere all users of client contacts are grouped.\nThis function gives easy access and is also idempotent:</p>\n<pre>&gt;&gt;&gt; clients_group = api.get_group(\"Clients\")\n&gt;&gt;&gt; clients_group\n&lt;GroupData at /plone/portal_groupdata/Clients used for /plone/acl_users/source_groups&gt;\n\n&gt;&gt;&gt; api.get_group(clients_group)\n&lt;GroupData at /plone/portal_groupdata/Clients used for /plone/acl_users/source_groups&gt;\n</pre>\n<p>Non-existing groups are not found:</p>\n<pre>&gt;&gt;&gt; api.get_group(\"NonExistingGroup\")\n</pre>\n</div>\n<div id=\"getting-a-user\">\n<h3>Getting a User</h3>\n<p>Users can be fetched by their user id. The function is idempotent and handles\nuser objects as well:</p>\n<pre>&gt;&gt;&gt; from plone.app.testing import TEST_USER_ID\n&gt;&gt;&gt; user = api.get_user(TEST_USER_ID)\n&gt;&gt;&gt; user\n&lt;MemberData at /plone/portal_memberdata/test_user_1_ used for /plone/acl_users&gt;\n\n&gt;&gt;&gt; api.get_user(api.get_user(TEST_USER_ID))\n&lt;MemberData at /plone/portal_memberdata/test_user_1_ used for /plone/acl_users&gt;\n</pre>\n<p>Non-existing users are not found:</p>\n<pre>&gt;&gt;&gt; api.get_user(\"NonExistingUser\")\n</pre>\n</div>\n<div id=\"getting-user-properties\">\n<h3>Getting User Properties</h3>\n<p>User properties, like the email or full name, are stored as user properties.\nThis means that they are not on the user object. This function retrieves these\nproperties for you:</p>\n<pre>&gt;&gt;&gt; properties = api.get_user_properties(TEST_USER_ID)\n&gt;&gt;&gt; sorted(properties.items())\n[('description', ''), ('email', ''), ('error_log_update', 0.0), ('ext_editor', False), ...]\n\n&gt;&gt;&gt; sorted(api.get_user_properties(user).items())\n[('description', ''), ('email', ''), ('error_log_update', 0.0), ('ext_editor', False), ...]\n</pre>\n<p>An empty property dict is returned if no user could be found:</p>\n<pre>&gt;&gt;&gt; api.get_user_properties(\"NonExistingUser\")\n{}\n\n&gt;&gt;&gt; api.get_user_properties(None)\n{}\n</pre>\n</div>\n<div id=\"getting-users-by-their-roles\">\n<h3>Getting Users by their Roles</h3>\n<pre>&gt;&gt;&gt; from operator import methodcaller\n</pre>\n<p>Roles in Bika LIMS are basically a name for one or more permissions. For\nexample, a <cite>LabManager</cite> describes a role which is granted the most permissions.</p>\n<p>To see which users are granted a certain role, you can use this function:</p>\n<pre>&gt;&gt;&gt; labmanagers = api.get_users_by_roles([\"LabManager\"])\n&gt;&gt;&gt; sorted(labmanagers, key=methodcaller('getId'))\n[&lt;PloneUser 'test_labmanager'&gt;, &lt;PloneUser 'test_labmanager1'&gt;, &lt;PloneUser 'test-user'&gt;]\n</pre>\n<p>A single value can also be passed into this function:</p>\n<pre>&gt;&gt;&gt; sorted(api.get_users_by_roles(\"LabManager\"), key=methodcaller('getId'))\n[&lt;PloneUser 'test_labmanager'&gt;, &lt;PloneUser 'test_labmanager1'&gt;, &lt;PloneUser 'test-user'&gt;]\n</pre>\n</div>\n<div id=\"getting-the-current-user\">\n<h3>Getting the Current User</h3>\n<p>Getting the current logged in user:</p>\n<pre>&gt;&gt;&gt; api.get_current_user()\n&lt;MemberData at /plone/portal_memberdata/test_user_1_ used for /plone/acl_users&gt;\n</pre>\n</div>\n<div id=\"getting-the-contact-associated-to-a-plone-user\">\n<h3>Getting the Contact associated to a Plone user</h3>\n<p>Getting a Plone user previously registered with no contact assigned:</p>\n<pre>&gt;&gt;&gt; user = api.get_user('test_labmanager1')\n&gt;&gt;&gt; contact = api.get_user_contact(user)\n&gt;&gt;&gt; contact is None\nTrue\n</pre>\n<p>Assign a new contact to this user:</p>\n<pre>&gt;&gt;&gt; labcontacts = bika_setup.bika_labcontacts\n&gt;&gt;&gt; labcontact = api.create(labcontacts, \"LabContact\", Firstname=\"Lab\", Lastname=\"Manager\")\n&gt;&gt;&gt; labcontact.setUser(user)\nTrue\n</pre>\n<p>And get the contact associated to the user:</p>\n<pre>&gt;&gt;&gt; api.get_user_contact(user)\n&lt;LabContact at /plone/bika_setup/bika_labcontacts/labcontact-1&gt;\n</pre>\n<p>As well as if we specify only <cite>LabContact</cite> type:</p>\n<pre>&gt;&gt;&gt; api.get_user_contact(user, ['LabContact'])\n&lt;LabContact at /plone/bika_setup/bika_labcontacts/labcontact-1&gt;\n</pre>\n<p>But fails if we specify only <cite>Contact</cite> type:</p>\n<pre>&gt;&gt;&gt; nuser = api.get_user_contact(user, ['Contact'])\n&gt;&gt;&gt; nuser is None\nTrue\n</pre>\n</div>\n<div id=\"creating-a-cache-key\">\n<h3>Creating a Cache Key</h3>\n<p>This function creates a good cache key for a generic object or brain:</p>\n<pre>&gt;&gt;&gt; key1 = api.get_cache_key(client)\n&gt;&gt;&gt; key1\n'Client-client-1-...'\n</pre>\n<p>This can be also done for a catalog result brain:</p>\n<pre>&gt;&gt;&gt; portal_catalog = api.get_tool(\"portal_catalog\")\n&gt;&gt;&gt; brains = portal_catalog({\"portal_type\": \"Client\", \"UID\": api.get_uid(client)})\n&gt;&gt;&gt; key2 = api.get_cache_key(brains[0])\n&gt;&gt;&gt; key2\n'Client-client-1-...'\n</pre>\n<p>The two keys should be equal:</p>\n<pre>&gt;&gt;&gt; key1 == key2\nTrue\n</pre>\n<p>The key should change when the object get modified:</p>\n<pre>&gt;&gt;&gt; from zope.lifecycleevent import modified\n&gt;&gt;&gt; client.setClientID(\"TESTCLIENT\")\n&gt;&gt;&gt; modified(client)\n&gt;&gt;&gt; portal.aq_parent._p_jar.sync()\n&gt;&gt;&gt; key3 = api.get_cache_key(client)\n&gt;&gt;&gt; key3 != key1\nTrue\n</pre>\n<div>\n<p>Important</p>\n<p>Workflow changes do not change the modification date!\nA custom event subscriber will update it therefore.</p>\n</div>\n<p>A workflow transition should also change the cache key:</p>\n<pre>&gt;&gt;&gt; _ = api.do_transition_for(client, transition=\"deactivate\")\n&gt;&gt;&gt; api.get_inactive_status(client)\n'inactive'\n&gt;&gt;&gt; key4 = api.get_cache_key(client)\n&gt;&gt;&gt; key4 != key3\nTrue\n</pre>\n</div>\n<div id=\"cache-key-decorator\">\n<h3>Cache Key decorator</h3>\n<p>This decorator can be used for <cite>plone.memoize</cite> cache decorators in classes.\nThe decorator expects that the first argument is the class instance (<cite>self</cite>) and\nthe second argument a brain or object:</p>\n<pre>&gt;&gt;&gt; from plone.memoize.volatile import cache\n\n&gt;&gt;&gt; class BikaClass(object):\n...     @cache(api.bika_cache_key_decorator)\n...     def get_very_expensive_calculation(self, obj):\n...         print \"very expensive calculation\"\n...         return \"calculation result\"\n</pre>\n<p>Calling the (expensive) method of the class does the calculation just once:</p>\n<pre>&gt;&gt;&gt; instance = BikaClass()\n&gt;&gt;&gt; instance.get_very_expensive_calculation(client)\nvery expensive calculation\n'calculation result'\n&gt;&gt;&gt; instance.get_very_expensive_calculation(client)\n'calculation result'\n</pre>\n<p>The decorator can also handle brains:</p>\n<pre>&gt;&gt;&gt; instance = BikaClass()\n&gt;&gt;&gt; portal_catalog = api.get_tool(\"portal_catalog\")\n&gt;&gt;&gt; brain = portal_catalog(portal_type=\"Client\")[0]\n&gt;&gt;&gt; instance.get_very_expensive_calculation(brain)\nvery expensive calculation\n'calculation result'\n&gt;&gt;&gt; instance.get_very_expensive_calculation(brain)\n'calculation result'\n</pre>\n</div>\n<div id=\"id-normalizer\">\n<h3>ID Normalizer</h3>\n<p>Normalizes a string to be usable as a system ID:</p>\n<pre>&gt;&gt;&gt; api.normalize_id(\"My new ID\")\n'my-new-id'\n\n&gt;&gt;&gt; api.normalize_id(\"Really/Weird:Name;\")\n'really-weird-name'\n\n&gt;&gt;&gt; api.normalize_id(None)\nTraceback (most recent call last):\n[...]\nSenaiteAPIError: Type of argument must be string, found '&lt;type 'NoneType'&gt;'\n</pre>\n</div>\n<div id=\"file-normalizer\">\n<h3>File Normalizer</h3>\n<p>Normalizes a string to be usable as a file name:</p>\n<pre>&gt;&gt;&gt; api.normalize_filename(\"My new ID\")\n'My new ID'\n\n&gt;&gt;&gt; api.normalize_filename(\"Really/Weird:Name;\")\n'Really-Weird-Name'\n\n&gt;&gt;&gt; api.normalize_filename(None)\nTraceback (most recent call last):\n[...]\nSenaiteAPIError: Type of argument must be string, found '&lt;type 'NoneType'&gt;'\n</pre>\n</div>\n<div id=\"check-if-an-uid-is-valid\">\n<h3>Check if an UID is valid</h3>\n<p>Checks if an UID is a valid 23 alphanumeric uid:</p>\n<pre>&gt;&gt;&gt; api.is_uid(\"ajw2uw9\")\nFalse\n\n&gt;&gt;&gt; api.is_uid(None)\nFalse\n\n&gt;&gt;&gt; api.is_uid(\"\")\nFalse\n\n&gt;&gt;&gt; api.is_uid(\"0\")\nFalse\n\n&gt;&gt;&gt; api.is_uid('0e1dfc3d10d747bf999948a071bc161e')\nTrue\n</pre>\n<p>Checks if an UID is a valid 23 alphanumeric uid and with a brain:</p>\n<pre>&gt;&gt;&gt; api.is_uid(\"ajw2uw9\", validate=True)\nFalse\n\n&gt;&gt;&gt; api.is_uid(None, validate=True)\nFalse\n\n&gt;&gt;&gt; api.is_uid(\"\", validate=True)\nFalse\n\n&gt;&gt;&gt; api.is_uid(\"0\", validate=True)\nFalse\n\n&gt;&gt;&gt; api.is_uid('0e1dfc3d10d747bf999948a071bc161e', validate=True)\nFalse\n\n&gt;&gt;&gt; asfolder = self.portal.bika_setup.bika_analysisservices\n&gt;&gt;&gt; serv = api.create(asfolder, \"AnalysisService\", title=\"AS test\")\n&gt;&gt;&gt; serv.setKeyword(\"as_test\")\n&gt;&gt;&gt; uid = serv.UID()\n&gt;&gt;&gt; api.is_uid(uid, validate=True)\nTrue\n</pre>\n</div>\n<div id=\"check-if-a-date-is-valid\">\n<h3>Check if a Date is valid</h3>\n<p>Do some imports first:</p>\n<pre>&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; from DateTime import DateTime\n</pre>\n<p>Checks if a DateTime is valid:</p>\n<pre>&gt;&gt;&gt; now = DateTime()\n&gt;&gt;&gt; api.is_date(now)\nTrue\n\n&gt;&gt;&gt; now = datetime.now()\n&gt;&gt;&gt; api.is_date(now)\nTrue\n\n&gt;&gt;&gt; now = DateTime(now)\n&gt;&gt;&gt; api.is_date(now)\nTrue\n\n&gt;&gt;&gt; api.is_date(None)\nFalse\n\n&gt;&gt;&gt; api.is_date('2018-04-23')\nFalse\n</pre>\n</div>\n<div id=\"try-conversions-to-date\">\n<h3>Try conversions to Date</h3>\n<p>Try to convert to DateTime:</p>\n<pre>&gt;&gt;&gt; now = DateTime()\n&gt;&gt;&gt; zpdt = api.to_date(now)\n&gt;&gt;&gt; zpdt.ISO8601() == now.ISO8601()\nTrue\n\n&gt;&gt;&gt; now = datetime.now()\n&gt;&gt;&gt; zpdt = api.to_date(now)\n&gt;&gt;&gt; pydt = zpdt.asdatetime()\n</pre>\n<p>Note that here, for the comparison between dates, we convert DateTime to python\ndatetime, cause DateTime.strftime() is broken for timezones (always looks at\nsystem time zone, ignores the timezone and offset of the DateTime instance\nitself):</p>\n<pre>&gt;&gt;&gt; pydt.strftime('%Y-%m-%dT%H:%M:%S') == now.strftime('%Y-%m-%dT%H:%M:%S')\nTrue\n</pre>\n<p>Try the same, but with utcnow() instead:</p>\n<pre>&gt;&gt;&gt; now = datetime.utcnow()\n&gt;&gt;&gt; zpdt = api.to_date(now)\n&gt;&gt;&gt; pydt = zpdt.asdatetime()\n&gt;&gt;&gt; pydt.strftime('%Y-%m-%dT%H:%M:%S') == now.strftime('%Y-%m-%dT%H:%M:%S')\nTrue\n</pre>\n<p>Now we convert just a string formatted date:</p>\n<pre>&gt;&gt;&gt; strd = \"2018-12-01 17:50:34\"\n&gt;&gt;&gt; zpdt = api.to_date(strd)\n&gt;&gt;&gt; zpdt.ISO8601()\n'2018-12-01T17:50:34'\n</pre>\n<p>Now we convert just a string formatted date, but with timezone:</p>\n<pre>&gt;&gt;&gt; strd = \"2018-12-01 17:50:34 GMT+1\"\n&gt;&gt;&gt; zpdt = api.to_date(strd)\n&gt;&gt;&gt; zpdt.ISO8601()\n'2018-12-01T17:50:34+01:00'\n</pre>\n<p>We also check a bad date here (note the month is 13):</p>\n<pre>&gt;&gt;&gt; strd = \"2018-13-01 17:50:34\"\n&gt;&gt;&gt; zpdt = api.to_date(strd)\n&gt;&gt;&gt; api.is_date(zpdt)\nFalse\n</pre>\n<p>And with European format:</p>\n<pre>&gt;&gt;&gt; strd = \"01.12.2018 17:50:34\"\n&gt;&gt;&gt; zpdt = api.to_date(strd)\n&gt;&gt;&gt; zpdt.ISO8601()\n'2018-12-01T17:50:34'\n\n&gt;&gt;&gt; zpdt = api.to_date(None)\n&gt;&gt;&gt; zpdt is None\nTrue\n</pre>\n<p>Use a string formatted date as fallback:</p>\n<pre>&gt;&gt;&gt; strd = \"2018-13-01 17:50:34\"\n&gt;&gt;&gt; default_date = \"2018-01-01 19:30:30\"\n&gt;&gt;&gt; zpdt = api.to_date(strd, default_date)\n&gt;&gt;&gt; zpdt.ISO8601()\n'2018-01-01T19:30:30'\n</pre>\n<p>Use a DateTime object as fallback:</p>\n<pre>&gt;&gt;&gt; strd = \"2018-13-01 17:50:34\"\n&gt;&gt;&gt; default_date = \"2018-01-01 19:30:30\"\n&gt;&gt;&gt; default_date = api.to_date(default_date)\n&gt;&gt;&gt; zpdt = api.to_date(strd, default_date)\n&gt;&gt;&gt; zpdt.ISO8601() == default_date.ISO8601()\nTrue\n</pre>\n<p>Use a datetime object as fallback:</p>\n<pre>&gt;&gt;&gt; strd = \"2018-13-01 17:50:34\"\n&gt;&gt;&gt; default_date = datetime.now()\n&gt;&gt;&gt; zpdt = api.to_date(strd, default_date)\n&gt;&gt;&gt; dzpdt = api.to_date(default_date)\n&gt;&gt;&gt; zpdt.ISO8601() == dzpdt.ISO8601()\nTrue\n</pre>\n<p>Use a non-conversionable value as fallback:</p>\n<pre>&gt;&gt;&gt; strd = \"2018-13-01 17:50:34\"\n&gt;&gt;&gt; default_date = \"something wrong here\"\n&gt;&gt;&gt; zpdt = api.to_date(strd, default_date)\n&gt;&gt;&gt; zpdt is None\nTrue\n</pre>\n</div>\n<div id=\"check-if-floatable\">\n<h3>Check if floatable</h3>\n<pre>&gt;&gt;&gt; api.is_floatable(None)\nFalse\n\n&gt;&gt;&gt; api.is_floatable(\"\")\nFalse\n\n&gt;&gt;&gt; api.is_floatable(\"31\")\nTrue\n\n&gt;&gt;&gt; api.is_floatable(\"31.23\")\nTrue\n\n&gt;&gt;&gt; api.is_floatable(\"-13\")\nTrue\n\n&gt;&gt;&gt; api.is_floatable(\"12,35\")\nFalse\n</pre>\n</div>\n<div id=\"convert-to-a-float-number\">\n<h3>Convert to a float number</h3>\n<pre>&gt;&gt;&gt; api.to_float(\"2\")\n2.0\n\n&gt;&gt;&gt; api.to_float(\"2.234\")\n2.234\n</pre>\n<p>With default fallback:</p>\n<pre>&gt;&gt;&gt; api.to_float(None, 2)\n2.0\n\n&gt;&gt;&gt; api.to_float(None, \"2\")\n2.0\n\n&gt;&gt;&gt; api.to_float(\"\", 2)\n2.0\n\n&gt;&gt;&gt; api.to_float(\"\", \"2\")\n2.0\n\n&gt;&gt;&gt; api.to_float(2.1, 2)\n2.1\n\n&gt;&gt;&gt; api.to_float(\"2.1\", 2)\n2.1\n\n&gt;&gt;&gt; api.to_float(\"2.1\", \"2\")\n2.1\n</pre>\n</div>\n</div>\n<div id=\"api-analysis\">\n<h2>API Analysis</h2>\n<p>The api_analysis provides single functions for single purposes especifically\nrelated with analyses.</p>\n<p>Running this test from the buildout directory:</p>\n<pre>bin/test test_textual_doctests -t API_analysis\n</pre>\n<div id=\"test-setup\">\n<h3>Test Setup</h3>\n<p>Needed Imports:</p>\n<pre>&gt;&gt;&gt; import re\n&gt;&gt;&gt; from AccessControl.PermissionRole import rolesForPermissionOn\n&gt;&gt;&gt; from bika.lims import api\n&gt;&gt;&gt; from bika.lims.api.analysis import is_out_of_range\n&gt;&gt;&gt; from bika.lims.content.analysisrequest import AnalysisRequest\n&gt;&gt;&gt; from bika.lims.content.sample import Sample\n&gt;&gt;&gt; from bika.lims.content.samplepartition import SamplePartition\n&gt;&gt;&gt; from bika.lims.utils.analysisrequest import create_analysisrequest\n&gt;&gt;&gt; from bika.lims.utils.sample import create_sample\n&gt;&gt;&gt; from bika.lims.utils import tmpID\n&gt;&gt;&gt; from bika.lims.workflow import doActionFor\n&gt;&gt;&gt; from bika.lims.workflow import getCurrentState\n&gt;&gt;&gt; from bika.lims.workflow import getAllowedTransitions\n&gt;&gt;&gt; from DateTime import DateTime\n&gt;&gt;&gt; from plone.app.testing import TEST_USER_ID\n&gt;&gt;&gt; from plone.app.testing import TEST_USER_PASSWORD\n&gt;&gt;&gt; from plone.app.testing import setRoles\n</pre>\n<p>Functional Helpers:</p>\n<pre>&gt;&gt;&gt; def start_server():\n...     from Testing.ZopeTestCase.utils import startZServer\n...     ip, port = startZServer()\n...     return \"http://{}:{}/{}\".format(ip, port, portal.id)\n</pre>\n<p>Variables:</p>\n<pre>&gt;&gt;&gt; portal = self.portal\n&gt;&gt;&gt; request = self.request\n&gt;&gt;&gt; bikasetup = portal.bika_setup\n</pre>\n<p>We need to create some basic objects for the test:</p>\n<pre>&gt;&gt;&gt; setRoles(portal, TEST_USER_ID, ['LabManager',])\n&gt;&gt;&gt; date_now = DateTime().strftime(\"%Y-%m-%d\")\n&gt;&gt;&gt; date_future = (DateTime() + 5).strftime(\"%Y-%m-%d\")\n&gt;&gt;&gt; client = api.create(portal.clients, \"Client\", Name=\"Happy Hills\", ClientID=\"HH\", MemberDiscountApplies=True)\n&gt;&gt;&gt; contact = api.create(client, \"Contact\", Firstname=\"Rita\", Lastname=\"Mohale\")\n&gt;&gt;&gt; sampletype = api.create(bikasetup.bika_sampletypes, \"SampleType\", title=\"Water\", Prefix=\"W\")\n&gt;&gt;&gt; labcontact = api.create(bikasetup.bika_labcontacts, \"LabContact\", Firstname=\"Lab\", Lastname=\"Manager\")\n&gt;&gt;&gt; department = api.create(bikasetup.bika_departments, \"Department\", title=\"Chemistry\", Manager=labcontact)\n&gt;&gt;&gt; category = api.create(bikasetup.bika_analysiscategories, \"AnalysisCategory\", title=\"Metals\", Department=department)\n&gt;&gt;&gt; supplier = api.create(bikasetup.bika_suppliers, \"Supplier\", Name=\"Naralabs\")\n&gt;&gt;&gt; Cu = api.create(bikasetup.bika_analysisservices, \"AnalysisService\", title=\"Copper\", Keyword=\"Cu\", Price=\"15\", Category=category.UID(), DuplicateVariation=\"0.5\")\n&gt;&gt;&gt; Fe = api.create(bikasetup.bika_analysisservices, \"AnalysisService\", title=\"Iron\", Keyword=\"Fe\", Price=\"10\", Category=category.UID(), DuplicateVariation=\"0.5\")\n&gt;&gt;&gt; Au = api.create(bikasetup.bika_analysisservices, \"AnalysisService\", title=\"Gold\", Keyword=\"Au\", Price=\"20\", Category=category.UID(), DuplicateVariation=\"0.5\")\n&gt;&gt;&gt; Mg = api.create(bikasetup.bika_analysisservices, \"AnalysisService\", title=\"Magnesium\", Keyword=\"Mg\", Price=\"20\", Category=category.UID(), DuplicateVariation=\"0.5\")\n&gt;&gt;&gt; service_uids = [api.get_uid(an) for an in [Cu, Fe, Au, Mg]]\n</pre>\n<p>Create an Analysis Specification for <cite>Water</cite>:</p>\n<pre>&gt;&gt;&gt; sampletype_uid = api.get_uid(sampletype)\n&gt;&gt;&gt; rr1 = {\"keyword\": \"Au\", \"min\": \"-5\", \"max\":  \"5\", \"warn_min\": \"-5.5\", \"warn_max\": \"5.5\"}\n&gt;&gt;&gt; rr2 = {\"keyword\": \"Cu\", \"min\": \"10\", \"max\": \"20\", \"warn_min\":  \"9.5\", \"warn_max\": \"20.5\"}\n&gt;&gt;&gt; rr3 = {\"keyword\": \"Fe\", \"min\":  \"0\", \"max\": \"10\", \"warn_min\": \"-0.5\", \"warn_max\": \"10.5\"}\n&gt;&gt;&gt; rr4 = {\"keyword\": \"Mg\", \"min\": \"10\", \"max\": \"10\"}\n&gt;&gt;&gt; rr = [rr1, rr2, rr3, rr4]\n&gt;&gt;&gt; specification = api.create(bikasetup.bika_analysisspecs, \"AnalysisSpec\", title=\"Lab Water Spec\", SampleType=sampletype_uid, ResultsRange=rr)\n&gt;&gt;&gt; spec_uid = api.get_uid(specification)\n</pre>\n<p>Create a Reference Definition for blank:</p>\n<pre>&gt;&gt;&gt; blankdef = api.create(bikasetup.bika_referencedefinitions, \"ReferenceDefinition\", title=\"Blank definition\", Blank=True)\n&gt;&gt;&gt; blank_refs = [{'uid': Au.UID(), 'result': '0', 'min': '0', 'max': '0'},]\n&gt;&gt;&gt; blankdef.setReferenceResults(blank_refs)\n</pre>\n<p>And for control:</p>\n<pre>&gt;&gt;&gt; controldef = api.create(bikasetup.bika_referencedefinitions, \"ReferenceDefinition\", title=\"Control definition\")\n&gt;&gt;&gt; control_refs = [{'uid': Au.UID(), 'result': '10', 'min': '9.99', 'max': '10.01'},\n...                 {'uid': Cu.UID(), 'result': '-0.9','min': '-1.08', 'max': '-0.72'},]\n&gt;&gt;&gt; controldef.setReferenceResults(control_refs)\n\n&gt;&gt;&gt; blank = api.create(supplier, \"ReferenceSample\", title=\"Blank\",\n...                    ReferenceDefinition=blankdef,\n...                    Blank=True, ExpiryDate=date_future,\n...                    ReferenceResults=blank_refs)\n&gt;&gt;&gt; control = api.create(supplier, \"ReferenceSample\", title=\"Control\",\n...                      ReferenceDefinition=controldef,\n...                      Blank=False, ExpiryDate=date_future,\n...                      ReferenceResults=control_refs)\n</pre>\n<p>Create an Analysis Request:</p>\n<pre>&gt;&gt;&gt; values = {\n...     'Client': api.get_uid(client),\n...     'Contact': api.get_uid(contact),\n...     'DateSampled': date_now,\n...     'SampleType': sampletype_uid,\n...     'Specification': spec_uid,\n...     'Priority': '1',\n... }\n\n&gt;&gt;&gt; ar = create_analysisrequest(client, request, values, service_uids)\n&gt;&gt;&gt; success = doActionFor(ar, 'receive')\n</pre>\n<p>Create a new Worksheet and add the analyses:</p>\n<pre>&gt;&gt;&gt; worksheet = api.create(portal.worksheets, \"Worksheet\")\n&gt;&gt;&gt; analyses = map(api.get_object, ar.getAnalyses())\n&gt;&gt;&gt; for analysis in analyses:\n...     worksheet.addAnalysis(analysis)\n</pre>\n<p>Add a duplicate for <cite>Cu</cite>:</p>\n<pre>&gt;&gt;&gt; position = worksheet.get_slot_position(ar, 'a')\n&gt;&gt;&gt; duplicates = worksheet.addDuplicateAnalyses(position)\n&gt;&gt;&gt; duplicates.sort(key=lambda analysis: analysis.getKeyword(), reverse=False)\n</pre>\n<p>Add a blank and a control:</p>\n<pre>&gt;&gt;&gt; blanks = worksheet.addReferenceAnalyses(blank, service_uids)\n&gt;&gt;&gt; blanks.sort(key=lambda analysis: analysis.getKeyword(), reverse=False)\n&gt;&gt;&gt; controls = worksheet.addReferenceAnalyses(control, service_uids)\n&gt;&gt;&gt; controls.sort(key=lambda analysis: analysis.getKeyword(), reverse=False)\n</pre>\n</div>\n<div id=\"check-if-results-are-out-of-range\">\n<h3>Check if results are out of range</h3>\n<p>First, get the analyses from slot 1 and sort them asc:</p>\n<pre>&gt;&gt;&gt; analyses = worksheet.get_analyses_at(1)\n&gt;&gt;&gt; analyses.sort(key=lambda analysis: analysis.getKeyword(), reverse=False)\n</pre>\n<p>Set results for analysis <cite>Au</cite> (min: -5, max: 5, warn_min: -5.5, warn_max: 5.5):</p>\n<pre>&gt;&gt;&gt; au_analysis = analyses[0]\n&gt;&gt;&gt; au_analysis.setResult(2)\n&gt;&gt;&gt; is_out_of_range(au_analysis)\n(False, False)\n\n&gt;&gt;&gt; au_analysis.setResult(-2)\n&gt;&gt;&gt; is_out_of_range(au_analysis)\n(False, False)\n\n&gt;&gt;&gt; au_analysis.setResult(-5)\n&gt;&gt;&gt; is_out_of_range(au_analysis)\n(False, False)\n\n&gt;&gt;&gt; au_analysis.setResult(5)\n&gt;&gt;&gt; is_out_of_range(au_analysis)\n(False, False)\n\n&gt;&gt;&gt; au_analysis.setResult(10)\n&gt;&gt;&gt; is_out_of_range(au_analysis)\n(True, True)\n\n&gt;&gt;&gt; au_analysis.setResult(-10)\n&gt;&gt;&gt; is_out_of_range(au_analysis)\n(True, True)\n</pre>\n<p>Results in shoulders?:</p>\n<pre>&gt;&gt;&gt; au_analysis.setResult(-5.2)\n&gt;&gt;&gt; is_out_of_range(au_analysis)\n(True, False)\n\n&gt;&gt;&gt; au_analysis.setResult(-5.5)\n&gt;&gt;&gt; is_out_of_range(au_analysis)\n(True, False)\n\n&gt;&gt;&gt; au_analysis.setResult(-5.6)\n&gt;&gt;&gt; is_out_of_range(au_analysis)\n(True, True)\n\n&gt;&gt;&gt; au_analysis.setResult(5.2)\n&gt;&gt;&gt; is_out_of_range(au_analysis)\n(True, False)\n\n&gt;&gt;&gt; au_analysis.setResult(5.5)\n&gt;&gt;&gt; is_out_of_range(au_analysis)\n(True, False)\n\n&gt;&gt;&gt; au_analysis.setResult(5.6)\n&gt;&gt;&gt; is_out_of_range(au_analysis)\n(True, True)\n</pre>\n</div>\n<div id=\"check-if-results-for-duplicates-are-out-of-range\">\n<h3>Check if results for duplicates are out of range</h3>\n<p>Get the first duplicate analysis that comes from <cite>Au</cite>:</p>\n<pre>&gt;&gt;&gt; duplicate = duplicates[0]\n</pre>\n<p>A Duplicate will be considered out of range if its result does not match with\nthe result set to the analysis that was duplicated from, with the Duplicate\nVariation in % as the margin error. The Duplicate Variation assigned in the\nAnalysis Service <cite>Au</cite> is 0.5%:</p>\n<pre>&gt;&gt;&gt; dup_variation = au_analysis.getDuplicateVariation()\n&gt;&gt;&gt; dup_variation = api.to_float(dup_variation)\n&gt;&gt;&gt; dup_variation\n0.5\n</pre>\n<p>Set an in-range result (between -5 and 5) for routine analysis and check all\nvariants on it\u2019s duplicate. Given that the duplicate variation is 0.5, the\nvalid range for the duplicate must be <cite>Au +-0.5%</cite>:</p>\n<pre>&gt;&gt;&gt; result = 2.0\n&gt;&gt;&gt; au_analysis.setResult(result)\n&gt;&gt;&gt; is_out_of_range(au_analysis)\n(False, False)\n\n&gt;&gt;&gt; duplicate.setResult(result)\n&gt;&gt;&gt; is_out_of_range(duplicate)\n(False, False)\n\n&gt;&gt;&gt; dup_min_range = result - (result*(dup_variation/100))\n&gt;&gt;&gt; duplicate.setResult(dup_min_range)\n&gt;&gt;&gt; is_out_of_range(duplicate)\n(False, False)\n\n&gt;&gt;&gt; duplicate.setResult(dup_min_range - 0.5)\n&gt;&gt;&gt; is_out_of_range(duplicate)\n(True, True)\n\n&gt;&gt;&gt; dup_max_range = result + (result*(dup_variation/100))\n&gt;&gt;&gt; duplicate.setResult(dup_max_range)\n&gt;&gt;&gt; is_out_of_range(duplicate)\n(False, False)\n\n&gt;&gt;&gt; duplicate.setResult(dup_max_range + 0.5)\n&gt;&gt;&gt; is_out_of_range(duplicate)\n(True, True)\n</pre>\n<p>Set an out-of-range result, but within shoulders, for routine analysis and check\nall variants on it\u2019s duplicate. Given that the duplicate variation is 0.5, the\nvalid range for the duplicate must be <cite>Au +-0.5%</cite>:</p>\n<pre>&gt;&gt;&gt; result = 5.5\n&gt;&gt;&gt; au_analysis.setResult(result)\n&gt;&gt;&gt; is_out_of_range(au_analysis)\n(True, False)\n\n&gt;&gt;&gt; duplicate.setResult(result)\n&gt;&gt;&gt; is_out_of_range(duplicate)\n(False, False)\n\n&gt;&gt;&gt; dup_min_range = result - (result*(dup_variation/100))\n&gt;&gt;&gt; duplicate.setResult(dup_min_range)\n&gt;&gt;&gt; is_out_of_range(duplicate)\n(False, False)\n\n&gt;&gt;&gt; duplicate.setResult(dup_min_range - 0.5)\n&gt;&gt;&gt; is_out_of_range(duplicate)\n(True, True)\n\n&gt;&gt;&gt; dup_max_range = result + (result*(dup_variation/100))\n&gt;&gt;&gt; duplicate.setResult(dup_max_range)\n&gt;&gt;&gt; is_out_of_range(duplicate)\n(False, False)\n\n&gt;&gt;&gt; duplicate.setResult(dup_max_range + 0.5)\n&gt;&gt;&gt; is_out_of_range(duplicate)\n(True, True)\n</pre>\n<p>Set an out-of-range and out-of-shoulders result, for routine analysis and check\nall variants on it\u2019s duplicate. Given that the duplicate variation is 0.5, the\nvalid range for the duplicate must be <cite>Au +-0.5%</cite>:</p>\n<pre>&gt;&gt;&gt; result = -7.0\n&gt;&gt;&gt; au_analysis.setResult(result)\n&gt;&gt;&gt; is_out_of_range(au_analysis)\n(True, True)\n\n&gt;&gt;&gt; duplicate.setResult(result)\n&gt;&gt;&gt; is_out_of_range(duplicate)\n(False, False)\n\n&gt;&gt;&gt; dup_min_range = result - (abs(result)*(dup_variation/100))\n&gt;&gt;&gt; duplicate.setResult(dup_min_range)\n&gt;&gt;&gt; is_out_of_range(duplicate)\n(False, False)\n\n&gt;&gt;&gt; duplicate.setResult(dup_min_range - 0.5)\n&gt;&gt;&gt; is_out_of_range(duplicate)\n(True, True)\n\n&gt;&gt;&gt; dup_max_range = result + (abs(result)*(dup_variation/100))\n&gt;&gt;&gt; duplicate.setResult(dup_max_range)\n&gt;&gt;&gt; is_out_of_range(duplicate)\n(False, False)\n\n&gt;&gt;&gt; duplicate.setResult(dup_max_range + 0.5)\n&gt;&gt;&gt; is_out_of_range(duplicate)\n(True, True)\n</pre>\n</div>\n<div id=\"check-if-results-for-reference-analyses-blanks-controls-are-out-of-range\">\n<h3>Check if results for Reference Analyses (blanks + controls) are out of range</h3>\n<p>Reference Analyses (controls and blanks) do not use the result ranges defined in\nthe specifications, rather they use the result range defined in the Reference\nSample they have been generated from. In turn, the result ranges defined in\nReference Samples can be set manually or acquired from the Reference Definition\nthey might be associated with. Another difference from routine analyses is that\nreference analyses don\u2019t expect a valid range, rather a discrete value, so\nshoulders are built based on % error.</p>\n<div id=\"blank-analyses\">\n<h4>Blank Analyses</h4>\n<p>The first blank analysis corresponds to <cite>Au</cite>:</p>\n<pre>&gt;&gt;&gt; au_blank = blanks[0]\n</pre>\n<p>For <cite>Au</cite> blank, as per the reference definition used above, the expected result\nis 0 +/- 0.1%. Since the expected result is 0, no shoulders will be considered\nregardless of the % of error. Thus, result will always be \u201cout-of-shoulders\u201d\nwhen out of range:</p>\n<pre>&gt;&gt;&gt; au_blank.setResult(0.0)\n&gt;&gt;&gt; is_out_of_range(au_blank)\n(False, False)\n\n&gt;&gt;&gt; au_blank.setResult(\"0\")\n&gt;&gt;&gt; is_out_of_range(au_blank)\n(False, False)\n\n&gt;&gt;&gt; au_blank.setResult(0.0001)\n&gt;&gt;&gt; is_out_of_range(au_blank)\n(True, True)\n\n&gt;&gt;&gt; au_blank.setResult(\"0.0001\")\n&gt;&gt;&gt; is_out_of_range(au_blank)\n(True, True)\n\n&gt;&gt;&gt; au_blank.setResult(-0.0001)\n&gt;&gt;&gt; is_out_of_range(au_blank)\n(True, True)\n\n&gt;&gt;&gt; au_blank.setResult(\"-0.0001\")\n&gt;&gt;&gt; is_out_of_range(au_blank)\n(True, True)\n</pre>\n</div>\n<div id=\"control-analyses\">\n<h4>Control Analyses</h4>\n<p>The first control analysis corresponds to <cite>Au</cite>:</p>\n<pre>&gt;&gt;&gt; au_control = controls[0]\n</pre>\n<p>For <cite>Au</cite> control, as per the reference definition used above, the expected\nresult is 10 +/- 0.1% = 10 +/- 0.01</p>\n<p>First, check for in-range values:</p>\n<pre>&gt;&gt;&gt; au_control.setResult(10)\n&gt;&gt;&gt; is_out_of_range(au_control)\n(False, False)\n\n&gt;&gt;&gt; au_control.setResult(10.0)\n&gt;&gt;&gt; is_out_of_range(au_control)\n(False, False)\n\n&gt;&gt;&gt; au_control.setResult(\"10\")\n&gt;&gt;&gt; is_out_of_range(au_control)\n(False, False)\n\n&gt;&gt;&gt; au_control.setResult(\"10.0\")\n&gt;&gt;&gt; is_out_of_range(au_control)\n(False, False)\n\n&gt;&gt;&gt; au_control.setResult(9.995)\n&gt;&gt;&gt; is_out_of_range(au_control)\n(False, False)\n\n&gt;&gt;&gt; au_control.setResult(\"9.995\")\n&gt;&gt;&gt; is_out_of_range(au_control)\n(False, False)\n\n&gt;&gt;&gt; au_control.setResult(10.005)\n&gt;&gt;&gt; is_out_of_range(au_control)\n(False, False)\n\n&gt;&gt;&gt; au_control.setResult(\"10.005\")\n&gt;&gt;&gt; is_out_of_range(au_control)\n(False, False)\n\n&gt;&gt;&gt; au_control.setResult(9.99)\n&gt;&gt;&gt; is_out_of_range(au_control)\n(False, False)\n\n&gt;&gt;&gt; au_control.setResult(\"9.99\")\n&gt;&gt;&gt; is_out_of_range(au_control)\n(False, False)\n\n&gt;&gt;&gt; au_control.setResult(10.01)\n&gt;&gt;&gt; is_out_of_range(au_control)\n(False, False)\n\n&gt;&gt;&gt; au_control.setResult(\"10.01\")\n&gt;&gt;&gt; is_out_of_range(au_control)\n(False, False)\n</pre>\n<p>Now, check for out-of-range results:</p>\n<pre>&gt;&gt;&gt; au_control.setResult(9.98)\n&gt;&gt;&gt; is_out_of_range(au_control)\n(True, True)\n\n&gt;&gt;&gt; au_control.setResult(\"9.98\")\n&gt;&gt;&gt; is_out_of_range(au_control)\n(True, True)\n\n&gt;&gt;&gt; au_control.setResult(10.011)\n&gt;&gt;&gt; is_out_of_range(au_control)\n(True, True)\n\n&gt;&gt;&gt; au_control.setResult(\"10.011\")\n&gt;&gt;&gt; is_out_of_range(au_control)\n(True, True)\n</pre>\n<p>And do the same with the control for <cite>Cu</cite> that expects -0.9 +/- 20%:</p>\n<pre>&gt;&gt;&gt; cu_control = controls[1]\n</pre>\n<p>First, check for in-range values:</p>\n<pre>&gt;&gt;&gt; cu_control.setResult(-0.9)\n&gt;&gt;&gt; is_out_of_range(cu_control)\n(False, False)\n\n&gt;&gt;&gt; cu_control.setResult(\"-0.9\")\n&gt;&gt;&gt; is_out_of_range(cu_control)\n(False, False)\n\n&gt;&gt;&gt; cu_control.setResult(-1.08)\n&gt;&gt;&gt; is_out_of_range(cu_control)\n(False, False)\n\n&gt;&gt;&gt; cu_control.setResult(\"-1.08\")\n&gt;&gt;&gt; is_out_of_range(cu_control)\n(False, False)\n\n&gt;&gt;&gt; cu_control.setResult(-1.07)\n&gt;&gt;&gt; is_out_of_range(cu_control)\n(False, False)\n\n&gt;&gt;&gt; cu_control.setResult(\"-1.07\")\n&gt;&gt;&gt; is_out_of_range(cu_control)\n(False, False)\n\n&gt;&gt;&gt; cu_control.setResult(-0.72)\n&gt;&gt;&gt; is_out_of_range(cu_control)\n(False, False)\n\n&gt;&gt;&gt; cu_control.setResult(\"-0.72\")\n&gt;&gt;&gt; is_out_of_range(cu_control)\n(False, False)\n\n&gt;&gt;&gt; cu_control.setResult(-0.73)\n&gt;&gt;&gt; is_out_of_range(cu_control)\n(False, False)\n\n&gt;&gt;&gt; cu_control.setResult(\"-0.73\")\n&gt;&gt;&gt; is_out_of_range(cu_control)\n(False, False)\n</pre>\n<p>Now, check for out-of-range results:</p>\n<pre>&gt;&gt;&gt; cu_control.setResult(0)\n&gt;&gt;&gt; is_out_of_range(cu_control)\n(True, True)\n\n&gt;&gt;&gt; cu_control.setResult(\"0\")\n&gt;&gt;&gt; is_out_of_range(cu_control)\n(True, True)\n\n&gt;&gt;&gt; cu_control.setResult(-0.71)\n&gt;&gt;&gt; is_out_of_range(cu_control)\n(True, True)\n\n&gt;&gt;&gt; cu_control.setResult(\"-0.71\")\n&gt;&gt;&gt; is_out_of_range(cu_control)\n(True, True)\n\n&gt;&gt;&gt; cu_control.setResult(-1.09)\n&gt;&gt;&gt; is_out_of_range(cu_control)\n(True, True)\n\n&gt;&gt;&gt; cu_control.setResult(\"-1.09\")\n&gt;&gt;&gt; is_out_of_range(cu_control)\n(True, True)\n</pre>\n</div>\n</div>\n</div>\n<div id=\"changelog\">\n<h2>Changelog</h2>\n<div id=\"id1\">\n<h3>1.2.3 (2018-06-23)</h3>\n<ul>\n<li>More PyPI fixtures</li>\n</ul>\n</div>\n<div id=\"id2\">\n<h3>1.2.2 (2018-06-23)</h3>\n<ul>\n<li>PyPI Documentation Page fixtures</li>\n</ul>\n</div>\n<div id=\"id3\">\n<h3>1.2.1 (2018-06-23)</h3>\n<ul>\n<li>Better Documentation Page for PyPI</li>\n<li>Fixed formatting of Doctests</li>\n</ul>\n</div>\n<div id=\"id4\">\n<h3>1.2.0 (2018-06-23)</h3>\n<p><strong>Added</strong></p>\n<ul>\n<li>Added <cite>is_uid</cite> function</li>\n</ul>\n<p><strong>Removed</strong></p>\n<p><strong>Changed</strong></p>\n<ul>\n<li>Added SENAITE CORE API functions</li>\n</ul>\n<p><strong>Fixed</strong></p>\n<ul>\n<li>Fixed Tests</li>\n</ul>\n<p><strong>Security</strong></p>\n</div>\n<div id=\"id5\">\n<h3>1.1.0 (2018-01-03)</h3>\n<p><strong>Added</strong></p>\n<p><strong>Removed</strong></p>\n<p><strong>Changed</strong></p>\n<ul>\n<li>License changed to GPLv2</li>\n<li>Integration to SENAITE CORE</li>\n</ul>\n<p><strong>Fixed</strong></p>\n<ul>\n<li>Fixed Tests</li>\n</ul>\n<p><strong>Security</strong></p>\n</div>\n<div id=\"id6\">\n<h3>1.0.2 (2017-11-24)</h3>\n<ul>\n<li>#397(bika.lims) Fix Issue-396: AttributeError: uid_catalog on AR publication</li>\n</ul>\n</div>\n<div id=\"id7\">\n<h3>1.0.1 (2017-09-30)</h3>\n<ul>\n<li>Fixed broken release (missing MANIFEST.in)</li>\n</ul>\n</div>\n<div id=\"id8\">\n<h3>1.0.0 (2017-09-30)</h3>\n<ul>\n<li>First release</li>\n</ul>\n</div>\n</div>\n\n          </div>"}, "last_serial": 3993356, "releases": {"1.0.1": [{"comment_text": "", "digests": {"md5": "f5e7e6818623154c7b0b15a9a701b730", "sha256": "47665ac3ab08f49c20552ddbc13c7cc48122d3b40c3387a781b7a78da8ccd47b"}, "downloads": -1, "filename": "senaite.api-1.0.1.zip", "has_sig": false, "md5_digest": "f5e7e6818623154c7b0b15a9a701b730", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 45635, "upload_time": "2017-09-30T17:50:58", "upload_time_iso_8601": "2017-09-30T17:50:58.775052Z", "url": "https://files.pythonhosted.org/packages/bf/a5/20dca784a34d99aafb2cb2379c7fc45e262e71000fe296ab5838a1d89335/senaite.api-1.0.1.zip", "yanked": false}], "1.1.0": [{"comment_text": "", "digests": {"md5": "1811eb9d8ad23decd095f4e7d4405edd", "sha256": "951bf0b1a6084c8c56361f8323dc049910a8d5a596f4f16d0880ffef6a0ba451"}, "downloads": -1, "filename": "senaite.api-1.1.0.zip", "has_sig": false, "md5_digest": "1811eb9d8ad23decd095f4e7d4405edd", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 41286, "upload_time": "2018-01-03T17:01:05", "upload_time_iso_8601": "2018-01-03T17:01:05.978337Z", "url": "https://files.pythonhosted.org/packages/b3/8b/66fe1e14b9d7f523cc4038d104e7ee6c536cccbcf470f6ad2d9f011825b2/senaite.api-1.1.0.zip", "yanked": false}], "1.2.0": [{"comment_text": "", "digests": {"md5": "fd79949a3daad285e08f2df9289ada68", "sha256": "1311a05929ba01fae98fa0d4af69eff5e63f78a7627f3c7f7c3a1b0313a7be7e"}, "downloads": -1, "filename": "senaite.api-1.2.0-py2-none-any.whl", "has_sig": false, "md5_digest": "fd79949a3daad285e08f2df9289ada68", "packagetype": "bdist_wheel", "python_version": "py2", "requires_python": null, "size": 36476, "upload_time": "2018-06-23T13:17:15", "upload_time_iso_8601": "2018-06-23T13:17:15.854667Z", "url": "https://files.pythonhosted.org/packages/7b/b2/a84d1b7c16cd73a41d235810d4ff50db51928b94e3d620e622dd397704f2/senaite.api-1.2.0-py2-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "858a74079956ea9bfd83bb842236c6a6", "sha256": "a01d871db0123a873f00db747643d9595342b83b183fb18547041f279875edf9"}, "downloads": -1, "filename": "senaite.api-1.2.0.zip", "has_sig": false, "md5_digest": "858a74079956ea9bfd83bb842236c6a6", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 55668, "upload_time": "2018-06-23T13:17:17", "upload_time_iso_8601": "2018-06-23T13:17:17.418401Z", "url": "https://files.pythonhosted.org/packages/48/b7/672c0bdfe7f8369ea1377bdf47d5103cf836646275f652821dd453c43014/senaite.api-1.2.0.zip", "yanked": false}], "1.2.0.post1": [{"comment_text": "", "digests": {"md5": "cb9683455d2aa67c5a22f2cfd213440b", "sha256": "171aa0c2a5e093714350d1e39f211c07036e1c9f696075e339d6e190465b1880"}, "downloads": -1, "filename": "senaite.api-1.2.0.post1-py2-none-any.whl", "has_sig": false, "md5_digest": "cb9683455d2aa67c5a22f2cfd213440b", "packagetype": "bdist_wheel", "python_version": "py2", "requires_python": null, "size": 36577, "upload_time": "2018-06-23T13:32:21", "upload_time_iso_8601": "2018-06-23T13:32:21.871065Z", "url": "https://files.pythonhosted.org/packages/63/8c/a6cc6ff265523a8caf43bfab2513f50eaeab52e78a0cee4462609349361d/senaite.api-1.2.0.post1-py2-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "4edadf94cb3e33d03cd6a4d48fe26cb7", "sha256": "076302d9d0a0b44900474a7f8cd7a8957fc941652b370844e85d56cb1380d4fc"}, "downloads": -1, "filename": "senaite.api-1.2.0.post1.zip", "has_sig": false, "md5_digest": "4edadf94cb3e33d03cd6a4d48fe26cb7", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 56036, "upload_time": "2018-06-23T13:32:23", "upload_time_iso_8601": "2018-06-23T13:32:23.628366Z", "url": "https://files.pythonhosted.org/packages/02/ba/cc40c10b98f313935704c0413a64c8bf3cd766827fc5d88ede7f590e6430/senaite.api-1.2.0.post1.zip", "yanked": false}], "1.2.1": [{"comment_text": "", "digests": {"md5": "8a0787bd843fc2cc14d442204289952e", "sha256": "e0269e2274a76d7e6fdad7605a73bb6b74f75c8ef5a2aad35da78cd41b58aafb"}, "downloads": -1, "filename": "senaite.api-1.2.1-py2-none-any.whl", "has_sig": false, "md5_digest": "8a0787bd843fc2cc14d442204289952e", "packagetype": "bdist_wheel", "python_version": "py2", "requires_python": null, "size": 39421, "upload_time": "2018-06-23T17:43:13", "upload_time_iso_8601": "2018-06-23T17:43:13.760644Z", "url": "https://files.pythonhosted.org/packages/62/65/d9c63897ff0f436e232da2612e6d04c3d07422dcf39cbd0748a0f0d33bad/senaite.api-1.2.1-py2-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "7b5950f16f6b6e8c68c6a12bd6051c8f", "sha256": "f364067d8fef2c14251cf2201c72cef96ba571ba1ef48d9bd5d0f3dfb78f0471"}, "downloads": -1, "filename": "senaite.api-1.2.1.zip", "has_sig": false, "md5_digest": "7b5950f16f6b6e8c68c6a12bd6051c8f", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 62189, "upload_time": "2018-06-23T17:43:15", "upload_time_iso_8601": "2018-06-23T17:43:15.384443Z", "url": "https://files.pythonhosted.org/packages/c0/75/3bbf8b3e15023867294c2a699749bb62222877df9be78d805b73b1ce9e0f/senaite.api-1.2.1.zip", "yanked": false}], "1.2.2": [{"comment_text": "", "digests": {"md5": "6171d3a06732f8d6b384621805fcb336", "sha256": "d8e4125328b904704a7f5265ed6bac971a46d02ab13ad0a3cfffe189c52661ac"}, "downloads": -1, "filename": "senaite.api-1.2.2-py2-none-any.whl", "has_sig": false, "md5_digest": "6171d3a06732f8d6b384621805fcb336", "packagetype": "bdist_wheel", "python_version": "py2", "requires_python": null, "size": 40289, "upload_time": "2018-06-23T17:58:03", "upload_time_iso_8601": "2018-06-23T17:58:03.856807Z", "url": "https://files.pythonhosted.org/packages/fd/df/b813d171de415be51cde01c897c6d6a6a60d9c3576ae0c6fe7ea80e1726d/senaite.api-1.2.2-py2-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "d6079e2513e069ab1c5dc0171f12a18a", "sha256": "bbd8576177835e64d6946124e02bf6ee4c3230aeb64776e47fc28d8784f12049"}, "downloads": -1, "filename": "senaite.api-1.2.2.zip", "has_sig": false, "md5_digest": "d6079e2513e069ab1c5dc0171f12a18a", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 64927, "upload_time": "2018-06-23T17:58:05", "upload_time_iso_8601": "2018-06-23T17:58:05.646382Z", "url": "https://files.pythonhosted.org/packages/a7/46/f034c646dcb7eb0248e993c5736cfc3dfdb439835c40fed341d2934f427f/senaite.api-1.2.2.zip", "yanked": false}], "1.2.3": [{"comment_text": "", "digests": {"md5": "7c4724580884d457ce3ba2c51c2d9f1b", "sha256": "1bbdb0843530f3c13648edbfc19d671e9a39a1d8ae6e421d03d2684a59bc4792"}, "downloads": -1, "filename": "senaite.api-1.2.3-py2-none-any.whl", "has_sig": false, "md5_digest": "7c4724580884d457ce3ba2c51c2d9f1b", "packagetype": "bdist_wheel", "python_version": "py2", "requires_python": null, "size": 40306, "upload_time": "2018-06-23T18:00:09", "upload_time_iso_8601": "2018-06-23T18:00:09.041554Z", "url": "https://files.pythonhosted.org/packages/5f/ff/89bc491d551ece6b629b484378e52bfad4d0a5f4e614c3ab229b1119866b/senaite.api-1.2.3-py2-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "62eedfd54c61d04fda484b6f7680a557", "sha256": "10c789f0c55f9f1160c1fec9e12c2d37c585ba842697a6583f4d0ee69ae1c7b3"}, "downloads": -1, "filename": "senaite.api-1.2.3.zip", "has_sig": false, "md5_digest": "62eedfd54c61d04fda484b6f7680a557", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 64976, "upload_time": "2018-06-23T18:00:10", "upload_time_iso_8601": "2018-06-23T18:00:10.943433Z", "url": "https://files.pythonhosted.org/packages/bd/49/df41a01242651388a64d65dbd4dfaecbd644d15491987524dfe54a2eb1dc/senaite.api-1.2.3.zip", "yanked": false}], "1.2.3.post1": [{"comment_text": "", "digests": {"md5": "54ef9d1b7ce9719085451d6ee296f276", "sha256": "26787b31b87f4546433fa373fcabdfd24593a056e38b8d1ab253516d21eeb12b"}, "downloads": -1, "filename": "senaite.api-1.2.3.post1-py2-none-any.whl", "has_sig": false, "md5_digest": "54ef9d1b7ce9719085451d6ee296f276", "packagetype": "bdist_wheel", "python_version": "py2", "requires_python": null, "size": 40388, "upload_time": "2018-06-23T18:02:03", "upload_time_iso_8601": "2018-06-23T18:02:03.295003Z", "url": "https://files.pythonhosted.org/packages/39/32/6270627dbe5fac75409fb98eb42140017f7161d43c233dc68b4d70f6a874/senaite.api-1.2.3.post1-py2-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "b4fc7d14121646b107d2bf7d7d8f22f7", "sha256": "ca40d7f53f0fef3d2555ef3893a3276cf54c8003832ca417b4ceb264fafc1c96"}, "downloads": -1, "filename": "senaite.api-1.2.3.post1.zip", "has_sig": false, "md5_digest": "b4fc7d14121646b107d2bf7d7d8f22f7", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 65295, "upload_time": "2018-06-23T18:02:05", "upload_time_iso_8601": "2018-06-23T18:02:05.343863Z", "url": "https://files.pythonhosted.org/packages/ec/a9/1f7fb502fa9fdfb519bf015c22ae2dc4c74205ca3736bcbba0abd63c7c33/senaite.api-1.2.3.post1.zip", "yanked": false}], "1.2.3.post2": [{"comment_text": "", "digests": {"md5": "4fc28c7393bd344fe0f24abb7fb3944e", "sha256": "f5bcb758e417d536636572659140b11c29f7ef99b1eda7908205dda55fa089d6"}, "downloads": -1, "filename": "senaite.api-1.2.3.post2-py2-none-any.whl", "has_sig": false, "md5_digest": "4fc28c7393bd344fe0f24abb7fb3944e", "packagetype": "bdist_wheel", "python_version": "py2", "requires_python": null, "size": 40415, "upload_time": "2018-06-23T18:04:08", "upload_time_iso_8601": "2018-06-23T18:04:08.988308Z", "url": "https://files.pythonhosted.org/packages/ed/23/1aab6813ef25e02975476acc0016ecd090ec58ff76b3f0f123898c7a2c8c/senaite.api-1.2.3.post2-py2-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "7bab7b339babc3700510c7abd9fb7cff", "sha256": "0f9a4d35e82624b161656863932c3f5bd22427d159cf793d60ae9a9b0712a6a9"}, "downloads": -1, "filename": "senaite.api-1.2.3.post2.zip", "has_sig": false, "md5_digest": "7bab7b339babc3700510c7abd9fb7cff", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 65382, "upload_time": "2018-06-23T18:04:10", "upload_time_iso_8601": "2018-06-23T18:04:10.477784Z", "url": "https://files.pythonhosted.org/packages/46/f9/837045a9fc949025d60384336013895beed98159141b6d22fa47227ffa3e/senaite.api-1.2.3.post2.zip", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "4fc28c7393bd344fe0f24abb7fb3944e", "sha256": "f5bcb758e417d536636572659140b11c29f7ef99b1eda7908205dda55fa089d6"}, "downloads": -1, "filename": "senaite.api-1.2.3.post2-py2-none-any.whl", "has_sig": false, "md5_digest": "4fc28c7393bd344fe0f24abb7fb3944e", "packagetype": "bdist_wheel", "python_version": "py2", "requires_python": null, "size": 40415, "upload_time": "2018-06-23T18:04:08", "upload_time_iso_8601": "2018-06-23T18:04:08.988308Z", "url": "https://files.pythonhosted.org/packages/ed/23/1aab6813ef25e02975476acc0016ecd090ec58ff76b3f0f123898c7a2c8c/senaite.api-1.2.3.post2-py2-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "7bab7b339babc3700510c7abd9fb7cff", "sha256": "0f9a4d35e82624b161656863932c3f5bd22427d159cf793d60ae9a9b0712a6a9"}, "downloads": -1, "filename": "senaite.api-1.2.3.post2.zip", "has_sig": false, "md5_digest": "7bab7b339babc3700510c7abd9fb7cff", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 65382, "upload_time": "2018-06-23T18:04:10", "upload_time_iso_8601": "2018-06-23T18:04:10.477784Z", "url": "https://files.pythonhosted.org/packages/46/f9/837045a9fc949025d60384336013895beed98159141b6d22fa47227ffa3e/senaite.api-1.2.3.post2.zip", "yanked": false}], "timestamp": "Fri May  8 02:55:19 2020"}