{"info": {"author": "\u0141ukasz Langa", "author_email": "lukasz@langa.pl", "bugtrack_url": null, "classifiers": ["Development Status :: 5 - Production/Stable", "Framework :: Django", "License :: OSI Approved :: MIT License", "Natural Language :: English", "Programming Language :: Python", "Programming Language :: Python :: 2", "Programming Language :: Python :: 2.7", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.2", "Programming Language :: Python :: 3.3", "Topic :: Internet :: WWW/HTTP", "Topic :: Software Development :: Libraries :: Python Modules"], "description": "========\ndj.chain\n========\n\n.. image:: https://secure.travis-ci.org/ambv/dj.chain.png\n  :target: https://secure.travis-ci.org/ambv/dj.chain\n\nThis module provides a way to chain multiple finite iterables for consumption as\na QuerySet-compatible object.\n\n\nQuickstart\n----------\n\nLet's start with an example. Say we have a couple of abstract database models\nwhich enables us to reuse fields later on::\n\n  class Titled(db.Model):\n      title = db.CharField(max_length=100)\n\n      class Meta:\n          abstract = True\n\n  class Dynamic(db.Model):\n      duration = db.PositiveIntegerField()\n\n      class Meta:\n          abstract = True\n\nWe also have concrete database models that share some of those fields::\n\n  class Video(Titled, Dynamic):\n      RESOLUTION = (\n              (1, '240p'), (2, '320p'), (3, '480p'),\n              (4, '720p'), (5, '1080p')\n      )\n\n      author = db.CharField(max_length=100)\n      resolution = db.IntegerField(choices=RESOLUTION)\n\n  class Song(Titled, Dynamic):\n      GENRE = (\n              (1, 'Country'), (2, 'Folk'), (3, 'Polka'),\n              (4, 'Western'), (5, 'World')\n      )\n\n      artist = db.CharField(max_length=100)\n      genre = db.IntegerField(choices=GENRE)\n\nOur database already contains some data::\n\n  >>> Video.objects.all()\n  [<Video: Psy - Gangnam Style (253 s at 1080p)>,\n   <Video: Justin Bieber - Baby (225 s at 720p)>,\n   <Video: Lady Gaga - Bad Romance (308 s at 320p)>,\n   <Video: Shakira - Waka Waka (211 s at 480p)>]\n  >>> Song.objects.all()\n  [<Song: Gotye feat. Kimbra - Somebody That I Used to Know (244 s; Folk)>,\n   <Song: Coldplay - Clocks (307 s; Polka)>,\n   <Song: Muse - Madness (279 s; Country)>,\n   <Song: Florence + The Machine - Spectrum (218 s; Folk)>]\n\n\nA basic chain\n~~~~~~~~~~~~~\n\nLet's create a simple chain::\n\n  >>> from dj.chain import chain\n  >>> media = chain(Video.objects.all(), Song.objects.all())\n\nWe can collectively call QuerySet-related methods on it::\n\n  >>> media.count()\n  8\n\nWe can also filter it further::\n\n  >>> list(media.filter(duration__gt=250))\n  [<Video: Psy - Gangnam Style (253 s at 1080p)>,\n   <Video: Lady Gaga - Bad Romance (308 s at 320p)>,\n   <Song: Coldplay - Clocks (307 s; Polka)>,\n   <Song: Muse - Madness (279 s; Country)>]\n\nCheck the cumulative length::\n\n  >>> media.filter(duration__gt=250).count()\n  4\n\nUse indices and slices::\n\n  >>> media.filter(duration__gt=250)[1]\n  <Video: Lady Gaga - Bad Romance (308 s at 320p)>\n  >>> list(media[3:6])\n  [<Video: Shakira - Waka Waka (211 s at 480p)>,\n   <Song: Gotye feat. Kimbra - Somebody That I Used to Know (244 s; Folk)>,\n   <Song: Coldplay - Clocks (307 s; Polka)>]\n  >>> list(media[1::3])\n  [<Video: Justin Bieber - Baby (225 s at 720p)>, \n   <Song: Gotye feat. Kimbra - Somebody That I Used to Know (244 s; Folk)>,\n   <Song: Florence + The Machine - Spectrum (218 s; Folk)>]\n\nUse cumulative sorting and filtering::\n\n  >>> list(media.order_by('title'))\n  [<Video: Justin Bieber - Baby (225 s at 720p)>,\n   <Video: Lady Gaga - Bad Romance (308 s at 320p)>,\n   <Song: Coldplay - Clocks (307 s; Polka)>,\n   <Video: Psy - Gangnam Style (253 s at 1080p)>,\n   <Song: Muse - Madness (279 s; Country)>,\n   <Song: Gotye feat. Kimbra - Somebody That I Used to Know (244 s; Folk)>,\n   <Song: Florence + The Machine - Spectrum (218 s; Folk)>,\n   <Video: Shakira - Waka Waka (211 s at 480p)>]\n  >>> list(media.order_by('-duration').filter(duration__lt=300))\n  [<Song: Muse - Madness (279 s; Country)>,\n   <Video: Psy - Gangnam Style (253 s at 1080p)>,\n   <Song: Gotye feat. Kimbra - Somebody That I Used to Know (244 s; Folk)>,\n   <Video: Justin Bieber - Baby (225 s at 720p)>,\n   <Song: Florence + The Machine - Spectrum (218 s; Folk)>,\n   <Video: Shakira - Waka Waka (211 s at 480p)>]\n\nEtc.\n\n\nChaining heterogenic iterables\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nWe can add iterables that aren't QuerySets to the bunch::\n\n  >>> from collections import namedtuple\n  >>> Book = namedtuple('Book', \"author title page_count\")\n  >>> books=(\n  ... Book(author='Charles Dickens', title='A Tale of Two Cities', page_count=869),\n  ... Book(author='Miguel de Cervantes', title='Don Quixote', page_count=1212),\n  ... )\n  >>> media=chain(Video.objects.all(), books)\n  >>> media.count()\n  6\n  >>> list(media)\n  [<Video: Psy - Gangnam Style (253 s at 1080p)>,\n   <Video: Justin Bieber - Baby (225 s at 720p)>,\n   <Video: Lady Gaga - Bad Romance (308 s at 320p)>,\n   <Video: Shakira - Waka Waka (211 s at 480p)>,\n   Book(author='Charles Dickens', title='A Tale of Two Cities', page_count=869),\n   Book(author='Miguel de Cervantes', title='Don Quixote', page_count=1212)]\n\nYou can also use cumulative ordering in this case. The only thing you need to\nkeep in mind is that iterables which are not QuerySets should be presorted for\nthe cumulative result to be ordered correctly. An example::\n\n  >>> list(media.order_by('title'))\n  [Book(author='Charles Dickens', title='A Tale of Two Cities', page_count=869),\n   <Video: Justin Bieber - Baby (225 s at 720p)>,\n   <Video: Lady Gaga - Bad Romance (308 s at 320p)>,\n   Book(author='Miguel de Cervantes', title='Don Quixote', page_count=1212),\n   <Video: Psy - Gangnam Style (253 s at 1080p)>,\n   <Video: Shakira - Waka Waka (211 s at 480p)>]\n\nYou can also use the cumulative ``values`` and ``values_list`` transformations::\n\n  >>> media = chain(mt.Video.objects.all(), mt.books)\n  >>> list(media.values('title'))\n  [{'title': u'Gangnam Style'}, {'title': u'Baby'}, {'title': u'Bad Romance'},\n   {'title': u'Waka Waka'}, {'title': u'A Tale of Two Cities'},\n   {'title': u'Don Quixote'}]\n  >>> list(media.values_list('title', 'author'))\n  [(u'Gangnam Style', u'Psy'), (u'Baby', u'Justin Bieber'),\n   (u'Bad Romance', u'Lady Gaga'), (u'Waka Waka', u'Shakira'),\n   (u'A Tale of Two Cities', u'Charles Dickens'),\n   (u'Don Quixote', u'Miguel de Cervantes')]\n  >>> list(media.values_list('author', flat=True))\n  [u'Psy', u'Justin Bieber', u'Lady Gaga', u'Shakira', u'Charles Dickens',\n   u'Miguel de Cervantes']\n\nCustom filtering, sorting and transformations\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nChains provide special overridable static methods used while yielding values:\n\n* ``xfilter(value)`` - yield a value only if ``xfilter(value)`` returns\n  ``True``. See known issues below.\n\n* ``xform(value)`` - transforms the value JIT before yielding it back. It is\n  only called for values within the specified slice and those which passed\n  ``xfilter``.\n\n* ``xkey(value)`` - returns a value to be used in comparison between elements if\n  sorting should be used. Individual iterables should be presorted for the\n  complete result to be sorted properly. Any cumulative ``order_by`` clauses are\n  executed before the ``xkey`` method is used. \n\n\nMethods silently ignored on incompatible iterables\n--------------------------------------------------\n\nChains may contain both QuerySet-like objects and other iterables. There are\nmethods which apply only to the former if called collectively on the chain\nobject. These are:\n\n* ``defer``\n\n* ``exclude``\n\n* ``extra``\n\n* ``filter``\n\n* ``only``\n\n* ``prefetch_related``\n\n* ``select_for_update``\n\n* ``select_related``\n\n* ``using``\n\nBy default ``dj.chain`` considers any iterable a QuerySet-like object as long as\nit has a method required for the collective call. For example if your custom\niterable supports a ``defer`` method, it will be used on collective ``defer``\ncalls. If that behaviour is undesirable, you should pass ``strict=True`` when\nconstructing a chain::\n\n  c = chain(Article.objects.all(), custom_entries, strict=True)\n\nIn this case the above methods will only be called on actual QuerySet instances.\nNote that methods with custom handling of other iterables (like ``count`` and\n``order_by``) still work.\n\n\nUnsupported methods\n-------------------\n\nThe following methods cannot be supported in a heterogenic context:\n\n* ``create``\n\n* ``get_or_create``\n\n* ``bulk_create``\n\n\nMethods below are not supported yet but the support is planned in a future\nrelease:\n\n* ``aggregate``\n\n* ``annotate``\n\n* ``dates``\n\n* ``delete``\n\n* ``distinct``\n\n* ``get``\n\n* ``in_bulk``\n\n* ``reverse``\n\n* ``update``\n\n\nKnown issues\n------------\n\n1. If slicing or ``xfilter`` is used, reported ``len()`` is computed by\n   iterating over all iterables so performance is weak. Note that ``len()`` is\n   used by ``list()`` when you convert your chain to a list or when iterating\n   over the chain in Django templates.  If this is not expected, you can convert\n   to a list using a workaround like this::\n\n       list(e for e in some_chain)\n\n2. Indexing on chains uses iteration underneath so performance is weak. This\n   feature is only available as a last resort. Slicing on the other hand is also\n   lazy.\n\n3. Collective ``filter`` and ``exclude`` silently skip filtering on incompatible\n   iterables. Use ``xfilter(value)`` as a workaround.\n\n\nHow do I run the tests?\n-----------------------\n\nThe easiest way would be to run::\n\n  $ DJANGO_SETTINGS_MODULE=\"dj._chaintestproject.settings\" django-admin.py test\n\n\nChange Log\n----------\n\n0.9.2\n-----\n\n* Long overdue Python 3 support (considered experimental)\n\n\n0.9.1\n~~~~~\n\n* support for collective ``values`` and ``values_list`` transformations\n\n* support for collective ``defer``, ``extra``, ``only``, ``prefetch_related``,\n  ``select_for_update``, ``select_related`` and ``using`` methods (silently\n  ignored for incompatible iterables)\n\n* strict mode (non-QuerySet objects are not tried for compatibility with\n  collective methods)\n\n* fixed an import error due to incomplete separation from ``lck.django``\n\n\n0.9.0\n~~~~~\n\n* code separated from ``lck.django``\n\n* support for collective sort using QuerySet-like ``order_by`` on a chain\n\n* fix for slices with custom steps\n\n* PEP8-fied all sources \n\n\nAuthors\n-------\n\nGlued together by `\u0141ukasz Langa <mailto:lukasz@langa.pl>`_.", "description_content_type": null, "docs_url": null, "download_url": "UNKNOWN", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/ambv/dj.chain/", "keywords": "django dj extra contrib chain iterator iteration queryset lazy", "license": "MIT", "maintainer": null, "maintainer_email": null, "name": "dj.chain", "package_url": "https://pypi.org/project/dj.chain/", "platform": "any", "project_url": "https://pypi.org/project/dj.chain/", "project_urls": {"Download": "UNKNOWN", "Homepage": "https://github.com/ambv/dj.chain/"}, "release_url": "https://pypi.org/project/dj.chain/0.9.2/", "requires_dist": null, "requires_python": null, "summary": "An object that enables chaining multiple iterables to serve them lazily as a queryset-compatible object.", "version": "0.9.2", "yanked": false, "html_description": "<div class=\"project-description\">\n            <a href=\"https://secure.travis-ci.org/ambv/dj.chain\" rel=\"nofollow\"><img alt=\"https://secure.travis-ci.org/ambv/dj.chain.png\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/a7129d15ee2d29bc680591063785f933146c65e5/68747470733a2f2f7365637572652e7472617669732d63692e6f72672f616d62762f646a2e636861696e2e706e67\"></a>\n<p>This module provides a way to chain multiple finite iterables for consumption as\na QuerySet-compatible object.</p>\n<div id=\"quickstart\">\n<h2>Quickstart</h2>\n<p>Let\u2019s start with an example. Say we have a couple of abstract database models\nwhich enables us to reuse fields later on:</p>\n<pre>class Titled(db.Model):\n    title = db.CharField(max_length=100)\n\n    class Meta:\n        abstract = True\n\nclass Dynamic(db.Model):\n    duration = db.PositiveIntegerField()\n\n    class Meta:\n        abstract = True\n</pre>\n<p>We also have concrete database models that share some of those fields:</p>\n<pre>class Video(Titled, Dynamic):\n    RESOLUTION = (\n            (1, '240p'), (2, '320p'), (3, '480p'),\n            (4, '720p'), (5, '1080p')\n    )\n\n    author = db.CharField(max_length=100)\n    resolution = db.IntegerField(choices=RESOLUTION)\n\nclass Song(Titled, Dynamic):\n    GENRE = (\n            (1, 'Country'), (2, 'Folk'), (3, 'Polka'),\n            (4, 'Western'), (5, 'World')\n    )\n\n    artist = db.CharField(max_length=100)\n    genre = db.IntegerField(choices=GENRE)\n</pre>\n<p>Our database already contains some data:</p>\n<pre>&gt;&gt;&gt; Video.objects.all()\n[&lt;Video: Psy - Gangnam Style (253 s at 1080p)&gt;,\n &lt;Video: Justin Bieber - Baby (225 s at 720p)&gt;,\n &lt;Video: Lady Gaga - Bad Romance (308 s at 320p)&gt;,\n &lt;Video: Shakira - Waka Waka (211 s at 480p)&gt;]\n&gt;&gt;&gt; Song.objects.all()\n[&lt;Song: Gotye feat. Kimbra - Somebody That I Used to Know (244 s; Folk)&gt;,\n &lt;Song: Coldplay - Clocks (307 s; Polka)&gt;,\n &lt;Song: Muse - Madness (279 s; Country)&gt;,\n &lt;Song: Florence + The Machine - Spectrum (218 s; Folk)&gt;]\n</pre>\n<div id=\"a-basic-chain\">\n<h3>A basic chain</h3>\n<p>Let\u2019s create a simple chain:</p>\n<pre>&gt;&gt;&gt; from dj.chain import chain\n&gt;&gt;&gt; media = chain(Video.objects.all(), Song.objects.all())\n</pre>\n<p>We can collectively call QuerySet-related methods on it:</p>\n<pre>&gt;&gt;&gt; media.count()\n8\n</pre>\n<p>We can also filter it further:</p>\n<pre>&gt;&gt;&gt; list(media.filter(duration__gt=250))\n[&lt;Video: Psy - Gangnam Style (253 s at 1080p)&gt;,\n &lt;Video: Lady Gaga - Bad Romance (308 s at 320p)&gt;,\n &lt;Song: Coldplay - Clocks (307 s; Polka)&gt;,\n &lt;Song: Muse - Madness (279 s; Country)&gt;]\n</pre>\n<p>Check the cumulative length:</p>\n<pre>&gt;&gt;&gt; media.filter(duration__gt=250).count()\n4\n</pre>\n<p>Use indices and slices:</p>\n<pre>&gt;&gt;&gt; media.filter(duration__gt=250)[1]\n&lt;Video: Lady Gaga - Bad Romance (308 s at 320p)&gt;\n&gt;&gt;&gt; list(media[3:6])\n[&lt;Video: Shakira - Waka Waka (211 s at 480p)&gt;,\n &lt;Song: Gotye feat. Kimbra - Somebody That I Used to Know (244 s; Folk)&gt;,\n &lt;Song: Coldplay - Clocks (307 s; Polka)&gt;]\n&gt;&gt;&gt; list(media[1::3])\n[&lt;Video: Justin Bieber - Baby (225 s at 720p)&gt;,\n &lt;Song: Gotye feat. Kimbra - Somebody That I Used to Know (244 s; Folk)&gt;,\n &lt;Song: Florence + The Machine - Spectrum (218 s; Folk)&gt;]\n</pre>\n<p>Use cumulative sorting and filtering:</p>\n<pre>&gt;&gt;&gt; list(media.order_by('title'))\n[&lt;Video: Justin Bieber - Baby (225 s at 720p)&gt;,\n &lt;Video: Lady Gaga - Bad Romance (308 s at 320p)&gt;,\n &lt;Song: Coldplay - Clocks (307 s; Polka)&gt;,\n &lt;Video: Psy - Gangnam Style (253 s at 1080p)&gt;,\n &lt;Song: Muse - Madness (279 s; Country)&gt;,\n &lt;Song: Gotye feat. Kimbra - Somebody That I Used to Know (244 s; Folk)&gt;,\n &lt;Song: Florence + The Machine - Spectrum (218 s; Folk)&gt;,\n &lt;Video: Shakira - Waka Waka (211 s at 480p)&gt;]\n&gt;&gt;&gt; list(media.order_by('-duration').filter(duration__lt=300))\n[&lt;Song: Muse - Madness (279 s; Country)&gt;,\n &lt;Video: Psy - Gangnam Style (253 s at 1080p)&gt;,\n &lt;Song: Gotye feat. Kimbra - Somebody That I Used to Know (244 s; Folk)&gt;,\n &lt;Video: Justin Bieber - Baby (225 s at 720p)&gt;,\n &lt;Song: Florence + The Machine - Spectrum (218 s; Folk)&gt;,\n &lt;Video: Shakira - Waka Waka (211 s at 480p)&gt;]\n</pre>\n<p>Etc.</p>\n</div>\n<div id=\"chaining-heterogenic-iterables\">\n<h3>Chaining heterogenic iterables</h3>\n<p>We can add iterables that aren\u2019t QuerySets to the bunch:</p>\n<pre>&gt;&gt;&gt; from collections import namedtuple\n&gt;&gt;&gt; Book = namedtuple('Book', \"author title page_count\")\n&gt;&gt;&gt; books=(\n... Book(author='Charles Dickens', title='A Tale of Two Cities', page_count=869),\n... Book(author='Miguel de Cervantes', title='Don Quixote', page_count=1212),\n... )\n&gt;&gt;&gt; media=chain(Video.objects.all(), books)\n&gt;&gt;&gt; media.count()\n6\n&gt;&gt;&gt; list(media)\n[&lt;Video: Psy - Gangnam Style (253 s at 1080p)&gt;,\n &lt;Video: Justin Bieber - Baby (225 s at 720p)&gt;,\n &lt;Video: Lady Gaga - Bad Romance (308 s at 320p)&gt;,\n &lt;Video: Shakira - Waka Waka (211 s at 480p)&gt;,\n Book(author='Charles Dickens', title='A Tale of Two Cities', page_count=869),\n Book(author='Miguel de Cervantes', title='Don Quixote', page_count=1212)]\n</pre>\n<p>You can also use cumulative ordering in this case. The only thing you need to\nkeep in mind is that iterables which are not QuerySets should be presorted for\nthe cumulative result to be ordered correctly. An example:</p>\n<pre>&gt;&gt;&gt; list(media.order_by('title'))\n[Book(author='Charles Dickens', title='A Tale of Two Cities', page_count=869),\n &lt;Video: Justin Bieber - Baby (225 s at 720p)&gt;,\n &lt;Video: Lady Gaga - Bad Romance (308 s at 320p)&gt;,\n Book(author='Miguel de Cervantes', title='Don Quixote', page_count=1212),\n &lt;Video: Psy - Gangnam Style (253 s at 1080p)&gt;,\n &lt;Video: Shakira - Waka Waka (211 s at 480p)&gt;]\n</pre>\n<p>You can also use the cumulative <tt>values</tt> and <tt>values_list</tt> transformations:</p>\n<pre>&gt;&gt;&gt; media = chain(mt.Video.objects.all(), mt.books)\n&gt;&gt;&gt; list(media.values('title'))\n[{'title': u'Gangnam Style'}, {'title': u'Baby'}, {'title': u'Bad Romance'},\n {'title': u'Waka Waka'}, {'title': u'A Tale of Two Cities'},\n {'title': u'Don Quixote'}]\n&gt;&gt;&gt; list(media.values_list('title', 'author'))\n[(u'Gangnam Style', u'Psy'), (u'Baby', u'Justin Bieber'),\n (u'Bad Romance', u'Lady Gaga'), (u'Waka Waka', u'Shakira'),\n (u'A Tale of Two Cities', u'Charles Dickens'),\n (u'Don Quixote', u'Miguel de Cervantes')]\n&gt;&gt;&gt; list(media.values_list('author', flat=True))\n[u'Psy', u'Justin Bieber', u'Lady Gaga', u'Shakira', u'Charles Dickens',\n u'Miguel de Cervantes']\n</pre>\n</div>\n<div id=\"custom-filtering-sorting-and-transformations\">\n<h3>Custom filtering, sorting and transformations</h3>\n<p>Chains provide special overridable static methods used while yielding values:</p>\n<ul>\n<li><tt>xfilter(value)</tt> - yield a value only if <tt>xfilter(value)</tt> returns\n<tt>True</tt>. See known issues below.</li>\n<li><tt>xform(value)</tt> - transforms the value JIT before yielding it back. It is\nonly called for values within the specified slice and those which passed\n<tt>xfilter</tt>.</li>\n<li><tt>xkey(value)</tt> - returns a value to be used in comparison between elements if\nsorting should be used. Individual iterables should be presorted for the\ncomplete result to be sorted properly. Any cumulative <tt>order_by</tt> clauses are\nexecuted before the <tt>xkey</tt> method is used.</li>\n</ul>\n</div>\n</div>\n<div id=\"methods-silently-ignored-on-incompatible-iterables\">\n<h2>Methods silently ignored on incompatible iterables</h2>\n<p>Chains may contain both QuerySet-like objects and other iterables. There are\nmethods which apply only to the former if called collectively on the chain\nobject. These are:</p>\n<ul>\n<li><tt>defer</tt></li>\n<li><tt>exclude</tt></li>\n<li><tt>extra</tt></li>\n<li><tt>filter</tt></li>\n<li><tt>only</tt></li>\n<li><tt>prefetch_related</tt></li>\n<li><tt>select_for_update</tt></li>\n<li><tt>select_related</tt></li>\n<li><tt>using</tt></li>\n</ul>\n<p>By default <tt>dj.chain</tt> considers any iterable a QuerySet-like object as long as\nit has a method required for the collective call. For example if your custom\niterable supports a <tt>defer</tt> method, it will be used on collective <tt>defer</tt>\ncalls. If that behaviour is undesirable, you should pass <tt>strict=True</tt> when\nconstructing a chain:</p>\n<pre>c = chain(Article.objects.all(), custom_entries, strict=True)\n</pre>\n<p>In this case the above methods will only be called on actual QuerySet instances.\nNote that methods with custom handling of other iterables (like <tt>count</tt> and\n<tt>order_by</tt>) still work.</p>\n</div>\n<div id=\"unsupported-methods\">\n<h2>Unsupported methods</h2>\n<p>The following methods cannot be supported in a heterogenic context:</p>\n<ul>\n<li><tt>create</tt></li>\n<li><tt>get_or_create</tt></li>\n<li><tt>bulk_create</tt></li>\n</ul>\n<p>Methods below are not supported yet but the support is planned in a future\nrelease:</p>\n<ul>\n<li><tt>aggregate</tt></li>\n<li><tt>annotate</tt></li>\n<li><tt>dates</tt></li>\n<li><tt>delete</tt></li>\n<li><tt>distinct</tt></li>\n<li><tt>get</tt></li>\n<li><tt>in_bulk</tt></li>\n<li><tt>reverse</tt></li>\n<li><tt>update</tt></li>\n</ul>\n</div>\n<div id=\"known-issues\">\n<h2>Known issues</h2>\n<ol>\n<li><p>If slicing or <tt>xfilter</tt> is used, reported <tt>len()</tt> is computed by\niterating over all iterables so performance is weak. Note that <tt>len()</tt> is\nused by <tt>list()</tt> when you convert your chain to a list or when iterating\nover the chain in Django templates.  If this is not expected, you can convert\nto a list using a workaround like this:</p>\n<pre>list(e for e in some_chain)\n</pre>\n</li>\n<li><p>Indexing on chains uses iteration underneath so performance is weak. This\nfeature is only available as a last resort. Slicing on the other hand is also\nlazy.</p>\n</li>\n<li><p>Collective <tt>filter</tt> and <tt>exclude</tt> silently skip filtering on incompatible\niterables. Use <tt>xfilter(value)</tt> as a workaround.</p>\n</li>\n</ol>\n</div>\n<div id=\"how-do-i-run-the-tests\">\n<h2>How do I run the tests?</h2>\n<p>The easiest way would be to run:</p>\n<pre>$ DJANGO_SETTINGS_MODULE=\"dj._chaintestproject.settings\" django-admin.py test\n</pre>\n</div>\n<div id=\"change-log\">\n<h2>Change Log</h2>\n</div>\n<div id=\"id1\">\n<h2>0.9.2</h2>\n<ul>\n<li>Long overdue Python 3 support (considered experimental)</li>\n</ul>\n<div id=\"id2\">\n<h3>0.9.1</h3>\n<ul>\n<li>support for collective <tt>values</tt> and <tt>values_list</tt> transformations</li>\n<li>support for collective <tt>defer</tt>, <tt>extra</tt>, <tt>only</tt>, <tt>prefetch_related</tt>,\n<tt>select_for_update</tt>, <tt>select_related</tt> and <tt>using</tt> methods (silently\nignored for incompatible iterables)</li>\n<li>strict mode (non-QuerySet objects are not tried for compatibility with\ncollective methods)</li>\n<li>fixed an import error due to incomplete separation from <tt>lck.django</tt></li>\n</ul>\n</div>\n<div id=\"id3\">\n<h3>0.9.0</h3>\n<ul>\n<li>code separated from <tt>lck.django</tt></li>\n<li>support for collective sort using QuerySet-like <tt>order_by</tt> on a chain</li>\n<li>fix for slices with custom steps</li>\n<li>PEP8-fied all sources</li>\n</ul>\n</div>\n</div>\n<div id=\"authors\">\n<h2>Authors</h2>\n<p>Glued together by <a href=\"mailto:lukasz%40langa.pl\">\u0141ukasz Langa</a>.</p>\n</div>\n\n          </div>"}, "last_serial": 648554, "releases": {"0.9.0": [{"comment_text": "", "digests": {"md5": "882bb5a66fe74e1d4162b96634e944d2", "sha256": "792f72788373cf274c835d7b171fa3431b9c6eeec4429147cfb854bbedb3ac91"}, "downloads": -1, "filename": "dj.chain-0.9.0.tar.gz", "has_sig": false, "md5_digest": "882bb5a66fe74e1d4162b96634e944d2", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 14231, "upload_time": "2012-11-06T02:00:03", "upload_time_iso_8601": "2012-11-06T02:00:03.462684Z", "url": "https://files.pythonhosted.org/packages/91/50/398d9fa1f2c456acc1ab3c125ad2538ac586a80c25c34e62acd4491b444a/dj.chain-0.9.0.tar.gz", "yanked": false}], "0.9.1": [{"comment_text": "", "digests": {"md5": "4557f33660d4324ec9f9374921f3f89c", "sha256": "54c0633a764e4d7289f6230765a6b5e35bed5cb8c74b7eba5bfb639b4f75a5f0"}, "downloads": -1, "filename": "dj.chain-0.9.1.tar.gz", "has_sig": false, "md5_digest": "4557f33660d4324ec9f9374921f3f89c", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 17758, "upload_time": "2012-11-16T14:29:55", "upload_time_iso_8601": "2012-11-16T14:29:55.254398Z", "url": "https://files.pythonhosted.org/packages/53/69/132df128f9cca7c276bac96f251db7f434184b095dc34b16f98c34a73c9b/dj.chain-0.9.1.tar.gz", "yanked": false}], "0.9.2": [{"comment_text": "", "digests": {"md5": "539230aa498f8d987cc6112c5684bb26", "sha256": "b52b0820b7939fef4e4f3b2132a40b934149d9433badba8a69acc5f7c46ee47b"}, "downloads": -1, "filename": "dj.chain-0.9.2.tar.gz", "has_sig": false, "md5_digest": "539230aa498f8d987cc6112c5684bb26", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 17993, "upload_time": "2013-03-05T12:33:08", "upload_time_iso_8601": "2013-03-05T12:33:08.737084Z", "url": "https://files.pythonhosted.org/packages/52/ed/d534fa81cb6c9d0b24d933f2c062dbf694045f628de30ee689266e95755e/dj.chain-0.9.2.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "539230aa498f8d987cc6112c5684bb26", "sha256": "b52b0820b7939fef4e4f3b2132a40b934149d9433badba8a69acc5f7c46ee47b"}, "downloads": -1, "filename": "dj.chain-0.9.2.tar.gz", "has_sig": false, "md5_digest": "539230aa498f8d987cc6112c5684bb26", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 17993, "upload_time": "2013-03-05T12:33:08", "upload_time_iso_8601": "2013-03-05T12:33:08.737084Z", "url": "https://files.pythonhosted.org/packages/52/ed/d534fa81cb6c9d0b24d933f2c062dbf694045f628de30ee689266e95755e/dj.chain-0.9.2.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:51:40 2020"}