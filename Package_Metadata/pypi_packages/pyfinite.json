{"info": {"author": "Emin Martinian", "author_email": "emin.martinian@gmail.com", "bugtrack_url": null, "classifiers": ["Development Status :: 3 - Alpha", "Intended Audience :: Developers", "Programming Language :: Python :: 3"], "description": "Introduction\n============\n\nThe ``pyfinite`` package is a python package for dealing with finite\nfields and related mathematical operations. Also included is a generic\nmatrix package for doing matrix operations over generic fields. As an\nillustration a Reed-Solomon erasure correcting code implementation is\nprovided using these tools.\n\nRoughly speaking a \"field\" is a mathematical space where consistent\naddition, subtraction, multiplication, and division operations are\ndefined. A \"finite field\" is a field where the number of elements is\nfinite. Perhaps the most familiar finite field is the Boolean field\nwhere the elements are 0 and 1, addition (and subtraction) correspond to\nXOR, and multiplication (and division) work as normal for 0 and 1.\n\nMore complicated finite fields are useful and interesting for\ncryptography and erasure correcting codes.\n\nUsage\n=====\n\nAfter you install via something like ``pip install pyfinite``, the best\nway to get started is to look at the doctest examples in the following\nfiles:\n\n-  ``ffield.py``: See docstring for ``FField`` and ``FElement`` classes.\n\n   -  This shows you how to work with finite fields.\n\n-  ``genericmatrix.py``: See docstring for ``GenericMatrix`` class.\n\n   -  This shows you how to do matrix operations on a generic field.\n\n-  ``rs_code.py``: See docstring for ``RSCode`` class.\n\n   -  This shows you how to do Reed-Solomon erasure correcting codes.\n\n-  ``file_ecc.py``: See the top-level docstring for the ``file_ecc``\n   module.\n\n   -  Shows you how to encode a file into multiple pieces and decode\n      from a subset of those pieces.\n\nFor example, after you install ``pyfinite`` and start the python\ninterpreter, do something like the following to see help on finite\nfields:\n\n.. code:: python\n\n    >>> from pyfinite import ffield\n    >>> help(ffield.FField)\n\nor if you want to dive right in, you can try something like the\nfollowing:\n\n.. code:: python\n\n    >>> from pyfinite import ffield\n    >>> F = ffield.FField(5) # create the field GF(2^5)\n    >>> a = 7    # field elements are denoted as integers from 0 to 2^5-1\n    >>> b = 15\n    >>> F.ShowPolynomial(a) # show the polynomial representation of a\n    'x^2 + x^1 + 1'\n    >>> c = F.Multiply(a,b) # multiply a and b modulo the field generator\n    >>> c\n    8\n    >>> F.ShowPolynomial(c)\n    'x^3'\n\nAlternatively, you can jump into the ``genericmatrix.py`` package with\nsomething like:\n\n.. code:: python\n\n    >>> import genericmatrix\n    >>> v = genericmatrix.GenericMatrix((3,3))\n    >>> v.SetRow(0,[0.0, -1.0, 1.0])\n    >>> v.SetRow(1,[1.0, 1.0, 1.0])\n    >>> v.SetRow(2,[1.0, 1.0, -1.0])\n    >>> v\n    <matrix\n      0.0 -1.0  1.0\n      1.0  1.0  1.0\n      1.0  1.0 -1.0>\n    >>> vi = v.Inverse()\n\nThen for some real fun, you can try experimenting with generic matrix\noperations on elements of a finite field! The nice thing about the\n``genericmatrix`` module is that it only relies on the standard python\narithmetic operators so you can use it for anything with sane ``+``,\n``-``, ``*``, and ``/`` operators. See the help on ``genericmatrix`` for\nmore info.\n\nFinally, if you just want erasure correction, see the docs for the\n``rs_code`` and ``file_ecc`` modules via something like\n\n.. code:: python\n\n    >>> import rs_code, file_ecc\n    >>> help(file_ecc)\n    >>> help(rs_code)\n\nFuture work\n===========\n\nThis code was written many years ago and hosted on an old MIT web site\nunder the name ``py_ecc`` before being moved to github. It is in need of\nsome love. In particular, it could use:\n\n1. Reworking to fix pep8/pylint warnings and generally better python\n   style.\n2. More documentation.\n3. More examples.\n4. Travis setup to verify doctests in both python2 and python3.\n\n   -  These have been manually verified but it would be nice to have a\n      setup which can run tests on multiple versions of python in an\n      automated way.\n\nTo help or contribute please see the main project site at\nhttps://github.com/emin63/pyfinite.\n", "description_content_type": "", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "http://github.com/emin63/pyfinite", "keywords": "nosql persistence database", "license": "MIT", "maintainer": "", "maintainer_email": "", "name": "pyfinite", "package_url": "https://pypi.org/project/pyfinite/", "platform": "", "project_url": "https://pypi.org/project/pyfinite/", "project_urls": {"Homepage": "http://github.com/emin63/pyfinite"}, "release_url": "https://pypi.org/project/pyfinite/1.7/", "requires_dist": null, "requires_python": "", "summary": "Finite field operations and erasure correction codes.", "version": "1.7", "yanked": false, "html_description": "<div class=\"project-description\">\n            <div id=\"introduction\">\n<h2>Introduction</h2>\n<p>The <tt>pyfinite</tt> package is a python package for dealing with finite\nfields and related mathematical operations. Also included is a generic\nmatrix package for doing matrix operations over generic fields. As an\nillustration a Reed-Solomon erasure correcting code implementation is\nprovided using these tools.</p>\n<p>Roughly speaking a \u201cfield\u201d is a mathematical space where consistent\naddition, subtraction, multiplication, and division operations are\ndefined. A \u201cfinite field\u201d is a field where the number of elements is\nfinite. Perhaps the most familiar finite field is the Boolean field\nwhere the elements are 0 and 1, addition (and subtraction) correspond to\nXOR, and multiplication (and division) work as normal for 0 and 1.</p>\n<p>More complicated finite fields are useful and interesting for\ncryptography and erasure correcting codes.</p>\n</div>\n<div id=\"usage\">\n<h2>Usage</h2>\n<p>After you install via something like <tt>pip install pyfinite</tt>, the best\nway to get started is to look at the doctest examples in the following\nfiles:</p>\n<ul>\n<li><tt>ffield.py</tt>: See docstring for <tt>FField</tt> and <tt>FElement</tt> classes.<ul>\n<li>This shows you how to work with finite fields.</li>\n</ul>\n</li>\n<li><tt>genericmatrix.py</tt>: See docstring for <tt>GenericMatrix</tt> class.<ul>\n<li>This shows you how to do matrix operations on a generic field.</li>\n</ul>\n</li>\n<li><tt>rs_code.py</tt>: See docstring for <tt>RSCode</tt> class.<ul>\n<li>This shows you how to do Reed-Solomon erasure correcting codes.</li>\n</ul>\n</li>\n<li><tt>file_ecc.py</tt>: See the top-level docstring for the <tt>file_ecc</tt>\nmodule.<ul>\n<li>Shows you how to encode a file into multiple pieces and decode\nfrom a subset of those pieces.</li>\n</ul>\n</li>\n</ul>\n<p>For example, after you install <tt>pyfinite</tt> and start the python\ninterpreter, do something like the following to see help on finite\nfields:</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">from</span> <span class=\"nn\">pyfinite</span> <span class=\"kn\">import</span> <span class=\"n\">ffield</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">help</span><span class=\"p\">(</span><span class=\"n\">ffield</span><span class=\"o\">.</span><span class=\"n\">FField</span><span class=\"p\">)</span>\n</pre>\n<p>or if you want to dive right in, you can try something like the\nfollowing:</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">from</span> <span class=\"nn\">pyfinite</span> <span class=\"kn\">import</span> <span class=\"n\">ffield</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">F</span> <span class=\"o\">=</span> <span class=\"n\">ffield</span><span class=\"o\">.</span><span class=\"n\">FField</span><span class=\"p\">(</span><span class=\"mi\">5</span><span class=\"p\">)</span> <span class=\"c1\"># create the field GF(2^5)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">a</span> <span class=\"o\">=</span> <span class=\"mi\">7</span>    <span class=\"c1\"># field elements are denoted as integers from 0 to 2^5-1</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">b</span> <span class=\"o\">=</span> <span class=\"mi\">15</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">F</span><span class=\"o\">.</span><span class=\"n\">ShowPolynomial</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">)</span> <span class=\"c1\"># show the polynomial representation of a</span>\n<span class=\"s1\">'x^2 + x^1 + 1'</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">c</span> <span class=\"o\">=</span> <span class=\"n\">F</span><span class=\"o\">.</span><span class=\"n\">Multiply</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span><span class=\"n\">b</span><span class=\"p\">)</span> <span class=\"c1\"># multiply a and b modulo the field generator</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">c</span>\n<span class=\"mi\">8</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">F</span><span class=\"o\">.</span><span class=\"n\">ShowPolynomial</span><span class=\"p\">(</span><span class=\"n\">c</span><span class=\"p\">)</span>\n<span class=\"s1\">'x^3'</span>\n</pre>\n<p>Alternatively, you can jump into the <tt>genericmatrix.py</tt> package with\nsomething like:</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">import</span> <span class=\"nn\">genericmatrix</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">v</span> <span class=\"o\">=</span> <span class=\"n\">genericmatrix</span><span class=\"o\">.</span><span class=\"n\">GenericMatrix</span><span class=\"p\">((</span><span class=\"mi\">3</span><span class=\"p\">,</span><span class=\"mi\">3</span><span class=\"p\">))</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">v</span><span class=\"o\">.</span><span class=\"n\">SetRow</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,[</span><span class=\"mf\">0.0</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mf\">1.0</span><span class=\"p\">,</span> <span class=\"mf\">1.0</span><span class=\"p\">])</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">v</span><span class=\"o\">.</span><span class=\"n\">SetRow</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,[</span><span class=\"mf\">1.0</span><span class=\"p\">,</span> <span class=\"mf\">1.0</span><span class=\"p\">,</span> <span class=\"mf\">1.0</span><span class=\"p\">])</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">v</span><span class=\"o\">.</span><span class=\"n\">SetRow</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">,[</span><span class=\"mf\">1.0</span><span class=\"p\">,</span> <span class=\"mf\">1.0</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mf\">1.0</span><span class=\"p\">])</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">v</span>\n<span class=\"o\">&lt;</span><span class=\"n\">matrix</span>\n  <span class=\"mf\">0.0</span> <span class=\"o\">-</span><span class=\"mf\">1.0</span>  <span class=\"mf\">1.0</span>\n  <span class=\"mf\">1.0</span>  <span class=\"mf\">1.0</span>  <span class=\"mf\">1.0</span>\n  <span class=\"mf\">1.0</span>  <span class=\"mf\">1.0</span> <span class=\"o\">-</span><span class=\"mf\">1.0</span><span class=\"o\">&gt;</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">vi</span> <span class=\"o\">=</span> <span class=\"n\">v</span><span class=\"o\">.</span><span class=\"n\">Inverse</span><span class=\"p\">()</span>\n</pre>\n<p>Then for some real fun, you can try experimenting with generic matrix\noperations on elements of a finite field! The nice thing about the\n<tt>genericmatrix</tt> module is that it only relies on the standard python\narithmetic operators so you can use it for anything with sane <tt>+</tt>,\n<tt>-</tt>, <tt>*</tt>, and <tt>/</tt> operators. See the help on <tt>genericmatrix</tt> for\nmore info.</p>\n<p>Finally, if you just want erasure correction, see the docs for the\n<tt>rs_code</tt> and <tt>file_ecc</tt> modules via something like</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">import</span> <span class=\"nn\">rs_code</span><span class=\"o\">,</span> <span class=\"nn\">file_ecc</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">help</span><span class=\"p\">(</span><span class=\"n\">file_ecc</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">help</span><span class=\"p\">(</span><span class=\"n\">rs_code</span><span class=\"p\">)</span>\n</pre>\n</div>\n<div id=\"future-work\">\n<h2>Future work</h2>\n<p>This code was written many years ago and hosted on an old MIT web site\nunder the name <tt>py_ecc</tt> before being moved to github. It is in need of\nsome love. In particular, it could use:</p>\n<ol>\n<li>Reworking to fix pep8/pylint warnings and generally better python\nstyle.</li>\n<li>More documentation.</li>\n<li>More examples.</li>\n<li>Travis setup to verify doctests in both python2 and python3.<ul>\n<li>These have been manually verified but it would be nice to have a\nsetup which can run tests on multiple versions of python in an\nautomated way.</li>\n</ul>\n</li>\n</ol>\n<p>To help or contribute please see the main project site at\n<a href=\"https://github.com/emin63/pyfinite\" rel=\"nofollow\">https://github.com/emin63/pyfinite</a>.</p>\n</div>\n\n          </div>"}, "last_serial": 4614957, "releases": {"1.5": [{"comment_text": "", "digests": {"md5": "881b86ec5e5d54803fa93c702370c7eb", "sha256": "2a59c6d98e4f05464600eae1d1f3822409c91358624c0c8bf4c49e102f5a882c"}, "downloads": -1, "filename": "pyfinite-1.5.tar.gz", "has_sig": false, "md5_digest": "881b86ec5e5d54803fa93c702370c7eb", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 23763, "upload_time": "2018-01-04T03:36:12", "upload_time_iso_8601": "2018-01-04T03:36:12.087045Z", "url": "https://files.pythonhosted.org/packages/94/e5/ef9677175556e9612f7cdaa4501b46826a7e07f464e78f929d983dcfeb85/pyfinite-1.5.tar.gz", "yanked": false}], "1.6": [{"comment_text": "", "digests": {"md5": "bbea142dcf0c9a90ed571a71cae99e01", "sha256": "8b1b515320604c0b8079883c4196648744cb7b4168333d4d03ddb166dd2528c0"}, "downloads": -1, "filename": "pyfinite-1.6.tar.gz", "has_sig": false, "md5_digest": "bbea142dcf0c9a90ed571a71cae99e01", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 24740, "upload_time": "2018-10-30T19:03:29", "upload_time_iso_8601": "2018-10-30T19:03:29.725032Z", "url": "https://files.pythonhosted.org/packages/e8/93/78c68e5bfd882a52ac571669e3ac0b7609a64e0a562646cd763a15adee01/pyfinite-1.6.tar.gz", "yanked": false}], "1.7": [{"comment_text": "", "digests": {"md5": "9d16f87c2790aca335217eda419e7e7a", "sha256": "f3cf8daa0f3a5556b8e11008a4c8fd5bf9a60f97dbebe6736737774ccecea39e"}, "downloads": -1, "filename": "pyfinite-1.7.tar.gz", "has_sig": false, "md5_digest": "9d16f87c2790aca335217eda419e7e7a", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 24866, "upload_time": "2018-12-19T03:45:04", "upload_time_iso_8601": "2018-12-19T03:45:04.358037Z", "url": "https://files.pythonhosted.org/packages/ca/d3/c836cdb45006961c7917572d9673a0bd9e9e241df264cccca96cbbca1221/pyfinite-1.7.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "9d16f87c2790aca335217eda419e7e7a", "sha256": "f3cf8daa0f3a5556b8e11008a4c8fd5bf9a60f97dbebe6736737774ccecea39e"}, "downloads": -1, "filename": "pyfinite-1.7.tar.gz", "has_sig": false, "md5_digest": "9d16f87c2790aca335217eda419e7e7a", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 24866, "upload_time": "2018-12-19T03:45:04", "upload_time_iso_8601": "2018-12-19T03:45:04.358037Z", "url": "https://files.pythonhosted.org/packages/ca/d3/c836cdb45006961c7917572d9673a0bd9e9e241df264cccca96cbbca1221/pyfinite-1.7.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:05:47 2020"}