{"info": {"author": "Benjamin Paassen", "author_email": "bpaassen@techfak.uni-bielefeld.de", "bugtrack_url": null, "classifiers": ["License :: OSI Approved :: GNU General Public License v3 (GPLv3)", "Operating System :: OS Independent", "Programming Language :: Python :: 3"], "description": "# Python Edit Distances\n\nCopyright (C) 2019-2020 - Benjamin Paassen  \nMachine Learning Research Group  \nCenter of Excellence Cognitive Interaction Technology (CITEC)  \nBielefeld University\n\nThis program is free software; you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation; either version 3 of the License, or\n(at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program; if not, see <http://www.gnu.org/licenses/>.\n\n## Introduction\n\nThis library contains several edit distance and alignment algorithms for\nsequences and trees of arbitrary node type. Additionally, this library\ncontains multiple backtracing mechanisms for every algorithm in order to\nfacilitate more detailed interpretation and subsequent processing. Finally,\nthis library provides a reference implementation for embedding edit distance\nlearning (BEDL; [Paa\u00dfen et al., 2018][Paa2018]), which enables users to learn\nedit distance parameters instead of specifying them manually.\n\nRefer to the Quickstart Guide for how to use the library and refer to the\nlist below for a full list of the enclosed algorithms. The detailed API\ndocumentation is available at [readthedocs.org](https://edist.readthedocs.io/en/latest/index.html).\n\nIf you use this library in academic work, please cite:\n\n* Paa\u00dfen, B., Mokbel, B., & Hammer, B. (2015). A Toolbox for Adaptive Sequence\n    Dissimilarity Measures for Intelligent Tutoring Systems. In O. C. Santos,\n    J. G. Boticario, C. Romero, M. Pechenizkiy, A. Merceron, P. Mitros,\n    J. M. Luna, et al. (Eds.), Proceedings of the 8th International Conference\n    on Educational Data Mining (pp. 632-632). International Educational\n    Datamining Society. ([Link][Paa2015])\n\nThis library is historically based on its Java version, the\n[TCS Alignment Toolbox][tcs].\n\n## Installation\n\nThis package is available on [pypi][pypi] as `edist`. You can install\nit via\n\n```\npip install edist\n```\n\nIf you wish to build this project from source, you need to first install\n[cython][cython] and then execute the following commands in this directory:\n\n```\npython3 cython_setup.py build_ext --inplace\ncp *so edist/.\n```\n\n## Quickstart Guide\n\nThere are multiple example cases illustrated in our demo notebooks.\nIn particular:\n\n* `sed_demo.ipynb` illustrates the Levenshtein distance\n    (Levenshtein, 1965) and affine edit distance\n    ([Gotoh, 1982][Got1982]) as well as its backtracing,\n* `dtw_demo.ipynb` illustrates dynamic time warping ([Vintsyuk, 1968][Vin1968])\n    as well as its backtracing and speedup measures,\n* `ted_demo.ipynb` illustrates the tree edit distance\n    ([Zhang and Shasha, 1989][Zha1989]) as well as its backtracing and\n    support for edit functions, and\n* `bedl_demo.ipynb` illustrates embedding edit distance learning\n    ([Paa\u00dfen et al., 2018][Paa2018]).\n\nIn general, applying this library works as follows. First, you select the\nedit distance function that best fits for your data and your setting\n(see below for an overview of all available functions). Let's say your\nfunction is called `distfun`. Then, you can compute the distance between two\nlists/trees `x` and `y` via `distfun(x, y)`. If you wish to compute the matrix\nof all pairwise distances for an entire dataset of lists/trees `X`, then you\ncan use the `multiprocess` module as follows.\n\n```\nfrom edist.multiprocess import pairwise_distances_symmetric\nD = pairwise_distances_symmetric(X, distfun)\n```\n\nIf you wish to compute the matrix of all pairwise distances between one\ndataset `X` and another dataset `Y`, you can use the following function.\n\n```\nfrom edist.multiprocess import pairwise_distances\nD = pairwise_distances(X, Y, distfun)\n```\n\nIf you wish to use a custom local distance function `delta`, you can supply\nit as additional argument to either `distfun` itself, to\n`pairwise_distances_symmetric`, or to `pairwise_distances`.\n\nIf you wish to compute the optimal alignment between two lists/trees `x`\nand `y` according to `distfun`, you can use the function\n`distfun_backtrace(x, y)`. Note that, in case of multiple possible optimal\nalignments, this function will always return the option that uses replacements\nas early as possible. If you instead wish to sample a random optimal alignment,\nyou can use `distfun_backtrace_stochastic(x, y)`. Unfortunately, it is\ninfeasible to enumerate the entire set of co-optimal alignments because this\nset may be exponentially large. However, it is possible to characterize the\ndistribution of co-optimal alignments concisely by describing with which\nprobability each node in `x` is paired with each node in `y`. This probability\nmatrix is computed by the function `distfun_backtrace_matrix(x, y)` and follows\nthe forward-backward algorithm developed by [Paa\u00dfen (2018)][Paa2018arxiv].\n\n## List of Algorithms and Functions\n\nThe following edit distance algorithms and functions are contained in this\nlibrary.\n\n* The [Levenshtein distance][Lev]/sequence edit distance (Levenshtein, 1965):\n  * `edist.sed.standard_sed(x, y)` for edit distance computation between\n    sequences `x` and `y` with a cost of 1 for each replacement, deletion,\n    and insertion.\n  * `edist.sed.sed_string(x, y)` for the same, but specifically designed for\n    strings and thus considerably faster (~factor 3).\n  * `edist.sed.standard_sed_backtrace(x, y)` for backtracing for the standard\n    edit distance.\n  * `edist.sed.standard_sed_backtrace_stochastic(x, y)` for the same, but\n    returning a random optimal alignment instead of a fixed one.\n  * `edist.sed.standard_sed_backtrace_matrix(x, y)` for the same, but\n    returning a probability distribution over all pairings between elements\n    of `x` and `y`.\n  * `edist.sed.sed(x, y, delta)` for edit distance computation with a custom\n    element distance function `delta`.\n  * `edist.sed.sed_backtrace(x, y, delta)` for backtracing for the edit\n    distance with a custom element distance function `delta`.\n  * `edist.sed.sed_backtrace_stochastic(x, y, delta)` for the same, but\n    returning a random optimal alignment instead of a fixed one.\n  * `edist.sed.sed_backtrace_matrix(x, y, delta)` for the same, but\n    returning a probability distribution over all pairings between elements\n    of `x` and `y`.\n* The [dynamic time warping][dtw] distance (DTW; [Vintsyuk, 1968][Vin1968]):\n  * `edist.dtw.dtw_numeric(x, y)` for DTW computation between two time\n    series `x` and `y`, each given as a double array.\n  * `edist.dtw.dtw_manhattan(x, y)` for DTW computation between two time\n    series `x` and `y`, each given as a double matrix. The distance between\n    two frames is defined as the Manhattan distance.\n  * `edist.dtw.dtw_euclidean(x, y)` for DTW computation between two time\n    series `x` and `y`, each given as a double matrix. The distance between\n    two frames is defined as the Euclidean distance.\n  * `edist.dtw.dtw_string(x, y)` for DTW computation between two strings\n    `x` and `y`.\n  * `edist.dtw.dtw(x, y, delta)` for DTW computation between two arbitrary\n    sequences `x` and `y` with a custom element distance function `delta`.\n  * `edist.dtw.dtw_backtrace(x, y, delta)` for backtracing for DTW with a\n    custom element distance function `delta`.\n  * `edist.dtw.dtw_backtrace_stochastic(x, y, delta)` for the same, but\n    returning a random optimal alignment instead of a fixed one.\n  * `edist.dtw.dtw_backtrace_matrix(x, y, delta)` for the same, but\n    returning a probability distribution over all pairings between elements\n    of `x` and `y`.\n* The affine edit distance ([Gotoh, 1982][Got1982]):\n  * `edist.aed.aed(x, y, rep, gap, skip)` for affine edit distance computation\n    between two arbitrary sequences `x` and `y`, where each frame replacement\n    is scored with the function `rep`, each deletion and insertion is scored\n    with the function `gap`, and each deletion and insertion extension is\n    scored with the function `skip`.\n  * `edist.aed.aed_backtrace(x, y, rep, gap, skip)` for backtracing for the\n    affine edit distance with the replacement cost function `rep`, the\n    deletion/insertion cost function `gap`, and the gap extension cost function\n    `skip`.\n  * `edist.aed.aed_backtrace_stochastic(x, y, delta)` for the same, but\n    returning a random optimal alignment instead of a fixed one.\n  * `edist.aed.aed_backtrace_matrix(x, y, delta)` for the same, but\n    returning a probability distribution over all pairings between elements\n    of `x` and `y`.\n* The tree edit distance (TED; [Zhang and Shasha, 1989][Zha1989]):\n  * `edist.ted.standard_ted(x_nodes, x_adj, y_nodes, y_adj)` for edit distance\n    computation between the trees `x` and `y`, which are both given in a\n    node list/adjacency list format. Both lists are supposed to be in\n    depth-first-search order, e.g. a tree a(b, c) is supposed to be represented\n    as the two lists `['a', 'b', 'c']` and `[[1, 2], [], []]`. The cost for\n    replacements, deletions, and insertions is fixed to 1.\n  * `edist.ted.standard_ted_backtrace(x_nodes, x_adj, y_nodes, y_adj)`\n    for backtracing for the tree edit distance.\n  * `edist.sed.standard_sed_backtrace_matrix(x_nodes, x_adj, y_nodes, y_adj)`\n    for the same, but returning a probability distribution over all pairings\n    between elements of `x` and `y`.\n  * `edist.ted.ted(x_nodes, x_adj, y_nodes, delta)` for tree edit distance\n    computation with a custom node distance function `delta`.\n  * `edist.ted.ted_backtrace(x_nodes, x_adj, y_nodes, delta)` for backtracing\n    for the tree edit distance with a custom element distance function `delta`.\n  * `edist.ted.ted_backtrace_matrix(x_nodes, x_adj, y_nodes, delta)` for the\n    same, but returning a probability distribution over all pairings between\n    elements of `x` and `y`.\n* The set edit distance (SetED; unpublished, but using the Hungarian algorithm\n    of [Kuhn, 1955][Kuh1955] at its core):\n  * `edist.seted.standard_seted(x, y)` for set edit distance computation\n    between the sets `x` and `y`, which are both given as lists for\n    convenience. The cost for replacements, deletions, and insertions is fixed\n    to 1.\n  * `edist.seted.standard_seted_backtrace(x, y)` for backtracing for the set\n    edit distance.\n  * `edist.seted.seted(x, y, delta)` for set edit distance computation with a\n    custom element distance function `delta`.\n  * `edist.seted.seted_backtrace(x, y, delta)` for backtracing for the set\n    edit distance with a custom element distance function `delta`.\n\nAdditionally, this library contains a few helper modules, namely:\n\n* `edist.adp` contains functions to compute arbitrary sequence edit distances\n    that can be defined by a regular grammar. This is based on the framework\n    of algebraic dynamic programming (ADP; [Giegerich, Meyer, and Steffen, 2004][Gie2004]),\n    as applied by Paa\u00dfen, Mokbel, and Hammer ([2016][Paa2016]). In particular:\n  * `edist.adp.edit_distance(x, y, grammar, deltas)` computes the sequence edit\n    distance defined by the regular grammar `grammar` and the cost functions\n    `deltas` between sequences `x` and `y`,\n  * `edist.adp.backtrace(x, y, grammar, deltas)` computes the backtracing\n    for said edit distance,\n  * `edist.adp.backtrace_stochastic(x, y, grammar, deltas)` does the same,\n    but returns a random optimal alignment instead of a fixed one, and\n  * `edist.adp.backtrace_matrix(x, y, grammar, deltas)` does the same,\n    but returns a probability distribution over all pairings between elements\n    of `x` and `y`.\n* `edist.alignment` models backtraces/alignments between sequences or trees.\n    Instances of class `edist.alignment.Alignment` are returned by every\n    backtrace function (except for `backtrace_matrix` functions).\n* `edist.bedl` supports embedding edit distance learning (BEDL;\n    [Paa\u00dfen et al., 2018][Paa2018]) to learn parameters for edit distance\n    instead of learning them manually. Please refer to the `bedl_demo` for\n    more information.\n* `edist.edits` supports objects that model sequence edits, in particular\n    replacements, deletions, and insertions, and provides the function\n    `alignment_to_script(alignment, x, y)`, which transforms the alignment\n    `alignment` between the sequences `x` and `y` into a list of edits that\n    transform `x` into `y`.\n* `edist.tree_edits` supports objects that model tree edits, in particular\n    replacements, deletions, and insertions, and provides the function\n    `alignment_to_script(alignment, x_nodes, y_adj, y_nodes, y_adj)`, which\n    transforms the alignment `alignment` between the trees `x` and `y` into a\n    list of edits that transform `x` into `y`.\n* `edist.tree_utils` is a collection of supporting functions for tree handling\n    used by the library. Interesting for users of the library may be the\n    following:\n  * `edist.tree_utils.to_json` writes a tree to a JSON file.\n  * `edist.tree_utils.from_json` reads a tree from a JSON file.\n  * `edist.tree_utils.dataset_from_json` reads a list of trees from a\n    directory containing JSON files.\n  * `edist.tree_utils.tree_to_string` formats a tree as a string.\n\n## Background\n\nThe background for all algorithms covered in this library by far exceeds the\nscope of this Readme (we list material for further reading below).\nHowever, there are a few general points that are worth noting in short:\n\n* Edit distance algorithms heavily rely on _dynamic programming_ to be\n  efficient, i.e. to decompose the overall edit distance computation into\n  subtasks and to tabulate the results of these subtasks. In this way, we\n  can search an exponentially large space of possible alignments in polynomial\n  time. However, these decompositions rely on the critical assumption that\n  the element distance function $`\\delta`$ is a metric, especially that this\n  function is non-negative, zero for self-distances, and fulfills the\n  triangular inequality. If any of these assumptions is broken, there may\n  exist cheaper alignments that are not covered by the dynamic programming\n  computation. So this is critical when generating your own $`\\delta`$\n  functions.\n* Interestingly, if $`\\delta`$ is a metric, its metric properties translate\n  to the overall edit distance (refer, e.g., to Theorem 3.2. in\n  [Paa\u00dfen, 2019][Paa2019]). This can make handling edit distances quite\n  appealing, mathematically. However, this does _not_ hold for dynamic time\n  warping, which always violates the triangular inequality.\n* Even though dynamic programming makes edit distances polynomial, computing\n  them can become prohibitively expensive for long sequences/large trees. In\n  particular, any sequence edit distance lies in $`\\mathcal{O}(m \\cdot n)`$,\n  where $`m`$ and $`n`$ are the lengths of the input sequences, the tree\n  edit distance lies in $`\\mathcal{O}(m^2 \\cdot n^2)`$, and the set edit\n  distance in $`\\mathcal{O}((m+n)^3)`$. Fortunately, the [cython][cython]\n  implementation provided in this library is relatively fast and thus can cope\n  with $`m, n`$ even up to a few thousand elements (at least for sequence\n  edits). Still, it is key that you choose the edit distance function that is\n  best fitting to your case. For example, `edist.sed.sed_string` is about\n  factor 15 faster compared to the more general `edist.sed.sed`.\n\nFor more background on the algorithms, we refer to the Wikipedia articles for\nthe [Levenshtein distance][Lev] and [dynamic time warping][dtw], to the paper\nof [Gotoh (1982)][Got1982] with respect to the affine edit distance, to the\nreview paper of [Paa\u00dfen (2018)][Paa2018] with respect to the tree edit distance\nand its backtracing, to Section 2.3.2 of the dissertation of [Paa\u00dfen (2019)][Paa2019]\nwith respect to algebraic dynamic programming, and to Chapter 4 of the same\ndissertation with respect to embedding edit distance learning.\n\n## Licensing\n\nThis library is licensed under the [GNU General Public License Version 3][GPLv3].\n\n## Dependencies\n\nThis library depends on [NumPy][np] for matrix operations, and on [cython][cython]\nfor the effective C-interface. Further, the `bedl.py` module depends on\n[scikit-learn][scikit] for the base interfaces and on [SciPy][scipy] for\noptimization. Finally, the `seted.pyx` module depends on [SciPy][scipy] for\nan implementation of the Hungarian algorithm ([Kuhn, 1955][Kuh1955]).\n\n## Literature\n\n* Giegerich, R., Meyer, C., & Steffen, P. (2004). A discipline of dynamic\n    programming over sequence data. Science of Computer Programming, 51(3),\n    215-263. doi:[10.1016/j.scico.2003.12.005][Gie2004]\n* Gotoh, O. (1982). An improved algorithm for matching biological sequences.\n    Journal of Molecular Biology, 162(3), 705-708. doi:[10.1016/0022-2836(82)90398-9][Got1982]\n* Kuhn, H. (1955). The Hungarian method for the assignment problem.\n    Naval Research Logistics Quarterly, 2(1-2), 83-97. doi:[10.1002/nav.3800020109][Kuh1955]\n* Levenshtein, V. (1965). Binary codes capable of correcting deletions,\n    insertions, and reversals. Soviet Physics Doklady, 10(8), 707-710.\n* Paa\u00dfen, B., Mokbel, B., & Hammer, B. (2015). A Toolbox for Adaptive Sequence\n    Dissimilarity Measures for Intelligent Tutoring Systems. In O. C. Santos,\n    J. G. Boticario, C. Romero, M. Pechenizkiy, A. Merceron, P. Mitros,\n    J. M. Luna, et al. (Eds.), Proceedings of the 8th International Conference\n    on Educational Data Mining (pp. 632-632). International Educational\n    Datamining Society. [Link][Paa2015]\n* Paa\u00dfen, B., Mokbel, B., & Hammer, B. (2016). Adaptive structure metrics for\n    automated feedback provision in intelligent tutoring systems. Neurocomputing,\n    192, 3-13. doi:[10.1016/j.neucom.2015.12.108](https://doi.org/10.1016/j.neucom.2015.12.108).\n    [Link][Paa2016]\n* Paa\u00dfen, B., Gallicchio, C., Micheli, A., & Hammer, B. (2018). Tree Edit\n    Distance Learning via Adaptive Symbol Embeddings. Proceedings of the 35th\n    International Conference on Machine Learning (ICML 2018), 3973-3982.\n    [Link][Paa2018]\n* Paa\u00dfen, B. (2018). Revisiting the tree edit distance and its backtracing:\n    A tutorial. arXiv:[1805.06869][Paa2018arxiv].\n* Paa\u00dfen, B. (2019). Metric Learning for Structured Data. Dissertation.\n    Bielefeld University. doi:[10.4119/unibi/2935545][Paa2019]\n* Vintsyuk, T.K. (1968). Speech discrimination by dynamic programming.\n    Cybernetics, 4(1), 52-57. doi:[10.1007/BF01074755][Vin1968]\n* Zhang, K., & Shasha, D. (1989). Simple Fast Algorithms for the Editing\n    Distance between Trees and Related Problems. SIAM Journal on Computing,\n    18(6), 1245-1262. doi:[10.1137/0218082][Zha1989]\n\n<!-- References -->\n\n[Paa2015]:http://www.educationaldatamining.org/EDM2015/uploads/papers/paper_257.pdf \"Paa\u00dfen, B., Mokbel, B., & Hammer, B. (2015). A Toolbox for Adaptive Sequence Dissimilarity Measures for Intelligent Tutoring Systems. In O. C. Santos, J. G. Boticario, C. Romero, M. Pechenizkiy, A. Merceron, P. Mitros, J. M. Luna, et al. (Eds.), Proceedings of the 8th International Conference on Educational Data Mining (pp. 632-632). International Educational Datamining Society.\"\n[Paa2016]:https://pub.uni-bielefeld.de/record/2783224 \"Paa\u00dfen, B., Mokbel, B., & Hammer, B. (2016). Adaptive structure metrics for automated feedback provision in intelligent tutoring systems. Neurocomputing, 192, 3-13. doi:10.1016/j.neucom.2015.12.108\"\n[Paa2018]:http://proceedings.mlr.press/v80/paassen18a.html \"Paa\u00dfen, B., Gallicchio, C., Micheli, A., & Hammer, B. (2018). Tree Edit Distance Learning via Adaptive Symbol Embeddings. Proceedings of the 35th International Conference on Machine Learning (ICML 2018), 3973-3982.\"\n[Paa2018arxiv]:https://arxiv.org/abs/1805.06869 \"Paa\u00dfen, B. (2018). Revisiting the tree edit distance and its backtracing: A tutorial. arXiv:1805.06869.\"\n[Paa2019]:https://doi.org/10.4119/unibi/2935545 \"Paa\u00dfen, B. (2019). Metric Learning for Structured Data. Dissertation. Bielefeld University. doi:10.4119/unibi/2935545\"\n[Lev]:https://en.wikipedia.org/wiki/Levenshtein_distance \"Wikipedia page on Levenshtein distance.\"\n[dtw]:https://en.wikipedia.org/wiki/Dynamic_time_warping \"Wikipedia page on dynamic time warping.\"\n[Vin1968]:https://doi.org/10.1007/BF01074755 \"Vintsyuk, T.K. (1968). Speech discrimination by dynamic programming. Cybernetics, 4(1), 52-57. doi:10.1007/BF01074755\"\n[Got1982]:https://doi.org/10.1016/0022-2836(82)90398-9 \"Gotoh, O. (1982). An improved algorithm for matching biological sequences. Journal of Molecular Biology, 162(3), 705-708. doi:10.1016/0022-2836(82)90398-9\"\n[Gie2004]:https://doi.org/10.1016/j.scico.2003.12.005 \"Giegerich, R., Meyer, C., & Steffen, P. (2004). A discipline of dynamic programming over sequence data. Science of Computer Programming, 51(3), 215-263. doi:10.1016/j.scico.2003.12.005\"\n[Zha1989]:https://doi.org/10.1137/0218082 \"Zhang, K., & Shasha, D. (1989). Simple Fast Algorithms for the Editing Distance between Trees and Related Problems. SIAM Journal on Computing, 18(6), 1245-1262. doi:10.1137/0218082\"\n[Kuh1955]:https://doi.org/10.1002/nav.3800020109 \"Kuhn, H. (1955). The Hungarian method for the assignment problem. Naval Research Logistics Quarterly, 2(1-2), 83-97. doi:10.1002/nav.3800020109\"\n[tcs]:https://openresearch.cit-ec.de/projects/tcs \"TCS Alignment Toolbox homepage\"\n[pypi]:https://pypi.org/project/edist/ \"PyPi edist project page\"\n[cython]:https://cython.org/ \"cython homepage\"\n[scikit]: https://scikit-learn.org/stable/ \"Scikit-learn homepage\"\n[np]: http://numpy.org/ \"Numpy homepage\"\n[scipy]: https://scipy.org/ \"SciPy homepage\"\n[GPLv3]: https://www.gnu.org/licenses/gpl-3.0.en.html \"The GNU General Public License Version 3\"\n\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://gitlab.ub.uni-bielefeld.de/bpaassen/python-edit-distances", "keywords": "levenshtein-distance dynamic-time-warping sequence-edit-distance sequence-alignment tree-edit-distance algebraic-dynamic-programming", "license": "", "maintainer": "", "maintainer_email": "", "name": "edist", "package_url": "https://pypi.org/project/edist/", "platform": "", "project_url": "https://pypi.org/project/edist/", "project_urls": {"Homepage": "https://gitlab.ub.uni-bielefeld.de/bpaassen/python-edit-distances"}, "release_url": "https://pypi.org/project/edist/1.1.0/", "requires_dist": ["numpy", "scikit-learn", "scipy", "proto-dist-ml"], "requires_python": "", "summary": "Edit distance implementations in cython", "version": "1.1.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>Python Edit Distances</h1>\n<p>Copyright (C) 2019-2020 - Benjamin Paassen<br>\nMachine Learning Research Group<br>\nCenter of Excellence Cognitive Interaction Technology (CITEC)<br>\nBielefeld University</p>\n<p>This program is free software; you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation; either version 3 of the License, or\n(at your option) any later version.</p>\n<p>This program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.</p>\n<p>You should have received a copy of the GNU General Public License\nalong with this program; if not, see <a href=\"http://www.gnu.org/licenses/\" rel=\"nofollow\">http://www.gnu.org/licenses/</a>.</p>\n<h2>Introduction</h2>\n<p>This library contains several edit distance and alignment algorithms for\nsequences and trees of arbitrary node type. Additionally, this library\ncontains multiple backtracing mechanisms for every algorithm in order to\nfacilitate more detailed interpretation and subsequent processing. Finally,\nthis library provides a reference implementation for embedding edit distance\nlearning (BEDL; <a href=\"http://proceedings.mlr.press/v80/paassen18a.html\" rel=\"nofollow\" title=\"Paa\u00dfen, B., Gallicchio, C., Micheli, A., &amp; Hammer, B. (2018). Tree Edit Distance Learning via Adaptive Symbol Embeddings. Proceedings of the 35th International Conference on Machine Learning (ICML 2018), 3973-3982.\">Paa\u00dfen et al., 2018</a>), which enables users to learn\nedit distance parameters instead of specifying them manually.</p>\n<p>Refer to the Quickstart Guide for how to use the library and refer to the\nlist below for a full list of the enclosed algorithms. The detailed API\ndocumentation is available at <a href=\"https://edist.readthedocs.io/en/latest/index.html\" rel=\"nofollow\">readthedocs.org</a>.</p>\n<p>If you use this library in academic work, please cite:</p>\n<ul>\n<li>Paa\u00dfen, B., Mokbel, B., &amp; Hammer, B. (2015). A Toolbox for Adaptive Sequence\nDissimilarity Measures for Intelligent Tutoring Systems. In O. C. Santos,\nJ. G. Boticario, C. Romero, M. Pechenizkiy, A. Merceron, P. Mitros,\nJ. M. Luna, et al. (Eds.), Proceedings of the 8th International Conference\non Educational Data Mining (pp. 632-632). International Educational\nDatamining Society. (<a href=\"http://www.educationaldatamining.org/EDM2015/uploads/papers/paper_257.pdf\" rel=\"nofollow\" title=\"Paa\u00dfen, B., Mokbel, B., &amp; Hammer, B. (2015). A Toolbox for Adaptive Sequence Dissimilarity Measures for Intelligent Tutoring Systems. In O. C. Santos, J. G. Boticario, C. Romero, M. Pechenizkiy, A. Merceron, P. Mitros, J. M. Luna, et al. (Eds.), Proceedings of the 8th International Conference on Educational Data Mining (pp. 632-632). International Educational Datamining Society.\">Link</a>)</li>\n</ul>\n<p>This library is historically based on its Java version, the\n<a href=\"https://openresearch.cit-ec.de/projects/tcs\" rel=\"nofollow\" title=\"TCS Alignment Toolbox homepage\">TCS Alignment Toolbox</a>.</p>\n<h2>Installation</h2>\n<p>This package is available on <a href=\"https://pypi.org/project/edist/\" rel=\"nofollow\" title=\"PyPi edist project page\">pypi</a> as <code>edist</code>. You can install\nit via</p>\n<pre><code>pip install edist\n</code></pre>\n<p>If you wish to build this project from source, you need to first install\n<a href=\"https://cython.org/\" rel=\"nofollow\" title=\"cython homepage\">cython</a> and then execute the following commands in this directory:</p>\n<pre><code>python3 cython_setup.py build_ext --inplace\ncp *so edist/.\n</code></pre>\n<h2>Quickstart Guide</h2>\n<p>There are multiple example cases illustrated in our demo notebooks.\nIn particular:</p>\n<ul>\n<li><code>sed_demo.ipynb</code> illustrates the Levenshtein distance\n(Levenshtein, 1965) and affine edit distance\n(<a href=\"https://doi.org/10.1016/0022-2836(82)90398-9\" rel=\"nofollow\" title=\"Gotoh, O. (1982). An improved algorithm for matching biological sequences. Journal of Molecular Biology, 162(3), 705-708. doi:10.1016/0022-2836(82)90398-9\">Gotoh, 1982</a>) as well as its backtracing,</li>\n<li><code>dtw_demo.ipynb</code> illustrates dynamic time warping (<a href=\"https://doi.org/10.1007/BF01074755\" rel=\"nofollow\" title=\"Vintsyuk, T.K. (1968). Speech discrimination by dynamic programming. Cybernetics, 4(1), 52-57. doi:10.1007/BF01074755\">Vintsyuk, 1968</a>)\nas well as its backtracing and speedup measures,</li>\n<li><code>ted_demo.ipynb</code> illustrates the tree edit distance\n(<a href=\"https://doi.org/10.1137/0218082\" rel=\"nofollow\" title=\"Zhang, K., &amp; Shasha, D. (1989). Simple Fast Algorithms for the Editing Distance between Trees and Related Problems. SIAM Journal on Computing, 18(6), 1245-1262. doi:10.1137/0218082\">Zhang and Shasha, 1989</a>) as well as its backtracing and\nsupport for edit functions, and</li>\n<li><code>bedl_demo.ipynb</code> illustrates embedding edit distance learning\n(<a href=\"http://proceedings.mlr.press/v80/paassen18a.html\" rel=\"nofollow\" title=\"Paa\u00dfen, B., Gallicchio, C., Micheli, A., &amp; Hammer, B. (2018). Tree Edit Distance Learning via Adaptive Symbol Embeddings. Proceedings of the 35th International Conference on Machine Learning (ICML 2018), 3973-3982.\">Paa\u00dfen et al., 2018</a>).</li>\n</ul>\n<p>In general, applying this library works as follows. First, you select the\nedit distance function that best fits for your data and your setting\n(see below for an overview of all available functions). Let's say your\nfunction is called <code>distfun</code>. Then, you can compute the distance between two\nlists/trees <code>x</code> and <code>y</code> via <code>distfun(x, y)</code>. If you wish to compute the matrix\nof all pairwise distances for an entire dataset of lists/trees <code>X</code>, then you\ncan use the <code>multiprocess</code> module as follows.</p>\n<pre><code>from edist.multiprocess import pairwise_distances_symmetric\nD = pairwise_distances_symmetric(X, distfun)\n</code></pre>\n<p>If you wish to compute the matrix of all pairwise distances between one\ndataset <code>X</code> and another dataset <code>Y</code>, you can use the following function.</p>\n<pre><code>from edist.multiprocess import pairwise_distances\nD = pairwise_distances(X, Y, distfun)\n</code></pre>\n<p>If you wish to use a custom local distance function <code>delta</code>, you can supply\nit as additional argument to either <code>distfun</code> itself, to\n<code>pairwise_distances_symmetric</code>, or to <code>pairwise_distances</code>.</p>\n<p>If you wish to compute the optimal alignment between two lists/trees <code>x</code>\nand <code>y</code> according to <code>distfun</code>, you can use the function\n<code>distfun_backtrace(x, y)</code>. Note that, in case of multiple possible optimal\nalignments, this function will always return the option that uses replacements\nas early as possible. If you instead wish to sample a random optimal alignment,\nyou can use <code>distfun_backtrace_stochastic(x, y)</code>. Unfortunately, it is\ninfeasible to enumerate the entire set of co-optimal alignments because this\nset may be exponentially large. However, it is possible to characterize the\ndistribution of co-optimal alignments concisely by describing with which\nprobability each node in <code>x</code> is paired with each node in <code>y</code>. This probability\nmatrix is computed by the function <code>distfun_backtrace_matrix(x, y)</code> and follows\nthe forward-backward algorithm developed by <a href=\"https://arxiv.org/abs/1805.06869\" rel=\"nofollow\" title=\"Paa\u00dfen, B. (2018). Revisiting the tree edit distance and its backtracing: A tutorial. arXiv:1805.06869.\">Paa\u00dfen (2018)</a>.</p>\n<h2>List of Algorithms and Functions</h2>\n<p>The following edit distance algorithms and functions are contained in this\nlibrary.</p>\n<ul>\n<li>The <a href=\"https://en.wikipedia.org/wiki/Levenshtein_distance\" rel=\"nofollow\" title=\"Wikipedia page on Levenshtein distance.\">Levenshtein distance</a>/sequence edit distance (Levenshtein, 1965):\n<ul>\n<li><code>edist.sed.standard_sed(x, y)</code> for edit distance computation between\nsequences <code>x</code> and <code>y</code> with a cost of 1 for each replacement, deletion,\nand insertion.</li>\n<li><code>edist.sed.sed_string(x, y)</code> for the same, but specifically designed for\nstrings and thus considerably faster (~factor 3).</li>\n<li><code>edist.sed.standard_sed_backtrace(x, y)</code> for backtracing for the standard\nedit distance.</li>\n<li><code>edist.sed.standard_sed_backtrace_stochastic(x, y)</code> for the same, but\nreturning a random optimal alignment instead of a fixed one.</li>\n<li><code>edist.sed.standard_sed_backtrace_matrix(x, y)</code> for the same, but\nreturning a probability distribution over all pairings between elements\nof <code>x</code> and <code>y</code>.</li>\n<li><code>edist.sed.sed(x, y, delta)</code> for edit distance computation with a custom\nelement distance function <code>delta</code>.</li>\n<li><code>edist.sed.sed_backtrace(x, y, delta)</code> for backtracing for the edit\ndistance with a custom element distance function <code>delta</code>.</li>\n<li><code>edist.sed.sed_backtrace_stochastic(x, y, delta)</code> for the same, but\nreturning a random optimal alignment instead of a fixed one.</li>\n<li><code>edist.sed.sed_backtrace_matrix(x, y, delta)</code> for the same, but\nreturning a probability distribution over all pairings between elements\nof <code>x</code> and <code>y</code>.</li>\n</ul>\n</li>\n<li>The <a href=\"https://en.wikipedia.org/wiki/Dynamic_time_warping\" rel=\"nofollow\" title=\"Wikipedia page on dynamic time warping.\">dynamic time warping</a> distance (DTW; <a href=\"https://doi.org/10.1007/BF01074755\" rel=\"nofollow\" title=\"Vintsyuk, T.K. (1968). Speech discrimination by dynamic programming. Cybernetics, 4(1), 52-57. doi:10.1007/BF01074755\">Vintsyuk, 1968</a>):\n<ul>\n<li><code>edist.dtw.dtw_numeric(x, y)</code> for DTW computation between two time\nseries <code>x</code> and <code>y</code>, each given as a double array.</li>\n<li><code>edist.dtw.dtw_manhattan(x, y)</code> for DTW computation between two time\nseries <code>x</code> and <code>y</code>, each given as a double matrix. The distance between\ntwo frames is defined as the Manhattan distance.</li>\n<li><code>edist.dtw.dtw_euclidean(x, y)</code> for DTW computation between two time\nseries <code>x</code> and <code>y</code>, each given as a double matrix. The distance between\ntwo frames is defined as the Euclidean distance.</li>\n<li><code>edist.dtw.dtw_string(x, y)</code> for DTW computation between two strings\n<code>x</code> and <code>y</code>.</li>\n<li><code>edist.dtw.dtw(x, y, delta)</code> for DTW computation between two arbitrary\nsequences <code>x</code> and <code>y</code> with a custom element distance function <code>delta</code>.</li>\n<li><code>edist.dtw.dtw_backtrace(x, y, delta)</code> for backtracing for DTW with a\ncustom element distance function <code>delta</code>.</li>\n<li><code>edist.dtw.dtw_backtrace_stochastic(x, y, delta)</code> for the same, but\nreturning a random optimal alignment instead of a fixed one.</li>\n<li><code>edist.dtw.dtw_backtrace_matrix(x, y, delta)</code> for the same, but\nreturning a probability distribution over all pairings between elements\nof <code>x</code> and <code>y</code>.</li>\n</ul>\n</li>\n<li>The affine edit distance (<a href=\"https://doi.org/10.1016/0022-2836(82)90398-9\" rel=\"nofollow\" title=\"Gotoh, O. (1982). An improved algorithm for matching biological sequences. Journal of Molecular Biology, 162(3), 705-708. doi:10.1016/0022-2836(82)90398-9\">Gotoh, 1982</a>):\n<ul>\n<li><code>edist.aed.aed(x, y, rep, gap, skip)</code> for affine edit distance computation\nbetween two arbitrary sequences <code>x</code> and <code>y</code>, where each frame replacement\nis scored with the function <code>rep</code>, each deletion and insertion is scored\nwith the function <code>gap</code>, and each deletion and insertion extension is\nscored with the function <code>skip</code>.</li>\n<li><code>edist.aed.aed_backtrace(x, y, rep, gap, skip)</code> for backtracing for the\naffine edit distance with the replacement cost function <code>rep</code>, the\ndeletion/insertion cost function <code>gap</code>, and the gap extension cost function\n<code>skip</code>.</li>\n<li><code>edist.aed.aed_backtrace_stochastic(x, y, delta)</code> for the same, but\nreturning a random optimal alignment instead of a fixed one.</li>\n<li><code>edist.aed.aed_backtrace_matrix(x, y, delta)</code> for the same, but\nreturning a probability distribution over all pairings between elements\nof <code>x</code> and <code>y</code>.</li>\n</ul>\n</li>\n<li>The tree edit distance (TED; <a href=\"https://doi.org/10.1137/0218082\" rel=\"nofollow\" title=\"Zhang, K., &amp; Shasha, D. (1989). Simple Fast Algorithms for the Editing Distance between Trees and Related Problems. SIAM Journal on Computing, 18(6), 1245-1262. doi:10.1137/0218082\">Zhang and Shasha, 1989</a>):\n<ul>\n<li><code>edist.ted.standard_ted(x_nodes, x_adj, y_nodes, y_adj)</code> for edit distance\ncomputation between the trees <code>x</code> and <code>y</code>, which are both given in a\nnode list/adjacency list format. Both lists are supposed to be in\ndepth-first-search order, e.g. a tree a(b, c) is supposed to be represented\nas the two lists <code>['a', 'b', 'c']</code> and <code>[[1, 2], [], []]</code>. The cost for\nreplacements, deletions, and insertions is fixed to 1.</li>\n<li><code>edist.ted.standard_ted_backtrace(x_nodes, x_adj, y_nodes, y_adj)</code>\nfor backtracing for the tree edit distance.</li>\n<li><code>edist.sed.standard_sed_backtrace_matrix(x_nodes, x_adj, y_nodes, y_adj)</code>\nfor the same, but returning a probability distribution over all pairings\nbetween elements of <code>x</code> and <code>y</code>.</li>\n<li><code>edist.ted.ted(x_nodes, x_adj, y_nodes, delta)</code> for tree edit distance\ncomputation with a custom node distance function <code>delta</code>.</li>\n<li><code>edist.ted.ted_backtrace(x_nodes, x_adj, y_nodes, delta)</code> for backtracing\nfor the tree edit distance with a custom element distance function <code>delta</code>.</li>\n<li><code>edist.ted.ted_backtrace_matrix(x_nodes, x_adj, y_nodes, delta)</code> for the\nsame, but returning a probability distribution over all pairings between\nelements of <code>x</code> and <code>y</code>.</li>\n</ul>\n</li>\n<li>The set edit distance (SetED; unpublished, but using the Hungarian algorithm\nof <a href=\"https://doi.org/10.1002/nav.3800020109\" rel=\"nofollow\" title=\"Kuhn, H. (1955). The Hungarian method for the assignment problem. Naval Research Logistics Quarterly, 2(1-2), 83-97. doi:10.1002/nav.3800020109\">Kuhn, 1955</a> at its core):\n<ul>\n<li><code>edist.seted.standard_seted(x, y)</code> for set edit distance computation\nbetween the sets <code>x</code> and <code>y</code>, which are both given as lists for\nconvenience. The cost for replacements, deletions, and insertions is fixed\nto 1.</li>\n<li><code>edist.seted.standard_seted_backtrace(x, y)</code> for backtracing for the set\nedit distance.</li>\n<li><code>edist.seted.seted(x, y, delta)</code> for set edit distance computation with a\ncustom element distance function <code>delta</code>.</li>\n<li><code>edist.seted.seted_backtrace(x, y, delta)</code> for backtracing for the set\nedit distance with a custom element distance function <code>delta</code>.</li>\n</ul>\n</li>\n</ul>\n<p>Additionally, this library contains a few helper modules, namely:</p>\n<ul>\n<li><code>edist.adp</code> contains functions to compute arbitrary sequence edit distances\nthat can be defined by a regular grammar. This is based on the framework\nof algebraic dynamic programming (ADP; <a href=\"https://doi.org/10.1016/j.scico.2003.12.005\" rel=\"nofollow\" title=\"Giegerich, R., Meyer, C., &amp; Steffen, P. (2004). A discipline of dynamic programming over sequence data. Science of Computer Programming, 51(3), 215-263. doi:10.1016/j.scico.2003.12.005\">Giegerich, Meyer, and Steffen, 2004</a>),\nas applied by Paa\u00dfen, Mokbel, and Hammer (<a href=\"https://pub.uni-bielefeld.de/record/2783224\" rel=\"nofollow\" title=\"Paa\u00dfen, B., Mokbel, B., &amp; Hammer, B. (2016). Adaptive structure metrics for automated feedback provision in intelligent tutoring systems. Neurocomputing, 192, 3-13. doi:10.1016/j.neucom.2015.12.108\">2016</a>). In particular:\n<ul>\n<li><code>edist.adp.edit_distance(x, y, grammar, deltas)</code> computes the sequence edit\ndistance defined by the regular grammar <code>grammar</code> and the cost functions\n<code>deltas</code> between sequences <code>x</code> and <code>y</code>,</li>\n<li><code>edist.adp.backtrace(x, y, grammar, deltas)</code> computes the backtracing\nfor said edit distance,</li>\n<li><code>edist.adp.backtrace_stochastic(x, y, grammar, deltas)</code> does the same,\nbut returns a random optimal alignment instead of a fixed one, and</li>\n<li><code>edist.adp.backtrace_matrix(x, y, grammar, deltas)</code> does the same,\nbut returns a probability distribution over all pairings between elements\nof <code>x</code> and <code>y</code>.</li>\n</ul>\n</li>\n<li><code>edist.alignment</code> models backtraces/alignments between sequences or trees.\nInstances of class <code>edist.alignment.Alignment</code> are returned by every\nbacktrace function (except for <code>backtrace_matrix</code> functions).</li>\n<li><code>edist.bedl</code> supports embedding edit distance learning (BEDL;\n<a href=\"http://proceedings.mlr.press/v80/paassen18a.html\" rel=\"nofollow\" title=\"Paa\u00dfen, B., Gallicchio, C., Micheli, A., &amp; Hammer, B. (2018). Tree Edit Distance Learning via Adaptive Symbol Embeddings. Proceedings of the 35th International Conference on Machine Learning (ICML 2018), 3973-3982.\">Paa\u00dfen et al., 2018</a>) to learn parameters for edit distance\ninstead of learning them manually. Please refer to the <code>bedl_demo</code> for\nmore information.</li>\n<li><code>edist.edits</code> supports objects that model sequence edits, in particular\nreplacements, deletions, and insertions, and provides the function\n<code>alignment_to_script(alignment, x, y)</code>, which transforms the alignment\n<code>alignment</code> between the sequences <code>x</code> and <code>y</code> into a list of edits that\ntransform <code>x</code> into <code>y</code>.</li>\n<li><code>edist.tree_edits</code> supports objects that model tree edits, in particular\nreplacements, deletions, and insertions, and provides the function\n<code>alignment_to_script(alignment, x_nodes, y_adj, y_nodes, y_adj)</code>, which\ntransforms the alignment <code>alignment</code> between the trees <code>x</code> and <code>y</code> into a\nlist of edits that transform <code>x</code> into <code>y</code>.</li>\n<li><code>edist.tree_utils</code> is a collection of supporting functions for tree handling\nused by the library. Interesting for users of the library may be the\nfollowing:\n<ul>\n<li><code>edist.tree_utils.to_json</code> writes a tree to a JSON file.</li>\n<li><code>edist.tree_utils.from_json</code> reads a tree from a JSON file.</li>\n<li><code>edist.tree_utils.dataset_from_json</code> reads a list of trees from a\ndirectory containing JSON files.</li>\n<li><code>edist.tree_utils.tree_to_string</code> formats a tree as a string.</li>\n</ul>\n</li>\n</ul>\n<h2>Background</h2>\n<p>The background for all algorithms covered in this library by far exceeds the\nscope of this Readme (we list material for further reading below).\nHowever, there are a few general points that are worth noting in short:</p>\n<ul>\n<li>Edit distance algorithms heavily rely on <em>dynamic programming</em> to be\nefficient, i.e. to decompose the overall edit distance computation into\nsubtasks and to tabulate the results of these subtasks. In this way, we\ncan search an exponentially large space of possible alignments in polynomial\ntime. However, these decompositions rely on the critical assumption that\nthe element distance function $<code>\\delta</code>$ is a metric, especially that this\nfunction is non-negative, zero for self-distances, and fulfills the\ntriangular inequality. If any of these assumptions is broken, there may\nexist cheaper alignments that are not covered by the dynamic programming\ncomputation. So this is critical when generating your own $<code>\\delta</code>$\nfunctions.</li>\n<li>Interestingly, if $<code>\\delta</code>$ is a metric, its metric properties translate\nto the overall edit distance (refer, e.g., to Theorem 3.2. in\n<a href=\"https://doi.org/10.4119/unibi/2935545\" rel=\"nofollow\" title=\"Paa\u00dfen, B. (2019). Metric Learning for Structured Data. Dissertation. Bielefeld University. doi:10.4119/unibi/2935545\">Paa\u00dfen, 2019</a>). This can make handling edit distances quite\nappealing, mathematically. However, this does <em>not</em> hold for dynamic time\nwarping, which always violates the triangular inequality.</li>\n<li>Even though dynamic programming makes edit distances polynomial, computing\nthem can become prohibitively expensive for long sequences/large trees. In\nparticular, any sequence edit distance lies in $<code>\\mathcal{O}(m \\cdot n)</code>$,\nwhere $<code>m</code>$ and $<code>n</code>$ are the lengths of the input sequences, the tree\nedit distance lies in $<code>\\mathcal{O}(m^2 \\cdot n^2)</code>$, and the set edit\ndistance in $<code>\\mathcal{O}((m+n)^3)</code>$. Fortunately, the <a href=\"https://cython.org/\" rel=\"nofollow\" title=\"cython homepage\">cython</a>\nimplementation provided in this library is relatively fast and thus can cope\nwith $<code>m, n</code>$ even up to a few thousand elements (at least for sequence\nedits). Still, it is key that you choose the edit distance function that is\nbest fitting to your case. For example, <code>edist.sed.sed_string</code> is about\nfactor 15 faster compared to the more general <code>edist.sed.sed</code>.</li>\n</ul>\n<p>For more background on the algorithms, we refer to the Wikipedia articles for\nthe <a href=\"https://en.wikipedia.org/wiki/Levenshtein_distance\" rel=\"nofollow\" title=\"Wikipedia page on Levenshtein distance.\">Levenshtein distance</a> and <a href=\"https://en.wikipedia.org/wiki/Dynamic_time_warping\" rel=\"nofollow\" title=\"Wikipedia page on dynamic time warping.\">dynamic time warping</a>, to the paper\nof <a href=\"https://doi.org/10.1016/0022-2836(82)90398-9\" rel=\"nofollow\" title=\"Gotoh, O. (1982). An improved algorithm for matching biological sequences. Journal of Molecular Biology, 162(3), 705-708. doi:10.1016/0022-2836(82)90398-9\">Gotoh (1982)</a> with respect to the affine edit distance, to the\nreview paper of <a href=\"http://proceedings.mlr.press/v80/paassen18a.html\" rel=\"nofollow\" title=\"Paa\u00dfen, B., Gallicchio, C., Micheli, A., &amp; Hammer, B. (2018). Tree Edit Distance Learning via Adaptive Symbol Embeddings. Proceedings of the 35th International Conference on Machine Learning (ICML 2018), 3973-3982.\">Paa\u00dfen (2018)</a> with respect to the tree edit distance\nand its backtracing, to Section 2.3.2 of the dissertation of <a href=\"https://doi.org/10.4119/unibi/2935545\" rel=\"nofollow\" title=\"Paa\u00dfen, B. (2019). Metric Learning for Structured Data. Dissertation. Bielefeld University. doi:10.4119/unibi/2935545\">Paa\u00dfen (2019)</a>\nwith respect to algebraic dynamic programming, and to Chapter 4 of the same\ndissertation with respect to embedding edit distance learning.</p>\n<h2>Licensing</h2>\n<p>This library is licensed under the <a href=\"https://www.gnu.org/licenses/gpl-3.0.en.html\" rel=\"nofollow\" title=\"The GNU General Public License Version 3\">GNU General Public License Version 3</a>.</p>\n<h2>Dependencies</h2>\n<p>This library depends on <a href=\"http://numpy.org/\" rel=\"nofollow\" title=\"Numpy homepage\">NumPy</a> for matrix operations, and on <a href=\"https://cython.org/\" rel=\"nofollow\" title=\"cython homepage\">cython</a>\nfor the effective C-interface. Further, the <code>bedl.py</code> module depends on\n<a href=\"https://scikit-learn.org/stable/\" rel=\"nofollow\" title=\"Scikit-learn homepage\">scikit-learn</a> for the base interfaces and on <a href=\"https://scipy.org/\" rel=\"nofollow\" title=\"SciPy homepage\">SciPy</a> for\noptimization. Finally, the <code>seted.pyx</code> module depends on <a href=\"https://scipy.org/\" rel=\"nofollow\" title=\"SciPy homepage\">SciPy</a> for\nan implementation of the Hungarian algorithm (<a href=\"https://doi.org/10.1002/nav.3800020109\" rel=\"nofollow\" title=\"Kuhn, H. (1955). The Hungarian method for the assignment problem. Naval Research Logistics Quarterly, 2(1-2), 83-97. doi:10.1002/nav.3800020109\">Kuhn, 1955</a>).</p>\n<h2>Literature</h2>\n<ul>\n<li>Giegerich, R., Meyer, C., &amp; Steffen, P. (2004). A discipline of dynamic\nprogramming over sequence data. Science of Computer Programming, 51(3),\n215-263. doi:<a href=\"https://doi.org/10.1016/j.scico.2003.12.005\" rel=\"nofollow\" title=\"Giegerich, R., Meyer, C., &amp; Steffen, P. (2004). A discipline of dynamic programming over sequence data. Science of Computer Programming, 51(3), 215-263. doi:10.1016/j.scico.2003.12.005\">10.1016/j.scico.2003.12.005</a></li>\n<li>Gotoh, O. (1982). An improved algorithm for matching biological sequences.\nJournal of Molecular Biology, 162(3), 705-708. doi:<a href=\"https://doi.org/10.1016/0022-2836(82)90398-9\" rel=\"nofollow\" title=\"Gotoh, O. (1982). An improved algorithm for matching biological sequences. Journal of Molecular Biology, 162(3), 705-708. doi:10.1016/0022-2836(82)90398-9\">10.1016/0022-2836(82)90398-9</a></li>\n<li>Kuhn, H. (1955). The Hungarian method for the assignment problem.\nNaval Research Logistics Quarterly, 2(1-2), 83-97. doi:<a href=\"https://doi.org/10.1002/nav.3800020109\" rel=\"nofollow\" title=\"Kuhn, H. (1955). The Hungarian method for the assignment problem. Naval Research Logistics Quarterly, 2(1-2), 83-97. doi:10.1002/nav.3800020109\">10.1002/nav.3800020109</a></li>\n<li>Levenshtein, V. (1965). Binary codes capable of correcting deletions,\ninsertions, and reversals. Soviet Physics Doklady, 10(8), 707-710.</li>\n<li>Paa\u00dfen, B., Mokbel, B., &amp; Hammer, B. (2015). A Toolbox for Adaptive Sequence\nDissimilarity Measures for Intelligent Tutoring Systems. In O. C. Santos,\nJ. G. Boticario, C. Romero, M. Pechenizkiy, A. Merceron, P. Mitros,\nJ. M. Luna, et al. (Eds.), Proceedings of the 8th International Conference\non Educational Data Mining (pp. 632-632). International Educational\nDatamining Society. <a href=\"http://www.educationaldatamining.org/EDM2015/uploads/papers/paper_257.pdf\" rel=\"nofollow\" title=\"Paa\u00dfen, B., Mokbel, B., &amp; Hammer, B. (2015). A Toolbox for Adaptive Sequence Dissimilarity Measures for Intelligent Tutoring Systems. In O. C. Santos, J. G. Boticario, C. Romero, M. Pechenizkiy, A. Merceron, P. Mitros, J. M. Luna, et al. (Eds.), Proceedings of the 8th International Conference on Educational Data Mining (pp. 632-632). International Educational Datamining Society.\">Link</a></li>\n<li>Paa\u00dfen, B., Mokbel, B., &amp; Hammer, B. (2016). Adaptive structure metrics for\nautomated feedback provision in intelligent tutoring systems. Neurocomputing,\n192, 3-13. doi:<a href=\"https://doi.org/10.1016/j.neucom.2015.12.108\" rel=\"nofollow\">10.1016/j.neucom.2015.12.108</a>.\n<a href=\"https://pub.uni-bielefeld.de/record/2783224\" rel=\"nofollow\" title=\"Paa\u00dfen, B., Mokbel, B., &amp; Hammer, B. (2016). Adaptive structure metrics for automated feedback provision in intelligent tutoring systems. Neurocomputing, 192, 3-13. doi:10.1016/j.neucom.2015.12.108\">Link</a></li>\n<li>Paa\u00dfen, B., Gallicchio, C., Micheli, A., &amp; Hammer, B. (2018). Tree Edit\nDistance Learning via Adaptive Symbol Embeddings. Proceedings of the 35th\nInternational Conference on Machine Learning (ICML 2018), 3973-3982.\n<a href=\"http://proceedings.mlr.press/v80/paassen18a.html\" rel=\"nofollow\" title=\"Paa\u00dfen, B., Gallicchio, C., Micheli, A., &amp; Hammer, B. (2018). Tree Edit Distance Learning via Adaptive Symbol Embeddings. Proceedings of the 35th International Conference on Machine Learning (ICML 2018), 3973-3982.\">Link</a></li>\n<li>Paa\u00dfen, B. (2018). Revisiting the tree edit distance and its backtracing:\nA tutorial. arXiv:<a href=\"https://arxiv.org/abs/1805.06869\" rel=\"nofollow\" title=\"Paa\u00dfen, B. (2018). Revisiting the tree edit distance and its backtracing: A tutorial. arXiv:1805.06869.\">1805.06869</a>.</li>\n<li>Paa\u00dfen, B. (2019). Metric Learning for Structured Data. Dissertation.\nBielefeld University. doi:<a href=\"https://doi.org/10.4119/unibi/2935545\" rel=\"nofollow\" title=\"Paa\u00dfen, B. (2019). Metric Learning for Structured Data. Dissertation. Bielefeld University. doi:10.4119/unibi/2935545\">10.4119/unibi/2935545</a></li>\n<li>Vintsyuk, T.K. (1968). Speech discrimination by dynamic programming.\nCybernetics, 4(1), 52-57. doi:<a href=\"https://doi.org/10.1007/BF01074755\" rel=\"nofollow\" title=\"Vintsyuk, T.K. (1968). Speech discrimination by dynamic programming. Cybernetics, 4(1), 52-57. doi:10.1007/BF01074755\">10.1007/BF01074755</a></li>\n<li>Zhang, K., &amp; Shasha, D. (1989). Simple Fast Algorithms for the Editing\nDistance between Trees and Related Problems. SIAM Journal on Computing,\n18(6), 1245-1262. doi:<a href=\"https://doi.org/10.1137/0218082\" rel=\"nofollow\" title=\"Zhang, K., &amp; Shasha, D. (1989). Simple Fast Algorithms for the Editing Distance between Trees and Related Problems. SIAM Journal on Computing, 18(6), 1245-1262. doi:10.1137/0218082\">10.1137/0218082</a></li>\n</ul>\n\n\n          </div>"}, "last_serial": 7094566, "releases": {"1.0.0": [{"comment_text": "", "digests": {"md5": "b53b80bc9eab5f63b79dc17de441cdbd", "sha256": "4218e2cbe9a6ef8928090eaaf3a1da412b07571bec86f512b995a68ec17734c4"}, "downloads": -1, "filename": "edist-1.0.0-cp37-cp37m-manylinux1_x86_64.whl", "has_sig": false, "md5_digest": "b53b80bc9eab5f63b79dc17de441cdbd", "packagetype": "bdist_wheel", "python_version": "cp37", "requires_python": null, "size": 3129126, "upload_time": "2019-08-22T09:37:32", "upload_time_iso_8601": "2019-08-22T09:37:32.383438Z", "url": "https://files.pythonhosted.org/packages/12/d6/bf5a32b3df4e1eda46119e5536bf4888f2c18e438216b584a8b3ead6b6ae/edist-1.0.0-cp37-cp37m-manylinux1_x86_64.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "f82346df633d65fe565338fe10c432ab", "sha256": "ed339e6b0857ff8cdd896e72c5c84c3ab9f30416eef7ad61765572d79345560d"}, "downloads": -1, "filename": "edist-1.0.0-cp37-cp37m-manylinux2010_x86_64.whl", "has_sig": false, "md5_digest": "f82346df633d65fe565338fe10c432ab", "packagetype": "bdist_wheel", "python_version": "cp37", "requires_python": null, "size": 3129129, "upload_time": "2019-08-22T09:37:38", "upload_time_iso_8601": "2019-08-22T09:37:38.300465Z", "url": "https://files.pythonhosted.org/packages/f6/74/e88ddac93dcaa7a0808b55c249e102d79dec469d2cf0c18036f29a9d7107/edist-1.0.0-cp37-cp37m-manylinux2010_x86_64.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "69a94faa123d85a0366c0f21eda4f6dc", "sha256": "eb67b56a55359ecbeba85450c35ae23894531510c1dc8b23f8b5cf5f3c43a4f8"}, "downloads": -1, "filename": "edist-1.0.0.tar.gz", "has_sig": false, "md5_digest": "69a94faa123d85a0366c0f21eda4f6dc", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 757570, "upload_time": "2019-08-22T09:37:41", "upload_time_iso_8601": "2019-08-22T09:37:41.435864Z", "url": "https://files.pythonhosted.org/packages/3f/e7/a07c6a15b6a83729b8bfb1150ff213e70d60f51442ea441e02ef8a4fdef0/edist-1.0.0.tar.gz", "yanked": false}], "1.1.0": [{"comment_text": "", "digests": {"md5": "ecd4f9be1aaaa9a498fd5336501aeb29", "sha256": "95641c6f963f466f07a54ec60fa2897c0eb2e732876af222abc80d6f77c7b031"}, "downloads": -1, "filename": "edist-1.1.0-cp37-cp37m-manylinux1_x86_64.whl", "has_sig": false, "md5_digest": "ecd4f9be1aaaa9a498fd5336501aeb29", "packagetype": "bdist_wheel", "python_version": "cp37", "requires_python": null, "size": 3545040, "upload_time": "2020-04-24T17:14:09", "upload_time_iso_8601": "2020-04-24T17:14:09.011403Z", "url": "https://files.pythonhosted.org/packages/f5/e9/2fdd4691fa32e0ee20afa0fabadc63341088803e496516e336dea59a7807/edist-1.1.0-cp37-cp37m-manylinux1_x86_64.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "148281b6055de91b00480f7942d7c895", "sha256": "57aa4c76fb989dac94c6b1298a1b1552244b80cb12b867d459fd1bb948cf2646"}, "downloads": -1, "filename": "edist-1.1.0-cp37-cp37m-manylinux2010_x86_64.whl", "has_sig": false, "md5_digest": "148281b6055de91b00480f7942d7c895", "packagetype": "bdist_wheel", "python_version": "cp37", "requires_python": null, "size": 3545045, "upload_time": "2020-04-24T17:14:14", "upload_time_iso_8601": "2020-04-24T17:14:14.034725Z", "url": "https://files.pythonhosted.org/packages/af/17/fbe4b9741c00dc184dda4c898fe57617810664e432a4b435f930da1ed42e/edist-1.1.0-cp37-cp37m-manylinux2010_x86_64.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "a6bf7f36a21a05604521449f2a35737d", "sha256": "3d83e0ec5004e5c4a952527df2c3300d976a18ff31250f3917b9cd97f0742238"}, "downloads": -1, "filename": "edist-1.1.0-cp37-cp37m-manylinux2014_x86_64.whl", "has_sig": false, "md5_digest": "a6bf7f36a21a05604521449f2a35737d", "packagetype": "bdist_wheel", "python_version": "cp37", "requires_python": null, "size": 3298560, "upload_time": "2020-04-24T16:25:19", "upload_time_iso_8601": "2020-04-24T16:25:19.243857Z", "url": "https://files.pythonhosted.org/packages/c7/e9/7d0f82e2e9b3714b27a336bcbf037d22b0ef0ec625eb552ed7e796421390/edist-1.1.0-cp37-cp37m-manylinux2014_x86_64.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "b1a4bba6563f7196dfd5c7b66980cda4", "sha256": "da37ef0fff4855c9c4178a700907d059773a67e99b50b58f45834a26b5d0fd2c"}, "downloads": -1, "filename": "edist-1.1.0-cp38-cp38-manylinux1_x86_64.whl", "has_sig": false, "md5_digest": "b1a4bba6563f7196dfd5c7b66980cda4", "packagetype": "bdist_wheel", "python_version": "cp38", "requires_python": null, "size": 4179897, "upload_time": "2020-04-24T17:14:20", "upload_time_iso_8601": "2020-04-24T17:14:20.754457Z", "url": "https://files.pythonhosted.org/packages/d7/6e/014f6fd682ffc8ff362ae14d83ce58c5dd71245db0f27645fa24967493f4/edist-1.1.0-cp38-cp38-manylinux1_x86_64.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "dfe6b8473c743f4ed2c24c42c695f859", "sha256": "5954f781475ef97cbc30bbf172e56b1eab580a146277601bdc99bdfe2785f500"}, "downloads": -1, "filename": "edist-1.1.0-cp38-cp38-manylinux2010_x86_64.whl", "has_sig": false, "md5_digest": "dfe6b8473c743f4ed2c24c42c695f859", "packagetype": "bdist_wheel", "python_version": "cp38", "requires_python": null, "size": 4179900, "upload_time": "2020-04-24T17:14:26", "upload_time_iso_8601": "2020-04-24T17:14:26.311422Z", "url": "https://files.pythonhosted.org/packages/b6/f7/064f60cbfa80cd074ab278aa2c2ad139e148a827a8edd1828ae89b43d505/edist-1.1.0-cp38-cp38-manylinux2010_x86_64.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "9e4900273346b9ee647190c6b8aa81bd", "sha256": "afea331acf5d7932da3625ce8799b766fd3f9798ce5aea43b94e9d3fa3aa6bab"}, "downloads": -1, "filename": "edist-1.1.0-cp38-cp38-manylinux2014_x86_64.whl", "has_sig": false, "md5_digest": "9e4900273346b9ee647190c6b8aa81bd", "packagetype": "bdist_wheel", "python_version": "cp38", "requires_python": null, "size": 3820207, "upload_time": "2020-04-24T16:13:07", "upload_time_iso_8601": "2020-04-24T16:13:07.092726Z", "url": "https://files.pythonhosted.org/packages/83/60/5a3d7345e392724254d678c1cc8ee03f1e208f8f4ed05a80c50dc9273f5c/edist-1.1.0-cp38-cp38-manylinux2014_x86_64.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "6da5b2663b087d4232d4c128d98ab12d", "sha256": "b7cc851edd56feceb3959c575e080b9b93dc5152abc3d1137c6af2cc43e89675"}, "downloads": -1, "filename": "edist-1.1.0.tar.gz", "has_sig": false, "md5_digest": "6da5b2663b087d4232d4c128d98ab12d", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 898574, "upload_time": "2020-04-24T16:13:10", "upload_time_iso_8601": "2020-04-24T16:13:10.675064Z", "url": "https://files.pythonhosted.org/packages/3b/f0/c50afd1c0fc2ff4c0aa08421da87b7746cae3f03a67870b243e78ea316ae/edist-1.1.0.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "ecd4f9be1aaaa9a498fd5336501aeb29", "sha256": "95641c6f963f466f07a54ec60fa2897c0eb2e732876af222abc80d6f77c7b031"}, "downloads": -1, "filename": "edist-1.1.0-cp37-cp37m-manylinux1_x86_64.whl", "has_sig": false, "md5_digest": "ecd4f9be1aaaa9a498fd5336501aeb29", "packagetype": "bdist_wheel", "python_version": "cp37", "requires_python": null, "size": 3545040, "upload_time": "2020-04-24T17:14:09", "upload_time_iso_8601": "2020-04-24T17:14:09.011403Z", "url": "https://files.pythonhosted.org/packages/f5/e9/2fdd4691fa32e0ee20afa0fabadc63341088803e496516e336dea59a7807/edist-1.1.0-cp37-cp37m-manylinux1_x86_64.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "148281b6055de91b00480f7942d7c895", "sha256": "57aa4c76fb989dac94c6b1298a1b1552244b80cb12b867d459fd1bb948cf2646"}, "downloads": -1, "filename": "edist-1.1.0-cp37-cp37m-manylinux2010_x86_64.whl", "has_sig": false, "md5_digest": "148281b6055de91b00480f7942d7c895", "packagetype": "bdist_wheel", "python_version": "cp37", "requires_python": null, "size": 3545045, "upload_time": "2020-04-24T17:14:14", "upload_time_iso_8601": "2020-04-24T17:14:14.034725Z", "url": "https://files.pythonhosted.org/packages/af/17/fbe4b9741c00dc184dda4c898fe57617810664e432a4b435f930da1ed42e/edist-1.1.0-cp37-cp37m-manylinux2010_x86_64.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "a6bf7f36a21a05604521449f2a35737d", "sha256": "3d83e0ec5004e5c4a952527df2c3300d976a18ff31250f3917b9cd97f0742238"}, "downloads": -1, "filename": "edist-1.1.0-cp37-cp37m-manylinux2014_x86_64.whl", "has_sig": false, "md5_digest": "a6bf7f36a21a05604521449f2a35737d", "packagetype": "bdist_wheel", "python_version": "cp37", "requires_python": null, "size": 3298560, "upload_time": "2020-04-24T16:25:19", "upload_time_iso_8601": "2020-04-24T16:25:19.243857Z", "url": "https://files.pythonhosted.org/packages/c7/e9/7d0f82e2e9b3714b27a336bcbf037d22b0ef0ec625eb552ed7e796421390/edist-1.1.0-cp37-cp37m-manylinux2014_x86_64.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "b1a4bba6563f7196dfd5c7b66980cda4", "sha256": "da37ef0fff4855c9c4178a700907d059773a67e99b50b58f45834a26b5d0fd2c"}, "downloads": -1, "filename": "edist-1.1.0-cp38-cp38-manylinux1_x86_64.whl", "has_sig": false, "md5_digest": "b1a4bba6563f7196dfd5c7b66980cda4", "packagetype": "bdist_wheel", "python_version": "cp38", "requires_python": null, "size": 4179897, "upload_time": "2020-04-24T17:14:20", "upload_time_iso_8601": "2020-04-24T17:14:20.754457Z", "url": "https://files.pythonhosted.org/packages/d7/6e/014f6fd682ffc8ff362ae14d83ce58c5dd71245db0f27645fa24967493f4/edist-1.1.0-cp38-cp38-manylinux1_x86_64.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "dfe6b8473c743f4ed2c24c42c695f859", "sha256": "5954f781475ef97cbc30bbf172e56b1eab580a146277601bdc99bdfe2785f500"}, "downloads": -1, "filename": "edist-1.1.0-cp38-cp38-manylinux2010_x86_64.whl", "has_sig": false, "md5_digest": "dfe6b8473c743f4ed2c24c42c695f859", "packagetype": "bdist_wheel", "python_version": "cp38", "requires_python": null, "size": 4179900, "upload_time": "2020-04-24T17:14:26", "upload_time_iso_8601": "2020-04-24T17:14:26.311422Z", "url": "https://files.pythonhosted.org/packages/b6/f7/064f60cbfa80cd074ab278aa2c2ad139e148a827a8edd1828ae89b43d505/edist-1.1.0-cp38-cp38-manylinux2010_x86_64.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "9e4900273346b9ee647190c6b8aa81bd", "sha256": "afea331acf5d7932da3625ce8799b766fd3f9798ce5aea43b94e9d3fa3aa6bab"}, "downloads": -1, "filename": "edist-1.1.0-cp38-cp38-manylinux2014_x86_64.whl", "has_sig": false, "md5_digest": "9e4900273346b9ee647190c6b8aa81bd", "packagetype": "bdist_wheel", "python_version": "cp38", "requires_python": null, "size": 3820207, "upload_time": "2020-04-24T16:13:07", "upload_time_iso_8601": "2020-04-24T16:13:07.092726Z", "url": "https://files.pythonhosted.org/packages/83/60/5a3d7345e392724254d678c1cc8ee03f1e208f8f4ed05a80c50dc9273f5c/edist-1.1.0-cp38-cp38-manylinux2014_x86_64.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "6da5b2663b087d4232d4c128d98ab12d", "sha256": "b7cc851edd56feceb3959c575e080b9b93dc5152abc3d1137c6af2cc43e89675"}, "downloads": -1, "filename": "edist-1.1.0.tar.gz", "has_sig": false, "md5_digest": "6da5b2663b087d4232d4c128d98ab12d", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 898574, "upload_time": "2020-04-24T16:13:10", "upload_time_iso_8601": "2020-04-24T16:13:10.675064Z", "url": "https://files.pythonhosted.org/packages/3b/f0/c50afd1c0fc2ff4c0aa08421da87b7746cae3f03a67870b243e78ea316ae/edist-1.1.0.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:47:44 2020"}