{"info": {"author": "Erez Shinan, Evandro Coan", "author_email": "erezshin@gmail.com", "bugtrack_url": null, "classifiers": ["Development Status :: 1 - Planning", "Environment :: Console", "Intended Audience :: Developers", "License :: OSI Approved :: MIT License", "Operating System :: OS Independent", "Programming Language :: Python", "Programming Language :: Python :: 2", "Programming Language :: Python :: 2.7", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.3", "Programming Language :: Python :: 3.4", "Programming Language :: Python :: 3.5", "Programming Language :: Python :: 3.6", "Topic :: Software Development :: Libraries :: Python Modules", "Topic :: Text Processing :: General", "Topic :: Text Processing :: Linguistic"], "description": "# Pushdown - a modern parsing library for Python\n\nThis project is a fork from https://github.com/lark-parser/lark,\nand the new name transition still in progress.\nThen,\nuntil this process is complete,\nyou should see the name `Lark` several places.\n\nParse any context-free grammar, FAST and EASY!\n\n**Beginners**:\nLark is not just another parser.\nIt can parse any grammar you throw at it,\nno matter how complicated or ambiguous,\nand do so efficiently.\nIt also constructs a parse-tree for you,\nwithout additional code on your part.\n\n**Experts**:\nLark lets you choose between Earley and LALR(1),\nto trade-off power and speed.\nIt also contains a CYK parser and unique features such as a contextual-lexer.\n\nLark can:\n\n - Parse all context-free grammars, and handle all ambiguity\n - Build a parse-tree automagically, no construction code required\n - Outperform all other Python libraries when using LALR(1) (Yes, including PLY)\n - Run on every Python interpreter (it's pure-python)\n - Generate a stand-alone parser (for LALR(1) grammars)\n\nAnd many more features. Read ahead and find out.\n\nMost importantly,\nLark will save you time and prevent you from getting parsing headaches.\n\n\n### Quick links\n\n- [Tutorial](/docs/json_tutorial.md) for writing a JSON parser.\n\n\n### Install pushdown\n\n    $ pip install pushdown\n\nPushdown has no dependencies.\n\n\n### Syntax Highlighting (new)\n\nLark now provides syntax highlighting for its grammar files (\\*.lark):\n\n- [Sublime Text & TextMate](https://github.com/evandroforks/lark_syntax)\n\n\n### Hello World\n\nHere is a little program to parse \"Hello, World!\" (Or any other similar phrase):\n\n```python\nfrom lark import Lark\n\nl = Lark('''start: WORD \",\" WORD \"!\"\n\n            %import common.WORD   // imports from terminal library\n            %ignore \" \"           // Disregard spaces in text\n         ''')\n\nprint( l.parse(\"Hello, World!\") )\n```\n\nAnd the output is:\n\n```python\nTree(start, [Token(WORD, 'Hello'), Token(WORD, 'World')])\n```\n\nNotice punctuation doesn't appear in the resulting tree. It's automatically filtered away by Lark.\n\n\n### Fruit flies like bananas\n\nLark is great at handling ambiguity. Let's parse the phrase \"fruit flies like bananas\":\n\n![fruitflies.png](examples/fruitflies.png)\n\nSee more [examples in the wiki](https://github.com/erezsh/lark/wiki/Examples)\n\n\n\n## List of main features\n\n - Builds a parse-tree (AST) automagically, based on the structure of the grammar\n - **Earley** parser\n    - Can parse all context-free grammars\n    - Full support for ambiguous grammars\n - **LALR(1)** parser\n    - Fast and light, competitive with PLY\n    - Can generate a stand-alone parser\n - **CYK** parser, for highly ambiguous grammars (NEW! Courtesy of [ehudt](https://github.com/ehudt))\n - **EBNF** grammar\n - **Unicode** fully supported\n - **Python 2 & 3** compatible\n - Automatic line & column tracking\n - Standard library of terminals (strings, numbers, names, etc.)\n - Import grammars from Nearley.js\n - And much more!\n\nSee the full list of [features in the wiki](https://github.com/erezsh/lark/wiki/Features)\n\n\n### Comparison to other libraries\n\n#### Performance comparison\n\nLark is the fastest and lightest (lower is better)\n\n![Run-time Comparison](docs/comparison_runtime.png)\n\n![Memory Usage Comparison](docs/comparison_memory.png)\n\n\nCheck out the [JSON tutorial](/docs/json_tutorial.md#conclusion) for more details on how the comparison was made.\n\n*Note: I really wanted to add PLY to the benchmark, but I couldn't find a working JSON parser anywhere written in PLY. If anyone can point me to one that actually works, I would be happy to add it!*\n\n\n#### Feature comparison\n\n| Library | Algorithm | Grammar | Builds tree? | Supports ambiguity? | Can handle every CFG? | Line/Column tracking | Generates Stand-alone\n|:--------|:----------|:----|:--------|:------------|:------------|:----------|:----------\n| **Lark** | Earley/LALR(1) | EBNF | Yes! | Yes! | Yes! | Yes! | Yes! (LALR only) |\n| [PLY](http://www.dabeaz.com/ply/) | LALR(1) | BNF | No | No | No | No | No |\n| [PyParsing](http://pyparsing.wikispaces.com/) | PEG | Combinators | No | No | No\\* | No | No |\n| [Parsley](https://pypi.python.org/pypi/Parsley) | PEG | EBNF | No | No | No\\* | No | No |\n| [funcparserlib](https://github.com/vlasovskikh/funcparserlib) | Recursive-Descent | Combinators | No | No | No | No | No |\n| [Parsimonious](https://github.com/erikrose/parsimonious) | PEG | EBNF | Yes | No | No\\* | No | No |\n| [ANTLR](https://github.com/antlr/antlr4) | LL(*) | EBNF | Yes | No | Yes? | Yes | No |\n\n\n(\\* *PEGs cannot handle non-deterministic grammars. Also, according to Wikipedia, it remains unanswered whether PEGs can really parse all deterministic CFGs*)\n\n\n### Projects using Lark\n\n - [mappyfile](https://github.com/geographika/mappyfile) - a MapFile parser for working with MapServer configuration\n - [pytreeview](https://gitlab.com/parmenti/pytreeview) - a lightweight tree-based grammar explorer\n - [tartiflette](https://github.com/dailymotion/tartiflette) - a GraphQL engine by Dailymotion (Lark is used to parse the GraphQL schemas definitions)\n\nUsing Lark? Send me a message and I'll add your project!\n\n\n### How to use Nearley grammars in Lark\n\nLark comes with a tool to convert grammars from [Nearley](https://github.com/Hardmath123/nearley), a popular Earley library for Javascript. It uses [Js2Py](https://github.com/PiotrDabkowski/Js2Py) to convert and run the Javascript postprocessing code segments.\n\nHere's an example:\n```bash\ngit clone https://github.com/Hardmath123/nearley\npython -m lark.tools.nearley nearley/examples/calculator/arithmetic.ne main nearley > ncalc.py\n```\n\nYou can use the output as a regular python module:\n\n```python\n>>> import ncalc\n>>> ncalc.parse('sin(pi/4) ^ e')\n0.38981434460254655\n```\n\n\n## License\n\nLark uses the [MIT license](LICENSE).\n\n(The standalone tool is under GPL2)\n\n\n## Contribute\n\nLark is currently accepting pull-requests.\n\nThere are many ways you can help the project:\n\n* Help solve issues\n* Improve the documentation\n* Write new grammars for Lark's library\n* Write a blog post introducing Lark to your audience\n* Port Lark to another language\n* Help me with code developemnt\n\nIf you're interested in taking one of these on, let me know and I will provide more details and assist you in the process.\n\n\n## Donate\n\nFor the original project called `lark-parser`, see: https://github.com/lark-parser/lark#donate\n\n\n## Contact\n\nFor the original project called `lark-parser`, see: https://github.com/lark-parser/lark#contact\n\nFor this fork project called `pushdown`,\nopen a new issue on:\nhttps://github.com/evandrocoan/pushdown/issues", "description_content_type": "text/markdown", "docs_url": null, "download_url": "https://github.com/evandrocoan/pushdown/archive/master.zip", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/evandrocoan/pushdown", "keywords": "Earley LALR parser parsing ast", "license": "MIT", "maintainer": "", "maintainer_email": "", "name": "pushdown", "package_url": "https://pypi.org/project/pushdown/", "platform": "", "project_url": "https://pypi.org/project/pushdown/", "project_urls": {"Download": "https://github.com/evandrocoan/pushdown/archive/master.zip", "Homepage": "https://github.com/evandrocoan/pushdown"}, "release_url": "https://pypi.org/project/pushdown/0.6.7/", "requires_dist": null, "requires_python": "", "summary": "A fork form lark-parser, a modern parsing library", "version": "0.6.7", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>Pushdown - a modern parsing library for Python</h1>\n<p>This project is a fork from <a href=\"https://github.com/lark-parser/lark\" rel=\"nofollow\">https://github.com/lark-parser/lark</a>,\nand the new name transition still in progress.\nThen,\nuntil this process is complete,\nyou should see the name <code>Lark</code> several places.</p>\n<p>Parse any context-free grammar, FAST and EASY!</p>\n<p><strong>Beginners</strong>:\nLark is not just another parser.\nIt can parse any grammar you throw at it,\nno matter how complicated or ambiguous,\nand do so efficiently.\nIt also constructs a parse-tree for you,\nwithout additional code on your part.</p>\n<p><strong>Experts</strong>:\nLark lets you choose between Earley and LALR(1),\nto trade-off power and speed.\nIt also contains a CYK parser and unique features such as a contextual-lexer.</p>\n<p>Lark can:</p>\n<ul>\n<li>Parse all context-free grammars, and handle all ambiguity</li>\n<li>Build a parse-tree automagically, no construction code required</li>\n<li>Outperform all other Python libraries when using LALR(1) (Yes, including PLY)</li>\n<li>Run on every Python interpreter (it's pure-python)</li>\n<li>Generate a stand-alone parser (for LALR(1) grammars)</li>\n</ul>\n<p>And many more features. Read ahead and find out.</p>\n<p>Most importantly,\nLark will save you time and prevent you from getting parsing headaches.</p>\n<h3>Quick links</h3>\n<ul>\n<li><a href=\"/docs/json_tutorial.md\" rel=\"nofollow\">Tutorial</a> for writing a JSON parser.</li>\n</ul>\n<h3>Install pushdown</h3>\n<pre><code>$ pip install pushdown\n</code></pre>\n<p>Pushdown has no dependencies.</p>\n<h3>Syntax Highlighting (new)</h3>\n<p>Lark now provides syntax highlighting for its grammar files (*.lark):</p>\n<ul>\n<li><a href=\"https://github.com/evandroforks/lark_syntax\" rel=\"nofollow\">Sublime Text &amp; TextMate</a></li>\n</ul>\n<h3>Hello World</h3>\n<p>Here is a little program to parse \"Hello, World!\" (Or any other similar phrase):</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">lark</span> <span class=\"kn\">import</span> <span class=\"n\">Lark</span>\n\n<span class=\"n\">l</span> <span class=\"o\">=</span> <span class=\"n\">Lark</span><span class=\"p\">(</span><span class=\"s1\">'''start: WORD \",\" WORD \"!\"</span>\n\n<span class=\"s1\">            </span><span class=\"si\">%i</span><span class=\"s1\">mport common.WORD   // imports from terminal library</span>\n<span class=\"s1\">            </span><span class=\"si\">%i</span><span class=\"s1\">gnore \" \"           // Disregard spaces in text</span>\n<span class=\"s1\">         '''</span><span class=\"p\">)</span>\n\n<span class=\"nb\">print</span><span class=\"p\">(</span> <span class=\"n\">l</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"s2\">\"Hello, World!\"</span><span class=\"p\">)</span> <span class=\"p\">)</span>\n</pre>\n<p>And the output is:</p>\n<pre><span class=\"n\">Tree</span><span class=\"p\">(</span><span class=\"n\">start</span><span class=\"p\">,</span> <span class=\"p\">[</span><span class=\"n\">Token</span><span class=\"p\">(</span><span class=\"n\">WORD</span><span class=\"p\">,</span> <span class=\"s1\">'Hello'</span><span class=\"p\">),</span> <span class=\"n\">Token</span><span class=\"p\">(</span><span class=\"n\">WORD</span><span class=\"p\">,</span> <span class=\"s1\">'World'</span><span class=\"p\">)])</span>\n</pre>\n<p>Notice punctuation doesn't appear in the resulting tree. It's automatically filtered away by Lark.</p>\n<h3>Fruit flies like bananas</h3>\n<p>Lark is great at handling ambiguity. Let's parse the phrase \"fruit flies like bananas\":</p>\n<p><img alt=\"fruitflies.png\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/256ee38a321533a8e204dbc3cc984866a05af148/6578616d706c65732f6672756974666c6965732e706e67\"></p>\n<p>See more <a href=\"https://github.com/erezsh/lark/wiki/Examples\" rel=\"nofollow\">examples in the wiki</a></p>\n<h2>List of main features</h2>\n<ul>\n<li>Builds a parse-tree (AST) automagically, based on the structure of the grammar</li>\n<li><strong>Earley</strong> parser\n<ul>\n<li>Can parse all context-free grammars</li>\n<li>Full support for ambiguous grammars</li>\n</ul>\n</li>\n<li><strong>LALR(1)</strong> parser\n<ul>\n<li>Fast and light, competitive with PLY</li>\n<li>Can generate a stand-alone parser</li>\n</ul>\n</li>\n<li><strong>CYK</strong> parser, for highly ambiguous grammars (NEW! Courtesy of <a href=\"https://github.com/ehudt\" rel=\"nofollow\">ehudt</a>)</li>\n<li><strong>EBNF</strong> grammar</li>\n<li><strong>Unicode</strong> fully supported</li>\n<li><strong>Python 2 &amp; 3</strong> compatible</li>\n<li>Automatic line &amp; column tracking</li>\n<li>Standard library of terminals (strings, numbers, names, etc.)</li>\n<li>Import grammars from Nearley.js</li>\n<li>And much more!</li>\n</ul>\n<p>See the full list of <a href=\"https://github.com/erezsh/lark/wiki/Features\" rel=\"nofollow\">features in the wiki</a></p>\n<h3>Comparison to other libraries</h3>\n<h4>Performance comparison</h4>\n<p>Lark is the fastest and lightest (lower is better)</p>\n<p><img alt=\"Run-time Comparison\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/45f8cb59e3cc57797cded5ec50e2d041b4be6024/646f63732f636f6d70617269736f6e5f72756e74696d652e706e67\"></p>\n<p><img alt=\"Memory Usage Comparison\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/ba43d2daec82fd5628b2e3a7100caf246da1bcc5/646f63732f636f6d70617269736f6e5f6d656d6f72792e706e67\"></p>\n<p>Check out the <a href=\"/docs/json_tutorial.md#conclusion\" rel=\"nofollow\">JSON tutorial</a> for more details on how the comparison was made.</p>\n<p><em>Note: I really wanted to add PLY to the benchmark, but I couldn't find a working JSON parser anywhere written in PLY. If anyone can point me to one that actually works, I would be happy to add it!</em></p>\n<h4>Feature comparison</h4>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Library</th>\n<th align=\"left\">Algorithm</th>\n<th align=\"left\">Grammar</th>\n<th align=\"left\">Builds tree?</th>\n<th align=\"left\">Supports ambiguity?</th>\n<th align=\"left\">Can handle every CFG?</th>\n<th align=\"left\">Line/Column tracking</th>\n<th align=\"left\">Generates Stand-alone</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\"><strong>Lark</strong></td>\n<td align=\"left\">Earley/LALR(1)</td>\n<td align=\"left\">EBNF</td>\n<td align=\"left\">Yes!</td>\n<td align=\"left\">Yes!</td>\n<td align=\"left\">Yes!</td>\n<td align=\"left\">Yes!</td>\n<td align=\"left\">Yes! (LALR only)</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"http://www.dabeaz.com/ply/\" rel=\"nofollow\">PLY</a></td>\n<td align=\"left\">LALR(1)</td>\n<td align=\"left\">BNF</td>\n<td align=\"left\">No</td>\n<td align=\"left\">No</td>\n<td align=\"left\">No</td>\n<td align=\"left\">No</td>\n<td align=\"left\">No</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"http://pyparsing.wikispaces.com/\" rel=\"nofollow\">PyParsing</a></td>\n<td align=\"left\">PEG</td>\n<td align=\"left\">Combinators</td>\n<td align=\"left\">No</td>\n<td align=\"left\">No</td>\n<td align=\"left\">No*</td>\n<td align=\"left\">No</td>\n<td align=\"left\">No</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://pypi.python.org/pypi/Parsley\" rel=\"nofollow\">Parsley</a></td>\n<td align=\"left\">PEG</td>\n<td align=\"left\">EBNF</td>\n<td align=\"left\">No</td>\n<td align=\"left\">No</td>\n<td align=\"left\">No*</td>\n<td align=\"left\">No</td>\n<td align=\"left\">No</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://github.com/vlasovskikh/funcparserlib\" rel=\"nofollow\">funcparserlib</a></td>\n<td align=\"left\">Recursive-Descent</td>\n<td align=\"left\">Combinators</td>\n<td align=\"left\">No</td>\n<td align=\"left\">No</td>\n<td align=\"left\">No</td>\n<td align=\"left\">No</td>\n<td align=\"left\">No</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://github.com/erikrose/parsimonious\" rel=\"nofollow\">Parsimonious</a></td>\n<td align=\"left\">PEG</td>\n<td align=\"left\">EBNF</td>\n<td align=\"left\">Yes</td>\n<td align=\"left\">No</td>\n<td align=\"left\">No*</td>\n<td align=\"left\">No</td>\n<td align=\"left\">No</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://github.com/antlr/antlr4\" rel=\"nofollow\">ANTLR</a></td>\n<td align=\"left\">LL(*)</td>\n<td align=\"left\">EBNF</td>\n<td align=\"left\">Yes</td>\n<td align=\"left\">No</td>\n<td align=\"left\">Yes?</td>\n<td align=\"left\">Yes</td>\n<td align=\"left\">No</td>\n</tr></tbody></table>\n<p>(* <em>PEGs cannot handle non-deterministic grammars. Also, according to Wikipedia, it remains unanswered whether PEGs can really parse all deterministic CFGs</em>)</p>\n<h3>Projects using Lark</h3>\n<ul>\n<li><a href=\"https://github.com/geographika/mappyfile\" rel=\"nofollow\">mappyfile</a> - a MapFile parser for working with MapServer configuration</li>\n<li><a href=\"https://gitlab.com/parmenti/pytreeview\" rel=\"nofollow\">pytreeview</a> - a lightweight tree-based grammar explorer</li>\n<li><a href=\"https://github.com/dailymotion/tartiflette\" rel=\"nofollow\">tartiflette</a> - a GraphQL engine by Dailymotion (Lark is used to parse the GraphQL schemas definitions)</li>\n</ul>\n<p>Using Lark? Send me a message and I'll add your project!</p>\n<h3>How to use Nearley grammars in Lark</h3>\n<p>Lark comes with a tool to convert grammars from <a href=\"https://github.com/Hardmath123/nearley\" rel=\"nofollow\">Nearley</a>, a popular Earley library for Javascript. It uses <a href=\"https://github.com/PiotrDabkowski/Js2Py\" rel=\"nofollow\">Js2Py</a> to convert and run the Javascript postprocessing code segments.</p>\n<p>Here's an example:</p>\n<pre>git clone https://github.com/Hardmath123/nearley\npython -m lark.tools.nearley nearley/examples/calculator/arithmetic.ne main nearley &gt; ncalc.py\n</pre>\n<p>You can use the output as a regular python module:</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">import</span> <span class=\"nn\">ncalc</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">ncalc</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"s1\">'sin(pi/4) ^ e'</span><span class=\"p\">)</span>\n<span class=\"mf\">0.38981434460254655</span>\n</pre>\n<h2>License</h2>\n<p>Lark uses the <a href=\"LICENSE\" rel=\"nofollow\">MIT license</a>.</p>\n<p>(The standalone tool is under GPL2)</p>\n<h2>Contribute</h2>\n<p>Lark is currently accepting pull-requests.</p>\n<p>There are many ways you can help the project:</p>\n<ul>\n<li>Help solve issues</li>\n<li>Improve the documentation</li>\n<li>Write new grammars for Lark's library</li>\n<li>Write a blog post introducing Lark to your audience</li>\n<li>Port Lark to another language</li>\n<li>Help me with code developemnt</li>\n</ul>\n<p>If you're interested in taking one of these on, let me know and I will provide more details and assist you in the process.</p>\n<h2>Donate</h2>\n<p>For the original project called <code>lark-parser</code>, see: <a href=\"https://github.com/lark-parser/lark#donate\" rel=\"nofollow\">https://github.com/lark-parser/lark#donate</a></p>\n<h2>Contact</h2>\n<p>For the original project called <code>lark-parser</code>, see: <a href=\"https://github.com/lark-parser/lark#contact\" rel=\"nofollow\">https://github.com/lark-parser/lark#contact</a></p>\n<p>For this fork project called <code>pushdown</code>,\nopen a new issue on:\n<a href=\"https://github.com/evandrocoan/pushdown/issues\" rel=\"nofollow\">https://github.com/evandrocoan/pushdown/issues</a></p>\n\n          </div>"}, "last_serial": 4425468, "releases": {"0.6.7": [{"comment_text": "", "digests": {"md5": "4af1e0e51e55d84a1c1c2d11f4be8ade", "sha256": "e1e9469c2774c6f1e10b6a1ce5ad1832b66f9046f075d7c7bb325200963e80f7"}, "downloads": -1, "filename": "pushdown-0.6.7.tar.gz", "has_sig": false, "md5_digest": "4af1e0e51e55d84a1c1c2d11f4be8ade", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 261310, "upload_time": "2018-10-28T23:16:53", "upload_time_iso_8601": "2018-10-28T23:16:53.311182Z", "url": "https://files.pythonhosted.org/packages/c7/3a/9d3230aa6bf5471b4b035bb6a633f806d23c0d93837d8b18c7cb40e6ea11/pushdown-0.6.7.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "4af1e0e51e55d84a1c1c2d11f4be8ade", "sha256": "e1e9469c2774c6f1e10b6a1ce5ad1832b66f9046f075d7c7bb325200963e80f7"}, "downloads": -1, "filename": "pushdown-0.6.7.tar.gz", "has_sig": false, "md5_digest": "4af1e0e51e55d84a1c1c2d11f4be8ade", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 261310, "upload_time": "2018-10-28T23:16:53", "upload_time_iso_8601": "2018-10-28T23:16:53.311182Z", "url": "https://files.pythonhosted.org/packages/c7/3a/9d3230aa6bf5471b4b035bb6a633f806d23c0d93837d8b18c7cb40e6ea11/pushdown-0.6.7.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:13:12 2020"}