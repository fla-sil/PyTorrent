{"info": {"author": "Jarn", "author_email": "info@jarn.com", "bugtrack_url": null, "classifiers": ["Framework :: Plone", "Framework :: Plone :: 4.0", "Framework :: Plone :: 4.1", "Framework :: Plone :: 4.2", "Framework :: Plone :: 4.3", "Framework :: Zope2", "Framework :: Zope3", "License :: OSI Approved :: GNU General Public License (GPL)", "Programming Language :: Python", "Programming Language :: Python :: 2.6", "Programming Language :: Python :: 2.7", "Topic :: Software Development :: Libraries :: Application Frameworks", "Topic :: Software Development :: Libraries :: Python Modules"], "description": "===============================\nPlone transmogrifier blueprints\n===============================\n\n.. contents::\n\nThis package contains several blueprints for collective.transmogrifier\npipelines, commonly used to import content into a Plone site.\n\nInstallation\n============\n\nSee docs/INSTALL.rst for installation instructions.\n\nCredits\n=======\n\nDevelopment sponsored by\n    Elkj\u00f8p Nordic AS\n    \nDesign and development\n    `Martijn Pieters`_ at Jarn_\n    `Florian Schulze`_ at Jarn_\n    \n.. _Martijn Pieters: mailto:mj@jarn.com\n.. _Florian Schulze: mailto:fschulze@jarn.com\n.. _Jarn: http://www.jarn.com/\n\nDetailed Documentation\n======================\n\nATSchema updater section\n------------------------\n\nAn AT schema updater pipeline section is another important transmogrifier\ncontent import pipeline element. It updates field values for Archetypes\nobjects based on their schema based on the items it processes. The AT schema\nupdater section blueprint name is\n``plone.app.transmogrifier.atschemaupdater``. AT Schema updater sections\noperate on objects already present in the ZODB, be they created by a\nconstructor or pre-existing objects.\n\nSchema updating needs at least 1 piece of information: the path to the object\nto update. To determine the path, the schema updater section inspects each\nitem and looks for one key, as described below. Any item missing this piece of\ninformation will be skipped. Similarly, items with a path that doesn't exist\nor are not Archetypes objects will be skipped as well.\n\nFor the object path, it'll look (in order) for\n``_plone.app.transmogrifier.atschemaupdater_[sectionname]_path``,\n``_plone.app.transmogrifier.atschemaupdater_path``, ``_[sectionname]_path``\nand ``_path``, where ``[sectionname]`` is replaced with the name given to the\ncurrent section. This allows you to target the right section precisely if\nneeded. Alternatively, you can specify what key to use for the path by\nspecifying the ``path-key`` option, which should be a list of keys to try (one\nkey per line, use a ``re:`` or ``regexp:`` prefix to specify regular\nexpressions).\n\nPaths to objects are always interpreted as relative to the context. Any\nwritable field who's id matches a key in the current item will be updated with\nthe corresponding value, using the field's mutator.\n\n::\n\n    >>> import pprint\n    >>> atschema = \"\"\"\n    ... [transmogrifier]\n    ... pipeline =\n    ...     schemasource\n    ...     schemaupdater\n    ...     printer\n    ...\n    ... [schemasource]\n    ... blueprint = plone.app.transmogrifier.tests.schemasource\n    ...\n    ... [schemaupdater]\n    ... blueprint = plone.app.transmogrifier.atschemaupdater\n    ...\n    ... [printer]\n    ... blueprint = collective.transmogrifier.sections.logger\n    ... name = logger\n    ... \"\"\"\n    >>> registerConfig(u'plone.app.transmogrifier.tests.atschema', atschema)\n\n    >>> transmogrifier(u'plone.app.transmogrifier.tests.atschema')\n    >>> print handler\n    logger INFO\n        {'_path': '/spam/eggs/foo',\n       'fieldnotchanged': 'nochange',\n       'fieldone': 'one value',\n       'fieldtwo': 2,\n       'fieldunicode': u'\\xe5',\n       'nosuchfield': 'ignored'}\n    logger INFO\n        {'_path': 'not/existing/bar',\n       'fieldone': 'one value',\n       'title': 'Should not be updated, not an existing path'}\n    logger INFO\n      {'fieldone': 'one value', 'title': 'Should not be updated, no path'}\n    logger INFO\n        {'_path': '/spam/eggs/notatcontent',\n       'fieldtwo': 2,\n       'title': 'Should not be updated, not an AT base object'}\n    >>> pprint.pprint(plone.updated)\n    [('spam/eggs/foo', 'fieldone', 'one value-by-mutator'),\n     ('spam/eggs/foo', 'fieldtwo', 2)]\n\n\nBrowser default section\n-----------------------\n\nA browser default pipeline section sets the default-page on a folder, and the\nlayout template on content objects. They are the Transmogrifier equivalent of\nthe ``display`` menu in Plone. The browser default section blueprint name is\n``plone.app.transmogrifier.browserdefault``. Browser default sections operate\non objects already present in the ZODB, be they created by a constructor or\npre-existing objects.\n\nSetting the browser default needs at least 1 piece of information: the path to\nthe object to modify. To determine the path, the browser default section\ninspects each item and looks for one key, as described below. Any item missing\nthis piece of information will be skipped. Similarly, items with a path that\ndoesn't exist or do not support the Plone ISelectableBrowserDefault interface\nwill be skipped as well.\n\nFor the object path, it'll look (in order) for\n``_plone.app.transmogrifier.browserdefault_[sectionname]_path``,\n``_plone.app.transmogrifier.browserdefault_path``, ``_[sectionname]_path``\nand ``_path``, where ``[sectionname]`` is replaced with the name given to the\ncurrent section. This allows you to target the right section precisely if\nneeded. Alternatively, you can specify what key to use for the path by\nspecifying the ``path-key`` option, which should be a list of keys to try (one\nkey per line, use a ``re:`` or ``regexp:`` prefix to specify regular\nexpressions).\n\nOnce an object has been located, the section will looks for defaultpage\nand layout keys. Like the path key, these can be specified in the source\nconfiguration, named by the ``default-page-key`` and ``layout-key`` options,\nrespectively, and like the path key, the default keys the section looks for\nare the usual list of specific-to-generic keys based on blueprint and section\nnames, from\n``_plone.app.transmogrifier.browserdefault_[sectionname]_defaultpage`` and\n``_plone.app.transmogrifier.browserdefault_[sectionname]_layout`` down to\n``_defaultpage`` and ``_layout``.\n\nThe defaultpage key will set the id of the default page that should be\npresented when the content object is loaded, and the layout key will set the\nid of the layout to use for the content item.\n\n::\n\n    >>> import pprint\n    >>> browserdefault = \"\"\"\n    ... [transmogrifier]\n    ... pipeline =\n    ...     browserdefaultsource\n    ...     browserdefault\n    ...     printer\n    ...\n    ... [browserdefaultsource]\n    ... blueprint = plone.app.transmogrifier.tests.browserdefaultsource\n    ...\n    ... [browserdefault]\n    ... blueprint = plone.app.transmogrifier.browserdefault\n    ...\n    ... [printer]\n    ... blueprint = collective.transmogrifier.sections.logger\n    ... name = logger\n    ... \"\"\"\n    >>> registerConfig(u'plone.app.transmogrifier.tests.browserdefault',\n    ...                browserdefault)\n    >>> transmogrifier(u'plone.app.transmogrifier.tests.browserdefault')\n    >>> print(handler)\n    logger INFO\n      {'_layout': 'spam', '_path': '/spam/eggs/foo'}\n    logger INFO\n      {'_defaultpage': 'eggs', '_path': '/spam/eggs/bar'}\n    logger INFO\n      {'_defaultpage': 'eggs', '_layout': 'spam', '_path': '/spam/eggs/baz'}\n    logger INFO\n        {'_layout': 'spam',\n       '_path': 'not/existing/bar',\n       'title': 'Should not be updated, not an existing path'}\n    logger INFO\n        {'_path': 'spam/eggs/incomplete',\n       'title': 'Should not be updated, no layout or defaultpage'}\n    logger INFO\n        {'_layout': '',\n       '_path': 'spam/eggs/emptylayout',\n       'title': 'Should not be updated, no layout or defaultpage'}\n    logger INFO\n        {'_defaultpage': '',\n       '_path': 'spam/eggs/emptydefaultpage',\n       'title': 'Should not be updated, no layout or defaultpage'}\n    >>> pprint.pprint(plone.updated)\n    [('spam/eggs/foo', 'layout', 'spam'),\n     ('spam/eggs/bar', 'defaultpage', 'eggs'),\n     ('spam/eggs/baz', 'layout', 'spam'),\n     ('spam/eggs/baz', 'defaultpage', 'eggs')]\n\n\nCriterion adder section\n-----------------------\n\nA criterion adder section is used to add criteria to collections. It's section\nblueprint name is ``plone.app.transmogrifier.criterionadder``. Criterion adder\nsections operate on objects already present in the ZODB, be they created by a\nconstructor or pre-existing objects.\n\nGiven a path, a criterion type and a field name, this section will look up\na Collection at the given path, and add a criterion field, then alter the\npath of the item so further sections will act on the added criterion. For\nexample, an item with keys ``_path=bar/baz``, ``_field=modified`` and\n``_criterion=ATFriendlyDateCriteria`` will result in a new date criterion\nadded inside the bar/baz collection, and the item's path will be updated\nto ``bar/baz/crit__ATFriendlyDateCriteria_modified``.\n\nFor the  path, criterion type and field keys, it'll look (in order) for\n``_plone.app.transmogrifier.atschemaupdater_[sectionname]_[key]``,\n``_plone.app.transmogrifier.atschemaupdater_[key]``, ``_[sectionname]_[key]``\nand ``_[key]``, where ``[sectionname]`` is replaced with the name given to the\ncurrent section and ``[key]`` is ``path``, ``criterion`` and ``field``\nrespectively. This allows you to target the right section precisely if\nneeded. Alternatively, you can specify what key to use for these by\nspecifying the ``path-key``, ``criterion-key`` and ``field-key`` options,\nwhich should be a list of keys to try (one key per line, use a ``re:`` or\n``regexp:`` prefix to specify regular expressions).\n\nPaths to objects are always interpreted as relative to the context, and must\nresolve to IATTopic classes.\n\n::\n\n    >>> import pprint\n    >>> criteria = \"\"\"\n    ... [transmogrifier]\n    ... pipeline =\n    ...     criteriasource\n    ...     criterionadder\n    ...     printer\n    ...\n    ... [criteriasource]\n    ... blueprint = plone.app.transmogrifier.tests.criteriasource\n    ...\n    ... [criterionadder]\n    ... blueprint = plone.app.transmogrifier.criterionadder\n    ...\n    ... [printer]\n    ... blueprint = collective.transmogrifier.sections.logger\n    ... name = logger\n    ... \"\"\"\n    >>> registerConfig(u'plone.app.transmogrifier.tests.criteria', criteria)\n    >>> transmogrifier(u'plone.app.transmogrifier.tests.criteria')\n    >>> print(handler)\n    logger INFO\n      {'_criterion': 'bar', '_field': 'baz', '_path': '/spam/eggs/foo/crit__baz_bar'}\n    logger INFO\n        {'_criterion': 'bar',\n       '_field': 'baz',\n       '_path': 'not/existing/bar',\n       'title': 'Should not be updated, not an existing path'}\n    logger INFO\n        {'_path': 'spam/eggs/incomplete',\n       'title': 'Should not be updated, no criterion or field'}\n    >>> pprint.pprint(plone.criteria)\n    [('spam/eggs/foo', 'baz', 'bar')]\n\n\nDatesUpdater section\n--------------------\n\nThis blueprint sets creation, modification and effective dates on objects.\n\nBlueprint name: ``plone.app.transmogrifier.datesupdater``\n\nOption path-key: The key for the path to the object.\n\nOption creation-key: The key for the creation date.\n\nOption modification-key: The key for the modification date.\n\nOption effective-key: The key for the effective date.\n\nOption expiration-key: The key for the expiration date.\n\n::\n\n    >>> import pprint\n    >>> pipeline = \"\"\"\n    ... [transmogrifier]\n    ... pipeline =\n    ...     schemasource\n    ...     datesupdater\n    ...     logger\n    ...\n    ... [schemasource]\n    ... blueprint = plone.app.transmogrifier.tests.schemasource\n    ...\n    ... [datesupdater]\n    ... blueprint = plone.app.transmogrifier.datesupdater\n    ... path-key = _path\n    ... creation-key = creation_date\n    ... modification-key = modification_date\n    ... effective-key = effective_date\n    ... expiration-key = expiration_date\n    ...\n    ... [logger]\n    ... blueprint = collective.transmogrifier.sections.logger\n    ... name = logger\n    ... \"\"\"\n    >>> registerConfig(u'plone.app.transmogrifier.tests.datesupdater', pipeline)\n\n    >>> transmogrifier(u'plone.app.transmogrifier.tests.datesupdater')\n\n\nPrint out the source structure::\n\n    >>> print handler\n    logger INFO\n        {'_path': '/spam/eggs/foo',\n       'creation_date': DateTime('2010/10/10 00:00:00 UTC'),\n       'effective_date': DateTime('2010/10/10 00:00:00 UTC'),\n       'expiration_date': DateTime('2012/12/12 00:00:00 UTC'),\n       'modification_date': DateTime('2011/11/11 00:00:00 UTC')}\n    logger INFO\n        {'_path': '/spam/eggs/bar',\n       'creation_date': DateTime('2010/10/10 00:00:00 UTC')}\n    logger INFO\n        {'_path': '/spam/eggs/baz',\n       'modification_date': DateTime('2011/11/11 00:00:00 UTC')}\n    logger INFO\n        {'_path': '/spam/eggs/qux',\n       'effective_date': DateTime('2010/10/10 00:00:00 UTC')}\n    logger INFO\n        {'_path': '/spam/eggs/norf',\n       'expiration_date': DateTime('2012/12/12 00:00:00 UTC')}\n    logger INFO\n        {'_path': 'not/existing/bar',\n       'creation_date': DateTime('2010/10/10 00:00:00 UTC'),\n       'effective_date': DateTime('2010/10/10 00:00:00 UTC'),\n       'expiration_date': DateTime('2012/12/12 00:00:00 UTC'),\n       'modification_date': DateTime('2011/11/11 00:00:00 UTC')}\n    logger INFO\n        {'creation_date': DateTime('2010/10/10 00:00:00 UTC'),\n       'effective_date': DateTime('2010/10/10 00:00:00 UTC'),\n       'expiration_date': DateTime('2012/12/12 00:00:00 UTC'),\n       'modification_date': DateTime('2011/11/11 00:00:00 UTC')}\n\n\nThat was changed on the object::\n\n    >>> pprint.pprint(plone.updated)\n    [('spam/eggs/foo', 'creation_date', DateTime('2010/10/10 00:00:00 UTC')),\n     ('spam/eggs/foo', 'modification_date', DateTime('2011/11/11 00:00:00 UTC')),\n     ('spam/eggs/foo', 'effective_date', DateTime('2010/10/10 00:00:00 UTC')),\n     ('spam/eggs/foo', 'expiration_date', DateTime('2012/12/12 00:00:00 UTC')),\n     ('spam/eggs/bar', 'creation_date', DateTime('2010/10/10 00:00:00 UTC')),\n     ('spam/eggs/baz', 'modification_date', DateTime('2011/11/11 00:00:00 UTC')),\n     ('spam/eggs/qux', 'effective_date', DateTime('2010/10/10 00:00:00 UTC')),\n     ('spam/eggs/norf', 'expiration_date', DateTime('2012/12/12 00:00:00 UTC'))]\n\n\nMime encapsulator section\n-------------------------\n\nA mime encapsulator section wraps arbitrary data in ``OFS.Image.File``\nobjects, together with a MIME type. This wrapping is a pre-requisite for\nArchetypes image, file or text fields, which can only take such File objects.\nThe mime encapsulator blueprint name is\n``plone.app.transmogrifier.mimeencapsulator``.\n\nAn encapsulator section needs 3 pieces of information: the key at which to\nfind the data to encapsulate, the MIME type of this data, and the name of the\nfield where the encapsulated data will be stored. The idea is that the data\nis copied from a \"data key\" (defaulting to ``_data`` and settable with the\n``data-key`` option), wrapped into a ``File`` object with a MIME type (read\nfrom the ``mimetype`` option, which contains a TALES expression), and then\nsaved into the pipeline item dictionary under a new key, most likely\ncorresponding to an Archetypes field name (read from the ``field`` option,\nwhich is also a TALES expression).\n\nThe data key defaults to the series ``_[blueprintname]_[sectionname]_data``,\n``_[blueprintname]_data``, ``_[sectionname]_data`` and ``_data``, where\n``[blueprintname]`` is ``plone.app.transmogrifier.mimeencapsulator`` and\n``[sectionname]`` is replaced with the name of the current section. You can\noverride this by specifying the ``data-key`` option.\n\nYou specify the mimetype with the ``mimetype`` option, which takes a TALES\nexpression.\n\nThe ``field`` option, also a TALES expression, sets the output field name.\n\nOptionally, you can specify a ``condition`` option, again a TALES expression,\nthat when evaluating to ``False``, causes the section to skip encapsulation\nfor  that item.\n\n::\n\n    >>> encapsulator = \"\"\"\n    ... [transmogrifier]\n    ... pipeline =\n    ...     source\n    ...     encapsulator\n    ...     conditionalencapsulator\n    ...     printer\n    ...\n    ... [source]\n    ... blueprint = plone.app.transmogrifier.tests.encapsulatorsource\n    ...\n    ... [encapsulator]\n    ... blueprint = plone.app.transmogrifier.mimeencapsulator\n    ... # Read the mimetype from the item\n    ... mimetype = item/_mimetype\n    ... field = string:datafield\n    ...\n    ... [conditionalencapsulator]\n    ... blueprint = plone.app.transmogrifier.mimeencapsulator\n    ... data-key = portrait\n    ... mimetype = python:item.get('_%s_mimetype' % key)\n    ... # replace the data in-place\n    ... field = key\n    ... condition = mimetype\n    ...\n    ... [printer]\n    ... blueprint = plone.app.transmogrifier.tests.ofsfileprinter\n    ... \"\"\"\n    >>> registerConfig(u'plone.app.transmogrifier.tests.encapsulator',\n    ...                encapsulator)\n    >>> transmogrifier(u'plone.app.transmogrifier.tests.encapsulator')\n    datafield: (application/x-test-data) foobarbaz\n    portrait: (image/jpeg) someportraitdata\n\n\nThe ``field`` expression has access to the following:\n\n``item``\n    The current pipeline item\n\n``key``\n    The name of the matched data key\n\n``match``\n    If the key was matched by a regular expression, the match object, otherwise boolean True\n\n``transmogrifier``\n    The transmogrifier\n\n``name``\n    The name of the splitter section\n\n``options``\n    The splitter options\n\n``modules``\n    ``sys.modules``\n\n\nThe ``mimetype`` expression has access to the same information as the ``field``\nexpression, plus:\n\n``field``\n    The name of the field in which the encapsulated data will be stored.\n\nThe ``condition`` expression has access to the same information as the\n``mimetype`` expression, plus:\n\n``mimetype``\n    The mimetype used to encapsulate the data.\n\n\nPathFixer section\n-----------------\n\nWhen importing contents from a old site into a new, the path to the Plone site\nroot may have changed. This blueprint updates the old paths to match the new\nstructrue by removing or appending strings from the right side of the path\nvalue.\n\nIt also converts the path to ``str`` and removes any invalid characters from it.\n\nBlueprint name: ``plone.app.transmogrifier.pathfixer``\n\nOption path-key: The key of the item under which the path to be manipulated can\n                 be found. E.g. ``_path``.\n\nOption stripstring: A string to strip from the path value.\n\nOption prependstring: A string to append to the path value.\n\n\nLook, here. Original path structure from\nplone.app.transmogrifier.tests.schemasource is::\n\n    /spam/eggs/foo\n    relative/path\n    /spam/eggs/another\n\n\nNow lets manipulate it::\n\n    >>> import pprint\n    >>> pipeline = \"\"\"\n    ... [transmogrifier]\n    ... pipeline =\n    ...     schemasource\n    ...     pathfixer\n    ...     logger\n    ...\n    ... [schemasource]\n    ... blueprint = plone.app.transmogrifier.tests.schemasource\n    ...\n    ... [pathfixer]\n    ... blueprint = plone.app.transmogrifier.pathfixer\n    ... path-key = _path\n    ... stripstring = /spam/eggs/\n    ... prependstring = subfolder/\n    ...\n    ... [logger]\n    ... blueprint = collective.transmogrifier.sections.logger\n    ... name = logger\n    ... key = _path\n    ... \"\"\"\n    >>> registerConfig(u'plone.app.transmogrifier.tests.pathfixer', pipeline)\n\n    >>> transmogrifier(u'plone.app.transmogrifier.tests.pathfixer')\n    >>> print handler\n    logger INFO\n      subfolder/foo\n    logger INFO\n      subfolder/relative/path\n    logger INFO\n      subfolder/another\n\n\n\nPortal Transforms section\n-------------------------\n\nA portal transforms pipeline section lets you use Portal Transforms to\ntransform item values. The portal transforms section blueprint name is\n``plone.app.transmogrifier.portaltransforms``.\n\nWhat values to transform is determined by the ``keys`` option, which takes a\nset of newline-separated key names. If a key name starts with ``re:`` or\n``regexp:`` it is treated as a regular expression instead.\n\nYou can specify what transformation to apply in two ways. Firstly, you can\ndirectly specify a transformation by naming it with the ``transform`` option;\nthe named transformation is run directly. Alternatively you can let the portal\ntransforms tool figure out what transform to use by specifying ``target`` and\nan optional ``from`` mimetype. The portal transforms tool will select one or\nmore transforms based on these mimetypes, and if no ``from`` option is given\nthe original item value is used to determine one.\n\nAlso optional is the ``condition`` option, which lets you specify a TALES\nexpression that when evaluating to False will prevent any transformations from\nhappening. The condition is evaluated for every matched key.\n\n::\n\n    >>> ptransforms = \"\"\"\n    ... [transmogrifier]\n    ... pipeline =\n    ...     source\n    ...     transform-id\n    ...     transform-title\n    ...     transform-status\n    ...     printer\n    ...\n    ... [source]\n    ... blueprint = collective.transmogrifier.sections.tests.samplesource\n    ... encoding = utf8\n    ...\n    ... [transform-id]\n    ... blueprint = plone.app.transmogrifier.portaltransforms\n    ... transform = identity\n    ... keys = id\n    ...\n    ... [transform-title]\n    ... blueprint = plone.app.transmogrifier.portaltransforms\n    ... target = text/plain\n    ... keys = title\n    ...\n    ... [transform-status]\n    ... blueprint = plone.app.transmogrifier.portaltransforms\n    ... from = text/plain\n    ... target = text/plain\n    ... keys = status\n    ...\n    ... [printer]\n    ... blueprint = collective.transmogrifier.sections.logger\n    ... name = logger\n    ... \"\"\"\n    >>> registerConfig(u'plone.app.transmogrifier.tests.ptransforms',\n    ...                ptransforms)\n\n    >>> transmogrifier(u'plone.app.transmogrifier.tests.ptransforms')\n    >>> print handler\n    logger INFO\n        {'id': \"Transformed 'foo' using the identity transform\",\n       'status': \"Transformed '\\\\xe2\\\\x84\\\\x97' from text/plain to text/plain\",\n       'title': \"Transformed 'The Foo Fighters \\\\xe2\\\\x84\\\\x97' to text/plain\"}\n    logger INFO\n        {'id': \"Transformed 'bar' using the identity transform\",\n       'status': \"Transformed '\\\\xe2\\\\x84\\\\xa2' from text/plain to text/plain\",\n       'title': \"Transformed 'Brand Chocolate Bar \\\\xe2\\\\x84\\\\xa2' to text/plain\"}\n    logger INFO\n        {'id': \"Transformed 'monty-python' using the identity transform\",\n       'status': \"Transformed '\\\\xc2\\\\xa9' from text/plain to text/plain\",\n       'title': 'Transformed \"Monty Python\\'s Flying Circus \\\\xc2\\\\xa9\" to text/plain'}\n\nThe ``condition`` expression has access to the following:\n\n``item``\n    The current pipeline item\n\n``key``\n    The name of the matched key\n\n``match``\n    If the key was matched by a regular expression, the match object, otherwise boolean True\n\n``transmogrifier``\n    The transmogrifier\n\n``name``\n    The name of the splitter section\n\n``options``\n    The splitter options\n\n``modules``\n    ``sys.modules``\n\n\nRedirector section\n------------------\n\nA redirector section uses `plone.app.redirector` to manage redirects and update\npaths in keys.\n\n::\n\n    >>> import pprint\n    >>> redirector = \"\"\"\n    ... [transmogrifier]\n    ... pipeline =\n    ...     source\n    ...     clean-old-paths\n    ...     old-paths\n    ...     content-element\n    ...     redirect\n    ...     href\n    ...     logger\n    ...\n    ... [source]\n    ... blueprint = collective.transmogrifier.sections.csvsource\n    ... filename = plone.app.transmogrifier:redirector.csv\n    ...\n    ... [clean-old-paths]\n    ... blueprint = collective.transmogrifier.sections.manipulator\n    ... condition = not:item/_old_paths|nothing\n    ... delete = _old_paths\n    ...\n    ... [old-paths]\n    ... blueprint = collective.transmogrifier.sections.inserter\n    ... key = string:_old_paths\n    ... condition = exists:item/_old_paths\n    ... value = python:item['_old_paths'].split('|')\n    ...\n    ... [content-element]\n    ... blueprint = collective.transmogrifier.sections.inserter\n    ... key = string:_content_element\n    ... condition = item/remoteUrl\n    ... value = python:modules['xml.etree.ElementTree'].Element(\\\n    ...     'a', dict(href=item['remoteUrl']))\n    ...\n    ... [redirect]\n    ... blueprint = plone.app.transmogrifier.redirector\n    ...\n    ... [href]\n    ... blueprint = collective.transmogrifier.sections.inserter\n    ... key = string:_content_element\n    ... condition = exists:item/_content_element\n    ... value = python:item['_content_element'].attrib['href']\n    ...\n    ... [logger]\n    ... blueprint = collective.transmogrifier.sections.logger\n    ... name = logger\n    ... level = INFO\n    ... \"\"\"\n    >>> registerConfig(\n    ...     u'plone.app.transmogrifier.tests.redirector', redirector)\n\n    >>> transmogrifier(u'plone.app.transmogrifier.tests.redirector')\n    >>> print handler\n    logger INFO\n      {'_old_paths': ['corge', 'waldo'], '_redirect_path': 'foo', 'remoteUrl': ''}\n    logger INFO\n      {'_redirect_path': 'foo', 'remoteUrl': ''}\n    logger INFO\n        {'_old_paths': ['corge/item-00', 'waldo/item-00'],\n       '_redirect_path': 'foo/item-00',\n       'remoteUrl': ''}\n    logger INFO\n        {'_content_element': 'foo/item-00',\n       '_old_paths': ['corge/grault', 'waldo/fred'],\n       '_redirect_path': 'foo/bar',\n       'remoteUrl': 'foo/item-00'}\n    logger INFO\n        {'_content_element': '/foo/item-00#fragment',\n       '_old_paths': ['corge/grault/item-01', 'waldo/fred/item-01'],\n       '_redirect_path': 'http://nohost/foo/bar/item-01',\n       'remoteUrl': '/foo/item-00#fragment'}\n    logger INFO\n      {'_redirect_path': '/foo/bar/qux', 'remoteUrl': ''}\n    logger INFO\n        {'_content_element': 'http://nohost/foo/bar/item-01',\n       '_redirect_path': '/foo/bar/qux/item-02',\n       'remoteUrl': 'http://nohost/foo/bar/item-01'}\n\n    >>> import pprint\n    >>> from zope.component import getUtility\n    >>> from plone.app.redirector.interfaces import IRedirectionStorage\n    >>> storage = getUtility(IRedirectionStorage)\n    >>> pprint.pprint(dict((path, storage.get(path)) for path in storage))\n    {'/plone/corge': '/plone/foo',\n     '/plone/corge/grault': '/plone/foo/bar',\n     '/plone/corge/grault/item-01': 'http://nohost/foo/bar/item-01',\n     '/plone/corge/item-00': '/plone/foo/item-00',\n     '/plone/waldo': '/plone/foo',\n     '/plone/waldo/fred': '/plone/foo/bar',\n     '/plone/waldo/fred/item-01': 'http://nohost/foo/bar/item-01',\n     '/plone/waldo/item-00': '/plone/foo/item-00'}\n\n\nIndexing section\n----------------\n\nA ReindexObject section allows you to reindex an existing object in the\nportal_catalog. ReindexObject sections operate on objects already present in the\nZODB, be they created by a constructor or pre-existing objects.\n\nThe ReindexObject blueprint name is ``plone.app.transmogrifier.reindexobject``.\n\nTo determine the path, the ReindexObject section inspects each item and looks\nfor a path key, as described below. Any item missing this key will be skipped.\nSimilarly, items with a path that doesn't exist or are not referenceable\n(Archetypes) or do not inherit from CMFCatalogAware will be skipped as well.\n\nThe object path will be found under the first key found among the following:\n\n* ``_plone.app.transmogrifier.reindexobject_[sectionname]_path``\n* ``_plone.app.transmogrifier.reindexobject_path``\n* ``_[sectionname]_path``\n* ``_path``\n\nwhere ``[sectionname]`` is replaced with the name given to the current section.\nThis allows you to target the right section precisely if needed.\n\nAlternatively, you can specify what key to use for the path by specifying the\n``path-key`` option, which should be a list of keys to try (one key per line;\nuse a ``re:`` or ``regexp:`` prefix to specify regular expressions).\n\nPaths to objects are always interpreted as relative to the context.\n\n::\n\n    >>> import pprint\n    >>> reindexobject_1 = \"\"\"\n    ... [transmogrifier]\n    ... pipeline =\n    ...     reindexobjectsource\n    ...     reindexobject\n    ...     printer\n    ...\n    ... [reindexobjectsource]\n    ... blueprint = plone.app.transmogrifier.tests.reindexobjectsource\n    ...\n    ... [reindexobject]\n    ... blueprint = plone.app.transmogrifier.reindexobject\n    ...\n    ... [printer]\n    ... blueprint = collective.transmogrifier.sections.logger\n    ... name = logger\n    ... \"\"\"\n    >>> registerConfig(u'plone.app.transmogrifier.tests.reindexobject_1', reindexobject_1)\n\n    >>> transmogrifier(u'plone.app.transmogrifier.tests.reindexobject_1')\n    >>> print(handler)\n    logger INFO\n      {'_path': '/spam/eggs/foo'}\n    logger INFO\n      {'_path': '/spam/eggs/bar'}\n    logger INFO\n      {'_path': '/spam/eggs/baz'}\n    logger INFO\n        {'_path': 'not/a/catalog/aware/content',\n       'title': 'Should not be reindexed, not a CMFCatalogAware content'}\n    logger INFO\n        {'_path': 'not/existing/bar',\n       'title': 'Should not be reindexed, not an existing path'}\n\n    >>> pprint.pprint(plone.reindexed)\n    [('spam/eggs/foo', 'reindexed', 'indexes: all'),\n     ('spam/eggs/bar', 'reindexed', 'indexes: all'),\n     ('spam/eggs/baz', 'reindexed', 'indexes: all')]\n\n    Reset:\n    >>> plone.reindexed = []\n\n\n\nIndex only the ``foo`` index::\n\n    >>> import pprint\n    >>> reindexobject_2 = \"\"\"\n    ... [transmogrifier]\n    ... pipeline =\n    ...     reindexobjectsource\n    ...     reindexobject\n    ...     printer\n    ...\n    ... [reindexobjectsource]\n    ... blueprint = plone.app.transmogrifier.tests.reindexobjectsource\n    ...\n    ... [reindexobject]\n    ... blueprint = plone.app.transmogrifier.reindexobject\n    ... indexes = foo\n    ...\n    ... [printer]\n    ... blueprint = collective.transmogrifier.sections.logger\n    ... name = logger\n    ... \"\"\"\n    >>> registerConfig(u'plone.app.transmogrifier.tests.reindexobject_2', reindexobject_2)\n\n    >>> transmogrifier(u'plone.app.transmogrifier.tests.reindexobject_2')\n\n    >>> pprint.pprint(plone.reindexed)\n    [('spam/eggs/foo', 'reindexed', 'indexes: foo'),\n     ('spam/eggs/bar', 'reindexed', 'indexes: foo'),\n     ('spam/eggs/baz', 'reindexed', 'indexes: foo')]\n\n    Reset:\n    >>> plone.reindexed = []\n\n\nIndex only the ``foo``, ``bar`` and ``baz`` indexes::\n\n    >>> import pprint\n    >>> reindexobject_3 = \"\"\"\n    ... [transmogrifier]\n    ... pipeline =\n    ...     reindexobjectsource\n    ...     reindexobject\n    ...     printer\n    ...\n    ... [reindexobjectsource]\n    ... blueprint = plone.app.transmogrifier.tests.reindexobjectsource\n    ...\n    ... [reindexobject]\n    ... blueprint = plone.app.transmogrifier.reindexobject\n    ... indexes =\n    ...     foo\n    ...     bar\n    ...     baz\n    ...\n    ... [printer]\n    ... blueprint = collective.transmogrifier.sections.logger\n    ... name = logger\n    ... \"\"\"\n    >>> registerConfig(u'plone.app.transmogrifier.tests.reindexobject_3', reindexobject_3)\n\n    >>> transmogrifier(u'plone.app.transmogrifier.tests.reindexobject_3')\n\n    >>> pprint.pprint(plone.reindexed)\n    [('spam/eggs/foo', 'reindexed', 'indexes: foo, bar, baz'),\n     ('spam/eggs/bar', 'reindexed', 'indexes: foo, bar, baz'),\n     ('spam/eggs/baz', 'reindexed', 'indexes: foo, bar, baz')]\n\n    Reset:\n    >>> plone.reindexed = []\n\n\nUID updater section\n-------------------\n\nIf an Archetypes content object is created in a pipeline, e.g. by the standard\ncontent constructor section, it will get a new UID. If you are importing\ncontent from another Plone site, and you have references (or links embedded\nin content using Plone's link-by-UID feature) to existing content, you may\nwant to retain UIDs. The UID updater section allows you to set the UID on an\nexisting object for this purpose.\n\nThe UID updater blueprint name is ``plone.app.transmogrifier.uidupdater``.\n\nUID updating requires two pieces of information: the path to the object\nto update, and the new UID to set.\n\nTo determine the path, the UID updater section inspects each item and looks\nfor a path key, as described below. Any item missing this key will be skipped.\nSimilarly, items with a path that doesn't exist or are not referenceable\n(Archetypes) objects will be skipped.\n\nThe object path will be found under the first key found among the following:\n\n* ``_plone.app.transmogrifier.atschemaupdater_[sectionname]_path``\n* ``_plone.app.transmogrifier.atschemaupdater_path``\n* ``_[sectionname]_path``\n* ``_path``\n\nwhere ``[sectionname]`` is replaced with the name given to the current\nsection. This allows you to target the right section precisely if\nneeded.\n\nAlternatively, you can specify what key to use for the path by specifying the\n``path-key`` option, which should be a list of keys to try (one key per line;\nuse a ``re:`` or ``regexp:`` prefix to specify regular expressions).\n\nPaths to objects are always interpreted as relative to the context.\n\nSimilarly, the UID to set must be a string under a given key. You can set the\nkey with the ``uid-key`` option, which behaves much like ``path-key``. The\ndefault is to look under:\n\n* ``_plone.app.transmogrifier.atschemaupdater_[sectionname]_uid``\n* ``_plone.app.transmogrifier.atschemaupdater_uid``\n* ``_[sectionname]_uid``\n* ``_uid``\n\nIf the UID key is missing, the item will be skipped.\n\nBelow is an example of a standard updater. The test uid source produces\nitems with two keys: a path under ``_path`` and a UID string under ``_uid``.\n\n::\n\n    >>> import pprint\n    >>> atschema = \"\"\"\n    ... [transmogrifier]\n    ... pipeline =\n    ...     schemasource\n    ...     schemaupdater\n    ...     printer\n    ...\n    ... [schemasource]\n    ... blueprint = plone.app.transmogrifier.tests.uidsource\n    ...\n    ... [schemaupdater]\n    ... blueprint = plone.app.transmogrifier.uidupdater\n    ...\n    ... [printer]\n    ... blueprint = collective.transmogrifier.sections.logger\n    ... name = logger\n    ... \"\"\"\n    >>> registerConfig(u'plone.app.transmogrifier.tests.uid', atschema)\n    >>> transmogrifier(u'plone.app.transmogrifier.tests.uid')\n    >>> print(handler)\n    logger INFO\n      {'_path': '/spam/eggs/foo', '_uid': 'abc'}\n    logger INFO\n      {'_path': '/spam/eggs/bar', '_uid': 'xyz'}\n    logger INFO\n      {'_path': 'not/existing/bar', '_uid': 'def'}\n    logger INFO\n      {'_uid': 'geh'}\n    logger INFO\n      {'_path': '/spam/eggs/baz'}\n    logger INFO\n      {'_path': '/spam/notatcontent', '_uid': 'ijk'}\n\n    >>> pprint.pprint(plone.uids_set)\n    [('spam/eggs/foo', 'abc')]\n\n\nURL Normalizer section\n----------------------\n\nA URLNormalizer section allows you to parse any piece of text into a url-safe\nstring which is then assigned to a specified key. It uses plone.i18n.normalizer\nto perform the normalization. The url normalizer section blueprint name is\n``plone.app.transmogrifier.urlnormalizer``.\n\nThe URL normalizer accepts the following optional keys -\n``source-key``: The name of the object key that you wish to normalize,\n``destination-key``: Where you want the normalized string to be stored,\n``locale``: if you want the normalizer to be aware of locale, use this.\n\n::\n\n    >>> import pprint\n    >>> urlnormalizer = \"\"\"\n    ... [transmogrifier]\n    ... pipeline =\n    ...     urlnormalizersource\n    ...     urlnormalizer\n    ...     printer\n    ...\n    ... [urlnormalizersource]\n    ... blueprint = plone.app.transmogrifier.tests.urlnormalizersource\n    ...\n    ... [urlnormalizer]\n    ... blueprint = plone.app.transmogrifier.urlnormalizer\n    ... source-key = title\n    ... destination-key = string:id\n    ... locale = string:en\n    ...\n    ... [printer]\n    ... blueprint = collective.transmogrifier.sections.logger\n    ... name = logger\n    ... \"\"\"\n    >>> registerConfig(u'plone.app.transmogrifier.tests.urlnormalizer',\n    ...                urlnormalizer)\n    >>> transmogrifier(u'plone.app.transmogrifier.tests.urlnormalizer')\n    >>> print(handler)\n    logger INFO\n      {'id': 'mytitle', 'title': 'mytitle'}\n    logger INFO\n      {'id': 'is-this-a-title-of-any-sort', 'title': 'Is this a title of any sort?'}\n    logger INFO\n        {'id': 'put-some-br-1lly-v4lues-here-there',\n       'title': 'Put some <br /> $1llY V4LUES -- here&there'}\n    logger INFO\n        {'id': 'what-about-line-breaks-system',\n       'title': 'What about \\r\\n line breaks (system)'}\n    logger INFO\n      {'id': 'try-one-of-these-oh', 'title': 'Try one of these --------- oh'}\n    logger INFO\n      {'language': 'My language is de'}\n    logger INFO\n      {'language': 'my language is en'}\n\nAs you can see, only items containing the specified source-key have been\nprocessed, the others have been ignored and yielded without change.\n\nDestination-key and locale accept TALES expressions, so for example you could\nset your destination-key based on your locale element, which is in turn derived\nfrom your source-key:\n\n::\n\n    >>> import pprint\n    >>> urlnormalizer = \"\"\"\n    ... [transmogrifier]\n    ... pipeline =\n    ...     urlnormalizersource\n    ...     urlnormalizer\n    ...     printer\n    ...\n    ... [urlnormalizersource]\n    ... blueprint = plone.app.transmogrifier.tests.urlnormalizersource\n    ...\n    ... [urlnormalizer]\n    ... blueprint = plone.app.transmogrifier.urlnormalizer\n    ... source-key = language\n    ... locale = python:str(item.get('${urlnormalizer:source-key}', 'na')[-2:])\n    ... destination-key = ${urlnormalizer:locale}\n    ...\n    ... [printer]\n    ... blueprint = collective.transmogrifier.sections.logger\n    ... name = logger\n    ... \"\"\"\n    >>> registerConfig(u'plone.app.transmogrifier.tests.urlnormalizer2',\n    ...                urlnormalizer)\n\n    >>> handler.clear()\n    >>> transmogrifier(u'plone.app.transmogrifier.tests.urlnormalizer2')\n    >>> print(handler)\n    logger INFO\n      {'title': 'mytitle'}\n    logger INFO\n      {'title': 'Is this a title of any sort?'}\n    logger INFO\n      {'title': 'Put some <br /> $1llY V4LUES -- here&there'}\n    logger INFO\n      {'title': 'What about \\r\\n line breaks (system)'}\n    logger INFO\n      {'title': 'Try one of these --------- oh'}\n    logger INFO\n      {'de': 'my-language-is-de', 'language': 'My language is de'}\n    logger INFO\n      {'en': 'my-language-is-en', 'language': 'my language is en'}\n\nIn this case only items containing the 'language' key have been processed, and\nthe destination-key has been set to the same value as the locale was. This is\nmore to illuminate the fact that the locale was set, rather than providing a\nsensible use-case for destination-key.\n\nIf ZERO options are specified, the normalizer falls back to a set of default\nvalues as follows:\n``source-key``: title,\n``locale``: en,\n``destination-key``: _id\n\n::\n\n    >>> import pprint\n    >>> urlnormalizer = \"\"\"\n    ... [transmogrifier]\n    ... pipeline =\n    ...     urlnormalizersource\n    ...     urlnormalizer\n    ...     printer\n    ...\n    ... [urlnormalizersource]\n    ... blueprint = plone.app.transmogrifier.tests.urlnormalizersource\n    ...\n    ... [urlnormalizer]\n    ... blueprint = plone.app.transmogrifier.urlnormalizer\n    ...\n    ... [printer]\n    ... blueprint = collective.transmogrifier.sections.logger\n    ... name = logger\n    ... \"\"\"\n    >>> registerConfig(u'plone.app.transmogrifier.tests.urlnormalizer3',\n    ...                urlnormalizer)\n\n    >>> handler.clear()\n    >>> transmogrifier(u'plone.app.transmogrifier.tests.urlnormalizer3')\n    >>> print(handler)\n    logger INFO\n      {'_id': 'mytitle', 'title': 'mytitle'}\n    logger INFO\n      {'_id': 'is-this-a-title-of-any-sort', 'title': 'Is this a title of any sort?'}\n    logger INFO\n        {'_id': 'put-some-br-1lly-v4lues-here-there',\n       'title': 'Put some <br /> $1llY V4LUES -- here&there'}\n    logger INFO\n        {'_id': 'what-about-line-breaks-system',\n       'title': 'What about \\r\\n line breaks (system)'}\n    logger INFO\n      {'_id': 'try-one-of-these-oh', 'title': 'Try one of these --------- oh'}\n    logger INFO\n      {'language': 'My language is de'}\n    logger INFO\n      {'language': 'my language is en'}\n\nIn this case, the destination-key is set to a controller variable, like _path,\nas it is expected that the newly formed Id will in most cases be used further\ndown the pipeline in constructing the full, final path to the new Plone object.\n\nIt should be noted that this section can effectively transform *any* section of\ntext and turn it into a normalized, web safe string (max 255 chars) This string\ndoes not necessarily need to be used for a URL.\n\n\nDisable / enable versioning sections\n------------------------------------\n\nIt can be helpful to disable versioning during content construction to avoid\nstoring incomplete versions in the content item's revision history.\n\nFor example::\n\n    [transmogrifier]\n    pipeline =\n        schemasource\n        disable_versioning\n        constructor\n        enable_versioning\n        schemaupdater\n\n    [disable_versioning]\n    blueprint = plone.app.transmogrifier.versioning.disable\n\n    [constructor]\n    blueprint = collective.transmogrifier.sections.constructor\n\n    [enable_versioning]\n    blueprint = plone.app.transmogrifier.versioning.enable\n\n\n\nWorkflow updater section\n------------------------\n\nA workflow updater pipeline section is another important transmogrifier content\nimport pipeline element. It executes workflow transitions on Plone content\nbased on the items it processes. The workflow updater section blueprint name is\n``plone.app.transmogrifier.workflowupdater``. Workflow updater sections operate\non objects already present in the ZODB, be they created by a constructor or\npre-existing objects.\n\nWorkflow updating needs 2 pieces of information: the path to the object, and\nwhat transitions to execute. To determine these, the workflow updater section\ninspects each item and looks for two keys, as described below. Any item missing\nany of these two pieces will be skipped. Similarly, items with a path that\ndoesn't exist will be skipped as well.\n\nFor the object path, it'll look (in order) for\n``_plone.app.transmogrifier.atschemaupdater_[sectionname]_path``,\n``_plone.app.transmogrifier.atschemaupdater_path``, ``_[sectionname]_path`` and\n``_path``, where ``[sectionname]`` is replaced with the name given to the\ncurrent section. This allows you to target the right section precisely if\nneeded. Alternatively, you can specify what key to use for the path by\nspecifying the ``path-key`` option, which should be a list of keys to try (one\nkey per line, use a ``re:`` or ``regexp:`` prefix to specify regular\nexpressions).\n\nFor the transitions, use the ``transitions-key`` option (same interpretation\nas ``path-key``), defaulting to\n``_plone.app.transmogrifier.atschemaupdater_[sectionname]_transitions``,\n``_plone.app.transmogrifier.atschemaupdater_transitions``,\n``_[sectionname]_transitions`` and ``_transitions``.\n\nUnicode paths are encoded to ASCII. Paths to objects are always interpreted as\nrelative to the context object. Transitions are specified as a sequence of\ntransition names, or as a string specifying one transition, or a list of\ndictionaries containing 'action' as transition id, 'review_state' as state id\nand 'time' as a DateTime representing the transition time (if so, the worflow\nhistory will be updated with the provided date). Transitions are executed in\norder, failing transitions are silently ignored.\n\n::\n\n    >>> import pprint\n    >>> workflow = \"\"\"\n    ... [transmogrifier]\n    ... pipeline =\n    ...     workflowsource\n    ...     workflowupdater\n    ...     printer\n    ...\n    ... [workflowsource]\n    ... blueprint = plone.app.transmogrifier.tests.workflowsource\n    ...\n    ... [workflowupdater]\n    ... blueprint = plone.app.transmogrifier.workflowupdater\n    ...\n    ... [printer]\n    ... blueprint = collective.transmogrifier.sections.logger\n    ... name = logger\n    ... \"\"\"\n    >>> registerConfig(u'plone.app.transmogrifier.tests.workflow',\n    ...                workflow)\n    >>> transmogrifier(u'plone.app.transmogrifier.tests.workflow')\n    >>> print(handler)\n    logger INFO\n      {'_path': '/spam/eggs/foo', '_transitions': 'spam'}\n    logger INFO\n      {'_path': '/spam/eggs/baz', '_transitions': ('spam', 'eggs')}\n    logger INFO\n        {'_path': 'not/existing/bar',\n       '_transitions': ('spam', 'eggs'),\n       'title': 'Should not be updated, not an existing path'}\n    logger INFO\n        {'_path': 'spam/eggs/incomplete',\n       'title': 'Should not be updated, no transitions'}\n    logger INFO\n        {'_path': '/spam/eggs/nosuchtransition',\n       '_transitions': ('nonsuch',),\n       'title': 'Should not be updated, no such transition'}\n    logger INFO\n        {'_path': '/spam/eggs/bla',\n       '_transitions': ({'action': 'spam',\n                         'review_state': 'spammed',\n                         'time': DateTime('2014/06/20 00:00:00 GMT+0')},)}\n\n    >>> pprint.pprint(plone.updated)\n    [('spam/eggs/foo', 'spam'),\n     ('spam/eggs/baz', 'spam'),\n     ('spam/eggs/baz', 'eggs'),\n     ('spam/eggs/bla', 'spam')]\n\n\nChangelog\n=========\n\n1.4.2 (2019-09-24)\n------------------\n\n- ``plone.app.transmogrifier.atschemaupdater`` updates fields in fixed order\n  (field names) for bette debuggability.\n  [gotcha]\n\n- ``plone.app.transmogrifier.pathfixer`` now also converts a path into ``str`` and removes any invalid characters from it;\n  this avoids ``UnicodeEncodeError`` in many blueprint sections.\n  [hvelarde]\n\n\n1.4.1 (2018-02-27)\n------------------\n\n- Avoid failures on redirector section when there is no object in referenced path.\n  [hvelarde]\n\n- Fix ``plone.app.transmogrifier.browserdefault`` blueprint section:\n  ``default_page`` and ``layout`` properties should be string, not unicode.\n  [sunew]\n\n\n1.4 (2015-10-23)\n----------------\n\n- Support updating effective and expiration dates on ``plone.app.transmogrifier.datesupdater`` blueprint.\n  Fix field discovering logic to avoid skipping the ones set as ``None``.\n  Fix documentation.\n  [hvelarde]\n\n- Support indexing of individual indexes for the\n  ``plone.app.transmogrifier.reindexobject`` blueprint.\n  [thet]\n\n\n1.3 (2015-01-22)\n----------------\n\n- Ignore if workflow_history is not available on objects when running the\n  workflowupdater blueprint.\n  [thet]\n\n- Add datesupdater section to set creation_date and modification_date on\n  objects.\n  [thet]\n\n- Add pathfixer section to remove/prepend parts of the path.\n  [thet]\n\n- PEP 8.\n  [thet]\n\n- Fix uidsection for dexterity.\n  [shylux]\n\n- Allow to import transition date in the worflow history\n  [ebrehault]\n\n- Fix field accessor and mutator for updating schemaextended field values\n  with schemaupdater.\n  In some cases when using fields extended by schemaextender it defines\n  an accessor attribute which is not accessable. To cover all fields, its\n  better to access and mutate over the getAccessor and getMutator methods on\n  archetype fields.\n  [elioschmutz]\n\n- Add a section to manage `plone.app.redirector` and to use it to\n  update paths.\n  [rpatterson]\n\n- Support field accessor and mutator for updating field values with\n  schemaupdater.\n  [phgross]\n\n\n1.2 (2011-05-23)\n----------------\n\n- Sections to disable and enable versioning within the pipeline.\n  [elro]\n\n- Convert paths to strings.\n  [elro]\n\n- Add a 'verbose' option to reindexobject blueprint\n  that logs the object currently reindexed and number of objects reindexed.\n  [thomasdesvenain]\n\n- Check for CatalogAware base class when reindexing an object instead of\n  CMFCatalogAware because in Plone 4 folders do not inherit from\n  CMFCatalogAware.\n  [buchi]\n\n\n1.1 (2010-03-30)\n----------------\n\n- Added Indexing section. See reindexobject.rst.\n  [sylvainb]\n\n- Added UID updated section. See uidupdater.rst.\n  [optilude]\n\n- Fixed tests for Plone 4, in the same way that they were fixed in\n  collective.transmogrifier.\n  [optilude]\n\n\n1.0 (2009-08-09)\n----------------\n\n- Initial package.\n  [mj]", "description_content_type": "", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "http://pypi.python.org/pypi/plone.app.transmogrifier", "keywords": "content import filtering plone", "license": "GPL", "maintainer": "", "maintainer_email": "", "name": "plone.app.transmogrifier", "package_url": "https://pypi.org/project/plone.app.transmogrifier/", "platform": "", "project_url": "https://pypi.org/project/plone.app.transmogrifier/", "project_urls": {"Homepage": "http://pypi.python.org/pypi/plone.app.transmogrifier"}, "release_url": "https://pypi.org/project/plone.app.transmogrifier/1.4.2/", "requires_dist": null, "requires_python": "", "summary": "Plone blueprints for collective.transmogrifier pipelines", "version": "1.4.2", "yanked": false, "html_description": "<div class=\"project-description\">\n            <div id=\"contents\">\n<p>Contents</p>\n<ul>\n<li><a href=\"#installation\" id=\"id8\" rel=\"nofollow\">Installation</a></li>\n<li><a href=\"#credits\" id=\"id9\" rel=\"nofollow\">Credits</a></li>\n<li><a href=\"#detailed-documentation\" id=\"id10\" rel=\"nofollow\">Detailed Documentation</a><ul>\n<li><a href=\"#atschema-updater-section\" id=\"id11\" rel=\"nofollow\">ATSchema updater section</a></li>\n<li><a href=\"#browser-default-section\" id=\"id12\" rel=\"nofollow\">Browser default section</a></li>\n<li><a href=\"#criterion-adder-section\" id=\"id13\" rel=\"nofollow\">Criterion adder section</a></li>\n<li><a href=\"#datesupdater-section\" id=\"id14\" rel=\"nofollow\">DatesUpdater section</a></li>\n<li><a href=\"#mime-encapsulator-section\" id=\"id15\" rel=\"nofollow\">Mime encapsulator section</a></li>\n<li><a href=\"#pathfixer-section\" id=\"id16\" rel=\"nofollow\">PathFixer section</a></li>\n<li><a href=\"#portal-transforms-section\" id=\"id17\" rel=\"nofollow\">Portal Transforms section</a></li>\n<li><a href=\"#redirector-section\" id=\"id18\" rel=\"nofollow\">Redirector section</a></li>\n<li><a href=\"#indexing-section\" id=\"id19\" rel=\"nofollow\">Indexing section</a></li>\n<li><a href=\"#uid-updater-section\" id=\"id20\" rel=\"nofollow\">UID updater section</a></li>\n<li><a href=\"#url-normalizer-section\" id=\"id21\" rel=\"nofollow\">URL Normalizer section</a></li>\n<li><a href=\"#disable-enable-versioning-sections\" id=\"id22\" rel=\"nofollow\">Disable / enable versioning sections</a></li>\n<li><a href=\"#workflow-updater-section\" id=\"id23\" rel=\"nofollow\">Workflow updater section</a></li>\n</ul>\n</li>\n<li><a href=\"#changelog\" id=\"id24\" rel=\"nofollow\">Changelog</a><ul>\n<li><a href=\"#id1\" id=\"id25\" rel=\"nofollow\">1.4.2 (2019-09-24)</a></li>\n<li><a href=\"#id2\" id=\"id26\" rel=\"nofollow\">1.4.1 (2018-02-27)</a></li>\n<li><a href=\"#id3\" id=\"id27\" rel=\"nofollow\">1.4 (2015-10-23)</a></li>\n<li><a href=\"#id4\" id=\"id28\" rel=\"nofollow\">1.3 (2015-01-22)</a></li>\n<li><a href=\"#id5\" id=\"id29\" rel=\"nofollow\">1.2 (2011-05-23)</a></li>\n<li><a href=\"#id6\" id=\"id30\" rel=\"nofollow\">1.1 (2010-03-30)</a></li>\n<li><a href=\"#id7\" id=\"id31\" rel=\"nofollow\">1.0 (2009-08-09)</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<p>This package contains several blueprints for collective.transmogrifier\npipelines, commonly used to import content into a Plone site.</p>\n<div id=\"installation\">\n<h2><a href=\"#id8\" rel=\"nofollow\">Installation</a></h2>\n<p>See docs/INSTALL.rst for installation instructions.</p>\n</div>\n<div id=\"credits\">\n<h2><a href=\"#id9\" rel=\"nofollow\">Credits</a></h2>\n<dl>\n<dt>Development sponsored by</dt>\n<dd>Elkj\u00f8p Nordic AS</dd>\n<dt>Design and development</dt>\n<dd><a href=\"mailto:mj%40jarn.com\">Martijn Pieters</a> at <a href=\"http://www.jarn.com/\" rel=\"nofollow\">Jarn</a>\n<a href=\"mailto:fschulze%40jarn.com\">Florian Schulze</a> at <a href=\"http://www.jarn.com/\" rel=\"nofollow\">Jarn</a></dd>\n</dl>\n</div>\n<div id=\"detailed-documentation\">\n<h2><a href=\"#id10\" rel=\"nofollow\">Detailed Documentation</a></h2>\n<div id=\"atschema-updater-section\">\n<h3><a href=\"#id11\" rel=\"nofollow\">ATSchema updater section</a></h3>\n<p>An AT schema updater pipeline section is another important transmogrifier\ncontent import pipeline element. It updates field values for Archetypes\nobjects based on their schema based on the items it processes. The AT schema\nupdater section blueprint name is\n<tt>plone.app.transmogrifier.atschemaupdater</tt>. AT Schema updater sections\noperate on objects already present in the ZODB, be they created by a\nconstructor or pre-existing objects.</p>\n<p>Schema updating needs at least 1 piece of information: the path to the object\nto update. To determine the path, the schema updater section inspects each\nitem and looks for one key, as described below. Any item missing this piece of\ninformation will be skipped. Similarly, items with a path that doesn\u2019t exist\nor are not Archetypes objects will be skipped as well.</p>\n<p>For the object path, it\u2019ll look (in order) for\n<tt>_plone.app.transmogrifier.atschemaupdater_[sectionname]_path</tt>,\n<tt>_plone.app.transmogrifier.atschemaupdater_path</tt>, <tt>_[sectionname]_path</tt>\nand <tt>_path</tt>, where <tt>[sectionname]</tt> is replaced with the name given to the\ncurrent section. This allows you to target the right section precisely if\nneeded. Alternatively, you can specify what key to use for the path by\nspecifying the <tt><span class=\"pre\">path-key</span></tt> option, which should be a list of keys to try (one\nkey per line, use a <tt>re:</tt> or <tt>regexp:</tt> prefix to specify regular\nexpressions).</p>\n<p>Paths to objects are always interpreted as relative to the context. Any\nwritable field who\u2019s id matches a key in the current item will be updated with\nthe corresponding value, using the field\u2019s mutator.</p>\n<pre>&gt;&gt;&gt; import pprint\n&gt;&gt;&gt; atschema = \"\"\"\n... [transmogrifier]\n... pipeline =\n...     schemasource\n...     schemaupdater\n...     printer\n...\n... [schemasource]\n... blueprint = plone.app.transmogrifier.tests.schemasource\n...\n... [schemaupdater]\n... blueprint = plone.app.transmogrifier.atschemaupdater\n...\n... [printer]\n... blueprint = collective.transmogrifier.sections.logger\n... name = logger\n... \"\"\"\n&gt;&gt;&gt; registerConfig(u'plone.app.transmogrifier.tests.atschema', atschema)\n\n&gt;&gt;&gt; transmogrifier(u'plone.app.transmogrifier.tests.atschema')\n&gt;&gt;&gt; print handler\nlogger INFO\n    {'_path': '/spam/eggs/foo',\n   'fieldnotchanged': 'nochange',\n   'fieldone': 'one value',\n   'fieldtwo': 2,\n   'fieldunicode': u'\\xe5',\n   'nosuchfield': 'ignored'}\nlogger INFO\n    {'_path': 'not/existing/bar',\n   'fieldone': 'one value',\n   'title': 'Should not be updated, not an existing path'}\nlogger INFO\n  {'fieldone': 'one value', 'title': 'Should not be updated, no path'}\nlogger INFO\n    {'_path': '/spam/eggs/notatcontent',\n   'fieldtwo': 2,\n   'title': 'Should not be updated, not an AT base object'}\n&gt;&gt;&gt; pprint.pprint(plone.updated)\n[('spam/eggs/foo', 'fieldone', 'one value-by-mutator'),\n ('spam/eggs/foo', 'fieldtwo', 2)]\n</pre>\n</div>\n<div id=\"browser-default-section\">\n<h3><a href=\"#id12\" rel=\"nofollow\">Browser default section</a></h3>\n<p>A browser default pipeline section sets the default-page on a folder, and the\nlayout template on content objects. They are the Transmogrifier equivalent of\nthe <tt>display</tt> menu in Plone. The browser default section blueprint name is\n<tt>plone.app.transmogrifier.browserdefault</tt>. Browser default sections operate\non objects already present in the ZODB, be they created by a constructor or\npre-existing objects.</p>\n<p>Setting the browser default needs at least 1 piece of information: the path to\nthe object to modify. To determine the path, the browser default section\ninspects each item and looks for one key, as described below. Any item missing\nthis piece of information will be skipped. Similarly, items with a path that\ndoesn\u2019t exist or do not support the Plone ISelectableBrowserDefault interface\nwill be skipped as well.</p>\n<p>For the object path, it\u2019ll look (in order) for\n<tt>_plone.app.transmogrifier.browserdefault_[sectionname]_path</tt>,\n<tt>_plone.app.transmogrifier.browserdefault_path</tt>, <tt>_[sectionname]_path</tt>\nand <tt>_path</tt>, where <tt>[sectionname]</tt> is replaced with the name given to the\ncurrent section. This allows you to target the right section precisely if\nneeded. Alternatively, you can specify what key to use for the path by\nspecifying the <tt><span class=\"pre\">path-key</span></tt> option, which should be a list of keys to try (one\nkey per line, use a <tt>re:</tt> or <tt>regexp:</tt> prefix to specify regular\nexpressions).</p>\n<p>Once an object has been located, the section will looks for defaultpage\nand layout keys. Like the path key, these can be specified in the source\nconfiguration, named by the <tt><span class=\"pre\">default-page-key</span></tt> and <tt><span class=\"pre\">layout-key</span></tt> options,\nrespectively, and like the path key, the default keys the section looks for\nare the usual list of specific-to-generic keys based on blueprint and section\nnames, from\n<tt>_plone.app.transmogrifier.browserdefault_[sectionname]_defaultpage</tt> and\n<tt>_plone.app.transmogrifier.browserdefault_[sectionname]_layout</tt> down to\n<tt>_defaultpage</tt> and <tt>_layout</tt>.</p>\n<p>The defaultpage key will set the id of the default page that should be\npresented when the content object is loaded, and the layout key will set the\nid of the layout to use for the content item.</p>\n<pre>&gt;&gt;&gt; import pprint\n&gt;&gt;&gt; browserdefault = \"\"\"\n... [transmogrifier]\n... pipeline =\n...     browserdefaultsource\n...     browserdefault\n...     printer\n...\n... [browserdefaultsource]\n... blueprint = plone.app.transmogrifier.tests.browserdefaultsource\n...\n... [browserdefault]\n... blueprint = plone.app.transmogrifier.browserdefault\n...\n... [printer]\n... blueprint = collective.transmogrifier.sections.logger\n... name = logger\n... \"\"\"\n&gt;&gt;&gt; registerConfig(u'plone.app.transmogrifier.tests.browserdefault',\n...                browserdefault)\n&gt;&gt;&gt; transmogrifier(u'plone.app.transmogrifier.tests.browserdefault')\n&gt;&gt;&gt; print(handler)\nlogger INFO\n  {'_layout': 'spam', '_path': '/spam/eggs/foo'}\nlogger INFO\n  {'_defaultpage': 'eggs', '_path': '/spam/eggs/bar'}\nlogger INFO\n  {'_defaultpage': 'eggs', '_layout': 'spam', '_path': '/spam/eggs/baz'}\nlogger INFO\n    {'_layout': 'spam',\n   '_path': 'not/existing/bar',\n   'title': 'Should not be updated, not an existing path'}\nlogger INFO\n    {'_path': 'spam/eggs/incomplete',\n   'title': 'Should not be updated, no layout or defaultpage'}\nlogger INFO\n    {'_layout': '',\n   '_path': 'spam/eggs/emptylayout',\n   'title': 'Should not be updated, no layout or defaultpage'}\nlogger INFO\n    {'_defaultpage': '',\n   '_path': 'spam/eggs/emptydefaultpage',\n   'title': 'Should not be updated, no layout or defaultpage'}\n&gt;&gt;&gt; pprint.pprint(plone.updated)\n[('spam/eggs/foo', 'layout', 'spam'),\n ('spam/eggs/bar', 'defaultpage', 'eggs'),\n ('spam/eggs/baz', 'layout', 'spam'),\n ('spam/eggs/baz', 'defaultpage', 'eggs')]\n</pre>\n</div>\n<div id=\"criterion-adder-section\">\n<h3><a href=\"#id13\" rel=\"nofollow\">Criterion adder section</a></h3>\n<p>A criterion adder section is used to add criteria to collections. It\u2019s section\nblueprint name is <tt>plone.app.transmogrifier.criterionadder</tt>. Criterion adder\nsections operate on objects already present in the ZODB, be they created by a\nconstructor or pre-existing objects.</p>\n<p>Given a path, a criterion type and a field name, this section will look up\na Collection at the given path, and add a criterion field, then alter the\npath of the item so further sections will act on the added criterion. For\nexample, an item with keys <tt>_path=bar/baz</tt>, <tt>_field=modified</tt> and\n<tt>_criterion=ATFriendlyDateCriteria</tt> will result in a new date criterion\nadded inside the bar/baz collection, and the item\u2019s path will be updated\nto <tt>bar/baz/crit__ATFriendlyDateCriteria_modified</tt>.</p>\n<p>For the  path, criterion type and field keys, it\u2019ll look (in order) for\n<tt>_plone.app.transmogrifier.atschemaupdater_[sectionname]_[key]</tt>,\n<tt>_plone.app.transmogrifier.atschemaupdater_[key]</tt>, <tt>_[sectionname]_[key]</tt>\nand <tt>_[key]</tt>, where <tt>[sectionname]</tt> is replaced with the name given to the\ncurrent section and <tt>[key]</tt> is <tt>path</tt>, <tt>criterion</tt> and <tt>field</tt>\nrespectively. This allows you to target the right section precisely if\nneeded. Alternatively, you can specify what key to use for these by\nspecifying the <tt><span class=\"pre\">path-key</span></tt>, <tt><span class=\"pre\">criterion-key</span></tt> and <tt><span class=\"pre\">field-key</span></tt> options,\nwhich should be a list of keys to try (one key per line, use a <tt>re:</tt> or\n<tt>regexp:</tt> prefix to specify regular expressions).</p>\n<p>Paths to objects are always interpreted as relative to the context, and must\nresolve to IATTopic classes.</p>\n<pre>&gt;&gt;&gt; import pprint\n&gt;&gt;&gt; criteria = \"\"\"\n... [transmogrifier]\n... pipeline =\n...     criteriasource\n...     criterionadder\n...     printer\n...\n... [criteriasource]\n... blueprint = plone.app.transmogrifier.tests.criteriasource\n...\n... [criterionadder]\n... blueprint = plone.app.transmogrifier.criterionadder\n...\n... [printer]\n... blueprint = collective.transmogrifier.sections.logger\n... name = logger\n... \"\"\"\n&gt;&gt;&gt; registerConfig(u'plone.app.transmogrifier.tests.criteria', criteria)\n&gt;&gt;&gt; transmogrifier(u'plone.app.transmogrifier.tests.criteria')\n&gt;&gt;&gt; print(handler)\nlogger INFO\n  {'_criterion': 'bar', '_field': 'baz', '_path': '/spam/eggs/foo/crit__baz_bar'}\nlogger INFO\n    {'_criterion': 'bar',\n   '_field': 'baz',\n   '_path': 'not/existing/bar',\n   'title': 'Should not be updated, not an existing path'}\nlogger INFO\n    {'_path': 'spam/eggs/incomplete',\n   'title': 'Should not be updated, no criterion or field'}\n&gt;&gt;&gt; pprint.pprint(plone.criteria)\n[('spam/eggs/foo', 'baz', 'bar')]\n</pre>\n</div>\n<div id=\"datesupdater-section\">\n<h3><a href=\"#id14\" rel=\"nofollow\">DatesUpdater section</a></h3>\n<p>This blueprint sets creation, modification and effective dates on objects.</p>\n<p>Blueprint name: <tt>plone.app.transmogrifier.datesupdater</tt></p>\n<p>Option path-key: The key for the path to the object.</p>\n<p>Option creation-key: The key for the creation date.</p>\n<p>Option modification-key: The key for the modification date.</p>\n<p>Option effective-key: The key for the effective date.</p>\n<p>Option expiration-key: The key for the expiration date.</p>\n<pre>&gt;&gt;&gt; import pprint\n&gt;&gt;&gt; pipeline = \"\"\"\n... [transmogrifier]\n... pipeline =\n...     schemasource\n...     datesupdater\n...     logger\n...\n... [schemasource]\n... blueprint = plone.app.transmogrifier.tests.schemasource\n...\n... [datesupdater]\n... blueprint = plone.app.transmogrifier.datesupdater\n... path-key = _path\n... creation-key = creation_date\n... modification-key = modification_date\n... effective-key = effective_date\n... expiration-key = expiration_date\n...\n... [logger]\n... blueprint = collective.transmogrifier.sections.logger\n... name = logger\n... \"\"\"\n&gt;&gt;&gt; registerConfig(u'plone.app.transmogrifier.tests.datesupdater', pipeline)\n\n&gt;&gt;&gt; transmogrifier(u'plone.app.transmogrifier.tests.datesupdater')\n</pre>\n<p>Print out the source structure:</p>\n<pre>&gt;&gt;&gt; print handler\nlogger INFO\n    {'_path': '/spam/eggs/foo',\n   'creation_date': DateTime('2010/10/10 00:00:00 UTC'),\n   'effective_date': DateTime('2010/10/10 00:00:00 UTC'),\n   'expiration_date': DateTime('2012/12/12 00:00:00 UTC'),\n   'modification_date': DateTime('2011/11/11 00:00:00 UTC')}\nlogger INFO\n    {'_path': '/spam/eggs/bar',\n   'creation_date': DateTime('2010/10/10 00:00:00 UTC')}\nlogger INFO\n    {'_path': '/spam/eggs/baz',\n   'modification_date': DateTime('2011/11/11 00:00:00 UTC')}\nlogger INFO\n    {'_path': '/spam/eggs/qux',\n   'effective_date': DateTime('2010/10/10 00:00:00 UTC')}\nlogger INFO\n    {'_path': '/spam/eggs/norf',\n   'expiration_date': DateTime('2012/12/12 00:00:00 UTC')}\nlogger INFO\n    {'_path': 'not/existing/bar',\n   'creation_date': DateTime('2010/10/10 00:00:00 UTC'),\n   'effective_date': DateTime('2010/10/10 00:00:00 UTC'),\n   'expiration_date': DateTime('2012/12/12 00:00:00 UTC'),\n   'modification_date': DateTime('2011/11/11 00:00:00 UTC')}\nlogger INFO\n    {'creation_date': DateTime('2010/10/10 00:00:00 UTC'),\n   'effective_date': DateTime('2010/10/10 00:00:00 UTC'),\n   'expiration_date': DateTime('2012/12/12 00:00:00 UTC'),\n   'modification_date': DateTime('2011/11/11 00:00:00 UTC')}\n</pre>\n<p>That was changed on the object:</p>\n<pre>&gt;&gt;&gt; pprint.pprint(plone.updated)\n[('spam/eggs/foo', 'creation_date', DateTime('2010/10/10 00:00:00 UTC')),\n ('spam/eggs/foo', 'modification_date', DateTime('2011/11/11 00:00:00 UTC')),\n ('spam/eggs/foo', 'effective_date', DateTime('2010/10/10 00:00:00 UTC')),\n ('spam/eggs/foo', 'expiration_date', DateTime('2012/12/12 00:00:00 UTC')),\n ('spam/eggs/bar', 'creation_date', DateTime('2010/10/10 00:00:00 UTC')),\n ('spam/eggs/baz', 'modification_date', DateTime('2011/11/11 00:00:00 UTC')),\n ('spam/eggs/qux', 'effective_date', DateTime('2010/10/10 00:00:00 UTC')),\n ('spam/eggs/norf', 'expiration_date', DateTime('2012/12/12 00:00:00 UTC'))]\n</pre>\n</div>\n<div id=\"mime-encapsulator-section\">\n<h3><a href=\"#id15\" rel=\"nofollow\">Mime encapsulator section</a></h3>\n<p>A mime encapsulator section wraps arbitrary data in <tt>OFS.Image.File</tt>\nobjects, together with a MIME type. This wrapping is a pre-requisite for\nArchetypes image, file or text fields, which can only take such File objects.\nThe mime encapsulator blueprint name is\n<tt>plone.app.transmogrifier.mimeencapsulator</tt>.</p>\n<p>An encapsulator section needs 3 pieces of information: the key at which to\nfind the data to encapsulate, the MIME type of this data, and the name of the\nfield where the encapsulated data will be stored. The idea is that the data\nis copied from a \u201cdata key\u201d (defaulting to <tt>_data</tt> and settable with the\n<tt><span class=\"pre\">data-key</span></tt> option), wrapped into a <tt>File</tt> object with a MIME type (read\nfrom the <tt>mimetype</tt> option, which contains a TALES expression), and then\nsaved into the pipeline item dictionary under a new key, most likely\ncorresponding to an Archetypes field name (read from the <tt>field</tt> option,\nwhich is also a TALES expression).</p>\n<p>The data key defaults to the series <tt>_[blueprintname]_[sectionname]_data</tt>,\n<tt>_[blueprintname]_data</tt>, <tt>_[sectionname]_data</tt> and <tt>_data</tt>, where\n<tt>[blueprintname]</tt> is <tt>plone.app.transmogrifier.mimeencapsulator</tt> and\n<tt>[sectionname]</tt> is replaced with the name of the current section. You can\noverride this by specifying the <tt><span class=\"pre\">data-key</span></tt> option.</p>\n<p>You specify the mimetype with the <tt>mimetype</tt> option, which takes a TALES\nexpression.</p>\n<p>The <tt>field</tt> option, also a TALES expression, sets the output field name.</p>\n<p>Optionally, you can specify a <tt>condition</tt> option, again a TALES expression,\nthat when evaluating to <tt>False</tt>, causes the section to skip encapsulation\nfor  that item.</p>\n<pre>&gt;&gt;&gt; encapsulator = \"\"\"\n... [transmogrifier]\n... pipeline =\n...     source\n...     encapsulator\n...     conditionalencapsulator\n...     printer\n...\n... [source]\n... blueprint = plone.app.transmogrifier.tests.encapsulatorsource\n...\n... [encapsulator]\n... blueprint = plone.app.transmogrifier.mimeencapsulator\n... # Read the mimetype from the item\n... mimetype = item/_mimetype\n... field = string:datafield\n...\n... [conditionalencapsulator]\n... blueprint = plone.app.transmogrifier.mimeencapsulator\n... data-key = portrait\n... mimetype = python:item.get('_%s_mimetype' % key)\n... # replace the data in-place\n... field = key\n... condition = mimetype\n...\n... [printer]\n... blueprint = plone.app.transmogrifier.tests.ofsfileprinter\n... \"\"\"\n&gt;&gt;&gt; registerConfig(u'plone.app.transmogrifier.tests.encapsulator',\n...                encapsulator)\n&gt;&gt;&gt; transmogrifier(u'plone.app.transmogrifier.tests.encapsulator')\ndatafield: (application/x-test-data) foobarbaz\nportrait: (image/jpeg) someportraitdata\n</pre>\n<p>The <tt>field</tt> expression has access to the following:</p>\n<dl>\n<dt><tt>item</tt></dt>\n<dd>The current pipeline item</dd>\n<dt><tt>key</tt></dt>\n<dd>The name of the matched data key</dd>\n<dt><tt>match</tt></dt>\n<dd>If the key was matched by a regular expression, the match object, otherwise boolean True</dd>\n<dt><tt>transmogrifier</tt></dt>\n<dd>The transmogrifier</dd>\n<dt><tt>name</tt></dt>\n<dd>The name of the splitter section</dd>\n<dt><tt>options</tt></dt>\n<dd>The splitter options</dd>\n<dt><tt>modules</tt></dt>\n<dd><tt>sys.modules</tt></dd>\n</dl>\n<p>The <tt>mimetype</tt> expression has access to the same information as the <tt>field</tt>\nexpression, plus:</p>\n<dl>\n<dt><tt>field</tt></dt>\n<dd>The name of the field in which the encapsulated data will be stored.</dd>\n</dl>\n<p>The <tt>condition</tt> expression has access to the same information as the\n<tt>mimetype</tt> expression, plus:</p>\n<dl>\n<dt><tt>mimetype</tt></dt>\n<dd>The mimetype used to encapsulate the data.</dd>\n</dl>\n</div>\n<div id=\"pathfixer-section\">\n<h3><a href=\"#id16\" rel=\"nofollow\">PathFixer section</a></h3>\n<p>When importing contents from a old site into a new, the path to the Plone site\nroot may have changed. This blueprint updates the old paths to match the new\nstructrue by removing or appending strings from the right side of the path\nvalue.</p>\n<p>It also converts the path to <tt>str</tt> and removes any invalid characters from it.</p>\n<p>Blueprint name: <tt>plone.app.transmogrifier.pathfixer</tt></p>\n<dl>\n<dt>Option path-key: The key of the item under which the path to be manipulated can</dt>\n<dd>be found. E.g. <tt>_path</tt>.</dd>\n</dl>\n<p>Option stripstring: A string to strip from the path value.</p>\n<p>Option prependstring: A string to append to the path value.</p>\n<p>Look, here. Original path structure from\nplone.app.transmogrifier.tests.schemasource is:</p>\n<pre>/spam/eggs/foo\nrelative/path\n/spam/eggs/another\n</pre>\n<p>Now lets manipulate it:</p>\n<pre>&gt;&gt;&gt; import pprint\n&gt;&gt;&gt; pipeline = \"\"\"\n... [transmogrifier]\n... pipeline =\n...     schemasource\n...     pathfixer\n...     logger\n...\n... [schemasource]\n... blueprint = plone.app.transmogrifier.tests.schemasource\n...\n... [pathfixer]\n... blueprint = plone.app.transmogrifier.pathfixer\n... path-key = _path\n... stripstring = /spam/eggs/\n... prependstring = subfolder/\n...\n... [logger]\n... blueprint = collective.transmogrifier.sections.logger\n... name = logger\n... key = _path\n... \"\"\"\n&gt;&gt;&gt; registerConfig(u'plone.app.transmogrifier.tests.pathfixer', pipeline)\n\n&gt;&gt;&gt; transmogrifier(u'plone.app.transmogrifier.tests.pathfixer')\n&gt;&gt;&gt; print handler\nlogger INFO\n  subfolder/foo\nlogger INFO\n  subfolder/relative/path\nlogger INFO\n  subfolder/another\n</pre>\n</div>\n<div id=\"portal-transforms-section\">\n<h3><a href=\"#id17\" rel=\"nofollow\">Portal Transforms section</a></h3>\n<p>A portal transforms pipeline section lets you use Portal Transforms to\ntransform item values. The portal transforms section blueprint name is\n<tt>plone.app.transmogrifier.portaltransforms</tt>.</p>\n<p>What values to transform is determined by the <tt>keys</tt> option, which takes a\nset of newline-separated key names. If a key name starts with <tt>re:</tt> or\n<tt>regexp:</tt> it is treated as a regular expression instead.</p>\n<p>You can specify what transformation to apply in two ways. Firstly, you can\ndirectly specify a transformation by naming it with the <tt>transform</tt> option;\nthe named transformation is run directly. Alternatively you can let the portal\ntransforms tool figure out what transform to use by specifying <tt>target</tt> and\nan optional <tt>from</tt> mimetype. The portal transforms tool will select one or\nmore transforms based on these mimetypes, and if no <tt>from</tt> option is given\nthe original item value is used to determine one.</p>\n<p>Also optional is the <tt>condition</tt> option, which lets you specify a TALES\nexpression that when evaluating to False will prevent any transformations from\nhappening. The condition is evaluated for every matched key.</p>\n<pre>&gt;&gt;&gt; ptransforms = \"\"\"\n... [transmogrifier]\n... pipeline =\n...     source\n...     transform-id\n...     transform-title\n...     transform-status\n...     printer\n...\n... [source]\n... blueprint = collective.transmogrifier.sections.tests.samplesource\n... encoding = utf8\n...\n... [transform-id]\n... blueprint = plone.app.transmogrifier.portaltransforms\n... transform = identity\n... keys = id\n...\n... [transform-title]\n... blueprint = plone.app.transmogrifier.portaltransforms\n... target = text/plain\n... keys = title\n...\n... [transform-status]\n... blueprint = plone.app.transmogrifier.portaltransforms\n... from = text/plain\n... target = text/plain\n... keys = status\n...\n... [printer]\n... blueprint = collective.transmogrifier.sections.logger\n... name = logger\n... \"\"\"\n&gt;&gt;&gt; registerConfig(u'plone.app.transmogrifier.tests.ptransforms',\n...                ptransforms)\n\n&gt;&gt;&gt; transmogrifier(u'plone.app.transmogrifier.tests.ptransforms')\n&gt;&gt;&gt; print handler\nlogger INFO\n    {'id': \"Transformed 'foo' using the identity transform\",\n   'status': \"Transformed '\\\\xe2\\\\x84\\\\x97' from text/plain to text/plain\",\n   'title': \"Transformed 'The Foo Fighters \\\\xe2\\\\x84\\\\x97' to text/plain\"}\nlogger INFO\n    {'id': \"Transformed 'bar' using the identity transform\",\n   'status': \"Transformed '\\\\xe2\\\\x84\\\\xa2' from text/plain to text/plain\",\n   'title': \"Transformed 'Brand Chocolate Bar \\\\xe2\\\\x84\\\\xa2' to text/plain\"}\nlogger INFO\n    {'id': \"Transformed 'monty-python' using the identity transform\",\n   'status': \"Transformed '\\\\xc2\\\\xa9' from text/plain to text/plain\",\n   'title': 'Transformed \"Monty Python\\'s Flying Circus \\\\xc2\\\\xa9\" to text/plain'}\n</pre>\n<p>The <tt>condition</tt> expression has access to the following:</p>\n<dl>\n<dt><tt>item</tt></dt>\n<dd>The current pipeline item</dd>\n<dt><tt>key</tt></dt>\n<dd>The name of the matched key</dd>\n<dt><tt>match</tt></dt>\n<dd>If the key was matched by a regular expression, the match object, otherwise boolean True</dd>\n<dt><tt>transmogrifier</tt></dt>\n<dd>The transmogrifier</dd>\n<dt><tt>name</tt></dt>\n<dd>The name of the splitter section</dd>\n<dt><tt>options</tt></dt>\n<dd>The splitter options</dd>\n<dt><tt>modules</tt></dt>\n<dd><tt>sys.modules</tt></dd>\n</dl>\n</div>\n<div id=\"redirector-section\">\n<h3><a href=\"#id18\" rel=\"nofollow\">Redirector section</a></h3>\n<p>A redirector section uses <cite>plone.app.redirector</cite> to manage redirects and update\npaths in keys.</p>\n<pre>&gt;&gt;&gt; import pprint\n&gt;&gt;&gt; redirector = \"\"\"\n... [transmogrifier]\n... pipeline =\n...     source\n...     clean-old-paths\n...     old-paths\n...     content-element\n...     redirect\n...     href\n...     logger\n...\n... [source]\n... blueprint = collective.transmogrifier.sections.csvsource\n... filename = plone.app.transmogrifier:redirector.csv\n...\n... [clean-old-paths]\n... blueprint = collective.transmogrifier.sections.manipulator\n... condition = not:item/_old_paths|nothing\n... delete = _old_paths\n...\n... [old-paths]\n... blueprint = collective.transmogrifier.sections.inserter\n... key = string:_old_paths\n... condition = exists:item/_old_paths\n... value = python:item['_old_paths'].split('|')\n...\n... [content-element]\n... blueprint = collective.transmogrifier.sections.inserter\n... key = string:_content_element\n... condition = item/remoteUrl\n... value = python:modules['xml.etree.ElementTree'].Element(\\\n...     'a', dict(href=item['remoteUrl']))\n...\n... [redirect]\n... blueprint = plone.app.transmogrifier.redirector\n...\n... [href]\n... blueprint = collective.transmogrifier.sections.inserter\n... key = string:_content_element\n... condition = exists:item/_content_element\n... value = python:item['_content_element'].attrib['href']\n...\n... [logger]\n... blueprint = collective.transmogrifier.sections.logger\n... name = logger\n... level = INFO\n... \"\"\"\n&gt;&gt;&gt; registerConfig(\n...     u'plone.app.transmogrifier.tests.redirector', redirector)\n\n&gt;&gt;&gt; transmogrifier(u'plone.app.transmogrifier.tests.redirector')\n&gt;&gt;&gt; print handler\nlogger INFO\n  {'_old_paths': ['corge', 'waldo'], '_redirect_path': 'foo', 'remoteUrl': ''}\nlogger INFO\n  {'_redirect_path': 'foo', 'remoteUrl': ''}\nlogger INFO\n    {'_old_paths': ['corge/item-00', 'waldo/item-00'],\n   '_redirect_path': 'foo/item-00',\n   'remoteUrl': ''}\nlogger INFO\n    {'_content_element': 'foo/item-00',\n   '_old_paths': ['corge/grault', 'waldo/fred'],\n   '_redirect_path': 'foo/bar',\n   'remoteUrl': 'foo/item-00'}\nlogger INFO\n    {'_content_element': '/foo/item-00#fragment',\n   '_old_paths': ['corge/grault/item-01', 'waldo/fred/item-01'],\n   '_redirect_path': 'http://nohost/foo/bar/item-01',\n   'remoteUrl': '/foo/item-00#fragment'}\nlogger INFO\n  {'_redirect_path': '/foo/bar/qux', 'remoteUrl': ''}\nlogger INFO\n    {'_content_element': 'http://nohost/foo/bar/item-01',\n   '_redirect_path': '/foo/bar/qux/item-02',\n   'remoteUrl': 'http://nohost/foo/bar/item-01'}\n\n&gt;&gt;&gt; import pprint\n&gt;&gt;&gt; from zope.component import getUtility\n&gt;&gt;&gt; from plone.app.redirector.interfaces import IRedirectionStorage\n&gt;&gt;&gt; storage = getUtility(IRedirectionStorage)\n&gt;&gt;&gt; pprint.pprint(dict((path, storage.get(path)) for path in storage))\n{'/plone/corge': '/plone/foo',\n '/plone/corge/grault': '/plone/foo/bar',\n '/plone/corge/grault/item-01': 'http://nohost/foo/bar/item-01',\n '/plone/corge/item-00': '/plone/foo/item-00',\n '/plone/waldo': '/plone/foo',\n '/plone/waldo/fred': '/plone/foo/bar',\n '/plone/waldo/fred/item-01': 'http://nohost/foo/bar/item-01',\n '/plone/waldo/item-00': '/plone/foo/item-00'}\n</pre>\n</div>\n<div id=\"indexing-section\">\n<h3><a href=\"#id19\" rel=\"nofollow\">Indexing section</a></h3>\n<p>A ReindexObject section allows you to reindex an existing object in the\nportal_catalog. ReindexObject sections operate on objects already present in the\nZODB, be they created by a constructor or pre-existing objects.</p>\n<p>The ReindexObject blueprint name is <tt>plone.app.transmogrifier.reindexobject</tt>.</p>\n<p>To determine the path, the ReindexObject section inspects each item and looks\nfor a path key, as described below. Any item missing this key will be skipped.\nSimilarly, items with a path that doesn\u2019t exist or are not referenceable\n(Archetypes) or do not inherit from CMFCatalogAware will be skipped as well.</p>\n<p>The object path will be found under the first key found among the following:</p>\n<ul>\n<li><tt>_plone.app.transmogrifier.reindexobject_[sectionname]_path</tt></li>\n<li><tt>_plone.app.transmogrifier.reindexobject_path</tt></li>\n<li><tt>_[sectionname]_path</tt></li>\n<li><tt>_path</tt></li>\n</ul>\n<p>where <tt>[sectionname]</tt> is replaced with the name given to the current section.\nThis allows you to target the right section precisely if needed.</p>\n<p>Alternatively, you can specify what key to use for the path by specifying the\n<tt><span class=\"pre\">path-key</span></tt> option, which should be a list of keys to try (one key per line;\nuse a <tt>re:</tt> or <tt>regexp:</tt> prefix to specify regular expressions).</p>\n<p>Paths to objects are always interpreted as relative to the context.</p>\n<pre>&gt;&gt;&gt; import pprint\n&gt;&gt;&gt; reindexobject_1 = \"\"\"\n... [transmogrifier]\n... pipeline =\n...     reindexobjectsource\n...     reindexobject\n...     printer\n...\n... [reindexobjectsource]\n... blueprint = plone.app.transmogrifier.tests.reindexobjectsource\n...\n... [reindexobject]\n... blueprint = plone.app.transmogrifier.reindexobject\n...\n... [printer]\n... blueprint = collective.transmogrifier.sections.logger\n... name = logger\n... \"\"\"\n&gt;&gt;&gt; registerConfig(u'plone.app.transmogrifier.tests.reindexobject_1', reindexobject_1)\n\n&gt;&gt;&gt; transmogrifier(u'plone.app.transmogrifier.tests.reindexobject_1')\n&gt;&gt;&gt; print(handler)\nlogger INFO\n  {'_path': '/spam/eggs/foo'}\nlogger INFO\n  {'_path': '/spam/eggs/bar'}\nlogger INFO\n  {'_path': '/spam/eggs/baz'}\nlogger INFO\n    {'_path': 'not/a/catalog/aware/content',\n   'title': 'Should not be reindexed, not a CMFCatalogAware content'}\nlogger INFO\n    {'_path': 'not/existing/bar',\n   'title': 'Should not be reindexed, not an existing path'}\n\n&gt;&gt;&gt; pprint.pprint(plone.reindexed)\n[('spam/eggs/foo', 'reindexed', 'indexes: all'),\n ('spam/eggs/bar', 'reindexed', 'indexes: all'),\n ('spam/eggs/baz', 'reindexed', 'indexes: all')]\n\nReset:\n&gt;&gt;&gt; plone.reindexed = []\n</pre>\n<p>Index only the <tt>foo</tt> index:</p>\n<pre>&gt;&gt;&gt; import pprint\n&gt;&gt;&gt; reindexobject_2 = \"\"\"\n... [transmogrifier]\n... pipeline =\n...     reindexobjectsource\n...     reindexobject\n...     printer\n...\n... [reindexobjectsource]\n... blueprint = plone.app.transmogrifier.tests.reindexobjectsource\n...\n... [reindexobject]\n... blueprint = plone.app.transmogrifier.reindexobject\n... indexes = foo\n...\n... [printer]\n... blueprint = collective.transmogrifier.sections.logger\n... name = logger\n... \"\"\"\n&gt;&gt;&gt; registerConfig(u'plone.app.transmogrifier.tests.reindexobject_2', reindexobject_2)\n\n&gt;&gt;&gt; transmogrifier(u'plone.app.transmogrifier.tests.reindexobject_2')\n\n&gt;&gt;&gt; pprint.pprint(plone.reindexed)\n[('spam/eggs/foo', 'reindexed', 'indexes: foo'),\n ('spam/eggs/bar', 'reindexed', 'indexes: foo'),\n ('spam/eggs/baz', 'reindexed', 'indexes: foo')]\n\nReset:\n&gt;&gt;&gt; plone.reindexed = []\n</pre>\n<p>Index only the <tt>foo</tt>, <tt>bar</tt> and <tt>baz</tt> indexes:</p>\n<pre>&gt;&gt;&gt; import pprint\n&gt;&gt;&gt; reindexobject_3 = \"\"\"\n... [transmogrifier]\n... pipeline =\n...     reindexobjectsource\n...     reindexobject\n...     printer\n...\n... [reindexobjectsource]\n... blueprint = plone.app.transmogrifier.tests.reindexobjectsource\n...\n... [reindexobject]\n... blueprint = plone.app.transmogrifier.reindexobject\n... indexes =\n...     foo\n...     bar\n...     baz\n...\n... [printer]\n... blueprint = collective.transmogrifier.sections.logger\n... name = logger\n... \"\"\"\n&gt;&gt;&gt; registerConfig(u'plone.app.transmogrifier.tests.reindexobject_3', reindexobject_3)\n\n&gt;&gt;&gt; transmogrifier(u'plone.app.transmogrifier.tests.reindexobject_3')\n\n&gt;&gt;&gt; pprint.pprint(plone.reindexed)\n[('spam/eggs/foo', 'reindexed', 'indexes: foo, bar, baz'),\n ('spam/eggs/bar', 'reindexed', 'indexes: foo, bar, baz'),\n ('spam/eggs/baz', 'reindexed', 'indexes: foo, bar, baz')]\n\nReset:\n&gt;&gt;&gt; plone.reindexed = []\n</pre>\n</div>\n<div id=\"uid-updater-section\">\n<h3><a href=\"#id20\" rel=\"nofollow\">UID updater section</a></h3>\n<p>If an Archetypes content object is created in a pipeline, e.g. by the standard\ncontent constructor section, it will get a new UID. If you are importing\ncontent from another Plone site, and you have references (or links embedded\nin content using Plone\u2019s link-by-UID feature) to existing content, you may\nwant to retain UIDs. The UID updater section allows you to set the UID on an\nexisting object for this purpose.</p>\n<p>The UID updater blueprint name is <tt>plone.app.transmogrifier.uidupdater</tt>.</p>\n<p>UID updating requires two pieces of information: the path to the object\nto update, and the new UID to set.</p>\n<p>To determine the path, the UID updater section inspects each item and looks\nfor a path key, as described below. Any item missing this key will be skipped.\nSimilarly, items with a path that doesn\u2019t exist or are not referenceable\n(Archetypes) objects will be skipped.</p>\n<p>The object path will be found under the first key found among the following:</p>\n<ul>\n<li><tt>_plone.app.transmogrifier.atschemaupdater_[sectionname]_path</tt></li>\n<li><tt>_plone.app.transmogrifier.atschemaupdater_path</tt></li>\n<li><tt>_[sectionname]_path</tt></li>\n<li><tt>_path</tt></li>\n</ul>\n<p>where <tt>[sectionname]</tt> is replaced with the name given to the current\nsection. This allows you to target the right section precisely if\nneeded.</p>\n<p>Alternatively, you can specify what key to use for the path by specifying the\n<tt><span class=\"pre\">path-key</span></tt> option, which should be a list of keys to try (one key per line;\nuse a <tt>re:</tt> or <tt>regexp:</tt> prefix to specify regular expressions).</p>\n<p>Paths to objects are always interpreted as relative to the context.</p>\n<p>Similarly, the UID to set must be a string under a given key. You can set the\nkey with the <tt><span class=\"pre\">uid-key</span></tt> option, which behaves much like <tt><span class=\"pre\">path-key</span></tt>. The\ndefault is to look under:</p>\n<ul>\n<li><tt>_plone.app.transmogrifier.atschemaupdater_[sectionname]_uid</tt></li>\n<li><tt>_plone.app.transmogrifier.atschemaupdater_uid</tt></li>\n<li><tt>_[sectionname]_uid</tt></li>\n<li><tt>_uid</tt></li>\n</ul>\n<p>If the UID key is missing, the item will be skipped.</p>\n<p>Below is an example of a standard updater. The test uid source produces\nitems with two keys: a path under <tt>_path</tt> and a UID string under <tt>_uid</tt>.</p>\n<pre>&gt;&gt;&gt; import pprint\n&gt;&gt;&gt; atschema = \"\"\"\n... [transmogrifier]\n... pipeline =\n...     schemasource\n...     schemaupdater\n...     printer\n...\n... [schemasource]\n... blueprint = plone.app.transmogrifier.tests.uidsource\n...\n... [schemaupdater]\n... blueprint = plone.app.transmogrifier.uidupdater\n...\n... [printer]\n... blueprint = collective.transmogrifier.sections.logger\n... name = logger\n... \"\"\"\n&gt;&gt;&gt; registerConfig(u'plone.app.transmogrifier.tests.uid', atschema)\n&gt;&gt;&gt; transmogrifier(u'plone.app.transmogrifier.tests.uid')\n&gt;&gt;&gt; print(handler)\nlogger INFO\n  {'_path': '/spam/eggs/foo', '_uid': 'abc'}\nlogger INFO\n  {'_path': '/spam/eggs/bar', '_uid': 'xyz'}\nlogger INFO\n  {'_path': 'not/existing/bar', '_uid': 'def'}\nlogger INFO\n  {'_uid': 'geh'}\nlogger INFO\n  {'_path': '/spam/eggs/baz'}\nlogger INFO\n  {'_path': '/spam/notatcontent', '_uid': 'ijk'}\n\n&gt;&gt;&gt; pprint.pprint(plone.uids_set)\n[('spam/eggs/foo', 'abc')]\n</pre>\n</div>\n<div id=\"url-normalizer-section\">\n<h3><a href=\"#id21\" rel=\"nofollow\">URL Normalizer section</a></h3>\n<p>A URLNormalizer section allows you to parse any piece of text into a url-safe\nstring which is then assigned to a specified key. It uses plone.i18n.normalizer\nto perform the normalization. The url normalizer section blueprint name is\n<tt>plone.app.transmogrifier.urlnormalizer</tt>.</p>\n<p>The URL normalizer accepts the following optional keys -\n<tt><span class=\"pre\">source-key</span></tt>: The name of the object key that you wish to normalize,\n<tt><span class=\"pre\">destination-key</span></tt>: Where you want the normalized string to be stored,\n<tt>locale</tt>: if you want the normalizer to be aware of locale, use this.</p>\n<pre>&gt;&gt;&gt; import pprint\n&gt;&gt;&gt; urlnormalizer = \"\"\"\n... [transmogrifier]\n... pipeline =\n...     urlnormalizersource\n...     urlnormalizer\n...     printer\n...\n... [urlnormalizersource]\n... blueprint = plone.app.transmogrifier.tests.urlnormalizersource\n...\n... [urlnormalizer]\n... blueprint = plone.app.transmogrifier.urlnormalizer\n... source-key = title\n... destination-key = string:id\n... locale = string:en\n...\n... [printer]\n... blueprint = collective.transmogrifier.sections.logger\n... name = logger\n... \"\"\"\n&gt;&gt;&gt; registerConfig(u'plone.app.transmogrifier.tests.urlnormalizer',\n...                urlnormalizer)\n&gt;&gt;&gt; transmogrifier(u'plone.app.transmogrifier.tests.urlnormalizer')\n&gt;&gt;&gt; print(handler)\nlogger INFO\n  {'id': 'mytitle', 'title': 'mytitle'}\nlogger INFO\n  {'id': 'is-this-a-title-of-any-sort', 'title': 'Is this a title of any sort?'}\nlogger INFO\n    {'id': 'put-some-br-1lly-v4lues-here-there',\n   'title': 'Put some &lt;br /&gt; $1llY V4LUES -- here&amp;there'}\nlogger INFO\n    {'id': 'what-about-line-breaks-system',\n   'title': 'What about \\r\\n line breaks (system)'}\nlogger INFO\n  {'id': 'try-one-of-these-oh', 'title': 'Try one of these --------- oh'}\nlogger INFO\n  {'language': 'My language is de'}\nlogger INFO\n  {'language': 'my language is en'}\n</pre>\n<p>As you can see, only items containing the specified source-key have been\nprocessed, the others have been ignored and yielded without change.</p>\n<p>Destination-key and locale accept TALES expressions, so for example you could\nset your destination-key based on your locale element, which is in turn derived\nfrom your source-key:</p>\n<pre>&gt;&gt;&gt; import pprint\n&gt;&gt;&gt; urlnormalizer = \"\"\"\n... [transmogrifier]\n... pipeline =\n...     urlnormalizersource\n...     urlnormalizer\n...     printer\n...\n... [urlnormalizersource]\n... blueprint = plone.app.transmogrifier.tests.urlnormalizersource\n...\n... [urlnormalizer]\n... blueprint = plone.app.transmogrifier.urlnormalizer\n... source-key = language\n... locale = python:str(item.get('${urlnormalizer:source-key}', 'na')[-2:])\n... destination-key = ${urlnormalizer:locale}\n...\n... [printer]\n... blueprint = collective.transmogrifier.sections.logger\n... name = logger\n... \"\"\"\n&gt;&gt;&gt; registerConfig(u'plone.app.transmogrifier.tests.urlnormalizer2',\n...                urlnormalizer)\n\n&gt;&gt;&gt; handler.clear()\n&gt;&gt;&gt; transmogrifier(u'plone.app.transmogrifier.tests.urlnormalizer2')\n&gt;&gt;&gt; print(handler)\nlogger INFO\n  {'title': 'mytitle'}\nlogger INFO\n  {'title': 'Is this a title of any sort?'}\nlogger INFO\n  {'title': 'Put some &lt;br /&gt; $1llY V4LUES -- here&amp;there'}\nlogger INFO\n  {'title': 'What about \\r\\n line breaks (system)'}\nlogger INFO\n  {'title': 'Try one of these --------- oh'}\nlogger INFO\n  {'de': 'my-language-is-de', 'language': 'My language is de'}\nlogger INFO\n  {'en': 'my-language-is-en', 'language': 'my language is en'}\n</pre>\n<p>In this case only items containing the \u2018language\u2019 key have been processed, and\nthe destination-key has been set to the same value as the locale was. This is\nmore to illuminate the fact that the locale was set, rather than providing a\nsensible use-case for destination-key.</p>\n<p>If ZERO options are specified, the normalizer falls back to a set of default\nvalues as follows:\n<tt><span class=\"pre\">source-key</span></tt>: title,\n<tt>locale</tt>: en,\n<tt><span class=\"pre\">destination-key</span></tt>: _id</p>\n<pre>&gt;&gt;&gt; import pprint\n&gt;&gt;&gt; urlnormalizer = \"\"\"\n... [transmogrifier]\n... pipeline =\n...     urlnormalizersource\n...     urlnormalizer\n...     printer\n...\n... [urlnormalizersource]\n... blueprint = plone.app.transmogrifier.tests.urlnormalizersource\n...\n... [urlnormalizer]\n... blueprint = plone.app.transmogrifier.urlnormalizer\n...\n... [printer]\n... blueprint = collective.transmogrifier.sections.logger\n... name = logger\n... \"\"\"\n&gt;&gt;&gt; registerConfig(u'plone.app.transmogrifier.tests.urlnormalizer3',\n...                urlnormalizer)\n\n&gt;&gt;&gt; handler.clear()\n&gt;&gt;&gt; transmogrifier(u'plone.app.transmogrifier.tests.urlnormalizer3')\n&gt;&gt;&gt; print(handler)\nlogger INFO\n  {'_id': 'mytitle', 'title': 'mytitle'}\nlogger INFO\n  {'_id': 'is-this-a-title-of-any-sort', 'title': 'Is this a title of any sort?'}\nlogger INFO\n    {'_id': 'put-some-br-1lly-v4lues-here-there',\n   'title': 'Put some &lt;br /&gt; $1llY V4LUES -- here&amp;there'}\nlogger INFO\n    {'_id': 'what-about-line-breaks-system',\n   'title': 'What about \\r\\n line breaks (system)'}\nlogger INFO\n  {'_id': 'try-one-of-these-oh', 'title': 'Try one of these --------- oh'}\nlogger INFO\n  {'language': 'My language is de'}\nlogger INFO\n  {'language': 'my language is en'}\n</pre>\n<p>In this case, the destination-key is set to a controller variable, like _path,\nas it is expected that the newly formed Id will in most cases be used further\ndown the pipeline in constructing the full, final path to the new Plone object.</p>\n<p>It should be noted that this section can effectively transform <em>any</em> section of\ntext and turn it into a normalized, web safe string (max 255 chars) This string\ndoes not necessarily need to be used for a URL.</p>\n</div>\n<div id=\"disable-enable-versioning-sections\">\n<h3><a href=\"#id22\" rel=\"nofollow\">Disable / enable versioning sections</a></h3>\n<p>It can be helpful to disable versioning during content construction to avoid\nstoring incomplete versions in the content item\u2019s revision history.</p>\n<p>For example:</p>\n<pre>[transmogrifier]\npipeline =\n    schemasource\n    disable_versioning\n    constructor\n    enable_versioning\n    schemaupdater\n\n[disable_versioning]\nblueprint = plone.app.transmogrifier.versioning.disable\n\n[constructor]\nblueprint = collective.transmogrifier.sections.constructor\n\n[enable_versioning]\nblueprint = plone.app.transmogrifier.versioning.enable\n</pre>\n</div>\n<div id=\"workflow-updater-section\">\n<h3><a href=\"#id23\" rel=\"nofollow\">Workflow updater section</a></h3>\n<p>A workflow updater pipeline section is another important transmogrifier content\nimport pipeline element. It executes workflow transitions on Plone content\nbased on the items it processes. The workflow updater section blueprint name is\n<tt>plone.app.transmogrifier.workflowupdater</tt>. Workflow updater sections operate\non objects already present in the ZODB, be they created by a constructor or\npre-existing objects.</p>\n<p>Workflow updating needs 2 pieces of information: the path to the object, and\nwhat transitions to execute. To determine these, the workflow updater section\ninspects each item and looks for two keys, as described below. Any item missing\nany of these two pieces will be skipped. Similarly, items with a path that\ndoesn\u2019t exist will be skipped as well.</p>\n<p>For the object path, it\u2019ll look (in order) for\n<tt>_plone.app.transmogrifier.atschemaupdater_[sectionname]_path</tt>,\n<tt>_plone.app.transmogrifier.atschemaupdater_path</tt>, <tt>_[sectionname]_path</tt> and\n<tt>_path</tt>, where <tt>[sectionname]</tt> is replaced with the name given to the\ncurrent section. This allows you to target the right section precisely if\nneeded. Alternatively, you can specify what key to use for the path by\nspecifying the <tt><span class=\"pre\">path-key</span></tt> option, which should be a list of keys to try (one\nkey per line, use a <tt>re:</tt> or <tt>regexp:</tt> prefix to specify regular\nexpressions).</p>\n<p>For the transitions, use the <tt><span class=\"pre\">transitions-key</span></tt> option (same interpretation\nas <tt><span class=\"pre\">path-key</span></tt>), defaulting to\n<tt>_plone.app.transmogrifier.atschemaupdater_[sectionname]_transitions</tt>,\n<tt>_plone.app.transmogrifier.atschemaupdater_transitions</tt>,\n<tt>_[sectionname]_transitions</tt> and <tt>_transitions</tt>.</p>\n<p>Unicode paths are encoded to ASCII. Paths to objects are always interpreted as\nrelative to the context object. Transitions are specified as a sequence of\ntransition names, or as a string specifying one transition, or a list of\ndictionaries containing \u2018action\u2019 as transition id, \u2018review_state\u2019 as state id\nand \u2018time\u2019 as a DateTime representing the transition time (if so, the worflow\nhistory will be updated with the provided date). Transitions are executed in\norder, failing transitions are silently ignored.</p>\n<pre>&gt;&gt;&gt; import pprint\n&gt;&gt;&gt; workflow = \"\"\"\n... [transmogrifier]\n... pipeline =\n...     workflowsource\n...     workflowupdater\n...     printer\n...\n... [workflowsource]\n... blueprint = plone.app.transmogrifier.tests.workflowsource\n...\n... [workflowupdater]\n... blueprint = plone.app.transmogrifier.workflowupdater\n...\n... [printer]\n... blueprint = collective.transmogrifier.sections.logger\n... name = logger\n... \"\"\"\n&gt;&gt;&gt; registerConfig(u'plone.app.transmogrifier.tests.workflow',\n...                workflow)\n&gt;&gt;&gt; transmogrifier(u'plone.app.transmogrifier.tests.workflow')\n&gt;&gt;&gt; print(handler)\nlogger INFO\n  {'_path': '/spam/eggs/foo', '_transitions': 'spam'}\nlogger INFO\n  {'_path': '/spam/eggs/baz', '_transitions': ('spam', 'eggs')}\nlogger INFO\n    {'_path': 'not/existing/bar',\n   '_transitions': ('spam', 'eggs'),\n   'title': 'Should not be updated, not an existing path'}\nlogger INFO\n    {'_path': 'spam/eggs/incomplete',\n   'title': 'Should not be updated, no transitions'}\nlogger INFO\n    {'_path': '/spam/eggs/nosuchtransition',\n   '_transitions': ('nonsuch',),\n   'title': 'Should not be updated, no such transition'}\nlogger INFO\n    {'_path': '/spam/eggs/bla',\n   '_transitions': ({'action': 'spam',\n                     'review_state': 'spammed',\n                     'time': DateTime('2014/06/20 00:00:00 GMT+0')},)}\n\n&gt;&gt;&gt; pprint.pprint(plone.updated)\n[('spam/eggs/foo', 'spam'),\n ('spam/eggs/baz', 'spam'),\n ('spam/eggs/baz', 'eggs'),\n ('spam/eggs/bla', 'spam')]\n</pre>\n</div>\n</div>\n<div id=\"changelog\">\n<h2><a href=\"#id24\" rel=\"nofollow\">Changelog</a></h2>\n<div id=\"id1\">\n<h3><a href=\"#id25\" rel=\"nofollow\">1.4.2 (2019-09-24)</a></h3>\n<ul>\n<li><tt>plone.app.transmogrifier.atschemaupdater</tt> updates fields in fixed order\n(field names) for bette debuggability.\n[gotcha]</li>\n<li><tt>plone.app.transmogrifier.pathfixer</tt> now also converts a path into <tt>str</tt> and removes any invalid characters from it;\nthis avoids <tt>UnicodeEncodeError</tt> in many blueprint sections.\n[hvelarde]</li>\n</ul>\n</div>\n<div id=\"id2\">\n<h3><a href=\"#id26\" rel=\"nofollow\">1.4.1 (2018-02-27)</a></h3>\n<ul>\n<li>Avoid failures on redirector section when there is no object in referenced path.\n[hvelarde]</li>\n<li>Fix <tt>plone.app.transmogrifier.browserdefault</tt> blueprint section:\n<tt>default_page</tt> and <tt>layout</tt> properties should be string, not unicode.\n[sunew]</li>\n</ul>\n</div>\n<div id=\"id3\">\n<h3><a href=\"#id27\" rel=\"nofollow\">1.4 (2015-10-23)</a></h3>\n<ul>\n<li>Support updating effective and expiration dates on <tt>plone.app.transmogrifier.datesupdater</tt> blueprint.\nFix field discovering logic to avoid skipping the ones set as <tt>None</tt>.\nFix documentation.\n[hvelarde]</li>\n<li>Support indexing of individual indexes for the\n<tt>plone.app.transmogrifier.reindexobject</tt> blueprint.\n[thet]</li>\n</ul>\n</div>\n<div id=\"id4\">\n<h3><a href=\"#id28\" rel=\"nofollow\">1.3 (2015-01-22)</a></h3>\n<ul>\n<li>Ignore if workflow_history is not available on objects when running the\nworkflowupdater blueprint.\n[thet]</li>\n<li>Add datesupdater section to set creation_date and modification_date on\nobjects.\n[thet]</li>\n<li>Add pathfixer section to remove/prepend parts of the path.\n[thet]</li>\n<li>PEP 8.\n[thet]</li>\n<li>Fix uidsection for dexterity.\n[shylux]</li>\n<li>Allow to import transition date in the worflow history\n[ebrehault]</li>\n<li>Fix field accessor and mutator for updating schemaextended field values\nwith schemaupdater.\nIn some cases when using fields extended by schemaextender it defines\nan accessor attribute which is not accessable. To cover all fields, its\nbetter to access and mutate over the getAccessor and getMutator methods on\narchetype fields.\n[elioschmutz]</li>\n<li>Add a section to manage <cite>plone.app.redirector</cite> and to use it to\nupdate paths.\n[rpatterson]</li>\n<li>Support field accessor and mutator for updating field values with\nschemaupdater.\n[phgross]</li>\n</ul>\n</div>\n<div id=\"id5\">\n<h3><a href=\"#id29\" rel=\"nofollow\">1.2 (2011-05-23)</a></h3>\n<ul>\n<li>Sections to disable and enable versioning within the pipeline.\n[elro]</li>\n<li>Convert paths to strings.\n[elro]</li>\n<li>Add a \u2018verbose\u2019 option to reindexobject blueprint\nthat logs the object currently reindexed and number of objects reindexed.\n[thomasdesvenain]</li>\n<li>Check for CatalogAware base class when reindexing an object instead of\nCMFCatalogAware because in Plone 4 folders do not inherit from\nCMFCatalogAware.\n[buchi]</li>\n</ul>\n</div>\n<div id=\"id6\">\n<h3><a href=\"#id30\" rel=\"nofollow\">1.1 (2010-03-30)</a></h3>\n<ul>\n<li>Added Indexing section. See reindexobject.rst.\n[sylvainb]</li>\n<li>Added UID updated section. See uidupdater.rst.\n[optilude]</li>\n<li>Fixed tests for Plone 4, in the same way that they were fixed in\ncollective.transmogrifier.\n[optilude]</li>\n</ul>\n</div>\n<div id=\"id7\">\n<h3><a href=\"#id31\" rel=\"nofollow\">1.0 (2009-08-09)</a></h3>\n<ul>\n<li>Initial package.\n[mj]</li>\n</ul>\n</div>\n</div>\n\n          </div>"}, "last_serial": 5878468, "releases": {"1.0": [{"comment_text": "", "digests": {"md5": "6a56334b17e07efd8dda94b3da195274", "sha256": "8d03a7457fc847d60ee25cbd63ac6d8524a9b4d9b6e343193440966f71b060db"}, "downloads": -1, "filename": "plone.app.transmogrifier-1.0.zip", "has_sig": false, "md5_digest": "6a56334b17e07efd8dda94b3da195274", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 44127, "upload_time": "2009-08-09T17:37:03", "upload_time_iso_8601": "2009-08-09T17:37:03.067774Z", "url": "https://files.pythonhosted.org/packages/ec/5b/d315d52f04200eb09b7cdfba22abd1aadd50c15d7e380390c787a2052af2/plone.app.transmogrifier-1.0.zip", "yanked": false}], "1.1": [{"comment_text": "", "digests": {"md5": "7204c8a30dfbf08ed2ac0b88d3bca9a5", "sha256": "b45e3ce8dc841a3bc55951b9cabc9da04c0daee1996f1b2137e481fa46bc9c43"}, "downloads": -1, "filename": "plone.app.transmogrifier-1.1.zip", "has_sig": false, "md5_digest": "7204c8a30dfbf08ed2ac0b88d3bca9a5", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 52195, "upload_time": "2010-03-30T14:42:37", "upload_time_iso_8601": "2010-03-30T14:42:37.836290Z", "url": "https://files.pythonhosted.org/packages/29/8c/274784290a584ea4f7223ebdb9e535969b2808fcad95b3ab117b0cb0d185/plone.app.transmogrifier-1.1.zip", "yanked": false}], "1.2": [{"comment_text": "", "digests": {"md5": "c720a56a2d1791230cedbfde54eef8fc", "sha256": "747a334559fa41bc8faadaebf72a12497eacf049457a997b189d39edfcf4b343"}, "downloads": -1, "filename": "plone.app.transmogrifier-1.2.zip", "has_sig": false, "md5_digest": "c720a56a2d1791230cedbfde54eef8fc", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 54750, "upload_time": "2011-05-23T19:59:37", "upload_time_iso_8601": "2011-05-23T19:59:37.485378Z", "url": "https://files.pythonhosted.org/packages/a0/39/443f81308f28291cfe2c1df75160bfe21def92c2dd6ef9b13756ee670620/plone.app.transmogrifier-1.2.zip", "yanked": false}], "1.3": [{"comment_text": "", "digests": {"md5": "8b365ca30622c3d0e070238e49b5a5a8", "sha256": "20c051d9d5fcc7e1d3806d0a6ad5eb54e9ab11b37758d9520466b36c37d06f74"}, "downloads": -1, "filename": "plone.app.transmogrifier-1.3.zip", "has_sig": false, "md5_digest": "8b365ca30622c3d0e070238e49b5a5a8", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 85740, "upload_time": "2015-01-22T15:04:49", "upload_time_iso_8601": "2015-01-22T15:04:49.010404Z", "url": "https://files.pythonhosted.org/packages/4f/c6/76cac56b8e4f3d02d0469d489fe8b931abe52103e505764c35359f200ed3/plone.app.transmogrifier-1.3.zip", "yanked": false}], "1.4": [{"comment_text": "", "digests": {"md5": "86b1c7d912bef877022d9b47aca57ddc", "sha256": "19190dfee35654fdb730c1dff33ff3e84c1c98175d9ab88ed35238d75887ae33"}, "downloads": -1, "filename": "plone.app.transmogrifier-1.4.tar.gz", "has_sig": false, "md5_digest": "86b1c7d912bef877022d9b47aca57ddc", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 65223, "upload_time": "2015-10-23T09:10:49", "upload_time_iso_8601": "2015-10-23T09:10:49.615153Z", "url": "https://files.pythonhosted.org/packages/4b/59/e57fc62ede9abcf43239facbe13ed7b588155d23924576697ba0ca23b015/plone.app.transmogrifier-1.4.tar.gz", "yanked": false}], "1.4.1": [{"comment_text": "", "digests": {"md5": "7992aa3250112d54555951c7d0e0d6d5", "sha256": "1a845ea96bafd9c0833f618dc4ced5d2f10ec4123fac288907581881c34b8830"}, "downloads": -1, "filename": "plone.app.transmogrifier-1.4.1.tar.gz", "has_sig": false, "md5_digest": "7992aa3250112d54555951c7d0e0d6d5", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 65883, "upload_time": "2018-02-27T16:06:59", "upload_time_iso_8601": "2018-02-27T16:06:59.636357Z", "url": "https://files.pythonhosted.org/packages/0d/56/c63cf8d336f5de4f5b7c5a94a6060eba1f0a110c3c998a2651f3c53bb5c9/plone.app.transmogrifier-1.4.1.tar.gz", "yanked": false}], "1.4.2": [{"comment_text": "", "digests": {"md5": "b43c9966ae64de9c061d4978c6540c3b", "sha256": "465a80ba555da62988a70ac8fe079b6de2cf344c3ac90e920dbe5172b8b0724b"}, "downloads": -1, "filename": "plone.app.transmogrifier-1.4.2.tar.gz", "has_sig": false, "md5_digest": "b43c9966ae64de9c061d4978c6540c3b", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 67431, "upload_time": "2019-09-24T09:01:32", "upload_time_iso_8601": "2019-09-24T09:01:32.438719Z", "url": "https://files.pythonhosted.org/packages/2a/61/39a90873f23622252ecd7c1f6e9f35220554546301c8cab5f4ac61f67836/plone.app.transmogrifier-1.4.2.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "b43c9966ae64de9c061d4978c6540c3b", "sha256": "465a80ba555da62988a70ac8fe079b6de2cf344c3ac90e920dbe5172b8b0724b"}, "downloads": -1, "filename": "plone.app.transmogrifier-1.4.2.tar.gz", "has_sig": false, "md5_digest": "b43c9966ae64de9c061d4978c6540c3b", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 67431, "upload_time": "2019-09-24T09:01:32", "upload_time_iso_8601": "2019-09-24T09:01:32.438719Z", "url": "https://files.pythonhosted.org/packages/2a/61/39a90873f23622252ecd7c1f6e9f35220554546301c8cab5f4ac61f67836/plone.app.transmogrifier-1.4.2.tar.gz", "yanked": false}], "timestamp": "Fri May  8 02:53:05 2020"}