{"info": {"author": "Mark Michon", "author_email": "markmichon7@gmail.com", "bugtrack_url": null, "classifiers": ["License :: OSI Approved :: MIT License", "Operating System :: OS Independent", "Programming Language :: Python :: 3.7"], "description": "**(10/29/19) GUI development starting in new repository!**  Work on transforming BitGlitter from a Python library to an executable with a GUI has begun.  It's been said for a long time on my Discord server that making it accessible to much larger group of people beyond Python devs would help a lot with exposure and getting more momentum, so its a no brainer to make this our next priority.  All future development work will continue there.  The Python library will continue to get all core architecture/performance/protocol updates.  The GUI will be made using PyQt5.  There are also a few planned performance updates to BitGlitter prior to the release of the program.  If you're following this project, be sure to follow this new link as well.  And as always, come check out our Discord server!\n\n**[https://github.com/MarkMichon1/BitGlitter-GUI](https://github.com/MarkMichon1/BitGlitter-GUI)**\n\n[![Downloads](https://pepy.tech/badge/bitglitter)](https://pepy.tech/project/bitglitter)\n\n**[Discord Server](https://discord.gg/t9uv2pZ)**\n\n![BitGlitter Logo](https://i.imgur.com/3GJ4bDx.png)\n\n# The basics\n\n![BitGlitter Sample GIF](https://i.imgur.com/n7E7lnd.gif)\n\n**[Click here](https://www.youtube.com/watch?v=HrY4deFrOoA) for a demo video of a real stream.**\n\nBitGlitter is an easy to use library that allows you to embed data inside of ordinary pictures or video.  Store and host\nfiles wherever images or videos can be hosted.\n\n### From physical barcodes to digital data transfer\n\nWhether it's barcodes at the store or QR codes you can scan with your phone- they both work on the same principle.  Data\nis encoded into the black and white.  You can think of each color as an abstraction for a binary value, so then when\nthose colors are read in sequence, you can pull meaningful data from the image.  I wondered how this concept could be\nimproved upon, and I wanted a cool first project as an introduction to programming.  BitGlitter was born.\n\nConventional barcodes are severely limited in application, in terms of their data density.  When you maximize the \nconcept and configure it for digital-digital transmission, a lot of capability is gained.  \nBitGlitter is in a class of it's own in several ways:\n\n![BitGlitter Default Palettes](https://i.imgur.com/dSYmq7V.png)\n\n+ **Multiple Color Palettes:**  By removing the constraint of only using black and white, the amount of data you can \nhold in a given \"block\" (each square) on the frame skyrockets.  The regular two color setup holds one bit per block.  \nFour colors holds two  bits (2x), sixty four colors holds six bits (6x), and lossless ~16.7M color palette holds 24 bits \n(24x improvement over black & white).  You choose what color palette you'd like to use according to your application.  \nSmaller sets are far resistant to compression and corruption, while larger sets have higher data densities.  You can\ncreate your own custom palettes as well with whatever colors you'd like to use.  More about that below.\n+ **Multi-Frame Videos:** BitGlitter automatically breaks up larger files into multiple frames, with several headers\nbuilt into them.  These include several layers of protection against corruption, as well as metadata about the frame\nas well as the stream itself so the reader can intelligently decide how to handle it.  By stitching these frames\n together and turning them into a video, you can embed files and folders of arbitrary size into videos and images.  \nYou're only limited by your hard drive.\n+ **Variable block size:** Each of the blocks in the frame can be set to any size, including one pixel.  Larger block \nsizes give your stream protection in lossy environments, while smaller blocks allow for greater densities.\n\nCurrently, BitGlitter is configured to transport files and folders on a computer.  But with minimal modification you can\nuse videos or images as a carrier for virtually any kind of binary data.\n\n### What this means in practical terms\n\nHere's some real data that gives you an idea of what is possible with this:\n\nNumber of Colors | Bits Per Block | Screen Resolution | Block Size in Pixels | Block Dimensions | Framerate | Throughput | Lossless Application\n--- | --- | --- | --- | --- | --- | --- | ---\n2 | 1 | 640 x 480 (480p) | 20 | 32 x 24 | 30 | 2.88 KB/s | No\n4 | 2 | 1280 \u00d7 720 (720p) | 20 | 64 x 36 | 30 | 17.28 KB/s | No\n8 | 3 | 1280 \u00d7 720 (720p) | 20 | 64 x 36 | 30 | 25.92 KB/s | No\n16 | 4 | 1920 x 1080 (1080p) | 20 | 96 x 54 | 30 | 77.76 KB/s | No\n64 | 6 | 1920 x 1080 (1080p) | 20 | 96 x 54 | 30 | 116.64 KB/s | No\n64 | 6 | 1920 x 1080 (1080p) | 20 | 96 x 54 | 60 | 233.28 KB/s | No\n16,777,216 | 24 | 1920 x 1080 (1080p) | 5 | 384 x 216 | 30 | 7.47 MB/s | Yes\n16,777,216 | 24 | 3840 x 2160 (4k) | 5 | 768 x 432 | 60 | 59.7 MB/s | Yes\n\nPut simply, you can now make videos that can hold large amounts of data inside of them.  There may be some pretty\ninteresting applications that can come out of this.\n\n# Features\n\n### Data\n\n+ **Supports streams up to ~1 EB in size, or ~4.3B frames:**  In other words, there is no practical limit to the\n stream's size.\n+ **Compression added:** This is done automatically, so don't worry about putting your files in a rar or zip prior to\nsending.\n+ **Encryption added:** Optional AES-256 encryption to protect your files.  Passwords are hashed with `scrypt`, \nparameters can be customized for your needs.\n+ **File masking:**  Optional ability to mask what files are included in the stream.  Only those who successfully grab \nthe stream (and decrypt it if applicable) will know of its contents.\n\n### Outputted Files\n\nYou can choose between either outputting all of your frames as a series of images (.png), or as a single .mp4.\n\n+ **Customizable resolution:** You have complete control of the size of the outputted frames, whether they are 480p or\n8K.\n+ **Customizable framerate:** Currently supports 30 and 60 FPS, custom values are coming soon.\n\n![Custom Color Showcase](https://i.imgur.com/4uQTxwT.png)\n\n+ **Custom Color Palettes:** The included default palettes are just a starting point.  Make any color palette that you\nwant to match the aesthetic where it's being used.  Anyone reading the stream will have the palette automatically saved\nto their machine, so then they can use it as well!  Functionality is included to output a text file outlining all of the\ncolor palettes you have available to use, both default and custom.\n\n### Reading\n\n+ **Error correction against compression or corruption:** BitGlitter protects your file against corruption and artifacts \non the image or video. After loading the correct palette, whenever it detects an incorrect color, it will \"snap\" it to \nthe nearest color in the palette.  This gives your file resistance against format changes, codecs, or file size \nreduction.  This allows BitGlitter streams to still be read in environments that would otherwise render all existing \nsteganography methods unreadable.\n\n+ **Complete file integrity:** When the stream is created, a hash (SHA-256) is taken of the entire stream, as\nwell as each frame.  The data must match what is expected to be accepted.  Damaged or corrupt files will not be blindly\npassed on to you.\n\n+ **Streamlined frame bypassing:**  If a frame cannot or doesn't need to be read (ie, a duplicate already read), the \nreader determines this from an initial frame header\n\n### Design\n\n+ **No metadata saved in the file:**  Compress the stream, change formats, upload it somewhere.  All data is encoded in\nthe blocks, so you don't have to worry (as much) about rendering the stream unreadable.\n\n+ **Easy to understand:** Whether you're learning about Python and want to understand how it works, or you're looking to\ncontribute, docstrings and notes are throughout the library.\n\n+ **Built in future-proofing:** As of now, BitGlitter has a single protocol (Protocol 1), which is a specific set of\n  procedures around how data is handled, and the components of a frame, as well as their layout.  Each protocol has its\n  own unique ID to identify it with.  This ID is added in the  header during the write process, and is picked up at \n  `read()`.  As new protocols get created, older versions of BitGlitter that don't have these included will notify the user\n  to update their version in order for it to be read.  All older protocol versions are saved in future library\n  iterations, so no matter how old the protocol version is used on the stream, it will always be able to be read.\n\n+ **Fully modular design:** Do you have a specialized use case?  Adapting this library to your own needs is quite easy.\n  I've built BitGlitter to be easy to modify and expand upon.  Rather than worrying about the lower-level functionality,\n  achieve your goal with the modular components I've created.\n\n### CLI\n\n**Temporary warning-** Due to issues uploading to PyPI, these features are only available on Github for now.  The PyPI version of BitGlitter still performs everything else fine.  This will be removed when the problem is fixed.\n\nWrite from command line:\n\n+ `python3 -m bitglitter write`\n\n      `-file` - The absolute path to the file\n      `-mode` - Either 'image' or 'video'. Default: video\n      `-o` - Output path\n\n Read from commnad line:\n\n+ `python3 -m bitglitter read`\n\n      `-file` - The absolute path to the file\n      `-o` - Output path\n\n### Applications\nTo be determined.  This will be updated as time progresses!\n\n# How to use\n\nAll of the functions to run this library are explained below.  I'm also working on several Wikipedia pages, explaining\nBitGlitter in greater detail (how it works, etc) with some included illustrations.  These are not yet complete, \n[but here is the link to the project's Wiki if you'd like to see it!](https://github.com/MarkMichon1/BitGlitter/wiki/Using-BitGlitter)\n\n### Installation\n\nIn addition to downloading the code from Github, you can also grab it directly from PyPI:\n\n`pip install bitglitter`\n\n**IMPORTANT:** The only part you will need to grab manually is a copy of ffmpeg.exe .  Place it in the same folder the \ncode will be running, and you'll be set.  This will be done automatically in the near future.  Get the package here on\nthe left side of the screen:\n\n[https://ffmpeg.org/download.html](https://ffmpeg.org/download.html)\n\nffmpeg.exe is all that is needed.\n\n**Required Third Party Libraries**\n\n+ `bitstring` - Bit manipulation.\n+ `cryptography` - Cryptographic functions.\n+ `ffmpeg-python` - Video rendering and output.\n+ `opencv-python` - Video loading and frame manipulation.\n+ `Pillow` - Frame creation and output, as well as loading images and reading pixel values.\n\nThanks to Tanmay Mishra for giving me a pre-release version of his upcoming library `filepackager`.  It has been heavily\nmodified and stripped down to suit this library.  The code is included with BitGlitter; there is no need to download it.\n\n**BitGlitter in 60 seconds**\n\nEven though it comes shipped with a lot of functionality, all you need to use it is `write()` (creates the streams) and \n`read()` (which reads them and extracts the data encoded in it).  The only required argument for both is the file you\nwish to input in string format.\n\n### write(), converting files into BitGlitter streams\n\nWe'll go a bit more in depth now.\n\n`write()` is the function that inputs files and turns them into a BitGlitter stream.  There are quite a few arguments\nto customize the stream, but there is only one required argument.  Everything else has defaults.\n\nNot surprisingly, that required argument defines what files or folders you wish to embed in the stream.  If and only if\nyou're sending a single file or folder path, argument `fileList` takes a string of the path.  BitGlitter also supports\nsending multiple files and folder together, of which there is no limit!  This would require using a tuple or list item\nfilled with strings of the file or folder paths.  File or folder paths that don't exist are automatically ignored.\n\n`stream_name=''` is what you can use to optionally title your stream, which will be printed out on the screen of whoever\nreads the file, along with other stream data.\n\n`stream_description=''` serves as a text field to optionally put a description for the stream.\n\n`output_path=False` is where you can optionally define the path of where the created media is outputted.  By\ndefault, media is saved where the python file is ran.  The folder path must already exist if used.\n\n`output_mode='video'` is where you define how you wish the stream to output, whether as an .mp4 video, or a series of\n.png images.  The only two valid arguments are `'image'` and `'video'`.\n\n`output_name=''` is how you can customize the output name of the file that is created.  Videos, for instance, will be \nnamed 'custom_name.mp4', while images will be named 'custom_name.png - 1', 'custom_name.png - 2', etc, the number being\neach frame number.  If left blank, it will use the current date and time of the `write()` function starting as the file\nname.\n\n`compression_enabled=True` enables or disables compression of your data, prior to rendering into frames.  This is enabled\nby default.\n\n`file_mask_enabled=False` is where you can omit the listing of files/folders from the stream header.  This effectively\nhides the contents of the stream, unless it is fully read.  By default, this is disabled.  What this means is when\nsomeone reads your stream, in the first several frames it will automatically display the contents of the stream (files\nas well as their size) on the screen.\n\n`encryption_key=''` optionally encrypts your data with AES-256.  By default, this is disabled.  The stream will not be\nable to be read unless the reader successfully inputs this.\n\nArguments `scrypt_N=14`, `scrypt_R=8` and `scrypt_P=1` allow you to customize the parameters of the `scrypt` key derivation \nfunction.  If you're a casual user, you'll never need to touch these (and shouldn't).  Only change these settings if\n you're comfortable with cryptography and you know what you're doing!  It's worth noting `scrypt_N` uses it's argument as\n 2^n.  Finally, if you're changing these numbers, they MUST be manually inputted during `read()` otherwise decryption\n will fail!  Custom values are deliberately not transmitted in the stream for security reasons.  Your end users of the\n stream must know these custom parameters.\n\n`header_palette_id='6'` sets the palette used in the 'setup' frames in the beginning.  It is strongly recommended you use\na default palette here if you don't know what you're doing, because this is where important information regarding the\nstream is read, and by using a custom palette, it will be impossible for anyone to read it who hasn't already 'learned'\nthe palette.\n\n`stream_palette_id='6'` sets the palette used for the payload.  By default, the 4 bit default color set is used.  I'll \nexplain all about palettes below.\n\n`pixel_width=24` sets how many pixels wide each block is when rendered.  By default it's 20 pixels.  This is a very\nimportant value regarding readability.  Having them overly large will make reading them easier, but will result in less\nefficient frames and require substantially longer streams.  Making them very small will greatly increase their\nefficiency, but at the same time a lot more susceptible to read failures if the files are shrunk, or otherwise\ndistorted.\n\n`block_height=45` sets how many blocks tall the frame will be, by default this is set to 45 (which along with \n`block_width`, creates a perfect 1080p sized frame).\n\n`block_width=80` sets how many blocks wide the frame will be.  By default this is set to 96.\n\n`frames_per_second=30` sets how many frames per second the video will play at, assuming argument `output_mode = \"video\"`.\nCurrently, 30fps and 60fps are accepted.\n\nFinally we have several arguments to control logging.\n\n`logging_level='info'` determines what level logging messages get outputted.  It accepts three arguments- `info` is\ndefault and only shows core status data during `read()` and `write()`.  `'debug'`  shows INFO level messages as well as\nlower level messages from the various processes.  Boolean `False` disables logging altogether.\n\n`logging_screen_output=True` sets whether logging messages are displayed on the screen or not.  Only accepts type `bool`. \nEnabled by default.\n\n`logging_save_output=False` determines whether logging messages are saved as text files or not.  Only accepts type `bool`.\nDisabled by default.  If set to `True`, a log folder will be created, and text files will be automatically saved there.\n\nThese default values have an 81KB/s transmission rate.  This is only a starting point that should be pretty resistant to\ncorruption.\n\n### read(), converting streams back into data\n\n`read()` is what you use to input BitGlitter streams (whether images or video), and will output the files.\n\nLike with `write()`, the only argument required is the BitGlitter-encoded file, whether that's an image or a video.\n`file_to_input` is the only required argument.  We'll go over the other ones.\n\n`output_path=None` Is where you can set where this stream will be saved once all frames have been successfully loaded.\n  It's 'set and forget', so if you are loading images this argument only has to be used once, and the folder path will\n  stick with that stream.  This argument requires a strong of a folder path that already exists.\n\n`bad_frame_strikes=10` This sets how many corrupted frames the reader is to detect before it aborts out of a video.  This\nallows you to break out of a stream relatively quickly if the video is substantially corrupted, without needing to\n iterate over each frame.  If this is set to 0, it will disable strikes altogether, and attempt to read each frame \n regardless of the level of corruption.\n\n`block_height_override=False` and `block_width_override=False` allow you to manually input the stream's block height and \nblock width.  Normally you'll never need to use this, as these values are automatically obtained as the frame is locked\nonto.  But for a badly corrupted or compressed frame, this may not be the case.  By using the override, the reader will\nattempt to lock onto the screen given these parameters.  Both must be filled in order for the override to work.\n\n`encryption_key=None` is where you add the encryption key to decrypt the stream.  Like argument `output_path`, you only\nneed this argument once, and it will bind to that save.\n\nArguments `scrypt_n=14`, `scrypt_r=8` and `scrypt_p=1`\n\n`logging_level = 'info'`, `logging_screen_output = True`, `logging_save_output = False` - Please see the full explanation at\n`write().`\n\n### Color Palettes\n\nIf you wish to make your own custom color palettes, BitGlitter gives you the ability to do that with these functions.\n\n`add_custom_palette(palette_name, palette_description, color_set, optional_nickname = \"\")`  This function adds custom palettes\nto use.  \n\nArgument `palette_name` takes a string and is the name of the palette that gets displayed and transmitted. \n\nArgument`palette_description` takes a string as well, and is the description of the palette, if you wish to add it.  \n\nArgument `color_set` takes a tuple of RGB tuples, these will be the actual colors used in the BitGlitter stream.  Here's \na simple example of what it would look like using two colors: `color_set=((0, 255, 0), (0, 0, 255))`.  There are a few\nrequirements to these tuples:\n+ No two identical values can be added.  For instance, the color black with the same RGB values twice.  Each color used\nmust be unique!  The more 'different' the colors are, the better.\n+ You must have a minimum of two colors.\n+ It must be 2^n colors used, so 2, 4, 8, 16, etc.\n\nArgument `optional_nickname=\"\"` allows you to use an easy to input nickname for your custom palette.  This nickname is \n  how you select this palette to specifically run on your stream.  Internally, custom palettes have a 64 character ID \n  code which you can use (more on this below).  This allows you to give it a string of your choosing to designate it as \n  well.  This field is optional.  If you do decide to use it though, both the internal ID AND the nickname will work.\n\n`edit_nickname_to_custom_palette(id_or_nick, new_name)` This function allows you to edit the nickname of your custom palette \nto something else.  Both arguments require strings.  You can use it's nickname you assigned it, or it's internal ID.\n\n`print_full_palette_list(path)` This function outputs a text file to the folder path outlining the palettes available, both\ndefault palettes and custom.  It shows information such as their name, description, date created, color set, nickname,\nand more.  The required argument is a string of a folder path, which must already exist.  Here's an example of how to\nformat it: `C:\\Users\\Mark\\Desktop`\n\n`clear_all_custom_palettes()` This removes all custom palettes from your config.  Please note that the default palettes \nwill not be removed.\n\n`remove_custom_palette(id_or_nick)` This function removes the custom palette from your config.  It takes a string argument\nof either it's internal ID, or a nickname you've previously given it.\n\n`remove_custom_palette_nickname(id_or_nick)` This function strips any nickname associated with a custom palette.  It takes a\nstring argument of either the internal ID or a previous nickname.\n\n`clear_custom_palette_nicknames()`  This removes all nicknames from all custom palettes.\n\n### Partial Save Control\n\nOnce the first frame of a stream is read, a PartialSave object is created.  This is essentially what manages the binary\nstrings, and holds various information on it's state.  These functions help better interface with them.\n\n`update_partial_save(stream_sha, reattempt_assembly = True, password_update = None, scrypt_n =  None, scrypt_r = None, \nscrypt_p = None, change_output_path = None)` This function allows you to update various parameters of the save.  Requires\na string input for `streamSHA` which is the ID number of the string.  \n\nArgument `reattempt_assembly` makes the assembler\nattempt to reassemble the frames, as well as output the embedded files and folders.  This would be used in the case of\nan incorrect password or scrypt parameters, and you'd like to try again.\n\nArgument `password_update` takes a string argument, and will add (or replace) the encryption key tied to this stream.\n\nArguments `scrypt_n, scrypt_r and scrypt_p` change the scrypt parameters used to derive the key used for decryption.  If\nthe scrypt parameters were left at default during `write()` of the stream, these can be left as is.  Otherwise, the \ncustom values will need to be inputted whether here or in the optional arguments of `read()`.\n\n`begin_assembly(stream_sha)` This function exists to initiate assembly of a package at a later time, rather than doing so \nimmediately for whatever reason.\n\n`print_full_save_list(path, debug_data=False)` This function outputs a text file to the folder path outlining all (if any)\npartial saves you have on your system.  You can check their status, as well as the state of the PartialSave object \nitself.  Argument `debugData` is `False` by default, but enabling it to `True` outputs various debug information \npertaining to the object as well, which wouldn't serve much utility seeing for someone such as a casual end user.\n\n`remove_partial_save(stream_sha)`  Using a string argument for the stream's ID (or stream SHA, as commonly used), this will\nremove the object from your config, as well as remove all temporary data associated with it.\n\n`remove_all_partial_saves()` All saves are removed from the config object, clearing all temporary data.\n\n### General Configuration\n\n`outputStats(path)` This function gives you a neat bird's eye view of your BitGlitter usage.  During all `read()` and \n`write()` cycles, the total amount of data transferred, as well as total frames transferred and individual blocks \nscanned gets added to a running total.  Argument `path` requires a string argument of a folder path that already exists.\nA small text file will be written to this location.\n\n`clear_stats()` All statistics will be reset to zero.\n\n`clear_session()` This wipes all inputted data.  Custom colors, statistics, and partial save objects will all be erased,\nas well as any temporary data for the partially read streams.  This is in essence a hard reset.\n\n# Contributing\n\nWhether you're a seasoned programmer or brand new, there's plenty of things you can do to help this project succeed.\nJoin our discord server, and check out all of the information I posted in the \"Information\" category.  Thank you for\nyour interest!\n\n**Discord Link**\n\n**https://discord.gg/t9uv2pZ**\n\nAlso, be sure to check out the \n[contributing master page](https://github.com/MarkMichon1/BitGlitter/wiki/Contributing-Master-Page).  It contains a lot\nof information.\n\n![Splitter](https://i.imgur.com/qIygifj.png)\n\n### Practical Limits\n\nIt's worth stating the constraints you may face while using this.  While the images and video BitGlitter exports are\nlossless (no compression applied), the \"real world\" on the internet is much different.  For instance, multimedia \nuploaded to popular social media sites is regularly compressed in order to save space (and ultimately cut down on \nexpenses).  You are protected *to an extent* with BitGlitter from this.  Write parameters are fully customizable\nprimarily for this reason.  \n\nWhile you can have greater throughput with larger colorsets, smaller blocks, and faster framerates, there may be a\npractical limit to whether it will work depending on the degree their compression reduces quality.  At the expense of\nthroughput, larger blocks, slower framerates, and fewer colors used will make the stream *far* more resistant to\npossible corruption.  Approaching the extreme limits of these parameters (tiny block sizes, very fast framerates, very\nlarge colorsets), in terms of reading it and converting it back into data, requires very precise measurements of\nposition and color value; *a codec's purpose is to blur those precise values to reduce it's bitrate, and in turn it's\nfile size.*  While BitGlitter will detect corruption and perform an \"emergency stop,\" I know you don't want to deal with\nthat, and neither do the people you're sharing with.\n\nIn closing, know the environment the video will be used in to ensure success in reading it.\n\n# MIT License\n\u00a9 2019 - \u221e Mark Michon\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated \ndocumentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the \nrights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit\n persons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the \nSoftware.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE \nWARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR \nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR \nOTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/MarkMichon1/BitGlitter", "keywords": "", "license": "", "maintainer": "", "maintainer_email": "", "name": "BitGlitter", "package_url": "https://pypi.org/project/BitGlitter/", "platform": "", "project_url": "https://pypi.org/project/BitGlitter/", "project_urls": {"Homepage": "https://github.com/MarkMichon1/BitGlitter"}, "release_url": "https://pypi.org/project/BitGlitter/1.0.3/", "requires_dist": ["bitstring", "cryptography", "ffmpeg-python", "opencv-python", "Pillow", "argparse"], "requires_python": "", "summary": "\u26a1 Embed data payloads inside of ordinary images or video, through high performance 2-D matrix codes.", "version": "1.0.3", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p><strong>(10/29/19) GUI development starting in new repository!</strong>  Work on transforming BitGlitter from a Python library to an executable with a GUI has begun.  It's been said for a long time on my Discord server that making it accessible to much larger group of people beyond Python devs would help a lot with exposure and getting more momentum, so its a no brainer to make this our next priority.  All future development work will continue there.  The Python library will continue to get all core architecture/performance/protocol updates.  The GUI will be made using PyQt5.  There are also a few planned performance updates to BitGlitter prior to the release of the program.  If you're following this project, be sure to follow this new link as well.  And as always, come check out our Discord server!</p>\n<p><strong><a href=\"https://github.com/MarkMichon1/BitGlitter-GUI\" rel=\"nofollow\">https://github.com/MarkMichon1/BitGlitter-GUI</a></strong></p>\n<p><a href=\"https://pepy.tech/project/bitglitter\" rel=\"nofollow\"><img alt=\"Downloads\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/dfcf118b0934c6cd69c07b91849f19a843d035ce/68747470733a2f2f706570792e746563682f62616467652f626974676c6974746572\"></a></p>\n<p><strong><a href=\"https://discord.gg/t9uv2pZ\" rel=\"nofollow\">Discord Server</a></strong></p>\n<p><img alt=\"BitGlitter Logo\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/9e0066eaf4a780f92311933b6604b9e7a564c882/68747470733a2f2f692e696d6775722e636f6d2f33474a346244782e706e67\"></p>\n<h1>The basics</h1>\n<p><img alt=\"BitGlitter Sample GIF\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/e2cd0c41b5ee751b34c56f184f17a02e2e0cfa3d/68747470733a2f2f692e696d6775722e636f6d2f6e3745376c6e642e676966\"></p>\n<p><strong><a href=\"https://www.youtube.com/watch?v=HrY4deFrOoA\" rel=\"nofollow\">Click here</a> for a demo video of a real stream.</strong></p>\n<p>BitGlitter is an easy to use library that allows you to embed data inside of ordinary pictures or video.  Store and host\nfiles wherever images or videos can be hosted.</p>\n<h3>From physical barcodes to digital data transfer</h3>\n<p>Whether it's barcodes at the store or QR codes you can scan with your phone- they both work on the same principle.  Data\nis encoded into the black and white.  You can think of each color as an abstraction for a binary value, so then when\nthose colors are read in sequence, you can pull meaningful data from the image.  I wondered how this concept could be\nimproved upon, and I wanted a cool first project as an introduction to programming.  BitGlitter was born.</p>\n<p>Conventional barcodes are severely limited in application, in terms of their data density.  When you maximize the\nconcept and configure it for digital-digital transmission, a lot of capability is gained.<br>\nBitGlitter is in a class of it's own in several ways:</p>\n<p><img alt=\"BitGlitter Default Palettes\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/8a3f4a1c36c1f1cfdca192e4fe1ece0a46d07230/68747470733a2f2f692e696d6775722e636f6d2f6453596d7137562e706e67\"></p>\n<ul>\n<li><strong>Multiple Color Palettes:</strong>  By removing the constraint of only using black and white, the amount of data you can\nhold in a given \"block\" (each square) on the frame skyrockets.  The regular two color setup holds one bit per block.<br>\nFour colors holds two  bits (2x), sixty four colors holds six bits (6x), and lossless ~16.7M color palette holds 24 bits\n(24x improvement over black &amp; white).  You choose what color palette you'd like to use according to your application.<br>\nSmaller sets are far resistant to compression and corruption, while larger sets have higher data densities.  You can\ncreate your own custom palettes as well with whatever colors you'd like to use.  More about that below.</li>\n<li><strong>Multi-Frame Videos:</strong> BitGlitter automatically breaks up larger files into multiple frames, with several headers\nbuilt into them.  These include several layers of protection against corruption, as well as metadata about the frame\nas well as the stream itself so the reader can intelligently decide how to handle it.  By stitching these frames\ntogether and turning them into a video, you can embed files and folders of arbitrary size into videos and images.<br>\nYou're only limited by your hard drive.</li>\n<li><strong>Variable block size:</strong> Each of the blocks in the frame can be set to any size, including one pixel.  Larger block\nsizes give your stream protection in lossy environments, while smaller blocks allow for greater densities.</li>\n</ul>\n<p>Currently, BitGlitter is configured to transport files and folders on a computer.  But with minimal modification you can\nuse videos or images as a carrier for virtually any kind of binary data.</p>\n<h3>What this means in practical terms</h3>\n<p>Here's some real data that gives you an idea of what is possible with this:</p>\n<table>\n<thead>\n<tr>\n<th>Number of Colors</th>\n<th>Bits Per Block</th>\n<th>Screen Resolution</th>\n<th>Block Size in Pixels</th>\n<th>Block Dimensions</th>\n<th>Framerate</th>\n<th>Throughput</th>\n<th>Lossless Application</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>2</td>\n<td>1</td>\n<td>640 x 480 (480p)</td>\n<td>20</td>\n<td>32 x 24</td>\n<td>30</td>\n<td>2.88 KB/s</td>\n<td>No</td>\n</tr>\n<tr>\n<td>4</td>\n<td>2</td>\n<td>1280 \u00d7 720 (720p)</td>\n<td>20</td>\n<td>64 x 36</td>\n<td>30</td>\n<td>17.28 KB/s</td>\n<td>No</td>\n</tr>\n<tr>\n<td>8</td>\n<td>3</td>\n<td>1280 \u00d7 720 (720p)</td>\n<td>20</td>\n<td>64 x 36</td>\n<td>30</td>\n<td>25.92 KB/s</td>\n<td>No</td>\n</tr>\n<tr>\n<td>16</td>\n<td>4</td>\n<td>1920 x 1080 (1080p)</td>\n<td>20</td>\n<td>96 x 54</td>\n<td>30</td>\n<td>77.76 KB/s</td>\n<td>No</td>\n</tr>\n<tr>\n<td>64</td>\n<td>6</td>\n<td>1920 x 1080 (1080p)</td>\n<td>20</td>\n<td>96 x 54</td>\n<td>30</td>\n<td>116.64 KB/s</td>\n<td>No</td>\n</tr>\n<tr>\n<td>64</td>\n<td>6</td>\n<td>1920 x 1080 (1080p)</td>\n<td>20</td>\n<td>96 x 54</td>\n<td>60</td>\n<td>233.28 KB/s</td>\n<td>No</td>\n</tr>\n<tr>\n<td>16,777,216</td>\n<td>24</td>\n<td>1920 x 1080 (1080p)</td>\n<td>5</td>\n<td>384 x 216</td>\n<td>30</td>\n<td>7.47 MB/s</td>\n<td>Yes</td>\n</tr>\n<tr>\n<td>16,777,216</td>\n<td>24</td>\n<td>3840 x 2160 (4k)</td>\n<td>5</td>\n<td>768 x 432</td>\n<td>60</td>\n<td>59.7 MB/s</td>\n<td>Yes</td>\n</tr></tbody></table>\n<p>Put simply, you can now make videos that can hold large amounts of data inside of them.  There may be some pretty\ninteresting applications that can come out of this.</p>\n<h1>Features</h1>\n<h3>Data</h3>\n<ul>\n<li><strong>Supports streams up to ~1 EB in size, or ~4.3B frames:</strong>  In other words, there is no practical limit to the\nstream's size.</li>\n<li><strong>Compression added:</strong> This is done automatically, so don't worry about putting your files in a rar or zip prior to\nsending.</li>\n<li><strong>Encryption added:</strong> Optional AES-256 encryption to protect your files.  Passwords are hashed with <code>scrypt</code>,\nparameters can be customized for your needs.</li>\n<li><strong>File masking:</strong>  Optional ability to mask what files are included in the stream.  Only those who successfully grab\nthe stream (and decrypt it if applicable) will know of its contents.</li>\n</ul>\n<h3>Outputted Files</h3>\n<p>You can choose between either outputting all of your frames as a series of images (.png), or as a single .mp4.</p>\n<ul>\n<li><strong>Customizable resolution:</strong> You have complete control of the size of the outputted frames, whether they are 480p or\n8K.</li>\n<li><strong>Customizable framerate:</strong> Currently supports 30 and 60 FPS, custom values are coming soon.</li>\n</ul>\n<p><img alt=\"Custom Color Showcase\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/f4cb6ece418b714c20d2c07ab6ec41f1a6429767/68747470733a2f2f692e696d6775722e636f6d2f347551547877542e706e67\"></p>\n<ul>\n<li><strong>Custom Color Palettes:</strong> The included default palettes are just a starting point.  Make any color palette that you\nwant to match the aesthetic where it's being used.  Anyone reading the stream will have the palette automatically saved\nto their machine, so then they can use it as well!  Functionality is included to output a text file outlining all of the\ncolor palettes you have available to use, both default and custom.</li>\n</ul>\n<h3>Reading</h3>\n<ul>\n<li>\n<p><strong>Error correction against compression or corruption:</strong> BitGlitter protects your file against corruption and artifacts\non the image or video. After loading the correct palette, whenever it detects an incorrect color, it will \"snap\" it to\nthe nearest color in the palette.  This gives your file resistance against format changes, codecs, or file size\nreduction.  This allows BitGlitter streams to still be read in environments that would otherwise render all existing\nsteganography methods unreadable.</p>\n</li>\n<li>\n<p><strong>Complete file integrity:</strong> When the stream is created, a hash (SHA-256) is taken of the entire stream, as\nwell as each frame.  The data must match what is expected to be accepted.  Damaged or corrupt files will not be blindly\npassed on to you.</p>\n</li>\n<li>\n<p><strong>Streamlined frame bypassing:</strong>  If a frame cannot or doesn't need to be read (ie, a duplicate already read), the\nreader determines this from an initial frame header</p>\n</li>\n</ul>\n<h3>Design</h3>\n<ul>\n<li>\n<p><strong>No metadata saved in the file:</strong>  Compress the stream, change formats, upload it somewhere.  All data is encoded in\nthe blocks, so you don't have to worry (as much) about rendering the stream unreadable.</p>\n</li>\n<li>\n<p><strong>Easy to understand:</strong> Whether you're learning about Python and want to understand how it works, or you're looking to\ncontribute, docstrings and notes are throughout the library.</p>\n</li>\n<li>\n<p><strong>Built in future-proofing:</strong> As of now, BitGlitter has a single protocol (Protocol 1), which is a specific set of\nprocedures around how data is handled, and the components of a frame, as well as their layout.  Each protocol has its\nown unique ID to identify it with.  This ID is added in the  header during the write process, and is picked up at\n<code>read()</code>.  As new protocols get created, older versions of BitGlitter that don't have these included will notify the user\nto update their version in order for it to be read.  All older protocol versions are saved in future library\niterations, so no matter how old the protocol version is used on the stream, it will always be able to be read.</p>\n</li>\n<li>\n<p><strong>Fully modular design:</strong> Do you have a specialized use case?  Adapting this library to your own needs is quite easy.\nI've built BitGlitter to be easy to modify and expand upon.  Rather than worrying about the lower-level functionality,\nachieve your goal with the modular components I've created.</p>\n</li>\n</ul>\n<h3>CLI</h3>\n<p><strong>Temporary warning-</strong> Due to issues uploading to PyPI, these features are only available on Github for now.  The PyPI version of BitGlitter still performs everything else fine.  This will be removed when the problem is fixed.</p>\n<p>Write from command line:</p>\n<ul>\n<li>\n<p><code>python3 -m bitglitter write</code></p>\n<pre><code>`-file` - The absolute path to the file\n`-mode` - Either 'image' or 'video'. Default: video\n`-o` - Output path\n</code></pre>\n</li>\n</ul>\n<p>Read from commnad line:</p>\n<ul>\n<li>\n<p><code>python3 -m bitglitter read</code></p>\n<pre><code>`-file` - The absolute path to the file\n`-o` - Output path\n</code></pre>\n</li>\n</ul>\n<h3>Applications</h3>\n<p>To be determined.  This will be updated as time progresses!</p>\n<h1>How to use</h1>\n<p>All of the functions to run this library are explained below.  I'm also working on several Wikipedia pages, explaining\nBitGlitter in greater detail (how it works, etc) with some included illustrations.  These are not yet complete,\n<a href=\"https://github.com/MarkMichon1/BitGlitter/wiki/Using-BitGlitter\" rel=\"nofollow\">but here is the link to the project's Wiki if you'd like to see it!</a></p>\n<h3>Installation</h3>\n<p>In addition to downloading the code from Github, you can also grab it directly from PyPI:</p>\n<p><code>pip install bitglitter</code></p>\n<p><strong>IMPORTANT:</strong> The only part you will need to grab manually is a copy of ffmpeg.exe .  Place it in the same folder the\ncode will be running, and you'll be set.  This will be done automatically in the near future.  Get the package here on\nthe left side of the screen:</p>\n<p><a href=\"https://ffmpeg.org/download.html\" rel=\"nofollow\">https://ffmpeg.org/download.html</a></p>\n<p>ffmpeg.exe is all that is needed.</p>\n<p><strong>Required Third Party Libraries</strong></p>\n<ul>\n<li><code>bitstring</code> - Bit manipulation.</li>\n<li><code>cryptography</code> - Cryptographic functions.</li>\n<li><code>ffmpeg-python</code> - Video rendering and output.</li>\n<li><code>opencv-python</code> - Video loading and frame manipulation.</li>\n<li><code>Pillow</code> - Frame creation and output, as well as loading images and reading pixel values.</li>\n</ul>\n<p>Thanks to Tanmay Mishra for giving me a pre-release version of his upcoming library <code>filepackager</code>.  It has been heavily\nmodified and stripped down to suit this library.  The code is included with BitGlitter; there is no need to download it.</p>\n<p><strong>BitGlitter in 60 seconds</strong></p>\n<p>Even though it comes shipped with a lot of functionality, all you need to use it is <code>write()</code> (creates the streams) and\n<code>read()</code> (which reads them and extracts the data encoded in it).  The only required argument for both is the file you\nwish to input in string format.</p>\n<h3>write(), converting files into BitGlitter streams</h3>\n<p>We'll go a bit more in depth now.</p>\n<p><code>write()</code> is the function that inputs files and turns them into a BitGlitter stream.  There are quite a few arguments\nto customize the stream, but there is only one required argument.  Everything else has defaults.</p>\n<p>Not surprisingly, that required argument defines what files or folders you wish to embed in the stream.  If and only if\nyou're sending a single file or folder path, argument <code>fileList</code> takes a string of the path.  BitGlitter also supports\nsending multiple files and folder together, of which there is no limit!  This would require using a tuple or list item\nfilled with strings of the file or folder paths.  File or folder paths that don't exist are automatically ignored.</p>\n<p><code>stream_name=''</code> is what you can use to optionally title your stream, which will be printed out on the screen of whoever\nreads the file, along with other stream data.</p>\n<p><code>stream_description=''</code> serves as a text field to optionally put a description for the stream.</p>\n<p><code>output_path=False</code> is where you can optionally define the path of where the created media is outputted.  By\ndefault, media is saved where the python file is ran.  The folder path must already exist if used.</p>\n<p><code>output_mode='video'</code> is where you define how you wish the stream to output, whether as an .mp4 video, or a series of\n.png images.  The only two valid arguments are <code>'image'</code> and <code>'video'</code>.</p>\n<p><code>output_name=''</code> is how you can customize the output name of the file that is created.  Videos, for instance, will be\nnamed 'custom_name.mp4', while images will be named 'custom_name.png - 1', 'custom_name.png - 2', etc, the number being\neach frame number.  If left blank, it will use the current date and time of the <code>write()</code> function starting as the file\nname.</p>\n<p><code>compression_enabled=True</code> enables or disables compression of your data, prior to rendering into frames.  This is enabled\nby default.</p>\n<p><code>file_mask_enabled=False</code> is where you can omit the listing of files/folders from the stream header.  This effectively\nhides the contents of the stream, unless it is fully read.  By default, this is disabled.  What this means is when\nsomeone reads your stream, in the first several frames it will automatically display the contents of the stream (files\nas well as their size) on the screen.</p>\n<p><code>encryption_key=''</code> optionally encrypts your data with AES-256.  By default, this is disabled.  The stream will not be\nable to be read unless the reader successfully inputs this.</p>\n<p>Arguments <code>scrypt_N=14</code>, <code>scrypt_R=8</code> and <code>scrypt_P=1</code> allow you to customize the parameters of the <code>scrypt</code> key derivation\nfunction.  If you're a casual user, you'll never need to touch these (and shouldn't).  Only change these settings if\nyou're comfortable with cryptography and you know what you're doing!  It's worth noting <code>scrypt_N</code> uses it's argument as\n2^n.  Finally, if you're changing these numbers, they MUST be manually inputted during <code>read()</code> otherwise decryption\nwill fail!  Custom values are deliberately not transmitted in the stream for security reasons.  Your end users of the\nstream must know these custom parameters.</p>\n<p><code>header_palette_id='6'</code> sets the palette used in the 'setup' frames in the beginning.  It is strongly recommended you use\na default palette here if you don't know what you're doing, because this is where important information regarding the\nstream is read, and by using a custom palette, it will be impossible for anyone to read it who hasn't already 'learned'\nthe palette.</p>\n<p><code>stream_palette_id='6'</code> sets the palette used for the payload.  By default, the 4 bit default color set is used.  I'll\nexplain all about palettes below.</p>\n<p><code>pixel_width=24</code> sets how many pixels wide each block is when rendered.  By default it's 20 pixels.  This is a very\nimportant value regarding readability.  Having them overly large will make reading them easier, but will result in less\nefficient frames and require substantially longer streams.  Making them very small will greatly increase their\nefficiency, but at the same time a lot more susceptible to read failures if the files are shrunk, or otherwise\ndistorted.</p>\n<p><code>block_height=45</code> sets how many blocks tall the frame will be, by default this is set to 45 (which along with\n<code>block_width</code>, creates a perfect 1080p sized frame).</p>\n<p><code>block_width=80</code> sets how many blocks wide the frame will be.  By default this is set to 96.</p>\n<p><code>frames_per_second=30</code> sets how many frames per second the video will play at, assuming argument <code>output_mode = \"video\"</code>.\nCurrently, 30fps and 60fps are accepted.</p>\n<p>Finally we have several arguments to control logging.</p>\n<p><code>logging_level='info'</code> determines what level logging messages get outputted.  It accepts three arguments- <code>info</code> is\ndefault and only shows core status data during <code>read()</code> and <code>write()</code>.  <code>'debug'</code>  shows INFO level messages as well as\nlower level messages from the various processes.  Boolean <code>False</code> disables logging altogether.</p>\n<p><code>logging_screen_output=True</code> sets whether logging messages are displayed on the screen or not.  Only accepts type <code>bool</code>.\nEnabled by default.</p>\n<p><code>logging_save_output=False</code> determines whether logging messages are saved as text files or not.  Only accepts type <code>bool</code>.\nDisabled by default.  If set to <code>True</code>, a log folder will be created, and text files will be automatically saved there.</p>\n<p>These default values have an 81KB/s transmission rate.  This is only a starting point that should be pretty resistant to\ncorruption.</p>\n<h3>read(), converting streams back into data</h3>\n<p><code>read()</code> is what you use to input BitGlitter streams (whether images or video), and will output the files.</p>\n<p>Like with <code>write()</code>, the only argument required is the BitGlitter-encoded file, whether that's an image or a video.\n<code>file_to_input</code> is the only required argument.  We'll go over the other ones.</p>\n<p><code>output_path=None</code> Is where you can set where this stream will be saved once all frames have been successfully loaded.\nIt's 'set and forget', so if you are loading images this argument only has to be used once, and the folder path will\nstick with that stream.  This argument requires a strong of a folder path that already exists.</p>\n<p><code>bad_frame_strikes=10</code> This sets how many corrupted frames the reader is to detect before it aborts out of a video.  This\nallows you to break out of a stream relatively quickly if the video is substantially corrupted, without needing to\niterate over each frame.  If this is set to 0, it will disable strikes altogether, and attempt to read each frame\nregardless of the level of corruption.</p>\n<p><code>block_height_override=False</code> and <code>block_width_override=False</code> allow you to manually input the stream's block height and\nblock width.  Normally you'll never need to use this, as these values are automatically obtained as the frame is locked\nonto.  But for a badly corrupted or compressed frame, this may not be the case.  By using the override, the reader will\nattempt to lock onto the screen given these parameters.  Both must be filled in order for the override to work.</p>\n<p><code>encryption_key=None</code> is where you add the encryption key to decrypt the stream.  Like argument <code>output_path</code>, you only\nneed this argument once, and it will bind to that save.</p>\n<p>Arguments <code>scrypt_n=14</code>, <code>scrypt_r=8</code> and <code>scrypt_p=1</code></p>\n<p><code>logging_level = 'info'</code>, <code>logging_screen_output = True</code>, <code>logging_save_output = False</code> - Please see the full explanation at\n<code>write().</code></p>\n<h3>Color Palettes</h3>\n<p>If you wish to make your own custom color palettes, BitGlitter gives you the ability to do that with these functions.</p>\n<p><code>add_custom_palette(palette_name, palette_description, color_set, optional_nickname = \"\")</code>  This function adds custom palettes\nto use.</p>\n<p>Argument <code>palette_name</code> takes a string and is the name of the palette that gets displayed and transmitted.</p>\n<p>Argument<code>palette_description</code> takes a string as well, and is the description of the palette, if you wish to add it.</p>\n<p>Argument <code>color_set</code> takes a tuple of RGB tuples, these will be the actual colors used in the BitGlitter stream.  Here's\na simple example of what it would look like using two colors: <code>color_set=((0, 255, 0), (0, 0, 255))</code>.  There are a few\nrequirements to these tuples:</p>\n<ul>\n<li>No two identical values can be added.  For instance, the color black with the same RGB values twice.  Each color used\nmust be unique!  The more 'different' the colors are, the better.</li>\n<li>You must have a minimum of two colors.</li>\n<li>It must be 2^n colors used, so 2, 4, 8, 16, etc.</li>\n</ul>\n<p>Argument <code>optional_nickname=\"\"</code> allows you to use an easy to input nickname for your custom palette.  This nickname is\nhow you select this palette to specifically run on your stream.  Internally, custom palettes have a 64 character ID\ncode which you can use (more on this below).  This allows you to give it a string of your choosing to designate it as\nwell.  This field is optional.  If you do decide to use it though, both the internal ID AND the nickname will work.</p>\n<p><code>edit_nickname_to_custom_palette(id_or_nick, new_name)</code> This function allows you to edit the nickname of your custom palette\nto something else.  Both arguments require strings.  You can use it's nickname you assigned it, or it's internal ID.</p>\n<p><code>print_full_palette_list(path)</code> This function outputs a text file to the folder path outlining the palettes available, both\ndefault palettes and custom.  It shows information such as their name, description, date created, color set, nickname,\nand more.  The required argument is a string of a folder path, which must already exist.  Here's an example of how to\nformat it: <code>C:\\Users\\Mark\\Desktop</code></p>\n<p><code>clear_all_custom_palettes()</code> This removes all custom palettes from your config.  Please note that the default palettes\nwill not be removed.</p>\n<p><code>remove_custom_palette(id_or_nick)</code> This function removes the custom palette from your config.  It takes a string argument\nof either it's internal ID, or a nickname you've previously given it.</p>\n<p><code>remove_custom_palette_nickname(id_or_nick)</code> This function strips any nickname associated with a custom palette.  It takes a\nstring argument of either the internal ID or a previous nickname.</p>\n<p><code>clear_custom_palette_nicknames()</code>  This removes all nicknames from all custom palettes.</p>\n<h3>Partial Save Control</h3>\n<p>Once the first frame of a stream is read, a PartialSave object is created.  This is essentially what manages the binary\nstrings, and holds various information on it's state.  These functions help better interface with them.</p>\n<p><code>update_partial_save(stream_sha, reattempt_assembly = True, password_update = None, scrypt_n = None, scrypt_r = None, scrypt_p = None, change_output_path = None)</code> This function allows you to update various parameters of the save.  Requires\na string input for <code>streamSHA</code> which is the ID number of the string.</p>\n<p>Argument <code>reattempt_assembly</code> makes the assembler\nattempt to reassemble the frames, as well as output the embedded files and folders.  This would be used in the case of\nan incorrect password or scrypt parameters, and you'd like to try again.</p>\n<p>Argument <code>password_update</code> takes a string argument, and will add (or replace) the encryption key tied to this stream.</p>\n<p>Arguments <code>scrypt_n, scrypt_r and scrypt_p</code> change the scrypt parameters used to derive the key used for decryption.  If\nthe scrypt parameters were left at default during <code>write()</code> of the stream, these can be left as is.  Otherwise, the\ncustom values will need to be inputted whether here or in the optional arguments of <code>read()</code>.</p>\n<p><code>begin_assembly(stream_sha)</code> This function exists to initiate assembly of a package at a later time, rather than doing so\nimmediately for whatever reason.</p>\n<p><code>print_full_save_list(path, debug_data=False)</code> This function outputs a text file to the folder path outlining all (if any)\npartial saves you have on your system.  You can check their status, as well as the state of the PartialSave object\nitself.  Argument <code>debugData</code> is <code>False</code> by default, but enabling it to <code>True</code> outputs various debug information\npertaining to the object as well, which wouldn't serve much utility seeing for someone such as a casual end user.</p>\n<p><code>remove_partial_save(stream_sha)</code>  Using a string argument for the stream's ID (or stream SHA, as commonly used), this will\nremove the object from your config, as well as remove all temporary data associated with it.</p>\n<p><code>remove_all_partial_saves()</code> All saves are removed from the config object, clearing all temporary data.</p>\n<h3>General Configuration</h3>\n<p><code>outputStats(path)</code> This function gives you a neat bird's eye view of your BitGlitter usage.  During all <code>read()</code> and\n<code>write()</code> cycles, the total amount of data transferred, as well as total frames transferred and individual blocks\nscanned gets added to a running total.  Argument <code>path</code> requires a string argument of a folder path that already exists.\nA small text file will be written to this location.</p>\n<p><code>clear_stats()</code> All statistics will be reset to zero.</p>\n<p><code>clear_session()</code> This wipes all inputted data.  Custom colors, statistics, and partial save objects will all be erased,\nas well as any temporary data for the partially read streams.  This is in essence a hard reset.</p>\n<h1>Contributing</h1>\n<p>Whether you're a seasoned programmer or brand new, there's plenty of things you can do to help this project succeed.\nJoin our discord server, and check out all of the information I posted in the \"Information\" category.  Thank you for\nyour interest!</p>\n<p><strong>Discord Link</strong></p>\n<p><strong><a href=\"https://discord.gg/t9uv2pZ\" rel=\"nofollow\">https://discord.gg/t9uv2pZ</a></strong></p>\n<p>Also, be sure to check out the\n<a href=\"https://github.com/MarkMichon1/BitGlitter/wiki/Contributing-Master-Page\" rel=\"nofollow\">contributing master page</a>.  It contains a lot\nof information.</p>\n<p><img alt=\"Splitter\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/afc05d24215570e207749c97ab8df05def40f205/68747470733a2f2f692e696d6775722e636f6d2f7149796769666a2e706e67\"></p>\n<h3>Practical Limits</h3>\n<p>It's worth stating the constraints you may face while using this.  While the images and video BitGlitter exports are\nlossless (no compression applied), the \"real world\" on the internet is much different.  For instance, multimedia\nuploaded to popular social media sites is regularly compressed in order to save space (and ultimately cut down on\nexpenses).  You are protected <em>to an extent</em> with BitGlitter from this.  Write parameters are fully customizable\nprimarily for this reason.</p>\n<p>While you can have greater throughput with larger colorsets, smaller blocks, and faster framerates, there may be a\npractical limit to whether it will work depending on the degree their compression reduces quality.  At the expense of\nthroughput, larger blocks, slower framerates, and fewer colors used will make the stream <em>far</em> more resistant to\npossible corruption.  Approaching the extreme limits of these parameters (tiny block sizes, very fast framerates, very\nlarge colorsets), in terms of reading it and converting it back into data, requires very precise measurements of\nposition and color value; <em>a codec's purpose is to blur those precise values to reduce it's bitrate, and in turn it's\nfile size.</em>  While BitGlitter will detect corruption and perform an \"emergency stop,\" I know you don't want to deal with\nthat, and neither do the people you're sharing with.</p>\n<p>In closing, know the environment the video will be used in to ensure success in reading it.</p>\n<h1>MIT License</h1>\n<p>\u00a9 2019 - \u221e Mark Michon</p>\n<p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated\ndocumentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the\nrights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit\npersons to whom the Software is furnished to do so, subject to the following conditions:</p>\n<p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the\nSoftware.</p>\n<p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE\nWARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\nOTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>\n\n          </div>"}, "last_serial": 6205961, "releases": {"1.0.1": [{"comment_text": "", "digests": {"md5": "5e87e8e90c82f0fcd5bf72f725d6a3d9", "sha256": "c5b127e20889513cea906b420f45f900c7c9e4ecf870f63aaf4b95747ec333ee"}, "downloads": -1, "filename": "BitGlitter-1.0.1-py3-none-any.whl", "has_sig": false, "md5_digest": "5e87e8e90c82f0fcd5bf72f725d6a3d9", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 12748612, "upload_time": "2019-05-24T23:25:45", "upload_time_iso_8601": "2019-05-24T23:25:45.306062Z", "url": "https://files.pythonhosted.org/packages/97/a2/c89c1498b106af58489039aa0d829c02a15138fe019315c0e7cb20bd4b2e/BitGlitter-1.0.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "a939d1d930a1b88a70b992d3518021db", "sha256": "19613812e5143728807ae8c8be9a36e25dbc44b2c8ce6707647367d379545506"}, "downloads": -1, "filename": "BitGlitter-1.0.1.tar.gz", "has_sig": false, "md5_digest": "a939d1d930a1b88a70b992d3518021db", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 5380593, "upload_time": "2019-05-24T23:25:56", "upload_time_iso_8601": "2019-05-24T23:25:56.429282Z", "url": "https://files.pythonhosted.org/packages/56/6e/c5ea3c02e1c57e116a3686736f5814b2611e019427d080d97ea0a2f6d517/BitGlitter-1.0.1.tar.gz", "yanked": false}], "1.0.2": [{"comment_text": "", "digests": {"md5": "c18ebef5750e3f5584a2fdd012c29f9b", "sha256": "bdcc28b9614756339230245f44010150250b32e5272d4bd21f1d78b70d303330"}, "downloads": -1, "filename": "BitGlitter-1.0.2.tar.gz", "has_sig": false, "md5_digest": "c18ebef5750e3f5584a2fdd012c29f9b", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 2879233, "upload_time": "2019-06-06T18:45:33", "upload_time_iso_8601": "2019-06-06T18:45:33.351702Z", "url": "https://files.pythonhosted.org/packages/0b/c4/8044bd40c777f15f843dad9994b54a6598f6e45aec0c79ac9fecae994416/BitGlitter-1.0.2.tar.gz", "yanked": false}], "1.0.3": [{"comment_text": "", "digests": {"md5": "0492fdd08a229567cfeb44c817330555", "sha256": "1f7f1e12b4201451c53c8b7e4651bd2d010ab02e782719573a12fc43ae2e641d"}, "downloads": -1, "filename": "BitGlitter-1.0.3-py3-none-any.whl", "has_sig": false, "md5_digest": "0492fdd08a229567cfeb44c817330555", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 77904, "upload_time": "2019-11-27T05:42:28", "upload_time_iso_8601": "2019-11-27T05:42:28.591192Z", "url": "https://files.pythonhosted.org/packages/26/69/086114635f8437920407cd4d4ebd617a87e048ebfd4f23b6eff6c0e18a1b/BitGlitter-1.0.3-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "ad6cac0eafe8cc9f28729c5d6b3d38c3", "sha256": "157019c50a3f3585672328540dd8bd34fd85064b9370774567187e09ec7dbe60"}, "downloads": -1, "filename": "BitGlitter-1.0.3.tar.gz", "has_sig": false, "md5_digest": "ad6cac0eafe8cc9f28729c5d6b3d38c3", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 73473, "upload_time": "2019-11-27T05:42:29", "upload_time_iso_8601": "2019-11-27T05:42:29.861946Z", "url": "https://files.pythonhosted.org/packages/54/16/a40772016ddc6bb8d833967f1c738c3fdd86dea0b7cfa8c0689d4c172566/BitGlitter-1.0.3.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "0492fdd08a229567cfeb44c817330555", "sha256": "1f7f1e12b4201451c53c8b7e4651bd2d010ab02e782719573a12fc43ae2e641d"}, "downloads": -1, "filename": "BitGlitter-1.0.3-py3-none-any.whl", "has_sig": false, "md5_digest": "0492fdd08a229567cfeb44c817330555", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 77904, "upload_time": "2019-11-27T05:42:28", "upload_time_iso_8601": "2019-11-27T05:42:28.591192Z", "url": "https://files.pythonhosted.org/packages/26/69/086114635f8437920407cd4d4ebd617a87e048ebfd4f23b6eff6c0e18a1b/BitGlitter-1.0.3-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "ad6cac0eafe8cc9f28729c5d6b3d38c3", "sha256": "157019c50a3f3585672328540dd8bd34fd85064b9370774567187e09ec7dbe60"}, "downloads": -1, "filename": "BitGlitter-1.0.3.tar.gz", "has_sig": false, "md5_digest": "ad6cac0eafe8cc9f28729c5d6b3d38c3", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 73473, "upload_time": "2019-11-27T05:42:29", "upload_time_iso_8601": "2019-11-27T05:42:29.861946Z", "url": "https://files.pythonhosted.org/packages/54/16/a40772016ddc6bb8d833967f1c738c3fdd86dea0b7cfa8c0689d4c172566/BitGlitter-1.0.3.tar.gz", "yanked": false}], "timestamp": "Thu May  7 22:37:17 2020"}