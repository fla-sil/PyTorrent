{"info": {"author": "Jaakko Luttinen", "author_email": "jaakko.luttinen@iki.fi", "bugtrack_url": null, "classifiers": ["Development Status :: 1 - Planning", "Environment :: Console", "Intended Audience :: Developers", "License :: OSI Approved :: MIT License", "Operating System :: OS Independent", "Programming Language :: Python :: 3 :: Only", "Topic :: Scientific/Engineering", "Topic :: Software Development :: Libraries"], "description": "# HaskPy - Haskell types and functions in Python\n\nHask is the category of types and functions in Haskell. This package provides\nclasses and functions inspired by Hask.\n\n\n## Overview\n\n### Features\n\n- Typeclasses: `Functor`, `Applicative`, `Monad`, `Semigroup`, `Monoid`,\n  `Commutative`, `CommutativeMonoid`, `Foldable`, `Contravariant`, `Profunctor`,\n  `Cartesian`, `Cocartesian`\n\n  - **TODO:** `Traversable`, `Bifunctor`, `Monoidal`\n\n- Types and type constructors: `Identity`, `Maybe`, `Either`, `List`,\n  `Function`, `Compose`\n\n  - **TODO:** `Constant`, `Validation`, `Dictionary`, `LinkedList`,\n    `State`, `Reader`, `Writer`, `IO`\n\n- Monad transformers: `MaybeT`, `IdentityT`\n\n  - **TODO:** `StateT`, `ReaderT`, `WriterT`, `ListT`\n\n- Simple monoids: `Sum`, `And`, `Or`, `String`, `Endo`\n\n  - **TODO:** `Product`\n\n- Profunctor optics: `adapter`, `lens`, `prism`\n\n  - **TODO**: `traversal`, `grate`, `affine`, `setter`\n\n- Operators for common tasks: ``**`` for function composition or functorial\n  mapping, ``@`` for applicative application, ``%`` for monadic binding and\n  ``>>`` for applicative/monadic sequencing.\n\n- Property-based testing of typeclass laws\n\nHaskPy has implemented typeclass laws as property-based tests. Thus, one can\neasily test that an implementation satisfies all the laws it should. Just add\nsomething like this to your test module and run with pytest:\n\n```python\nfrom haskpy.conftest import make_test_class\nfrom mystuff import MyClass\nTestMyClass = make_test_class(MyClass)\n```\n\nThis will automatically verify that `MyClass` satisfies all the typeclass laws\nof those typeclasses that it inherits. It makes use of great [Hypothesis\npackage](https://hypothesis.readthedocs.io/en/latest/).\n\n\n## Examples\n\n### Functors\n\nA minimal example of functorial mapping:\n\n```python\n>>> from haskpy import map, List\n>>> map(lambda x: x**2, List(1, 2, 3, 4, 5))\nList(1, 4, 9, 16, 25)\n```\n\nLift over two layers of functorial structure:\n\n```python\n>>> from haskpy import map, List, Just, Nothing\n>>> map(map(lambda x: x**2))(List(Just(1), Nothing, Just(3), Just(4), Nothing))\nList(Just(1), Nothing, Just(9), Just(16), Nothing)\n```\n\nNote that `haskpy.map` works for all Functor instances. That is, you don't need\nto use a different function to lift over different functors. You can even create\nfunction that performs some operation to values contained in any two-layer\nfunctorial structure. In the following example, `square` squares the values\ninside a two-layer functor:\n\n```python\n>>> square = map(map(lambda x: x**2))\n>>> square(List(Just(1), Nothing, Just(3)))\nList(Just(1), Nothing, Just(9))\n>>> square(List(List(1, 2, 3), List(4, 5)))\nList(List(1, 4, 9), List(16, 25))\n```\n\nEven functions are functors if they have been decorated with `function`:\n\n```python\n>>> @function\n... def f(x):\n...     return List(x, 2*x, 3*x)\n>>> square(f)(3)\nList(9, 36, 81)\n```\n\n### Currying\n\nHaskPy provides `curry` decorator which curries a function in such a way that\n**the function remains partially evaluated until all required arguments have\nbeen provided**:\n\n```python\n>>> from haskpy import curry\n>>> @curry\n... def concat(x, y, z):\n...    return x + y + z\n>>> concat(\"a\")(\"b\")(\"c\")\n\"abc\"\n>>> concat(\"a\")(\"b\", \"c\")\n\"abc\"\n```\n\nIt doesn't convert the function into nested one-argument functions (as currying\nstrictly speaking should do) but it gives more flexibility by accepting any\nnumber of arguments (even no arguments at all). It also handles keyword\narguments and any other optional arguments in an intuitive way similarly as\nnormal function calls.\n\nIt is very similar to the curry function in Toolz, but that implementation has\nsome critical design flaws (see\n[toolz/#471](https://github.com/pytoolz/toolz/issues/471)). In addition to\ncorrect behavior, the implementation of `haskpy.curry` is much simpler because\nit doesn't need to support old Python versions. Here's a bit more complex usage\nwith keyword arguments:\n\n\n```python\n>>> @curry\n... def concat_with_repeat(x, y, z, r=1):\n...     return r*x + r*y + r*z\n>>> concat_with_repeat(r=3)(\"a\", \"b\")(\"c\")\n\"aaabbbccc\"\n>>> concat_with_repeat(y=\"b\")(\"a\", z=\"c\", r=2)\n\"aabbcc\"\n```\n\nNote that positional arguments can be used as keyword arguments similarly as in\nnormal function calls.\n\n### Functions\n\nInstead of just currying a function, you may want to convert a function into an\nobject that has all the methods of functors, applicatives, monads and all other\ntypeclasses a function is an instance of. In that case, you can use `function`\ndecorator. Note that `function` also curries the function, so there's no need to\nuse `curry` in addition to `function`.\n\nAlmost all functions in HaskPy have been decorated with `function`.\n\n\n## Copyright\n\nCopyright (C) 2019 Jaakko Luttinen\n\nHaskPy is licensed under the MIT License. See LICENSE file for a text of the\nlicense or visit http://opensource.org/licenses/MIT.", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/jluttine/HaskPy", "keywords": "functional programming,category theory,Hask category,Haskell,functor,monad", "license": "", "maintainer": "", "maintainer_email": "", "name": "haskpy", "package_url": "https://pypi.org/project/haskpy/", "platform": "", "project_url": "https://pypi.org/project/haskpy/", "project_urls": {"Homepage": "https://github.com/jluttine/HaskPy"}, "release_url": "https://pypi.org/project/haskpy/0.1.3/", "requires_dist": null, "requires_python": "", "summary": "Functions and classes inspired by Haskell and Hask category", "version": "0.1.3", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>HaskPy - Haskell types and functions in Python</h1>\n<p>Hask is the category of types and functions in Haskell. This package provides\nclasses and functions inspired by Hask.</p>\n<h2>Overview</h2>\n<h3>Features</h3>\n<ul>\n<li>\n<p>Typeclasses: <code>Functor</code>, <code>Applicative</code>, <code>Monad</code>, <code>Semigroup</code>, <code>Monoid</code>,\n<code>Commutative</code>, <code>CommutativeMonoid</code>, <code>Foldable</code>, <code>Contravariant</code>, <code>Profunctor</code>,\n<code>Cartesian</code>, <code>Cocartesian</code></p>\n<ul>\n<li><strong>TODO:</strong> <code>Traversable</code>, <code>Bifunctor</code>, <code>Monoidal</code></li>\n</ul>\n</li>\n<li>\n<p>Types and type constructors: <code>Identity</code>, <code>Maybe</code>, <code>Either</code>, <code>List</code>,\n<code>Function</code>, <code>Compose</code></p>\n<ul>\n<li><strong>TODO:</strong> <code>Constant</code>, <code>Validation</code>, <code>Dictionary</code>, <code>LinkedList</code>,\n<code>State</code>, <code>Reader</code>, <code>Writer</code>, <code>IO</code></li>\n</ul>\n</li>\n<li>\n<p>Monad transformers: <code>MaybeT</code>, <code>IdentityT</code></p>\n<ul>\n<li><strong>TODO:</strong> <code>StateT</code>, <code>ReaderT</code>, <code>WriterT</code>, <code>ListT</code></li>\n</ul>\n</li>\n<li>\n<p>Simple monoids: <code>Sum</code>, <code>And</code>, <code>Or</code>, <code>String</code>, <code>Endo</code></p>\n<ul>\n<li><strong>TODO:</strong> <code>Product</code></li>\n</ul>\n</li>\n<li>\n<p>Profunctor optics: <code>adapter</code>, <code>lens</code>, <code>prism</code></p>\n<ul>\n<li><strong>TODO</strong>: <code>traversal</code>, <code>grate</code>, <code>affine</code>, <code>setter</code></li>\n</ul>\n</li>\n<li>\n<p>Operators for common tasks: <code>**</code> for function composition or functorial\nmapping, <code>@</code> for applicative application, <code>%</code> for monadic binding and\n<code>&gt;&gt;</code> for applicative/monadic sequencing.</p>\n</li>\n<li>\n<p>Property-based testing of typeclass laws</p>\n</li>\n</ul>\n<p>HaskPy has implemented typeclass laws as property-based tests. Thus, one can\neasily test that an implementation satisfies all the laws it should. Just add\nsomething like this to your test module and run with pytest:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">haskpy.conftest</span> <span class=\"kn\">import</span> <span class=\"n\">make_test_class</span>\n<span class=\"kn\">from</span> <span class=\"nn\">mystuff</span> <span class=\"kn\">import</span> <span class=\"n\">MyClass</span>\n<span class=\"n\">TestMyClass</span> <span class=\"o\">=</span> <span class=\"n\">make_test_class</span><span class=\"p\">(</span><span class=\"n\">MyClass</span><span class=\"p\">)</span>\n</pre>\n<p>This will automatically verify that <code>MyClass</code> satisfies all the typeclass laws\nof those typeclasses that it inherits. It makes use of great <a href=\"https://hypothesis.readthedocs.io/en/latest/\" rel=\"nofollow\">Hypothesis\npackage</a>.</p>\n<h2>Examples</h2>\n<h3>Functors</h3>\n<p>A minimal example of functorial mapping:</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">from</span> <span class=\"nn\">haskpy</span> <span class=\"kn\">import</span> <span class=\"nb\">map</span><span class=\"p\">,</span> <span class=\"n\">List</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"nb\">map</span><span class=\"p\">(</span><span class=\"k\">lambda</span> <span class=\"n\">x</span><span class=\"p\">:</span> <span class=\"n\">x</span><span class=\"o\">**</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"n\">List</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">))</span>\n<span class=\"n\">List</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"mi\">9</span><span class=\"p\">,</span> <span class=\"mi\">16</span><span class=\"p\">,</span> <span class=\"mi\">25</span><span class=\"p\">)</span>\n</pre>\n<p>Lift over two layers of functorial structure:</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">from</span> <span class=\"nn\">haskpy</span> <span class=\"kn\">import</span> <span class=\"nb\">map</span><span class=\"p\">,</span> <span class=\"n\">List</span><span class=\"p\">,</span> <span class=\"n\">Just</span><span class=\"p\">,</span> <span class=\"n\">Nothing</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"nb\">map</span><span class=\"p\">(</span><span class=\"nb\">map</span><span class=\"p\">(</span><span class=\"k\">lambda</span> <span class=\"n\">x</span><span class=\"p\">:</span> <span class=\"n\">x</span><span class=\"o\">**</span><span class=\"mi\">2</span><span class=\"p\">))(</span><span class=\"n\">List</span><span class=\"p\">(</span><span class=\"n\">Just</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">),</span> <span class=\"n\">Nothing</span><span class=\"p\">,</span> <span class=\"n\">Just</span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">),</span> <span class=\"n\">Just</span><span class=\"p\">(</span><span class=\"mi\">4</span><span class=\"p\">),</span> <span class=\"n\">Nothing</span><span class=\"p\">))</span>\n<span class=\"n\">List</span><span class=\"p\">(</span><span class=\"n\">Just</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">),</span> <span class=\"n\">Nothing</span><span class=\"p\">,</span> <span class=\"n\">Just</span><span class=\"p\">(</span><span class=\"mi\">9</span><span class=\"p\">),</span> <span class=\"n\">Just</span><span class=\"p\">(</span><span class=\"mi\">16</span><span class=\"p\">),</span> <span class=\"n\">Nothing</span><span class=\"p\">)</span>\n</pre>\n<p>Note that <code>haskpy.map</code> works for all Functor instances. That is, you don't need\nto use a different function to lift over different functors. You can even create\nfunction that performs some operation to values contained in any two-layer\nfunctorial structure. In the following example, <code>square</code> squares the values\ninside a two-layer functor:</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">square</span> <span class=\"o\">=</span> <span class=\"nb\">map</span><span class=\"p\">(</span><span class=\"nb\">map</span><span class=\"p\">(</span><span class=\"k\">lambda</span> <span class=\"n\">x</span><span class=\"p\">:</span> <span class=\"n\">x</span><span class=\"o\">**</span><span class=\"mi\">2</span><span class=\"p\">))</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">square</span><span class=\"p\">(</span><span class=\"n\">List</span><span class=\"p\">(</span><span class=\"n\">Just</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">),</span> <span class=\"n\">Nothing</span><span class=\"p\">,</span> <span class=\"n\">Just</span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">)))</span>\n<span class=\"n\">List</span><span class=\"p\">(</span><span class=\"n\">Just</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">),</span> <span class=\"n\">Nothing</span><span class=\"p\">,</span> <span class=\"n\">Just</span><span class=\"p\">(</span><span class=\"mi\">9</span><span class=\"p\">))</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">square</span><span class=\"p\">(</span><span class=\"n\">List</span><span class=\"p\">(</span><span class=\"n\">List</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">),</span> <span class=\"n\">List</span><span class=\"p\">(</span><span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">)))</span>\n<span class=\"n\">List</span><span class=\"p\">(</span><span class=\"n\">List</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"mi\">9</span><span class=\"p\">),</span> <span class=\"n\">List</span><span class=\"p\">(</span><span class=\"mi\">16</span><span class=\"p\">,</span> <span class=\"mi\">25</span><span class=\"p\">))</span>\n</pre>\n<p>Even functions are functors if they have been decorated with <code>function</code>:</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"nd\">@function</span>\n<span class=\"o\">...</span> <span class=\"k\">def</span> <span class=\"nf\">f</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">):</span>\n<span class=\"o\">...</span>     <span class=\"k\">return</span> <span class=\"n\">List</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"o\">*</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"o\">*</span><span class=\"n\">x</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">square</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"p\">)(</span><span class=\"mi\">3</span><span class=\"p\">)</span>\n<span class=\"n\">List</span><span class=\"p\">(</span><span class=\"mi\">9</span><span class=\"p\">,</span> <span class=\"mi\">36</span><span class=\"p\">,</span> <span class=\"mi\">81</span><span class=\"p\">)</span>\n</pre>\n<h3>Currying</h3>\n<p>HaskPy provides <code>curry</code> decorator which curries a function in such a way that\n<strong>the function remains partially evaluated until all required arguments have\nbeen provided</strong>:</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">from</span> <span class=\"nn\">haskpy</span> <span class=\"kn\">import</span> <span class=\"n\">curry</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"nd\">@curry</span>\n<span class=\"o\">...</span> <span class=\"k\">def</span> <span class=\"nf\">concat</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">y</span><span class=\"p\">,</span> <span class=\"n\">z</span><span class=\"p\">):</span>\n<span class=\"o\">...</span>    <span class=\"k\">return</span> <span class=\"n\">x</span> <span class=\"o\">+</span> <span class=\"n\">y</span> <span class=\"o\">+</span> <span class=\"n\">z</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">concat</span><span class=\"p\">(</span><span class=\"s2\">\"a\"</span><span class=\"p\">)(</span><span class=\"s2\">\"b\"</span><span class=\"p\">)(</span><span class=\"s2\">\"c\"</span><span class=\"p\">)</span>\n<span class=\"s2\">\"abc\"</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">concat</span><span class=\"p\">(</span><span class=\"s2\">\"a\"</span><span class=\"p\">)(</span><span class=\"s2\">\"b\"</span><span class=\"p\">,</span> <span class=\"s2\">\"c\"</span><span class=\"p\">)</span>\n<span class=\"s2\">\"abc\"</span>\n</pre>\n<p>It doesn't convert the function into nested one-argument functions (as currying\nstrictly speaking should do) but it gives more flexibility by accepting any\nnumber of arguments (even no arguments at all). It also handles keyword\narguments and any other optional arguments in an intuitive way similarly as\nnormal function calls.</p>\n<p>It is very similar to the curry function in Toolz, but that implementation has\nsome critical design flaws (see\n<a href=\"https://github.com/pytoolz/toolz/issues/471\" rel=\"nofollow\">toolz/#471</a>). In addition to\ncorrect behavior, the implementation of <code>haskpy.curry</code> is much simpler because\nit doesn't need to support old Python versions. Here's a bit more complex usage\nwith keyword arguments:</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"nd\">@curry</span>\n<span class=\"o\">...</span> <span class=\"k\">def</span> <span class=\"nf\">concat_with_repeat</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">y</span><span class=\"p\">,</span> <span class=\"n\">z</span><span class=\"p\">,</span> <span class=\"n\">r</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">):</span>\n<span class=\"o\">...</span>     <span class=\"k\">return</span> <span class=\"n\">r</span><span class=\"o\">*</span><span class=\"n\">x</span> <span class=\"o\">+</span> <span class=\"n\">r</span><span class=\"o\">*</span><span class=\"n\">y</span> <span class=\"o\">+</span> <span class=\"n\">r</span><span class=\"o\">*</span><span class=\"n\">z</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">concat_with_repeat</span><span class=\"p\">(</span><span class=\"n\">r</span><span class=\"o\">=</span><span class=\"mi\">3</span><span class=\"p\">)(</span><span class=\"s2\">\"a\"</span><span class=\"p\">,</span> <span class=\"s2\">\"b\"</span><span class=\"p\">)(</span><span class=\"s2\">\"c\"</span><span class=\"p\">)</span>\n<span class=\"s2\">\"aaabbbccc\"</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">concat_with_repeat</span><span class=\"p\">(</span><span class=\"n\">y</span><span class=\"o\">=</span><span class=\"s2\">\"b\"</span><span class=\"p\">)(</span><span class=\"s2\">\"a\"</span><span class=\"p\">,</span> <span class=\"n\">z</span><span class=\"o\">=</span><span class=\"s2\">\"c\"</span><span class=\"p\">,</span> <span class=\"n\">r</span><span class=\"o\">=</span><span class=\"mi\">2</span><span class=\"p\">)</span>\n<span class=\"s2\">\"aabbcc\"</span>\n</pre>\n<p>Note that positional arguments can be used as keyword arguments similarly as in\nnormal function calls.</p>\n<h3>Functions</h3>\n<p>Instead of just currying a function, you may want to convert a function into an\nobject that has all the methods of functors, applicatives, monads and all other\ntypeclasses a function is an instance of. In that case, you can use <code>function</code>\ndecorator. Note that <code>function</code> also curries the function, so there's no need to\nuse <code>curry</code> in addition to <code>function</code>.</p>\n<p>Almost all functions in HaskPy have been decorated with <code>function</code>.</p>\n<h2>Copyright</h2>\n<p>Copyright (C) 2019 Jaakko Luttinen</p>\n<p>HaskPy is licensed under the MIT License. See LICENSE file for a text of the\nlicense or visit <a href=\"http://opensource.org/licenses/MIT\" rel=\"nofollow\">http://opensource.org/licenses/MIT</a>.</p>\n\n          </div>"}, "last_serial": 6154348, "releases": {"0.0.2": [{"comment_text": "", "digests": {"md5": "5d7a2b0ae851566ee4fa60e3b6037782", "sha256": "5933fddb86f9ce2efecdecc456943a03ae92ed2712c4dbb18c36455b29bdbcff"}, "downloads": -1, "filename": "haskpy-0.0.2.tar.gz", "has_sig": false, "md5_digest": "5d7a2b0ae851566ee4fa60e3b6037782", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 20677, "upload_time": "2019-10-13T12:49:34", "upload_time_iso_8601": "2019-10-13T12:49:34.334073Z", "url": "https://files.pythonhosted.org/packages/16/e2/72711e22028f02c011ecd2fcf319610aa578861bd264eb5a60208b07f8ba/haskpy-0.0.2.tar.gz", "yanked": false}], "0.0.4": [{"comment_text": "", "digests": {"md5": "894e41f58f04d77d432bf7c871b6bd08", "sha256": "c4a348fa3b4ab20e63af9e18e0e62001bcf5a7ff915a69ccc92a818272b32fcd"}, "downloads": -1, "filename": "haskpy-0.0.4.tar.gz", "has_sig": false, "md5_digest": "894e41f58f04d77d432bf7c871b6bd08", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 20704, "upload_time": "2019-10-13T12:57:42", "upload_time_iso_8601": "2019-10-13T12:57:42.230784Z", "url": "https://files.pythonhosted.org/packages/27/4b/92e40807d1ea60d97f0ab0021fe688447ce3529bc8b29620ddf0e713f9ea/haskpy-0.0.4.tar.gz", "yanked": false}], "0.0.5": [{"comment_text": "", "digests": {"md5": "b3a8ac0ba3405c6959076d9cdfc4f460", "sha256": "189f134ae23b3dc959189a5715904efa3f530a27263f53ed44331e70fd917aa4"}, "downloads": -1, "filename": "haskpy-0.0.5.tar.gz", "has_sig": false, "md5_digest": "b3a8ac0ba3405c6959076d9cdfc4f460", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 36984, "upload_time": "2019-11-07T07:15:57", "upload_time_iso_8601": "2019-11-07T07:15:57.329751Z", "url": "https://files.pythonhosted.org/packages/08/9a/1c7ecec7d9a032447586f48610dc4d0fc4c9b9b2c8667d260ab50278f054/haskpy-0.0.5.tar.gz", "yanked": false}], "0.0.6": [{"comment_text": "", "digests": {"md5": "e375f8fe34ee9d4cdb0e05f4bfb9b699", "sha256": "e7460996993da40597e634beb46fdbc0db8f6d13ad35b71f9c53b9eba1eeffe0"}, "downloads": -1, "filename": "haskpy-0.0.6.tar.gz", "has_sig": false, "md5_digest": "e375f8fe34ee9d4cdb0e05f4bfb9b699", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 38682, "upload_time": "2019-11-10T17:31:29", "upload_time_iso_8601": "2019-11-10T17:31:29.053628Z", "url": "https://files.pythonhosted.org/packages/63/32/c053d3adddab9de7f3913e1fd0e392113ed4e2f9093b1b3fd8ee2bd81d47/haskpy-0.0.6.tar.gz", "yanked": false}], "0.0.7": [{"comment_text": "", "digests": {"md5": "b62ab58c9462cded1a6a9276e19004f2", "sha256": "bebc6bc307399c960a979fa1ef353a870774ef1cf17c6d59fd835f47f45d0e88"}, "downloads": -1, "filename": "haskpy-0.0.7.tar.gz", "has_sig": false, "md5_digest": "b62ab58c9462cded1a6a9276e19004f2", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 42165, "upload_time": "2019-11-15T11:39:06", "upload_time_iso_8601": "2019-11-15T11:39:06.831375Z", "url": "https://files.pythonhosted.org/packages/32/a4/bc8871229800c0fbc21ef1846c5beb2d9cd1457bab4e875319a7eb0fb044/haskpy-0.0.7.tar.gz", "yanked": false}], "0.1.0": [{"comment_text": "", "digests": {"md5": "d49dfaeaa7a32edfebb292e00182b0f3", "sha256": "ce5f33e46c6c9cfc26c09a3904eb40feeee322355927db47ec890e26e8378133"}, "downloads": -1, "filename": "haskpy-0.1.0.tar.gz", "has_sig": false, "md5_digest": "d49dfaeaa7a32edfebb292e00182b0f3", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 42494, "upload_time": "2019-11-15T16:18:31", "upload_time_iso_8601": "2019-11-15T16:18:31.982143Z", "url": "https://files.pythonhosted.org/packages/66/f6/7b5242accd86afe5ccddae4bc9ea46bc6d4fc986416cceb24085ca36db6d/haskpy-0.1.0.tar.gz", "yanked": false}], "0.1.2.dev20191117": [{"comment_text": "", "digests": {"md5": "a159c0b167c4ed1e44eaca7ae6ea4dcd", "sha256": "3245ef3164dd903ddb730b2438b8404aa85f7224997c7ee4274e9dfaecb5e2d2"}, "downloads": -1, "filename": "haskpy-0.1.2.dev20191117.tar.gz", "has_sig": false, "md5_digest": "a159c0b167c4ed1e44eaca7ae6ea4dcd", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 43277, "upload_time": "2019-11-17T13:41:13", "upload_time_iso_8601": "2019-11-17T13:41:13.406786Z", "url": "https://files.pythonhosted.org/packages/4d/c3/c782e450bb2d1739e699498d861a2035d243ba2831d3902f5db26b08aac9/haskpy-0.1.2.dev20191117.tar.gz", "yanked": false}], "0.1.3": [{"comment_text": "", "digests": {"md5": "3fa3af3ba4eaef81d15dabc8fec8ff80", "sha256": "3b83ae098d476cc25c1948012bc27b9ebd016e027da5d5fee2028ee14ea443d5"}, "downloads": -1, "filename": "haskpy-0.1.3.tar.gz", "has_sig": false, "md5_digest": "3fa3af3ba4eaef81d15dabc8fec8ff80", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 43250, "upload_time": "2019-11-17T20:03:18", "upload_time_iso_8601": "2019-11-17T20:03:18.631708Z", "url": "https://files.pythonhosted.org/packages/04/f9/c401893433ab84ce02e9e3bab15651d056debbf3f3dbe4beae0ff764b5ce/haskpy-0.1.3.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "3fa3af3ba4eaef81d15dabc8fec8ff80", "sha256": "3b83ae098d476cc25c1948012bc27b9ebd016e027da5d5fee2028ee14ea443d5"}, "downloads": -1, "filename": "haskpy-0.1.3.tar.gz", "has_sig": false, "md5_digest": "3fa3af3ba4eaef81d15dabc8fec8ff80", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 43250, "upload_time": "2019-11-17T20:03:18", "upload_time_iso_8601": "2019-11-17T20:03:18.631708Z", "url": "https://files.pythonhosted.org/packages/04/f9/c401893433ab84ce02e9e3bab15651d056debbf3f3dbe4beae0ff764b5ce/haskpy-0.1.3.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:52:19 2020"}