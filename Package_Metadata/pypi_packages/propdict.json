{"info": {"author": "Tom Lazar", "author_email": "tom@tomster.org", "bugtrack_url": null, "classifiers": ["Development Status :: 5 - Production/Stable", "Intended Audience :: Developers", "License :: OSI Approved :: BSD License", "Programming Language :: Python :: 2.6", "Programming Language :: Python :: 2.7", "Programming Language :: Python :: 3.3"], "description": "A Python dictionary implementation that supports properties, class variables and inheritance for your sophisticated templating needs.\n\n|travis_status| tested for Python 2.6, 2.7 and 3.3\n\n.. |travis_status| image:: https://travis-ci.org/tomster/propdict.png\n\n\nMotivation\n==========\n\nOverriding a specific behavior of a class is easy: create a subclass (or even just an instance) and just implement the aspect you are interested with and be done. Not so with templates, though. If you want to change one part of it, you need to override the entire template, essentially forking the work of the template author.\n\n``propdict`` counters this by allowing the template author to *put logic and behavior into the data* that goes into the template rather than the template itself.\n\nA consumer of the template can then simply subclass the `propdict` based data, override the specific aspects and leave the template as-is.\n\n\nBasic Features\n==============\n\n``propdict`` instances behave almost exactly as a regular dictionary, except that you can access values using the dict notation or attribute notation:\n\n    >>> server_foo.ip_addr\n    '10.0.0.1'\n    >>> server_foo['ip_addr']\n    '10.0.0.1'\n\n    >>> print server_foo['ifconfig']\n    ifconfig_em0=\"inet 10.0.0.1 netmask 255.255.255.0\"\n\n    >>> print server_foo.ifconfig\n    ifconfig_em0=\"inet 10.0.0.1 netmask 255.255.255.0\"\n\nThe same works also for assignment:\n\n    >>> server_foo.ip_addr = '192.168.1.1'\n    >>> print server_foo.ip_addr\n    192.168.1.1\n\n    >>> server_foo['ip_addr'] = '127.0.0.1'\n    >>> print server_foo.ip_addr\n    127.0.0.1\n\nAssignment also works for changing properties, of course, as you saw in the example:\n\n    >>> server_foo.ifconfig = u'foo mask'\n    >>> print server_foo.ifconfig\n    foo mask\n\nIt is noteworthy, though, that you cannot delete properties. However, you *can* delete custom *values* of properties, but that just re-exposes their original value:\n\n    >>> del server_foo['ifconfig']\n    >>> print server_foo.ifconfig\n    ifconfig_em0=\"inet 127.0.0.1 netmask 255.255.255.0\"\n\n    >>> del server_foo['ifconfig']\n    Traceback (most recent call last):\n    ...\n    KeyError: 'ifconfig'\n\n\nExample\n======= \n\nSay you're the author of a `set of templates for configuring *NIX style systems <https://github.com/ZeitOnline/briefkasten>`_. Naturally, a lot of these templates will be using the same values, for example the IP address of the machine being configured. Now, some *other* values in turn depend on the value of the IP address, too. Let's say one such file has a line configuring the network interface using a netmask, so you end up with a template containing the following snippet:\n\n    >>> template = '''ifconfig_%(iface)s=\"inet %(ip_addr)s netmask %(netmask)s\"'''\n\nGiven a dictionary with the necessary data, this would then evaluate to the following:\n\n    >>> print template % dict(ip_addr='192.168.1.1', iface='em0', netmask='255.255.255.0')\n    ifconfig_em0=\"inet 192.168.1.1 netmask 255.255.255.0\"\n\nThis works fine for most cases, but what if a particular host you deploy is behind a NAT and needs an entirely different configuration that doesn't follow the above format? You now either need to create a custom version of the template (which, unlike the basic example above, could well be of non-trivial length and complexity) that differs in just that one line or the author of the template needs to work in (yet another) special edgecase that won't affect 99% of the users.\n\nThe third solution is to keep (that line of) the templates as simple as possible:\n\n    >>> template = \"%(ifconfig)s\"\n\nand put the logic into the dictionary. Like so:\n\n    >>> from propdict import propdict\n    >>> class Host(propdict):\n    ...     ip_addr = None\n    ...     iface = 'em0'\n    ...     netmask = '255.255.255.0'\n    ...     @property\n    ...     def ifconfig(self):\n    ...         return '''ifconfig_%(iface)s=\"inet %(ip_addr)s netmask %(netmask)s\"''' % self\n\n\n    >>> server_foo = Host(ip_addr='10.0.0.1')\n    >>> print template % server_foo\n    ifconfig_em0=\"inet 10.0.0.1 netmask 255.255.255.0\"\n\nSo far so good, we got the same result as above. But let's consider another server:\n\n    >>> server_bar = Host(ip_addr='10.0.0.2', ifconfig='ifconfig_em1=\"inet 10.0.0.2 netmask 255.255.0.0\"')\n    >>> print template % server_bar\n    ifconfig_em1=\"inet 10.0.0.2 netmask 255.255.0.0\"\n\nNotice, how the new definition of ``ifconfig`` contains a new value for the interface (perhaps this host has two built-in) but still references ``ip_addr``. In this case it might be better to not simply provide a new, static value but to come up with a better implementation of the property:\n\n    >>> class HostBar(Host):\n    ...     iface_2 = 'em1'\n    ...     @property\n    ...     def ifconfig(self):\n    ...         return '''ifconfig_%(iface_2)s=\"inet %(ip_addr)s netmask %(netmask)s\"''' % self\n    >>> server_bar = HostBar(ip_addr='10.0.0.2', netmask='255.255.0.0')\n    >>> print template % server_bar\n    ifconfig_em1=\"inet 10.0.0.2 netmask 255.255.0.0\"\n\nSo, we were able to provide an arbitrary new value for the ``ifconfig`` key by changing just that and without touching the template, while still keeping the default behavior (it's automatically computed for you from the interface and IP address).\n\n\nInstallation\n============\n\n`propdict` has no dependencies and can simply be installed as an egg using your preferred tool, such as pip, easy_install, buildout, setuptools. You know the drill.\n\n\nRun Tests\n=========\n\nTo make sure that ``propdict`` works for your setup, run its tests. You need a checkout from github and `py.test <http://pytest.org/latest/>`_, perhaps like so::\n\n    git clone git@github.com:tomster/propdict\n    cd propdict\n    virtualenv .\n    source bin/activate\n    pip install pytest-cov\n\nThen, to run all tests (including this README)::\n\n    bin/py.test\n\nIf you made some changes and want to know whether you broke coverage::\n\n    bin/py.test --cov propdict --cov-report html --cov-report term test_propdict.py\n\n\nChangelog\n=========\n\n1.1 - 201310-18\n---------------\n\n- Packaging fix [fschulze]\n- Support dict in constructor [fschulze]\n\n\n1.0 - 2013-10-17\n----------------\n\nAfter several months in production, released the identical code as stable.\n\n\n0.1a1 - 2013-03-17\n------------------\n\nInitial public release", "description_content_type": null, "docs_url": null, "download_url": "UNKNOWN", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/tomster/propdict", "keywords": null, "license": "BSD", "maintainer": null, "maintainer_email": null, "name": "propdict", "package_url": "https://pypi.org/project/propdict/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/propdict/", "project_urls": {"Download": "UNKNOWN", "Homepage": "https://github.com/tomster/propdict"}, "release_url": "https://pypi.org/project/propdict/1.1/", "requires_dist": null, "requires_python": null, "summary": "A Python dictionary implementation that supports properties, class variables and inheritance for your sophisticated templating needs.", "version": "1.1", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p>A Python dictionary implementation that supports properties, class variables and inheritance for your sophisticated templating needs.</p>\n<p><img alt=\"travis_status\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/8d104912e7f28c9a5d7e9204d553684dd006a76a/68747470733a2f2f7472617669732d63692e6f72672f746f6d737465722f70726f70646963742e706e67\"> tested for Python 2.6, 2.7 and 3.3</p>\n<div id=\"motivation\">\n<h2>Motivation</h2>\n<p>Overriding a specific behavior of a class is easy: create a subclass (or even just an instance) and just implement the aspect you are interested with and be done. Not so with templates, though. If you want to change one part of it, you need to override the entire template, essentially forking the work of the template author.</p>\n<p><tt>propdict</tt> counters this by allowing the template author to <em>put logic and behavior into the data</em> that goes into the template rather than the template itself.</p>\n<p>A consumer of the template can then simply subclass the <cite>propdict</cite> based data, override the specific aspects and leave the template as-is.</p>\n</div>\n<div id=\"basic-features\">\n<h2>Basic Features</h2>\n<p><tt>propdict</tt> instances behave almost exactly as a regular dictionary, except that you can access values using the dict notation or attribute notation:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; server_foo.ip_addr\n'10.0.0.1'\n&gt;&gt;&gt; server_foo['ip_addr']\n'10.0.0.1'\n</pre>\n<pre>&gt;&gt;&gt; print server_foo['ifconfig']\nifconfig_em0=\"inet 10.0.0.1 netmask 255.255.255.0\"\n</pre>\n<pre>&gt;&gt;&gt; print server_foo.ifconfig\nifconfig_em0=\"inet 10.0.0.1 netmask 255.255.255.0\"\n</pre>\n</blockquote>\n<p>The same works also for assignment:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; server_foo.ip_addr = '192.168.1.1'\n&gt;&gt;&gt; print server_foo.ip_addr\n192.168.1.1\n</pre>\n<pre>&gt;&gt;&gt; server_foo['ip_addr'] = '127.0.0.1'\n&gt;&gt;&gt; print server_foo.ip_addr\n127.0.0.1\n</pre>\n</blockquote>\n<p>Assignment also works for changing properties, of course, as you saw in the example:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; server_foo.ifconfig = u'foo mask'\n&gt;&gt;&gt; print server_foo.ifconfig\nfoo mask\n</pre>\n</blockquote>\n<p>It is noteworthy, though, that you cannot delete properties. However, you <em>can</em> delete custom <em>values</em> of properties, but that just re-exposes their original value:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; del server_foo['ifconfig']\n&gt;&gt;&gt; print server_foo.ifconfig\nifconfig_em0=\"inet 127.0.0.1 netmask 255.255.255.0\"\n</pre>\n<pre>&gt;&gt;&gt; del server_foo['ifconfig']\nTraceback (most recent call last):\n...\nKeyError: 'ifconfig'\n</pre>\n</blockquote>\n</div>\n<div id=\"example\">\n<h2>Example</h2>\n<p>Say you\u2019re the author of a <a href=\"https://github.com/ZeitOnline/briefkasten\" rel=\"nofollow\">set of templates for configuring *NIX style systems</a>. Naturally, a lot of these templates will be using the same values, for example the IP address of the machine being configured. Now, some <em>other</em> values in turn depend on the value of the IP address, too. Let\u2019s say one such file has a line configuring the network interface using a netmask, so you end up with a template containing the following snippet:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; template = '''ifconfig_%(iface)s=\"inet %(ip_addr)s netmask %(netmask)s\"'''\n</pre>\n</blockquote>\n<p>Given a dictionary with the necessary data, this would then evaluate to the following:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; print template % dict(ip_addr='192.168.1.1', iface='em0', netmask='255.255.255.0')\nifconfig_em0=\"inet 192.168.1.1 netmask 255.255.255.0\"\n</pre>\n</blockquote>\n<p>This works fine for most cases, but what if a particular host you deploy is behind a NAT and needs an entirely different configuration that doesn\u2019t follow the above format? You now either need to create a custom version of the template (which, unlike the basic example above, could well be of non-trivial length and complexity) that differs in just that one line or the author of the template needs to work in (yet another) special edgecase that won\u2019t affect 99% of the users.</p>\n<p>The third solution is to keep (that line of) the templates as simple as possible:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; template = \"%(ifconfig)s\"\n</pre>\n</blockquote>\n<p>and put the logic into the dictionary. Like so:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from propdict import propdict\n&gt;&gt;&gt; class Host(propdict):\n...     ip_addr = None\n...     iface = 'em0'\n...     netmask = '255.255.255.0'\n...     @property\n...     def ifconfig(self):\n...         return '''ifconfig_%(iface)s=\"inet %(ip_addr)s netmask %(netmask)s\"''' % self\n</pre>\n<pre>&gt;&gt;&gt; server_foo = Host(ip_addr='10.0.0.1')\n&gt;&gt;&gt; print template % server_foo\nifconfig_em0=\"inet 10.0.0.1 netmask 255.255.255.0\"\n</pre>\n</blockquote>\n<p>So far so good, we got the same result as above. But let\u2019s consider another server:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; server_bar = Host(ip_addr='10.0.0.2', ifconfig='ifconfig_em1=\"inet 10.0.0.2 netmask 255.255.0.0\"')\n&gt;&gt;&gt; print template % server_bar\nifconfig_em1=\"inet 10.0.0.2 netmask 255.255.0.0\"\n</pre>\n</blockquote>\n<p>Notice, how the new definition of <tt>ifconfig</tt> contains a new value for the interface (perhaps this host has two built-in) but still references <tt>ip_addr</tt>. In this case it might be better to not simply provide a new, static value but to come up with a better implementation of the property:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; class HostBar(Host):\n...     iface_2 = 'em1'\n...     @property\n...     def ifconfig(self):\n...         return '''ifconfig_%(iface_2)s=\"inet %(ip_addr)s netmask %(netmask)s\"''' % self\n&gt;&gt;&gt; server_bar = HostBar(ip_addr='10.0.0.2', netmask='255.255.0.0')\n&gt;&gt;&gt; print template % server_bar\nifconfig_em1=\"inet 10.0.0.2 netmask 255.255.0.0\"\n</pre>\n</blockquote>\n<p>So, we were able to provide an arbitrary new value for the <tt>ifconfig</tt> key by changing just that and without touching the template, while still keeping the default behavior (it\u2019s automatically computed for you from the interface and IP address).</p>\n</div>\n<div id=\"installation\">\n<h2>Installation</h2>\n<p><cite>propdict</cite> has no dependencies and can simply be installed as an egg using your preferred tool, such as pip, easy_install, buildout, setuptools. You know the drill.</p>\n</div>\n<div id=\"run-tests\">\n<h2>Run Tests</h2>\n<p>To make sure that <tt>propdict</tt> works for your setup, run its tests. You need a checkout from github and <a href=\"http://pytest.org/latest/\" rel=\"nofollow\">py.test</a>, perhaps like so:</p>\n<pre>git clone git@github.com:tomster/propdict\ncd propdict\nvirtualenv .\nsource bin/activate\npip install pytest-cov\n</pre>\n<p>Then, to run all tests (including this README):</p>\n<pre>bin/py.test\n</pre>\n<p>If you made some changes and want to know whether you broke coverage:</p>\n<pre>bin/py.test --cov propdict --cov-report html --cov-report term test_propdict.py\n</pre>\n</div>\n<div id=\"changelog\">\n<h2>Changelog</h2>\n<div id=\"id1\">\n<h3>1.1 - 201310-18</h3>\n<ul>\n<li>Packaging fix [fschulze]</li>\n<li>Support dict in constructor [fschulze]</li>\n</ul>\n</div>\n<div id=\"id2\">\n<h3>1.0 - 2013-10-17</h3>\n<p>After several months in production, released the identical code as stable.</p>\n</div>\n<div id=\"a1-2013-03-17\">\n<h3>0.1a1 - 2013-03-17</h3>\n<p>Initial public release</p>\n</div>\n</div>\n\n          </div>"}, "last_serial": 897600, "releases": {"0.1a1": [{"comment_text": "", "digests": {"md5": "a2b039a56a8abd7add44da3e0953deb5", "sha256": "0fece3eaa49f5d29dbea5d7bf9ddf722877484b06b48a0966bce58dff4aaffba"}, "downloads": -1, "filename": "propdict-0.1a1.zip", "has_sig": false, "md5_digest": "a2b039a56a8abd7add44da3e0953deb5", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 12263, "upload_time": "2013-03-17T16:08:35", "upload_time_iso_8601": "2013-03-17T16:08:35.330663Z", "url": "https://files.pythonhosted.org/packages/ed/81/087df927c813305ed47934820872f9989ae020339d91d1937e9eb1ab6511/propdict-0.1a1.zip", "yanked": false}], "1.0": [{"comment_text": "", "digests": {"md5": "b732065ba956a0401d5dbc6b3d93642b", "sha256": "61d4e320a141849d118cf5ba39ff58bbeab8f1c996e1de6b1583625c3666a5c1"}, "downloads": -1, "filename": "propdict-1.0.zip", "has_sig": false, "md5_digest": "b732065ba956a0401d5dbc6b3d93642b", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 12364, "upload_time": "2013-10-17T19:51:38", "upload_time_iso_8601": "2013-10-17T19:51:38.083587Z", "url": "https://files.pythonhosted.org/packages/34/30/53f44398df66f5544c8616b2620c2511ce21f363612655b51c2529bf8cc6/propdict-1.0.zip", "yanked": false}], "1.1": [{"comment_text": "", "digests": {"md5": "077bc643eba3b9f2fe9dc1e121dac3da", "sha256": "8b2a3c1de90ca836926023e57739f22f1b8d82c0a47368b14ccaab84de561b76"}, "downloads": -1, "filename": "propdict-1.1.zip", "has_sig": false, "md5_digest": "077bc643eba3b9f2fe9dc1e121dac3da", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 12918, "upload_time": "2013-10-18T13:20:43", "upload_time_iso_8601": "2013-10-18T13:20:43.223776Z", "url": "https://files.pythonhosted.org/packages/db/2e/13ea4855514ec6221d2a400a616ecfb0dbf8411fa36b665f0b5edd8e00f9/propdict-1.1.zip", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "077bc643eba3b9f2fe9dc1e121dac3da", "sha256": "8b2a3c1de90ca836926023e57739f22f1b8d82c0a47368b14ccaab84de561b76"}, "downloads": -1, "filename": "propdict-1.1.zip", "has_sig": false, "md5_digest": "077bc643eba3b9f2fe9dc1e121dac3da", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 12918, "upload_time": "2013-10-18T13:20:43", "upload_time_iso_8601": "2013-10-18T13:20:43.223776Z", "url": "https://files.pythonhosted.org/packages/db/2e/13ea4855514ec6221d2a400a616ecfb0dbf8411fa36b665f0b5edd8e00f9/propdict-1.1.zip", "yanked": false}], "timestamp": "Fri May  8 03:16:59 2020"}