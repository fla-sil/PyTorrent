{"info": {"author": "Steve Lacy", "author_email": "slacy@slacy.com", "bugtrack_url": null, "classifiers": ["Development Status :: 3 - Alpha", "Intended Audience :: Developers", "Programming Language :: Python"], "description": "Method Pickle\n=============\n\nMethodPickle (methodpickle) is a quick library that allows simple pickling\nand unpickling of function and method invocation.  Function & method module\nloading is handled automatically, and methods can be specified by name as\nwell.\n\nThe ability to pickle a method invocation allows for queueing and delayed\nexecution of arbitrary code.  This is useful for parallelization, logging,\nqueueing, etc.\n\nContact::\n\n    Steve Lacy <github@slacy.com>\n    Twitter: @sklacy\n    http://slacy.com/blog\n\nFeatures & Usage\n----------------\n\nPlease see the unit tests in test.py for some more verbose examples, but\nI'll go through a quick example here.::\n\n  from methodpickle.defer import defer\n\n  # These are the functions that we're going to defer\n  def some_function(x, y):\n      return x*x + y*y\n\n  # methodpickle supports deferring execution of classmethods as well, so\n  # here's a simple class with a method:\n  def some_class(object):\n      def __init__(self, x):\n          self._x = x\n\n      def calc(self, y):\n          return (self._x * self._x + y * y)\n\n  if __name__ == '__main__':\n\n      # the defer function takes a method and it's arguments, and turns it\n      # into a pickleable object.\n      storable_func = defer(some_function, 5, 4)\n\n      # So, we pickle that guy into a string.\n      method_str = pickle.dumps(storable_func)\n\n      # You can now take method_str and do whatever you like with it.  Write\n      # it to a database, send it to another process, put it in your logs,\n      # whatever.\n\n      # Then, you can unpickle the stored method invocation, and run it,\n      # like this:\n      recovered_func = pickle.loads()\n      assert(recovered_func.run() == 5*5 + 4*4)\n\n      # methodpickle also supports pickling of classmethods.  Note that your\n      # class must support pickling and the methods should have no side\n      # effects.\n\n      i = some_class(2)\n      storable_classmethod = defer(i, 3)\n\n      classmethod_str = storable_method.dumps()\n      recovered_classmethod = pickle.loads(classmethod_str)\n      assert(recovered_classmethod.run() == 2*2 + 3*3)\n\nFor convenience, there's also a decorator form of the defer function, called\ndeferred.  Again, see the implementation or test.py for more details.\n\nCaveats\n-------\n\n* **All arguments to functions must themselves be pickle-able.** This\n    includes 'self' for class method invocations\n\n* **Functions and classes must be at the module level.** Inner classes and\n    inner functions don't have an easy-to-discover import path, so all the\n    deferred functions should be at the top level of your module.  I'd\n    suggest putting them all in the same file (say, tasks.py)\n\n* **All method arguments are deepcopied at the time of the deferral.** Thus,\n    if you pass a very large datastructure to the deferral methods, it may\n    have a performance impact.  In addition, if you pass a mutable\n    datastructur (dict, list, etc.) then subsequent modifications will have\n    no effect.\n\n* **Watch out for double invocation of functions & methods**.  This is both\n    a feature and a caveat.  Once you pickle a function call, that value\n    could be unpickled and run more than once.  Watch out for anything that\n    has unexpected side effects!", "description_content_type": null, "docs_url": null, "download_url": "UNKNOWN", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "http://github.com/slacy/methodpickle", "keywords": "python,method,pickle", "license": "UNKNOWN", "maintainer": null, "maintainer_email": null, "name": "methodpickle", "package_url": "https://pypi.org/project/methodpickle/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/methodpickle/", "project_urls": {"Download": "UNKNOWN", "Homepage": "http://github.com/slacy/methodpickle"}, "release_url": "https://pypi.org/project/methodpickle/0.1.0/", "requires_dist": null, "requires_python": null, "summary": "Simple method invocation pickling.", "version": "0.1.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p>MethodPickle (methodpickle) is a quick library that allows simple pickling\nand unpickling of function and method invocation.  Function &amp; method module\nloading is handled automatically, and methods can be specified by name as\nwell.</p>\n<p>The ability to pickle a method invocation allows for queueing and delayed\nexecution of arbitrary code.  This is useful for parallelization, logging,\nqueueing, etc.</p>\n<p>Contact:</p>\n<pre>Steve Lacy &lt;github@slacy.com&gt;\nTwitter: @sklacy\nhttp://slacy.com/blog\n</pre>\n<div id=\"features-usage\">\n<h2>Features &amp; Usage</h2>\n<p>Please see the unit tests in test.py for some more verbose examples, but\nI\u2019ll go through a quick example here.:</p>\n<pre>from methodpickle.defer import defer\n\n# These are the functions that we're going to defer\ndef some_function(x, y):\n    return x*x + y*y\n\n# methodpickle supports deferring execution of classmethods as well, so\n# here's a simple class with a method:\ndef some_class(object):\n    def __init__(self, x):\n        self._x = x\n\n    def calc(self, y):\n        return (self._x * self._x + y * y)\n\nif __name__ == '__main__':\n\n    # the defer function takes a method and it's arguments, and turns it\n    # into a pickleable object.\n    storable_func = defer(some_function, 5, 4)\n\n    # So, we pickle that guy into a string.\n    method_str = pickle.dumps(storable_func)\n\n    # You can now take method_str and do whatever you like with it.  Write\n    # it to a database, send it to another process, put it in your logs,\n    # whatever.\n\n    # Then, you can unpickle the stored method invocation, and run it,\n    # like this:\n    recovered_func = pickle.loads()\n    assert(recovered_func.run() == 5*5 + 4*4)\n\n    # methodpickle also supports pickling of classmethods.  Note that your\n    # class must support pickling and the methods should have no side\n    # effects.\n\n    i = some_class(2)\n    storable_classmethod = defer(i, 3)\n\n    classmethod_str = storable_method.dumps()\n    recovered_classmethod = pickle.loads(classmethod_str)\n    assert(recovered_classmethod.run() == 2*2 + 3*3)\n</pre>\n<p>For convenience, there\u2019s also a decorator form of the defer function, called\ndeferred.  Again, see the implementation or test.py for more details.</p>\n</div>\n<div id=\"caveats\">\n<h2>Caveats</h2>\n<ul>\n<li><dl>\n<dt><strong>All arguments to functions must themselves be pickle-able.</strong> This</dt>\n<dd>includes \u2018self\u2019 for class method invocations</dd>\n</dl>\n</li>\n<li><dl>\n<dt><strong>Functions and classes must be at the module level.</strong> Inner classes and</dt>\n<dd>inner functions don\u2019t have an easy-to-discover import path, so all the\ndeferred functions should be at the top level of your module.  I\u2019d\nsuggest putting them all in the same file (say, tasks.py)</dd>\n</dl>\n</li>\n<li><dl>\n<dt><strong>All method arguments are deepcopied at the time of the deferral.</strong> Thus,</dt>\n<dd>if you pass a very large datastructure to the deferral methods, it may\nhave a performance impact.  In addition, if you pass a mutable\ndatastructur (dict, list, etc.) then subsequent modifications will have\nno effect.</dd>\n</dl>\n</li>\n<li><dl>\n<dt><strong>Watch out for double invocation of functions &amp; methods</strong>.  This is both</dt>\n<dd>a feature and a caveat.  Once you pickle a function call, that value\ncould be unpickled and run more than once.  Watch out for anything that\nhas unexpected side effects!</dd>\n</dl>\n</li>\n</ul>\n</div>\n\n          </div>"}, "last_serial": 794728, "releases": {"0.1.0": [{"comment_text": "built for Linux-2.6.35-25-generic-x86_64-with-glibc2.4", "digests": {"md5": "08d57f654c601082ae653cf3d5d7e2e2", "sha256": "0d76bcc48d8dced24b1e4aca7f2ffd9c9bd1cae53b36247142a95e6a9a442e52"}, "downloads": -1, "filename": "methodpickle-0.1.0.linux-x86_64.tar.gz", "has_sig": false, "md5_digest": "08d57f654c601082ae653cf3d5d7e2e2", "packagetype": "bdist_dumb", "python_version": "any", "requires_python": null, "size": 7423, "upload_time": "2011-02-12T00:25:15", "upload_time_iso_8601": "2011-02-12T00:25:15.486301Z", "url": "https://files.pythonhosted.org/packages/a7/1e/d850ee6a4116774648e73fe3b97964eb830d4165ec8bbeb7e22ddc7b6887/methodpickle-0.1.0.linux-x86_64.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "built for Linux-2.6.35-25-generic-x86_64-with-glibc2.4", "digests": {"md5": "08d57f654c601082ae653cf3d5d7e2e2", "sha256": "0d76bcc48d8dced24b1e4aca7f2ffd9c9bd1cae53b36247142a95e6a9a442e52"}, "downloads": -1, "filename": "methodpickle-0.1.0.linux-x86_64.tar.gz", "has_sig": false, "md5_digest": "08d57f654c601082ae653cf3d5d7e2e2", "packagetype": "bdist_dumb", "python_version": "any", "requires_python": null, "size": 7423, "upload_time": "2011-02-12T00:25:15", "upload_time_iso_8601": "2011-02-12T00:25:15.486301Z", "url": "https://files.pythonhosted.org/packages/a7/1e/d850ee6a4116774648e73fe3b97964eb830d4165ec8bbeb7e22ddc7b6887/methodpickle-0.1.0.linux-x86_64.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:55:43 2020"}