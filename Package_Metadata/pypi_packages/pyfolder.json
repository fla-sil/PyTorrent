{"info": {"author": "Iv\u00e1n de Paz Centeno", "author_email": "ipazc@unileon.es", "bugtrack_url": null, "classifiers": ["Environment :: Console", "Intended Audience :: Developers", "Intended Audience :: Education", "Intended Audience :: Science/Research", "Natural Language :: English", "Programming Language :: Python :: 3.4", "Programming Language :: Python :: 3.5", "Programming Language :: Python :: 3.6", "Programming Language :: Python :: 3.7"], "description": "==============\npyfolder 0.0.2\n==============\n\n`PyFolder` is a package for managing a filesystem folders as a dictionary.\n\n.. image:: https://badge.fury.io/py/pyfolder.svg\n    :target: https://badge.fury.io/py/pyfolder\n\n.. image:: https://travis-ci.org/ipazc/pyfolder.svg?branch=master\n    :target: https://travis-ci.org/ipazc/pyfolder\n\n.. image:: https://coveralls.io/repos/github/ipazc/pyfolder/badge.svg?branch=master\n    :target: https://coveralls.io/github/ipazc/pyfolder?branch=master\n\n.. image:: https://landscape.io/github/ipazc/pyfolder/master/landscape.svg?style=flat\n   :target: https://landscape.io/github/ipazc/pyfolder/master\n   :alt: Code Health\n\n\nInstallation\n============\nCurrently it is only supported **Python 3.4.1** onwards:\n\n.. code:: bash\n\n    sudo pip3 install pyfolder\n\n\nExample\n=======\n.. code:: python\n\n    >>> from pyfolder import PyFolder\n    >>> \n    >>> pyfolder = PyFolder(\"/path/to/folder\")\n    >>> pyfolder[\"file.txt\"] = \"hello, this is going to be instantly the content of this file.\"\n\nBasic Usage\n===========\n`PyFolder` can easily store or read content from the filesystem. The usage is the same as a normal dictionary:\n\n* **Create a file with specific binary content:**\n\n.. code:: python\n\n    >>> from pyfolder import PyFolder\n    >>> \n    >>> pyfolder = PyFolder(\"/path/to/folder\")\n    >>> pyfolder['file.bin'] = b\"Content as bytes\"\n    >>> pyfolder['file.txt'] = \"Content as text\"\n    >>> pyfolder['file.json'] = {\"content\": \"Content as JSON\"}\n\n\n`PyFolder` automatically detects the kind of content to store.\n\nIt is also possible to reference the creation of a file in relative file URI notation:\n\n.. code:: python\n\n    >>> pyfolder[\"folder1/folder2/file.txt\"] = \"content\"\n\nIf folder specified doesn't exist, by default it will be created automatically unless the flag `auto_create_folder` is set to `False` during instantiation:\n\n.. code:: python\n\n    >>> pyfolder = PyFolder(\"/path/to/folder\", auto_create_folder=False)\n\nNote that \".\" or \"..\" chars are not allowed in URI notation, it must be relative URIs to the root.\n\n\n* **Get specific content:**\n\n.. code:: python\n\n    >>> pyfolder = PyFolder(\"/path/to/folder\")\n    >>> pyfolder['file.bin']\n    b\"Content as bytes\"\n    >>> pyfolder['file.txt']\n    \"Content as text\"\n    >>> pyfolder['file.json']\n    {\"content\": \"Content as JSON\"}\n    >>> pyfolder['folder1/folder2/file.bin']\n    b\"Other content\"\n\nBy default `PyFolder` will attempt to load the content with the best interpreter it has, based on the file extension. If no interpreter is found for\na content, it will return the content in bytes format. This behaviour can be disabled with the flag `interpret=False` during instantiation:\n\n.. code:: python\n\n    >>> pyfolder = PyFolder(\"/path/to/folder\", interpret=False)\n\n\n* **Edit content:**\n\n`PyFolder` won't allow modification or removal of elements unless the flag `allow_override` is specified during instantiation:\n\n.. code:: python\n\n    >>> pyfolder = PyFolder(\"/path/to/folder\", allow_override=True)\n    >>> pyfolder['file.bin'] = b\"replaced_content_bytes\"\n\n\n* **Remove content:**\n\n.. code:: python\n\n    >>> del pyfolder['file.bin']\n\n\nNote that a folder can also be removed:\n\n.. code:: python\n\n    >>> del pyfolder['folder1']\n    >>> del pyfolder['.']  # deletes PyFolder root folder\n\n\nBy default PyFolder won't remove a folder unless its content is empty. In order to be able to remove folders without restriction, enable the flag `allow_remove_folders_with_content`\n\n.. code:: python\n\n    >>> pyfolder = PyFolder(\"/path/to/folder\", allow_remove_folders_with_content=True)\n\n\n* **Iterate over the files:**\n\nBy default `PyFolder` allows iteration over files, including the folders:\n\n.. code:: python\n\n    >>> for file_name in pyfolder:\n    >>>    print(file_name)\n\nIf it is wanted to access also the content, it can be done with the `items()` method:\n\n.. code:: python\n\n    >>> for file_name, content in pyfolder.items():\n    >>>    print(file_name, content)\n\nIf only files are wanted, the `files()` method exists to serve the purpose:\n\n.. code:: python\n\n    >>> for file_name in pyfolder.files()\n    ...\n    >>> for file_name, content in pyfolder.files_items()\n\n\n* **Iterate over folders:**\n\n.. code:: python\n\n    >>> for folder_name in pyfolder.folders():\n    ...\n\n\nit is also possible to iterate over the folder name and its content at the same time:\n\n\n.. code:: python\n\n    >>> for folder_name, folder_content in pyfolder.folders_items():\n    ...\n\n\nIn `PyFolder`, each folder is a `PyFolder` object. It is perfectly possible to nest folders as follows:\n\n.. code:: python\n\n    >>> pyfolder[\"folder1\"][\"folder2\"]\n    >>> pyfolder[\"folder1/folder2\"]  # Equivalent in relative URI notation\n\n\n* **Search for files:**\n\n`PyFolder` eases the search of a file/folder by matching a name. It will return the list of relative URIs of the file-names found:\n\n.. code:: python\n\n    >>> pyfolder.index(\"name.bin\")\n    >>> ['path/to/name.bin', 'path2/to/name.bin']\n\n\nLICENSE\n=======\n\nIt is released under the MIT license.\n", "description_content_type": null, "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "http://github.com/ipazc/pyfolder", "keywords": "pyfolder dict folder file filesystem", "license": "MIT", "maintainer": "", "maintainer_email": "", "name": "pyfolder", "package_url": "https://pypi.org/project/pyfolder/", "platform": "", "project_url": "https://pypi.org/project/pyfolder/", "project_urls": {"Homepage": "http://github.com/ipazc/pyfolder"}, "release_url": "https://pypi.org/project/pyfolder/0.0.2/", "requires_dist": null, "requires_python": "", "summary": "PyFolder is a package for managing filesystem folders as a dictionary.", "version": "0.0.2", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p><cite>PyFolder</cite> is a package for managing a filesystem folders as a dictionary.</p>\n<a href=\"https://badge.fury.io/py/pyfolder\" rel=\"nofollow\"><img alt=\"https://badge.fury.io/py/pyfolder.svg\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/32b4412989f68d3b532adbabbca296ba5ebc7bac/68747470733a2f2f62616467652e667572792e696f2f70792f7079666f6c6465722e737667\"></a>\n<a href=\"https://travis-ci.org/ipazc/pyfolder\" rel=\"nofollow\"><img alt=\"https://travis-ci.org/ipazc/pyfolder.svg?branch=master\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/2dd79ea2196ce43c2386248e646049e5db8ad5ae/68747470733a2f2f7472617669732d63692e6f72672f6970617a632f7079666f6c6465722e7376673f6272616e63683d6d6173746572\"></a>\n<a href=\"https://coveralls.io/github/ipazc/pyfolder?branch=master\" rel=\"nofollow\"><img alt=\"https://coveralls.io/repos/github/ipazc/pyfolder/badge.svg?branch=master\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/696289cd0d08aaa10fee5711849810487e628132/68747470733a2f2f636f766572616c6c732e696f2f7265706f732f6769746875622f6970617a632f7079666f6c6465722f62616467652e7376673f6272616e63683d6d6173746572\"></a>\n<a href=\"https://landscape.io/github/ipazc/pyfolder/master\" rel=\"nofollow\"><img alt=\"Code Health\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/cef844dd1297101bab87dd38e10185b2512a4f06/68747470733a2f2f6c616e6473636170652e696f2f6769746875622f6970617a632f7079666f6c6465722f6d61737465722f6c616e6473636170652e7376673f7374796c653d666c6174\"></a>\n<div id=\"installation\">\n<h2>Installation</h2>\n<p>Currently it is only supported <strong>Python 3.4.1</strong> onwards:</p>\n<pre>sudo pip3 install pyfolder\n</pre>\n</div>\n<div id=\"example\">\n<h2>Example</h2>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">from</span> <span class=\"nn\">pyfolder</span> <span class=\"kn\">import</span> <span class=\"n\">PyFolder</span>\n<span class=\"o\">&gt;&gt;&gt;</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">pyfolder</span> <span class=\"o\">=</span> <span class=\"n\">PyFolder</span><span class=\"p\">(</span><span class=\"s2\">\"/path/to/folder\"</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">pyfolder</span><span class=\"p\">[</span><span class=\"s2\">\"file.txt\"</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"s2\">\"hello, this is going to be instantly the content of this file.\"</span>\n</pre>\n</div>\n<div id=\"basic-usage\">\n<h2>Basic Usage</h2>\n<p><cite>PyFolder</cite> can easily store or read content from the filesystem. The usage is the same as a normal dictionary:</p>\n<ul>\n<li><strong>Create a file with specific binary content:</strong></li>\n</ul>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">from</span> <span class=\"nn\">pyfolder</span> <span class=\"kn\">import</span> <span class=\"n\">PyFolder</span>\n<span class=\"o\">&gt;&gt;&gt;</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">pyfolder</span> <span class=\"o\">=</span> <span class=\"n\">PyFolder</span><span class=\"p\">(</span><span class=\"s2\">\"/path/to/folder\"</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">pyfolder</span><span class=\"p\">[</span><span class=\"s1\">'file.bin'</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"sa\">b</span><span class=\"s2\">\"Content as bytes\"</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">pyfolder</span><span class=\"p\">[</span><span class=\"s1\">'file.txt'</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"s2\">\"Content as text\"</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">pyfolder</span><span class=\"p\">[</span><span class=\"s1\">'file.json'</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"s2\">\"content\"</span><span class=\"p\">:</span> <span class=\"s2\">\"Content as JSON\"</span><span class=\"p\">}</span>\n</pre>\n<p><cite>PyFolder</cite> automatically detects the kind of content to store.</p>\n<p>It is also possible to reference the creation of a file in relative file URI notation:</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">pyfolder</span><span class=\"p\">[</span><span class=\"s2\">\"folder1/folder2/file.txt\"</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"s2\">\"content\"</span>\n</pre>\n<p>If folder specified doesn\u2019t exist, by default it will be created automatically unless the flag <cite>auto_create_folder</cite> is set to <cite>False</cite> during instantiation:</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">pyfolder</span> <span class=\"o\">=</span> <span class=\"n\">PyFolder</span><span class=\"p\">(</span><span class=\"s2\">\"/path/to/folder\"</span><span class=\"p\">,</span> <span class=\"n\">auto_create_folder</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">)</span>\n</pre>\n<p>Note that \u201c.\u201d or \u201c..\u201d chars are not allowed in URI notation, it must be relative URIs to the root.</p>\n<ul>\n<li><strong>Get specific content:</strong></li>\n</ul>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">pyfolder</span> <span class=\"o\">=</span> <span class=\"n\">PyFolder</span><span class=\"p\">(</span><span class=\"s2\">\"/path/to/folder\"</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">pyfolder</span><span class=\"p\">[</span><span class=\"s1\">'file.bin'</span><span class=\"p\">]</span>\n<span class=\"sa\">b</span><span class=\"s2\">\"Content as bytes\"</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">pyfolder</span><span class=\"p\">[</span><span class=\"s1\">'file.txt'</span><span class=\"p\">]</span>\n<span class=\"s2\">\"Content as text\"</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">pyfolder</span><span class=\"p\">[</span><span class=\"s1\">'file.json'</span><span class=\"p\">]</span>\n<span class=\"p\">{</span><span class=\"s2\">\"content\"</span><span class=\"p\">:</span> <span class=\"s2\">\"Content as JSON\"</span><span class=\"p\">}</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">pyfolder</span><span class=\"p\">[</span><span class=\"s1\">'folder1/folder2/file.bin'</span><span class=\"p\">]</span>\n<span class=\"sa\">b</span><span class=\"s2\">\"Other content\"</span>\n</pre>\n<p>By default <cite>PyFolder</cite> will attempt to load the content with the best interpreter it has, based on the file extension. If no interpreter is found for\na content, it will return the content in bytes format. This behaviour can be disabled with the flag <cite>interpret=False</cite> during instantiation:</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">pyfolder</span> <span class=\"o\">=</span> <span class=\"n\">PyFolder</span><span class=\"p\">(</span><span class=\"s2\">\"/path/to/folder\"</span><span class=\"p\">,</span> <span class=\"n\">interpret</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">)</span>\n</pre>\n<ul>\n<li><strong>Edit content:</strong></li>\n</ul>\n<p><cite>PyFolder</cite> won\u2019t allow modification or removal of elements unless the flag <cite>allow_override</cite> is specified during instantiation:</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">pyfolder</span> <span class=\"o\">=</span> <span class=\"n\">PyFolder</span><span class=\"p\">(</span><span class=\"s2\">\"/path/to/folder\"</span><span class=\"p\">,</span> <span class=\"n\">allow_override</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">pyfolder</span><span class=\"p\">[</span><span class=\"s1\">'file.bin'</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"sa\">b</span><span class=\"s2\">\"replaced_content_bytes\"</span>\n</pre>\n<ul>\n<li><strong>Remove content:</strong></li>\n</ul>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"k\">del</span> <span class=\"n\">pyfolder</span><span class=\"p\">[</span><span class=\"s1\">'file.bin'</span><span class=\"p\">]</span>\n</pre>\n<p>Note that a folder can also be removed:</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"k\">del</span> <span class=\"n\">pyfolder</span><span class=\"p\">[</span><span class=\"s1\">'folder1'</span><span class=\"p\">]</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"k\">del</span> <span class=\"n\">pyfolder</span><span class=\"p\">[</span><span class=\"s1\">'.'</span><span class=\"p\">]</span>  <span class=\"c1\"># deletes PyFolder root folder</span>\n</pre>\n<p>By default PyFolder won\u2019t remove a folder unless its content is empty. In order to be able to remove folders without restriction, enable the flag <cite>allow_remove_folders_with_content</cite></p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">pyfolder</span> <span class=\"o\">=</span> <span class=\"n\">PyFolder</span><span class=\"p\">(</span><span class=\"s2\">\"/path/to/folder\"</span><span class=\"p\">,</span> <span class=\"n\">allow_remove_folders_with_content</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n</pre>\n<ul>\n<li><strong>Iterate over the files:</strong></li>\n</ul>\n<p>By default <cite>PyFolder</cite> allows iteration over files, including the folders:</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"k\">for</span> <span class=\"n\">file_name</span> <span class=\"ow\">in</span> <span class=\"n\">pyfolder</span><span class=\"p\">:</span>\n<span class=\"o\">&gt;&gt;&gt;</span>    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">file_name</span><span class=\"p\">)</span>\n</pre>\n<p>If it is wanted to access also the content, it can be done with the <cite>items()</cite> method:</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"k\">for</span> <span class=\"n\">file_name</span><span class=\"p\">,</span> <span class=\"n\">content</span> <span class=\"ow\">in</span> <span class=\"n\">pyfolder</span><span class=\"o\">.</span><span class=\"n\">items</span><span class=\"p\">():</span>\n<span class=\"o\">&gt;&gt;&gt;</span>    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">file_name</span><span class=\"p\">,</span> <span class=\"n\">content</span><span class=\"p\">)</span>\n</pre>\n<p>If only files are wanted, the <cite>files()</cite> method exists to serve the purpose:</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"k\">for</span> <span class=\"n\">file_name</span> <span class=\"ow\">in</span> <span class=\"n\">pyfolder</span><span class=\"o\">.</span><span class=\"n\">files</span><span class=\"p\">()</span>\n<span class=\"o\">...</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"k\">for</span> <span class=\"n\">file_name</span><span class=\"p\">,</span> <span class=\"n\">content</span> <span class=\"ow\">in</span> <span class=\"n\">pyfolder</span><span class=\"o\">.</span><span class=\"n\">files_items</span><span class=\"p\">()</span>\n</pre>\n<ul>\n<li><strong>Iterate over folders:</strong></li>\n</ul>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"k\">for</span> <span class=\"n\">folder_name</span> <span class=\"ow\">in</span> <span class=\"n\">pyfolder</span><span class=\"o\">.</span><span class=\"n\">folders</span><span class=\"p\">():</span>\n<span class=\"o\">...</span>\n</pre>\n<p>it is also possible to iterate over the folder name and its content at the same time:</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"k\">for</span> <span class=\"n\">folder_name</span><span class=\"p\">,</span> <span class=\"n\">folder_content</span> <span class=\"ow\">in</span> <span class=\"n\">pyfolder</span><span class=\"o\">.</span><span class=\"n\">folders_items</span><span class=\"p\">():</span>\n<span class=\"o\">...</span>\n</pre>\n<p>In <cite>PyFolder</cite>, each folder is a <cite>PyFolder</cite> object. It is perfectly possible to nest folders as follows:</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">pyfolder</span><span class=\"p\">[</span><span class=\"s2\">\"folder1\"</span><span class=\"p\">][</span><span class=\"s2\">\"folder2\"</span><span class=\"p\">]</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">pyfolder</span><span class=\"p\">[</span><span class=\"s2\">\"folder1/folder2\"</span><span class=\"p\">]</span>  <span class=\"c1\"># Equivalent in relative URI notation</span>\n</pre>\n<ul>\n<li><strong>Search for files:</strong></li>\n</ul>\n<p><cite>PyFolder</cite> eases the search of a file/folder by matching a name. It will return the list of relative URIs of the file-names found:</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">pyfolder</span><span class=\"o\">.</span><span class=\"n\">index</span><span class=\"p\">(</span><span class=\"s2\">\"name.bin\"</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"p\">[</span><span class=\"s1\">'path/to/name.bin'</span><span class=\"p\">,</span> <span class=\"s1\">'path2/to/name.bin'</span><span class=\"p\">]</span>\n</pre>\n</div>\n<div id=\"license\">\n<h2>LICENSE</h2>\n<p>It is released under the MIT license.</p>\n</div>\n\n          </div>"}, "last_serial": 3236830, "releases": {"0.0.1": [{"comment_text": "", "digests": {"md5": "55e919d825c05816b0772ee219d634c6", "sha256": "47ab2298a22befb382aa13b69649cfc075c2f39a61965407a589d5a67bd2d3b7"}, "downloads": -1, "filename": "pyfolder-0.0.1.tar.gz", "has_sig": false, "md5_digest": "55e919d825c05816b0772ee219d634c6", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 8035, "upload_time": "2017-10-08T18:21:39", "upload_time_iso_8601": "2017-10-08T18:21:39.160385Z", "url": "https://files.pythonhosted.org/packages/ac/06/2e2b5aabaf4f0125e196635d95e08d400f6da6fd9cb3163124c53bbacfed/pyfolder-0.0.1.tar.gz", "yanked": false}], "0.0.2": [{"comment_text": "", "digests": {"md5": "af8a8371efd574a54d64a37ac4dd283e", "sha256": "7a3c0fb1e6387939881d419fbd891036cc55cfa04cede704ff2f58120a27b002"}, "downloads": -1, "filename": "pyfolder-0.0.2.tar.gz", "has_sig": false, "md5_digest": "af8a8371efd574a54d64a37ac4dd283e", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 9517, "upload_time": "2017-10-09T16:59:07", "upload_time_iso_8601": "2017-10-09T16:59:07.122747Z", "url": "https://files.pythonhosted.org/packages/1b/0f/8e997f6a735b9e59af76eb3c292106503d40ccc2b9662e817914ef8b114a/pyfolder-0.0.2.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "af8a8371efd574a54d64a37ac4dd283e", "sha256": "7a3c0fb1e6387939881d419fbd891036cc55cfa04cede704ff2f58120a27b002"}, "downloads": -1, "filename": "pyfolder-0.0.2.tar.gz", "has_sig": false, "md5_digest": "af8a8371efd574a54d64a37ac4dd283e", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 9517, "upload_time": "2017-10-09T16:59:07", "upload_time_iso_8601": "2017-10-09T16:59:07.122747Z", "url": "https://files.pythonhosted.org/packages/1b/0f/8e997f6a735b9e59af76eb3c292106503d40ccc2b9662e817914ef8b114a/pyfolder-0.0.2.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:05:37 2020"}