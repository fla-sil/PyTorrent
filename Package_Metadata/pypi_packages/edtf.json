{"info": {"author": "Greg Turner", "author_email": "greg@interaction.net.au", "bugtrack_url": null, "classifiers": ["Development Status :: 4 - Beta", "Intended Audience :: Developers", "Intended Audience :: End Users/Desktop", "License :: OSI Approved :: MIT License", "Operating System :: MacOS :: MacOS X", "Operating System :: POSIX :: Linux", "Programming Language :: Python", "Programming Language :: Python :: 2.7", "Programming Language :: Python :: 3.6"], "description": "python-edtf\n===========\n\nAn implementation of EDTF format in Python, together with utility functions for parsing natural language date texts, and converting EDTF dates to related Python `date` objects.\n\nSee http://www.loc.gov/standards/datetime/ for the current draft specification.\n\n## To install\n\n    pip install edtf\n\n## To use\n\n    >>> from edtf import parse_edtf\n    # Parse an EDTF string to an EDTFObject\n    >>> e = parse_edtf(\"1979-08~\") # approx August 1979\n    >>> e\n    UncertainOrApproximate: '1979-08~'\n    # normalised string representation (some different EDTF strings have identical meanings)\n    >>> unicode(e)\n    u'1979-08~'\n\n    # Derive Python date objects\n    # lower and upper bounds that strictly adhere to the given range\n    >>> e.lower_strict()[:3], e.upper_strict()[:3]\n    ((1979, 8, 1), (1979, 8, 31))\n    # lower and upper bounds that are padded if there's indicated uncertainty\n    >>> e.lower_fuzzy()[:3], e.upper_fuzzy()[:3]\n    ((1979, 7, 1), (1979, 9, 30))\n\n    # Date intervals\n    >>> interval = parse_edtf(\"1979-08~/open\")\n    >>> interval\n    Level1Interval: '1979-08~/open'\n    # Intervals have lower and upper EDTF objects.\n    >>> interval.lower, interval.upper\n    (UncertainOrApproximate: '1979-08~', UncertainOrApproximate: 'open')\n    >>> interval.lower.upper_strict()[:3]\n    (1979, 8, 31)\n    >>> interval.upper.lower_strict() # 'open' is interpreted to mean 'still happening'.\n    [Today's date]\n\n    # Date collections\n    >>> coll = parse_edtf('{1667,1668, 1670..1672}')\n    >>> coll\n    MultipleDates: '{1667, 1668, 1670..1672}'\n    >>> coll.objects\n    (Date: '1667', Date: '1668', Consecutives: '1670..1672')\n\nThe object returned by `parse_edtf()` is an instance of an `edtf.parser.parser_classes.EDTFObject` subclass, depending on the type of date that was parsed. These classes are:\n\n    # Level 0\n    Date\n    DateAndTime\n    Interval\n\n    # Level 1\n    UncertainOrApproximate\n    Unspecified\n    Level1Interval\n    LongYear\n    Season\n\n    # Level 2\n    PartialUncertainOrApproximate\n    PartialUnspecified\n    OneOfASet\n    MultipleDates\n    MaskedPrecision\n    Level2Interval\n    ExponentialYear\n\nAll of these implement `upper/lower_strict/fuzzy()` methods to derive Python `date` objects.\n\nThe `*Interval` instances have `upper` and `lower` properties that are themselves `EDTFObject` instances.\n\n`OneOfASet` and `MultipleDates` instances have an `objects` property that is a list of all of the EDTF dates parsed in the set or list.\n\n## EDTF Specification Inclusions\n\nThe library includes implementation of levels 0, 1 and 2 of the EDTF spec.\n\nTest coverage includes every example given in the spec table of features.\n\n### Level 0 ISO 8601 Features\n\n* Date:\n\n      >>> parse_edtf('1979-08') # August 1979\n      Date: '1979-08'\n\n* Date and Time:\n\n      >>> parse_edtf('2004-01-01T10:10:10+05:00')\n      DateAndTime: '2004-01-01T10:10:10+05:00'\n\n* Interval (start/end):\n\n      >>> parse_edtf('1979-08-28/1979-09-25') # From August 28 to September 25 1979\n      Interval: '1979-08-28/1979-09-25'\n\n### Level 1 Extensions\n\n* Uncertain/Approximate dates:\n\n      >>> parse_edtf('1979-08-28~') # Approximately August 28th 1979\n      UncertainOrApproximate: '1979-08-28~'\n\n* Unspecified dates:\n\n      >>> parse_edtf('1979-08-uu') # An unknown day in August 1979\n      Unspecified: '1979-08-uu'\n      >>> parse_edtf('1979-uu') # Some month in 1979\n      Unspecified: '1979-uu'\n\n* Extended intervals:\n\n      >>> parse_edtf('1984-06-02?/2004-08-08~')\n      Level1Interval: '1984-06-02?/2004-08-08~'\n\n* Years exceeding four digits:\n\n      >>> parse_edtf('y-12000') # 12000 years BCE\n      LongYear: 'y-12000'\n\n* Season:\n\n      >>> parse_edtf('1979-22') # Summer 1979\n      Season: '1979-22'\n\n### Level 2 Extensions\n\n* Partial uncertain/approximate:\n\n      >>> parse_edtf('(2011)-06-04~') # year certain, month/day approximate.\n      # Note that the result text is normalized\n      PartialUncertainOrApproximate: '2011-(06-04)~'\n\n* Partial unspecified:\n\n      >>> parse_edtf('1979-uu-28') # The 28th day of an uncertain month in 1979\n      PartialUnspecified: '1979-uu-28'\n\n* One of a set:\n\n      >>> parse_edtf(\"[..1760-12-03,1762]\")\n      OneOfASet: '[..1760-12-03, 1762]'\n\n* Multiple dates:\n\n      >>> parse_edtf('{1667,1668, 1670..1672}')\n      MultipleDates: '{1667, 1668, 1670..1672}'\n\n* Masked precision:\n\n      >>> parse_edtf('197x') # A date in the 1970s.\n      MaskedPrecision: '197x'\n\n* Level 2 Extended intervals:\n\n      >>> parse_edtf('2004-06-(01)~/2004-06-(20)~')\n      Level2Interval: '2004-06-(01)~/2004-06-(20)~'\n\n* Year requiring more than 4 digits - exponential form:\n\n      >>> parse_edtf('y-17e7')\n      ExponentialYear: 'y-17e7'\n\n### Natural language representation\n\n\nThe library includes a basic English natural language parser (it's not yet smart enough to work with occasions such as 'Easter', or in other languages):\n\n    >>> from edtf import text_to_edtf\n    >>> text_to_edtf(\"circa August 1979\")\n    '1979-08~'\n\nNote that the result is a string, not an `ETDFObject`.\n\nThe parser can parse strings such as:\n\n    'January 12, 1940' => '1940-01-12'\n    '90' => '1990' #implied century\n    'January 2008' => '2008-01'\n    'the year 1800' => '1800'\n    '10/7/2008' => '2008-10-07' # in a full-specced date, assume US ordering\n\n    # uncertain/approximate\n    '1860?' => '1860?'\n    '1862 (uncertain)' => '1862?'\n    'circa Feb 1812' => '1812-02~'\n    'c.1860' => '1860~' #with or without .\n    'ca1860' => '1860~'\n    'approx 1860' => '1860~'\n\n    # masked precision\n    '1860s' => '186x' #186x has decade precision, 186u has year precision.\n    '1800s' => '18xx' # without uncertainty indicators, assume century\n\n    # masked precision + uncertainty\n    'ca. 1860s' => '186x~'\n    'circa 1840s' => '184x~'\n    'ca. 1860s?' => '186x?~'\n    'c1800s?' => '180x?~' # with uncertainty indicators, use the decade\n\n    # unspecified parts\n    'January 12' => 'uuuu-01-12'\n    'January' => 'uuuu-01'\n    '7/2008' => '2008-07'\n\n    #seasons\n    'Autumn 1872' => '1872-23'\n    'Fall 1872' => '1872-23'\n\n    # before/after\n    'earlier than 1928' => 'unknown/1928'\n    'later than 1928' => '1928/unknown'\n    'before January 1928' => 'unknown/1928-01'\n    'after about the 1920s' => '192x~/unknown'\n\n    # unspecified\n    'year in the 1860s' => '186u' #186x has decade precision, 186u has year precision.\n    ('year in the 1800s', '18xu')\n    'month in 1872' => '1872-uu'\n    'day in January 1872' => '1872-01-uu'\n    'day in 1872' => '1872-uu-uu'\n\n    #centuries\n    '1st century' => '00xx'\n    '10c' => '09xx'\n    '19th century?' => '18xx?'\n\n    # just showing off now...\n    'a day in about Spring 1849?' => '1849-21-uu?~'\n\n    # simple ranges, which aren't as accurate as they could be. The parser is\n    limited to only picking the first year range it finds.\n    '1851-1852' => '1851/1852'\n    '1851-1852; printed 1853-1854' => '1851/1852'\n    '1851-52' => '1851/1852'\n    '1856-ca. 1865' => '1856/1865~'\n    '1860s-1870s' => '186x/187x'\n    '1920s -early 1930s' => '192x/193x'\n    '1938, printed 1940s-1950s' => '1938'\n\n\nGenerating natural text from an EDTF representation is a future goal.\n\n### What assumptions does the natural text parser make when interpreting an ambiguous date?\n\n* \"1800s\" is ambiguously a century or decade. If the given date is either uncertain or approximate, the decade interpretation is used. If the date is certain and precise, the century interpretation is used.\n\n* If the century isn't specified (`EDTF(natural_text=\"the '70s\")`), we imply the century to be \"19\" if the year is greater than the current year, otherwise we imply the century to be the current century.\n\n* US-ordered dates (mm/dd/yyyy) are assumed by default in natural language.  To change this, set `DAY_FIRST` to True in settings.\n\n* If a natural language groups dates with a '/', it's interpreted as \"or\" rather than \"and\". The resulting EDTF text is a list bracketed by `[]` (\"one of these dates\") rather than `{}` (all of these dates).\n\n\n## Converting to and from Python dates\n\n\nSince EDTF dates are often regions, and often imprecise, we need to use a few different Python dates, depending on the circumstance. Generally, Python dates are used for sorting and filtering, and are not displayed directly to users.\n\n\n### `struct_time` date representation\n\nBecause Python's `datetime` module does not support dates out side the range 1 AD to 9999 AD we return dates as `time.struct_time` objects by default instead of the `datetime.date` or `datetime.datetime` objects you might expect.\n\nThe `struct_time` representation is more difficult to work with, but can be sorted as-is which is the primary use-case, and can be converted relatively easily to `date` or `datetime` objects (provided the year is within 1 to 9999 AD) or to date objects in more flexible libraries like [astropy.time](http://docs.astropy.org/en/stable/time/index.html) for years outside these bounds.\n\nIf you are sure you are working with dates within the range supported by Python's `datetime` module, you can get these more convenient objects using the `edtf.struct_time_to_date` and `edtf.struct_time_to_datetime` functions.\n\nNOTE: This library previously did return `date` and `datetime` objects from methods by default before we switched to `struct_time`. See ticket https://github.com/ixc/python-edtf/issues/26.\n\n### `lower_strict` and `upper_strict`\n\nThese dates indicate the earliest and latest dates that are __strictly__ in the date range, ignoring uncertainty or approximation. One way to think about this is 'if you had to pick a single date to sort by, what would it be?'.\n\nIn an ascending sort (most recent last), sort by `lower_strict` to get a natural sort order. In a descending sort (most recent first), sort by `upper_strict`:\n\n    >>> e = parse_edtf('1912-04~')\n\n    >>> e.lower_strict()  # Returns struct_time\n    >>> time.struct_time(tm_year=1912, tm_mon=4, tm_mday=1, tm_hour=0, tm_min=0, tm_sec=0, tm_wday=0, tm_yday=0, tm_isdst=-1)\n\n    >>> e.lower_strict()[:3]  # Show only interesting parts of struct_time\n    (1912, 4, 01)\n\n    >>> from edtf import struct_time_to_date\n    >>> struct_time_to_date(e.lower_strict())  # Convert to date\n    datetime.date(1912, 4, 01)\n\n    >>> e.upper_strict()[:3]\n    (1912, 4, 30)\n\n    >>> struct_time_to_date(e.upper_strict())\n    datetime.date(1912, 4, 30)\n\n### `lower_fuzzy` and `upper_fuzzy`\n-----------------------------------\n\nThese dates indicate the earliest and latest dates that are __possible__ in the date range, for a fairly arbitrary definition of 'possibly'.\n\nThese values are useful for filtering results - i.e. testing which EDTF dates might conceivably fall into, or overlap, a desired date range.\n\nThe fuzzy dates are derived from the strict dates, plus or minus a level of padding that depends on how precise the date specfication is. For the case of approximate or uncertain dates, we (arbitrarily) pad the ostensible range by 100% of the uncertain timescale, or by a 12 weeks in the case of seasons. That is, if a date is approximate at the month scale, it is padded by a month. If it is approximate at the year scale, it is padded by a year:\n\n    >>> e = parse_edtf('1912-04~')\n    >>> e.lower_fuzzy()[:3]  # padding is 100% of a month\n    (1912, 3, 1)\n    >>> e.upper_fuzzy()[:3]\n    (1912, 5, 30)\n\n    >>> e = parse_edtf('1912~')\n    >>> e.lower_fuzzy()[:3]  # padding is 100% of a year\n    (1911, 1, 1)\n    >>> e.upper_fuzzy()[:3]\n    (1913, 12, 31)\n\nOne can interpret uncertain or approximate dates as 'plus or minus a [level of precision]'.\n\nIf a date is both uncertain __and__ approximate, the padding is applied twice, i.e. it gets 100% * 2 padding, or 'plus or minus two [levels of precision]'.\n\n### Seasons\n\nSeasons are interpreted as Northern Hemisphere by default. To change this, override the month mapping in `appsettings.py`.\n\n### Comparisons\n\nTwo EDTF dates are considered equal if their unicode() representations are the same. An EDTF date is considered greater than another if its `lower_strict` value is later.\n\n## Django ORM field\n\nThe `edtf.fields.EDTFField` implements a simple Django field that stores an EDTF object in the database.\n\nTo store a natural language value on your model, define another field, and set the `natural_text_field` parameter of your `EDTFField`.\n\nWhen your model is saved, the `natural_text_field` value will be parsed to set the `date_edtf` value, and the underlying EDTF object will set the `_earliest` and `_latest` fields on the model to a float value representing the Julian Date.\n\n\n**WARNING**: The conversion to and from Julian Date numerical values can be inaccurate, especially for ancient dates back to thousands of years BC. Ideally Julian Date values should be used for range and ordering operations only where complete accuracy is not required. They should **not** be used for definitive storage or for display after roundtrip conversions.\n\nExample usage:\n\n    from django.db import models\n    from edtf.fields import EDTFField\n\n    class MyModel(models.Model):\n         date_display = models.CharField(\n            \"Date of creation (display)\",\n            blank=True,\n            max_length=255,\n         )\n         date_edtf = EDTFField(\n             \"Date of creation (EDTF)\",\n             natural_text_field='date_display',\n             lower_fuzzy_field='date_earliest',\n             upper_fuzzy_field='date_latest',\n             lower_strict_field='date_sort_ascending',\n             upper_strict_field='date_sort_descending',\n             blank=True,\n             null=True,\n         )\n         # use for filtering\n         date_earliest = models.FloatField(blank=True, null=True)\n         date_latest = models.FloatField(blank=True, null=True)\n         # use for sorting\n         date_sort_ascending = models.FloatField(blank=True, null=True)\n         date_sort_descending = models.FloatField(blank=True, null=True)\n\n\nSince the `EDTFField` and the `_earliest` and `_latest` field values are set automatically, you may want to make them readonly, or not visible in your model admin.\n\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/ixc/python-edtf", "keywords": "edtf", "license": "MIT", "maintainer": "", "maintainer_email": "", "name": "edtf", "package_url": "https://pypi.org/project/edtf/", "platform": "", "project_url": "https://pypi.org/project/edtf/", "project_urls": {"Homepage": "https://github.com/ixc/python-edtf"}, "release_url": "https://pypi.org/project/edtf/4.0.1/", "requires_dist": ["python-dateutil", "pyparsing", "six", "django; extra == 'test'", "nose; extra == 'test'", "tox; extra == 'test'"], "requires_python": "", "summary": "Python implementation of Library of Congress EDTF (Extended Date Time Format) specification", "version": "4.0.1", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>python-edtf</h1>\n<p>An implementation of EDTF format in Python, together with utility functions for parsing natural language date texts, and converting EDTF dates to related Python <code>date</code> objects.</p>\n<p>See <a href=\"http://www.loc.gov/standards/datetime/\" rel=\"nofollow\">http://www.loc.gov/standards/datetime/</a> for the current draft specification.</p>\n<h2>To install</h2>\n<pre><code>pip install edtf\n</code></pre>\n<h2>To use</h2>\n<pre><code>&gt;&gt;&gt; from edtf import parse_edtf\n# Parse an EDTF string to an EDTFObject\n&gt;&gt;&gt; e = parse_edtf(\"1979-08~\") # approx August 1979\n&gt;&gt;&gt; e\nUncertainOrApproximate: '1979-08~'\n# normalised string representation (some different EDTF strings have identical meanings)\n&gt;&gt;&gt; unicode(e)\nu'1979-08~'\n\n# Derive Python date objects\n# lower and upper bounds that strictly adhere to the given range\n&gt;&gt;&gt; e.lower_strict()[:3], e.upper_strict()[:3]\n((1979, 8, 1), (1979, 8, 31))\n# lower and upper bounds that are padded if there's indicated uncertainty\n&gt;&gt;&gt; e.lower_fuzzy()[:3], e.upper_fuzzy()[:3]\n((1979, 7, 1), (1979, 9, 30))\n\n# Date intervals\n&gt;&gt;&gt; interval = parse_edtf(\"1979-08~/open\")\n&gt;&gt;&gt; interval\nLevel1Interval: '1979-08~/open'\n# Intervals have lower and upper EDTF objects.\n&gt;&gt;&gt; interval.lower, interval.upper\n(UncertainOrApproximate: '1979-08~', UncertainOrApproximate: 'open')\n&gt;&gt;&gt; interval.lower.upper_strict()[:3]\n(1979, 8, 31)\n&gt;&gt;&gt; interval.upper.lower_strict() # 'open' is interpreted to mean 'still happening'.\n[Today's date]\n\n# Date collections\n&gt;&gt;&gt; coll = parse_edtf('{1667,1668, 1670..1672}')\n&gt;&gt;&gt; coll\nMultipleDates: '{1667, 1668, 1670..1672}'\n&gt;&gt;&gt; coll.objects\n(Date: '1667', Date: '1668', Consecutives: '1670..1672')\n</code></pre>\n<p>The object returned by <code>parse_edtf()</code> is an instance of an <code>edtf.parser.parser_classes.EDTFObject</code> subclass, depending on the type of date that was parsed. These classes are:</p>\n<pre><code># Level 0\nDate\nDateAndTime\nInterval\n\n# Level 1\nUncertainOrApproximate\nUnspecified\nLevel1Interval\nLongYear\nSeason\n\n# Level 2\nPartialUncertainOrApproximate\nPartialUnspecified\nOneOfASet\nMultipleDates\nMaskedPrecision\nLevel2Interval\nExponentialYear\n</code></pre>\n<p>All of these implement <code>upper/lower_strict/fuzzy()</code> methods to derive Python <code>date</code> objects.</p>\n<p>The <code>*Interval</code> instances have <code>upper</code> and <code>lower</code> properties that are themselves <code>EDTFObject</code> instances.</p>\n<p><code>OneOfASet</code> and <code>MultipleDates</code> instances have an <code>objects</code> property that is a list of all of the EDTF dates parsed in the set or list.</p>\n<h2>EDTF Specification Inclusions</h2>\n<p>The library includes implementation of levels 0, 1 and 2 of the EDTF spec.</p>\n<p>Test coverage includes every example given in the spec table of features.</p>\n<h3>Level 0 ISO 8601 Features</h3>\n<ul>\n<li>\n<p>Date:</p>\n<pre><code>&gt;&gt;&gt; parse_edtf('1979-08') # August 1979\nDate: '1979-08'\n</code></pre>\n</li>\n<li>\n<p>Date and Time:</p>\n<pre><code>&gt;&gt;&gt; parse_edtf('2004-01-01T10:10:10+05:00')\nDateAndTime: '2004-01-01T10:10:10+05:00'\n</code></pre>\n</li>\n<li>\n<p>Interval (start/end):</p>\n<pre><code>&gt;&gt;&gt; parse_edtf('1979-08-28/1979-09-25') # From August 28 to September 25 1979\nInterval: '1979-08-28/1979-09-25'\n</code></pre>\n</li>\n</ul>\n<h3>Level 1 Extensions</h3>\n<ul>\n<li>\n<p>Uncertain/Approximate dates:</p>\n<pre><code>&gt;&gt;&gt; parse_edtf('1979-08-28~') # Approximately August 28th 1979\nUncertainOrApproximate: '1979-08-28~'\n</code></pre>\n</li>\n<li>\n<p>Unspecified dates:</p>\n<pre><code>&gt;&gt;&gt; parse_edtf('1979-08-uu') # An unknown day in August 1979\nUnspecified: '1979-08-uu'\n&gt;&gt;&gt; parse_edtf('1979-uu') # Some month in 1979\nUnspecified: '1979-uu'\n</code></pre>\n</li>\n<li>\n<p>Extended intervals:</p>\n<pre><code>&gt;&gt;&gt; parse_edtf('1984-06-02?/2004-08-08~')\nLevel1Interval: '1984-06-02?/2004-08-08~'\n</code></pre>\n</li>\n<li>\n<p>Years exceeding four digits:</p>\n<pre><code>&gt;&gt;&gt; parse_edtf('y-12000') # 12000 years BCE\nLongYear: 'y-12000'\n</code></pre>\n</li>\n<li>\n<p>Season:</p>\n<pre><code>&gt;&gt;&gt; parse_edtf('1979-22') # Summer 1979\nSeason: '1979-22'\n</code></pre>\n</li>\n</ul>\n<h3>Level 2 Extensions</h3>\n<ul>\n<li>\n<p>Partial uncertain/approximate:</p>\n<pre><code>&gt;&gt;&gt; parse_edtf('(2011)-06-04~') # year certain, month/day approximate.\n# Note that the result text is normalized\nPartialUncertainOrApproximate: '2011-(06-04)~'\n</code></pre>\n</li>\n<li>\n<p>Partial unspecified:</p>\n<pre><code>&gt;&gt;&gt; parse_edtf('1979-uu-28') # The 28th day of an uncertain month in 1979\nPartialUnspecified: '1979-uu-28'\n</code></pre>\n</li>\n<li>\n<p>One of a set:</p>\n<pre><code>&gt;&gt;&gt; parse_edtf(\"[..1760-12-03,1762]\")\nOneOfASet: '[..1760-12-03, 1762]'\n</code></pre>\n</li>\n<li>\n<p>Multiple dates:</p>\n<pre><code>&gt;&gt;&gt; parse_edtf('{1667,1668, 1670..1672}')\nMultipleDates: '{1667, 1668, 1670..1672}'\n</code></pre>\n</li>\n<li>\n<p>Masked precision:</p>\n<pre><code>&gt;&gt;&gt; parse_edtf('197x') # A date in the 1970s.\nMaskedPrecision: '197x'\n</code></pre>\n</li>\n<li>\n<p>Level 2 Extended intervals:</p>\n<pre><code>&gt;&gt;&gt; parse_edtf('2004-06-(01)~/2004-06-(20)~')\nLevel2Interval: '2004-06-(01)~/2004-06-(20)~'\n</code></pre>\n</li>\n<li>\n<p>Year requiring more than 4 digits - exponential form:</p>\n<pre><code>&gt;&gt;&gt; parse_edtf('y-17e7')\nExponentialYear: 'y-17e7'\n</code></pre>\n</li>\n</ul>\n<h3>Natural language representation</h3>\n<p>The library includes a basic English natural language parser (it's not yet smart enough to work with occasions such as 'Easter', or in other languages):</p>\n<pre><code>&gt;&gt;&gt; from edtf import text_to_edtf\n&gt;&gt;&gt; text_to_edtf(\"circa August 1979\")\n'1979-08~'\n</code></pre>\n<p>Note that the result is a string, not an <code>ETDFObject</code>.</p>\n<p>The parser can parse strings such as:</p>\n<pre><code>'January 12, 1940' =&gt; '1940-01-12'\n'90' =&gt; '1990' #implied century\n'January 2008' =&gt; '2008-01'\n'the year 1800' =&gt; '1800'\n'10/7/2008' =&gt; '2008-10-07' # in a full-specced date, assume US ordering\n\n# uncertain/approximate\n'1860?' =&gt; '1860?'\n'1862 (uncertain)' =&gt; '1862?'\n'circa Feb 1812' =&gt; '1812-02~'\n'c.1860' =&gt; '1860~' #with or without .\n'ca1860' =&gt; '1860~'\n'approx 1860' =&gt; '1860~'\n\n# masked precision\n'1860s' =&gt; '186x' #186x has decade precision, 186u has year precision.\n'1800s' =&gt; '18xx' # without uncertainty indicators, assume century\n\n# masked precision + uncertainty\n'ca. 1860s' =&gt; '186x~'\n'circa 1840s' =&gt; '184x~'\n'ca. 1860s?' =&gt; '186x?~'\n'c1800s?' =&gt; '180x?~' # with uncertainty indicators, use the decade\n\n# unspecified parts\n'January 12' =&gt; 'uuuu-01-12'\n'January' =&gt; 'uuuu-01'\n'7/2008' =&gt; '2008-07'\n\n#seasons\n'Autumn 1872' =&gt; '1872-23'\n'Fall 1872' =&gt; '1872-23'\n\n# before/after\n'earlier than 1928' =&gt; 'unknown/1928'\n'later than 1928' =&gt; '1928/unknown'\n'before January 1928' =&gt; 'unknown/1928-01'\n'after about the 1920s' =&gt; '192x~/unknown'\n\n# unspecified\n'year in the 1860s' =&gt; '186u' #186x has decade precision, 186u has year precision.\n('year in the 1800s', '18xu')\n'month in 1872' =&gt; '1872-uu'\n'day in January 1872' =&gt; '1872-01-uu'\n'day in 1872' =&gt; '1872-uu-uu'\n\n#centuries\n'1st century' =&gt; '00xx'\n'10c' =&gt; '09xx'\n'19th century?' =&gt; '18xx?'\n\n# just showing off now...\n'a day in about Spring 1849?' =&gt; '1849-21-uu?~'\n\n# simple ranges, which aren't as accurate as they could be. The parser is\nlimited to only picking the first year range it finds.\n'1851-1852' =&gt; '1851/1852'\n'1851-1852; printed 1853-1854' =&gt; '1851/1852'\n'1851-52' =&gt; '1851/1852'\n'1856-ca. 1865' =&gt; '1856/1865~'\n'1860s-1870s' =&gt; '186x/187x'\n'1920s -early 1930s' =&gt; '192x/193x'\n'1938, printed 1940s-1950s' =&gt; '1938'\n</code></pre>\n<p>Generating natural text from an EDTF representation is a future goal.</p>\n<h3>What assumptions does the natural text parser make when interpreting an ambiguous date?</h3>\n<ul>\n<li>\n<p>\"1800s\" is ambiguously a century or decade. If the given date is either uncertain or approximate, the decade interpretation is used. If the date is certain and precise, the century interpretation is used.</p>\n</li>\n<li>\n<p>If the century isn't specified (<code>EDTF(natural_text=\"the '70s\")</code>), we imply the century to be \"19\" if the year is greater than the current year, otherwise we imply the century to be the current century.</p>\n</li>\n<li>\n<p>US-ordered dates (mm/dd/yyyy) are assumed by default in natural language.  To change this, set <code>DAY_FIRST</code> to True in settings.</p>\n</li>\n<li>\n<p>If a natural language groups dates with a '/', it's interpreted as \"or\" rather than \"and\". The resulting EDTF text is a list bracketed by <code>[]</code> (\"one of these dates\") rather than <code>{}</code> (all of these dates).</p>\n</li>\n</ul>\n<h2>Converting to and from Python dates</h2>\n<p>Since EDTF dates are often regions, and often imprecise, we need to use a few different Python dates, depending on the circumstance. Generally, Python dates are used for sorting and filtering, and are not displayed directly to users.</p>\n<h3><code>struct_time</code> date representation</h3>\n<p>Because Python's <code>datetime</code> module does not support dates out side the range 1 AD to 9999 AD we return dates as <code>time.struct_time</code> objects by default instead of the <code>datetime.date</code> or <code>datetime.datetime</code> objects you might expect.</p>\n<p>The <code>struct_time</code> representation is more difficult to work with, but can be sorted as-is which is the primary use-case, and can be converted relatively easily to <code>date</code> or <code>datetime</code> objects (provided the year is within 1 to 9999 AD) or to date objects in more flexible libraries like <a href=\"http://docs.astropy.org/en/stable/time/index.html\" rel=\"nofollow\">astropy.time</a> for years outside these bounds.</p>\n<p>If you are sure you are working with dates within the range supported by Python's <code>datetime</code> module, you can get these more convenient objects using the <code>edtf.struct_time_to_date</code> and <code>edtf.struct_time_to_datetime</code> functions.</p>\n<p>NOTE: This library previously did return <code>date</code> and <code>datetime</code> objects from methods by default before we switched to <code>struct_time</code>. See ticket <a href=\"https://github.com/ixc/python-edtf/issues/26\" rel=\"nofollow\">https://github.com/ixc/python-edtf/issues/26</a>.</p>\n<h3><code>lower_strict</code> and <code>upper_strict</code></h3>\n<p>These dates indicate the earliest and latest dates that are <strong>strictly</strong> in the date range, ignoring uncertainty or approximation. One way to think about this is 'if you had to pick a single date to sort by, what would it be?'.</p>\n<p>In an ascending sort (most recent last), sort by <code>lower_strict</code> to get a natural sort order. In a descending sort (most recent first), sort by <code>upper_strict</code>:</p>\n<pre><code>&gt;&gt;&gt; e = parse_edtf('1912-04~')\n\n&gt;&gt;&gt; e.lower_strict()  # Returns struct_time\n&gt;&gt;&gt; time.struct_time(tm_year=1912, tm_mon=4, tm_mday=1, tm_hour=0, tm_min=0, tm_sec=0, tm_wday=0, tm_yday=0, tm_isdst=-1)\n\n&gt;&gt;&gt; e.lower_strict()[:3]  # Show only interesting parts of struct_time\n(1912, 4, 01)\n\n&gt;&gt;&gt; from edtf import struct_time_to_date\n&gt;&gt;&gt; struct_time_to_date(e.lower_strict())  # Convert to date\ndatetime.date(1912, 4, 01)\n\n&gt;&gt;&gt; e.upper_strict()[:3]\n(1912, 4, 30)\n\n&gt;&gt;&gt; struct_time_to_date(e.upper_strict())\ndatetime.date(1912, 4, 30)\n</code></pre>\n<h3><code>lower_fuzzy</code> and <code>upper_fuzzy</code></h3>\n<hr>\n<p>These dates indicate the earliest and latest dates that are <strong>possible</strong> in the date range, for a fairly arbitrary definition of 'possibly'.</p>\n<p>These values are useful for filtering results - i.e. testing which EDTF dates might conceivably fall into, or overlap, a desired date range.</p>\n<p>The fuzzy dates are derived from the strict dates, plus or minus a level of padding that depends on how precise the date specfication is. For the case of approximate or uncertain dates, we (arbitrarily) pad the ostensible range by 100% of the uncertain timescale, or by a 12 weeks in the case of seasons. That is, if a date is approximate at the month scale, it is padded by a month. If it is approximate at the year scale, it is padded by a year:</p>\n<pre><code>&gt;&gt;&gt; e = parse_edtf('1912-04~')\n&gt;&gt;&gt; e.lower_fuzzy()[:3]  # padding is 100% of a month\n(1912, 3, 1)\n&gt;&gt;&gt; e.upper_fuzzy()[:3]\n(1912, 5, 30)\n\n&gt;&gt;&gt; e = parse_edtf('1912~')\n&gt;&gt;&gt; e.lower_fuzzy()[:3]  # padding is 100% of a year\n(1911, 1, 1)\n&gt;&gt;&gt; e.upper_fuzzy()[:3]\n(1913, 12, 31)\n</code></pre>\n<p>One can interpret uncertain or approximate dates as 'plus or minus a [level of precision]'.</p>\n<p>If a date is both uncertain <strong>and</strong> approximate, the padding is applied twice, i.e. it gets 100% * 2 padding, or 'plus or minus two [levels of precision]'.</p>\n<h3>Seasons</h3>\n<p>Seasons are interpreted as Northern Hemisphere by default. To change this, override the month mapping in <code>appsettings.py</code>.</p>\n<h3>Comparisons</h3>\n<p>Two EDTF dates are considered equal if their unicode() representations are the same. An EDTF date is considered greater than another if its <code>lower_strict</code> value is later.</p>\n<h2>Django ORM field</h2>\n<p>The <code>edtf.fields.EDTFField</code> implements a simple Django field that stores an EDTF object in the database.</p>\n<p>To store a natural language value on your model, define another field, and set the <code>natural_text_field</code> parameter of your <code>EDTFField</code>.</p>\n<p>When your model is saved, the <code>natural_text_field</code> value will be parsed to set the <code>date_edtf</code> value, and the underlying EDTF object will set the <code>_earliest</code> and <code>_latest</code> fields on the model to a float value representing the Julian Date.</p>\n<p><strong>WARNING</strong>: The conversion to and from Julian Date numerical values can be inaccurate, especially for ancient dates back to thousands of years BC. Ideally Julian Date values should be used for range and ordering operations only where complete accuracy is not required. They should <strong>not</strong> be used for definitive storage or for display after roundtrip conversions.</p>\n<p>Example usage:</p>\n<pre><code>from django.db import models\nfrom edtf.fields import EDTFField\n\nclass MyModel(models.Model):\n     date_display = models.CharField(\n        \"Date of creation (display)\",\n        blank=True,\n        max_length=255,\n     )\n     date_edtf = EDTFField(\n         \"Date of creation (EDTF)\",\n         natural_text_field='date_display',\n         lower_fuzzy_field='date_earliest',\n         upper_fuzzy_field='date_latest',\n         lower_strict_field='date_sort_ascending',\n         upper_strict_field='date_sort_descending',\n         blank=True,\n         null=True,\n     )\n     # use for filtering\n     date_earliest = models.FloatField(blank=True, null=True)\n     date_latest = models.FloatField(blank=True, null=True)\n     # use for sorting\n     date_sort_ascending = models.FloatField(blank=True, null=True)\n     date_sort_descending = models.FloatField(blank=True, null=True)\n</code></pre>\n<p>Since the <code>EDTFField</code> and the <code>_earliest</code> and <code>_latest</code> field values are set automatically, you may want to make them readonly, or not visible in your model admin.</p>\n\n          </div>"}, "last_serial": 3930588, "releases": {"0.9.1": [{"comment_text": "", "digests": {"md5": "bab45742dc6fa9957353272741bfcf68", "sha256": "c90775a68831a465838c974e02a15f89636604cfcea0ec2d6277358b8e4dfe7a"}, "downloads": -1, "filename": "edtf-0.9.1.tar.gz", "has_sig": false, "md5_digest": "bab45742dc6fa9957353272741bfcf68", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 12442, "upload_time": "2015-06-09T08:08:01", "upload_time_iso_8601": "2015-06-09T08:08:01.064078Z", "url": "https://files.pythonhosted.org/packages/89/e9/8e81456bce9a9f48951a80dd879ade4607362ce152c2d932bd2752495709/edtf-0.9.1.tar.gz", "yanked": false}], "0.9.3": [{"comment_text": "", "digests": {"md5": "74055ac361506212e3a23f96a91b697e", "sha256": "7fb52e936b5e68861a2258ad274dc927af355369ec3e9c3dcf2dd77353c31e57"}, "downloads": -1, "filename": "edtf-0.9.3.tar.gz", "has_sig": false, "md5_digest": "74055ac361506212e3a23f96a91b697e", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 14822, "upload_time": "2016-12-15T00:23:04", "upload_time_iso_8601": "2016-12-15T00:23:04.021732Z", "url": "https://files.pythonhosted.org/packages/a3/4f/a268fe2dc504de03fea65aacee1ea0e821140cdeacb6da35e3f071b46b63/edtf-0.9.3.tar.gz", "yanked": false}], "2.0": [{"comment_text": "", "digests": {"md5": "d59cf8a7e4dac939f8d822bb68af392d", "sha256": "c07eb7aedf4bfcb3a39dd03a015dcffd05486464ccff2f2372be4f1bedf4b2e4"}, "downloads": -1, "filename": "edtf-2.0-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "d59cf8a7e4dac939f8d822bb68af392d", "packagetype": "bdist_wheel", "python_version": "2.7", "requires_python": null, "size": 29287, "upload_time": "2017-05-22T06:52:28", "upload_time_iso_8601": "2017-05-22T06:52:28.256906Z", "url": "https://files.pythonhosted.org/packages/44/85/acaf57ad987b66985eea034a4f7bbf437c754add008cd6e8956762eab6e0/edtf-2.0-py2.py3-none-any.whl", "yanked": false}], "2.0.1": [{"comment_text": "", "digests": {"md5": "84972aa334beccb5d13d00f1c387f290", "sha256": "cee86dfc7e431d686b1c532096d52db6c994fb05b1f56dd4ababfcb74c1c9f8f"}, "downloads": -1, "filename": "edtf-2.0.1-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "84972aa334beccb5d13d00f1c387f290", "packagetype": "bdist_wheel", "python_version": "2.7", "requires_python": null, "size": 29325, "upload_time": "2017-05-22T09:46:09", "upload_time_iso_8601": "2017-05-22T09:46:09.259861Z", "url": "https://files.pythonhosted.org/packages/5c/c7/4a04254222c18758f2ebdea65ff76978efeabc7ba000e04b864eac360f67/edtf-2.0.1-py2.py3-none-any.whl", "yanked": false}], "2.5": [{"comment_text": "", "digests": {"md5": "a2e04d8c861d7fec7a30905dc11fad98", "sha256": "baaa2855edab7f2ea93fd19593c9b7b16ef537b7a09d9f3726ef248cff9641cc"}, "downloads": -1, "filename": "edtf-2.5-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "a2e04d8c861d7fec7a30905dc11fad98", "packagetype": "bdist_wheel", "python_version": "2.7", "requires_python": null, "size": 29629, "upload_time": "2017-06-08T00:29:06", "upload_time_iso_8601": "2017-06-08T00:29:06.910597Z", "url": "https://files.pythonhosted.org/packages/26/24/64c240faca1e57b605cf7217e0ee28094d94d8e0971fbc6e76eef011360b/edtf-2.5-py2.py3-none-any.whl", "yanked": false}], "2.6.0": [{"comment_text": "", "digests": {"md5": "5bf30ef193ba043ca80f95b426e0694e", "sha256": "51578967cd817f51d722729995194677251101d6c0663d33a1bcd8dcd87bbea1"}, "downloads": -1, "filename": "edtf-2.6.0.tar.gz", "has_sig": false, "md5_digest": "5bf30ef193ba043ca80f95b426e0694e", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 25110, "upload_time": "2017-08-06T23:36:54", "upload_time_iso_8601": "2017-08-06T23:36:54.212316Z", "url": "https://files.pythonhosted.org/packages/a4/7a/fc5c78075453e6ce104e8ca41530f640b360d28674f41f8d0ca904951fc1/edtf-2.6.0.tar.gz", "yanked": false}], "2.7.0": [{"comment_text": "", "digests": {"md5": "11ed56d8cfdd2bedc44afd09768ced6e", "sha256": "60c99ff22f4db2922b0b6efb9925685a545d349af5c3d7507d7a9f8c4ab23031"}, "downloads": -1, "filename": "edtf-2.7.0.tar.gz", "has_sig": false, "md5_digest": "11ed56d8cfdd2bedc44afd09768ced6e", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 25342, "upload_time": "2018-01-09T02:43:56", "upload_time_iso_8601": "2018-01-09T02:43:56.979701Z", "url": "https://files.pythonhosted.org/packages/02/33/69207c4e393c01866f1e6b839dbdd73a966521273fd785697edb4dc4a5fa/edtf-2.7.0.tar.gz", "yanked": false}], "3.0.0": [{"comment_text": "", "digests": {"md5": "da6e54f0f12828015cd31ef93082482d", "sha256": "76fbcd2385d16acfbd7bbff6256ec44b4ab0b000e7cd4627268eb63b232f821b"}, "downloads": -1, "filename": "edtf-3.0.0-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "da6e54f0f12828015cd31ef93082482d", "packagetype": "bdist_wheel", "python_version": "2.7", "requires_python": null, "size": 30459, "upload_time": "2018-02-13T04:54:15", "upload_time_iso_8601": "2018-02-13T04:54:15.934028Z", "url": "https://files.pythonhosted.org/packages/c0/59/9c57965fb784114bd67d718a9a9ed6a3baf78e76d3770daa44658ba29d64/edtf-3.0.0-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "004b2979337f7ef36e68783d00c062e9", "sha256": "ec3292963b449d6df7921783bb81921e64bac96cdfb581182c228895423e2ae3"}, "downloads": -1, "filename": "edtf-3.0.0.tar.gz", "has_sig": false, "md5_digest": "004b2979337f7ef36e68783d00c062e9", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 29283, "upload_time": "2018-02-13T04:54:12", "upload_time_iso_8601": "2018-02-13T04:54:12.436353Z", "url": "https://files.pythonhosted.org/packages/63/50/fd4c91d96648f13ee4d43f5382ae248d230884b39dd0bf53a2fbf15f1011/edtf-3.0.0.tar.gz", "yanked": false}], "4.0.0": [{"comment_text": "", "digests": {"md5": "5efb619ad8e6bf57bd5c35096cf0c027", "sha256": "0ae3c431b6f40302d7626ac8a461624ac1b1a78762cfbe1065bde8462b8ba279"}, "downloads": -1, "filename": "edtf-4.0.0-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "5efb619ad8e6bf57bd5c35096cf0c027", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 33078, "upload_time": "2018-06-05T02:16:47", "upload_time_iso_8601": "2018-06-05T02:16:47.027520Z", "url": "https://files.pythonhosted.org/packages/1f/83/b0ceeb6a9ecdce9aa9ed3f73eca8c2d573c91a4bfc3073b1445b9e185d8f/edtf-4.0.0-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "8eb8a6890873cbc3979c80fa067b02a2", "sha256": "fac8f275361ee980c96921216406546fb9ca109a85dc0fd07bae89d8132a895e"}, "downloads": -1, "filename": "edtf-4.0.0.tar.gz", "has_sig": false, "md5_digest": "8eb8a6890873cbc3979c80fa067b02a2", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 37822, "upload_time": "2018-06-05T02:16:49", "upload_time_iso_8601": "2018-06-05T02:16:49.684514Z", "url": "https://files.pythonhosted.org/packages/9b/e6/e4e2262ec796576acd3c3a128d05f4b1c5e79a341b3a3532993eac5ff025/edtf-4.0.0.tar.gz", "yanked": false}], "4.0.1": [{"comment_text": "", "digests": {"md5": "5c5ca1f884bcb6ba2a75e66eedbb9c0c", "sha256": "744135d392774c636425d8ed6dc9182093f2c0174ca9f3f7968588b0168d826c"}, "downloads": -1, "filename": "edtf-4.0.1-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "5c5ca1f884bcb6ba2a75e66eedbb9c0c", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 32968, "upload_time": "2018-06-05T02:46:56", "upload_time_iso_8601": "2018-06-05T02:46:56.335868Z", "url": "https://files.pythonhosted.org/packages/32/9d/96936cfaf90fc13961cdc7dc8d637f8fd93d95b2eb69f24d6600f325a1c9/edtf-4.0.1-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "7d1ca11ae8eea6ca7fd4b4c7fab76b52", "sha256": "4f4a7425a4a32862f5870de4facecc9050f01a57e19394eb9739fb970cab810e"}, "downloads": -1, "filename": "edtf-4.0.1.tar.gz", "has_sig": false, "md5_digest": "7d1ca11ae8eea6ca7fd4b4c7fab76b52", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 37325, "upload_time": "2018-06-05T02:46:58", "upload_time_iso_8601": "2018-06-05T02:46:58.600351Z", "url": "https://files.pythonhosted.org/packages/a9/5f/1e2e40520f60ac4d0faed04aa2f4fd1fbf82fbb779a1a26188668c611762/edtf-4.0.1.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "5c5ca1f884bcb6ba2a75e66eedbb9c0c", "sha256": "744135d392774c636425d8ed6dc9182093f2c0174ca9f3f7968588b0168d826c"}, "downloads": -1, "filename": "edtf-4.0.1-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "5c5ca1f884bcb6ba2a75e66eedbb9c0c", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 32968, "upload_time": "2018-06-05T02:46:56", "upload_time_iso_8601": "2018-06-05T02:46:56.335868Z", "url": "https://files.pythonhosted.org/packages/32/9d/96936cfaf90fc13961cdc7dc8d637f8fd93d95b2eb69f24d6600f325a1c9/edtf-4.0.1-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "7d1ca11ae8eea6ca7fd4b4c7fab76b52", "sha256": "4f4a7425a4a32862f5870de4facecc9050f01a57e19394eb9739fb970cab810e"}, "downloads": -1, "filename": "edtf-4.0.1.tar.gz", "has_sig": false, "md5_digest": "7d1ca11ae8eea6ca7fd4b4c7fab76b52", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 37325, "upload_time": "2018-06-05T02:46:58", "upload_time_iso_8601": "2018-06-05T02:46:58.600351Z", "url": "https://files.pythonhosted.org/packages/a9/5f/1e2e40520f60ac4d0faed04aa2f4fd1fbf82fbb779a1a26188668c611762/edtf-4.0.1.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:47:39 2020"}