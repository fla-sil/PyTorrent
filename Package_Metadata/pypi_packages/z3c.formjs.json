{"info": {"author": "Paul Carduner and the Zope Community", "author_email": "zope-dev@zope.org", "bugtrack_url": null, "classifiers": ["Development Status :: 4 - Beta", "Environment :: Web Environment", "Framework :: Zope3", "Intended Audience :: Developers", "License :: OSI Approved :: Zope Public License", "Natural Language :: English", "Operating System :: OS Independent", "Programming Language :: Python", "Topic :: Internet :: WWW/HTTP"], "description": "This package is going to provide javascript support/enhancements to\nthe z3c.form library.\n\nDetailed Documentation\n**********************\n\n===========================\nForm Javascript Integration\n===========================\n\nThis package is designed to provide a Python API to common Javascript\nfeatures for forms written with the ``z3c.form*`` packages. While the\nreference backend-implementation is for the JQuery library, any other\nJavascript library can be hooked into the Python API.\n\nThe documents are ordered in the way they should be read:\n\n- ``jsaction.txt`` [must read]\n\n  This document describes how JS scripts can be connected to events on a\n  any widget, inclduing buttons.\n\n- ``jsvalidator.txt`` [must read]\n\n  This document demonstrates how \"live\" widget value validation can be\n  achieved.\n\n- ``jsevent.txt`` [advanced users]\n\n  This documents describes the generalization that allows hooking up script to\n  events on any field.\n\n- ``jqueryrenderer.txt`` [advanced users]\n\n  This document demonstrates all necessary backend renderer components\n  necessary to accomplish any of the features of this package.\n\n=============================\nJavascript Events for Buttons\n=============================\n\nIn the ``z3c.form`` package, buttons are most commonly rendered as \"submit\"\ninput fields within a form, meaning that the form will always be\nsubmitted. When working with Javascript, on the other hand, a click on the\nbutton often simply executes a script. The ``jsaction`` module of this package\nis designed to implement the latter kind.\n\n  &gt;&gt;&gt; from z3c.formjs import jsaction\n\n\nJavascript Buttons\n------------------\n\nBefore we can write a form that uses Javascript buttons, we have to define\nthem first. One common way to define buttons in ``z3c.form`` is to write a\nschema describing them; so let's do that now:\n\n  &gt;&gt;&gt; import zope.interface\n  &gt;&gt;&gt; class IButtons(zope.interface.Interface):\n  ...     hello = jsaction.JSButton(title=u'Hello World!')\n  ...     dblhello = jsaction.JSButton(title=u'Double Hello World!')\n\nInstead of declaring ``z3c.form.button.Button`` fields, we are now using a\nderived Javascript button field. While there is no difference initially, they\nwill later be rendered differently. (Basically, ``JSButton`` fields render as\nbutton widgets.)\n\n\nWidget Selector\n---------------\n\nLike for regular fields, the action of the buttons is defined using handlers,\nin our case Javascript handler. Selectors are used to determine the DOM\nelement or elements for which a handler is registered. The widget selector\nuses a widget to provide the selector API:\n\n  &gt;&gt;&gt; from z3c.form.testing import TestRequest\n  &gt;&gt;&gt; request = TestRequest()\n\n  &gt;&gt;&gt; from z3c.form.browser import text\n  &gt;&gt;&gt; msg = text.TextWidget(request)\n  &gt;&gt;&gt; msg.id = 'form-msg'\n  &gt;&gt;&gt; msg.name = 'msg'\n\n  &gt;&gt;&gt; selector = jsaction.WidgetSelector(msg)\n  &gt;&gt;&gt; selector\n  &lt;WidgetSelector \"form-msg\"&gt;\n\nSince the widget selector can determine the widget's id, it is also an id\nselector (see ``jsevent.txt``):\n\n  &gt;&gt;&gt; from z3c.formjs import interfaces\n  &gt;&gt;&gt; interfaces.IIdSelector.providedBy(selector)\n  True\n  &gt;&gt;&gt; selector.id\n  'form-msg'\n\nThis has the advantage that we can reuse the renderer of the id\nselector.\n\n\nJavascript Event Subscriptions\n------------------------------\n\nAs discussed in ``jsevent.txt``, all the Javascript event subscriptions are\nstored on the view in a special attribute called ``jsSubscriptions``. While\nupdating the form, one can simply add subscriptions to this registry. So let's\nsay we have the following handler:\n\n  &gt;&gt;&gt; def showSelectedWidget(event, selector, request):\n  ...     return 'alert(\"%r\");' %(selector.widget)\n\nWe now want to connect this handler to the ``msg`` widget to be executed when\nthe mouse is clicked within this element:\n\n  &gt;&gt;&gt; import zope.interface\n  &gt;&gt;&gt; from z3c.formjs import jsevent\n\n  &gt;&gt;&gt; class Form(object):\n  ...     zope.interface.implements(interfaces.IHaveJSSubscriptions)\n  ...     jsSubscriptions = jsevent.JSSubscriptions()\n  ...\n  ...     def update(self):\n  ...         self.jsSubscriptions.subscribe(\n  ...             jsevent.CLICK, selector, showSelectedWidget)\n\n  &gt;&gt;&gt; form = Form()\n  &gt;&gt;&gt; form.update()\n\nAfter registering the subscription-related renderers,\n\n  &gt;&gt;&gt; from z3c.formjs import testing\n  &gt;&gt;&gt; testing.setupRenderers()\n\nwe can use the subscription rendering viewlet to check the subscription\noutput:\n\n  &gt;&gt;&gt; viewlet = jsevent.JSSubscriptionsViewlet(None, request, form, None)\n  &gt;&gt;&gt; viewlet.update()\n  &gt;&gt;&gt; print viewlet.render()\n  &lt;script type=\"text/javascript\"&gt;\n    $(document).ready(function(){\n      $(\"#form-msg\").bind(\"click\", function(){alert(\"&lt;TextWidget 'msg'&gt;\");});\n    })\n  &lt;/script&gt;\n\nThe z3c.formjs package provides a viewlet manager with this viewlet\nalready registered for it.  The viewlet manager has the name\n``z3c.formjs.interfaces.IDynamicJavaScript`` and can be rendered in\nany template with the following:\n\n  &lt;script tal:replace=\"structure\n                       provider:z3c.formjs.interfaces.IDynamicJavaScript\"&gt;\n  &lt;/script&gt;\n\n\nForms with Javascript Buttons\n-----------------------------\n\nThe next step is create the form. Luckily we do not need any fields to\nrender a form. Also, instead of using usual\n``z3c.form.button.handler()`` function, we now have a special handler\ndecorator that connects a button to a Javascript event, along with an\nadditional decorator that creates the button at the same time. The\noutput of the handler itself is a string that is used as the\nJavascript script that is executed.\n\n  &gt;&gt;&gt; from z3c.form import button, form\n\n  &gt;&gt;&gt; class Form(form.Form):\n  ...     buttons = button.Buttons(IButtons)\n  ...\n  ...     @jsaction.handler(buttons['hello'])\n  ...     def showHelloWorldMessage(self, event, selector):\n  ...         return 'alert(\"%s\");' % selector.widget.title\n  ...\n  ...     @jsaction.handler(buttons['dblhello'], event=jsevent.DBLCLICK)\n  ...     def showDoubleHelloWorldMessage(self, event, selector):\n  ...         return 'alert(\"%s\");' % selector.widget.title\n  ...\n  ...     @jsaction.buttonAndHandler(u\"Click Me\")\n  ...     def handleClickMe(self, event, selector):\n  ...         return 'alert(\"You clicked the Click Me button.\");'\n\n\n\nThe ``handler()`` decorator takes two arguments, the button (acting as the DOM\nelement selector) and the event to which to bind the action. By default the\nevent is ``jsevent.CLICK``.\n\nAnd that is really everything that is required from a user's point of\nview. Let us now see how those handler declarations are converted into actions\nand Javascript subscriptions. First we need to initialize the form:\n\n  &gt;&gt;&gt; from z3c.form.testing import TestRequest\n  &gt;&gt;&gt; request = TestRequest()\n\n  &gt;&gt;&gt; demoform = Form(None, request)\n\nWe also need to register an adapter to create an action from a button:\n\n  &gt;&gt;&gt; from z3c.form.interfaces import IButtonAction\n  &gt;&gt;&gt; zope.component.provideAdapter(\n  ...     jsaction.JSButtonAction, provides=IButtonAction)\n\nFinally, for the Javascript subscriptions to be registered, we need an event\nlistener that reacts to \"after widget/action update\" events:\n\n  &gt;&gt;&gt; zope.component.provideHandler(jsaction.createSubscriptionsForWidget)\n\nAction managers are instantiated using the form, request, and\ncontext/content. A button-action-manager implementation is avaialble in the\n``z3c.form.button`` package:\n\n  &gt;&gt;&gt; actions = button.ButtonActions(demoform, request, None)\n  &gt;&gt;&gt; actions.update()\n\nOnce the action manager is updated, the buttons should be available as\nactions:\n\n  &gt;&gt;&gt; actions.keys()\n  ['hello', 'dblhello', '436c69636b204d65']\n  &gt;&gt;&gt; actions['hello']\n  &lt;JSButtonAction 'form.buttons.hello' u'Hello World!'&gt;\n\nSince special Javascript handlers were registered for those buttons, creating\nand updating the actions has also caused the form to become an\n``IHaveJSSubscriptions`` view:\n\n  &gt;&gt;&gt; from z3c.formjs import interfaces\n\n  &gt;&gt;&gt; interfaces.IHaveJSSubscriptions.providedBy(demoform)\n  True\n  &gt;&gt;&gt; demoform.jsSubscriptions\n  &lt;z3c.formjs.jsevent.JSSubscriptions object at ...&gt;\n\nThe interesting part about button subscriptions is the selector.\n\n  &gt;&gt;&gt; selector = list(demoform.jsSubscriptions)[0].selector\n  &gt;&gt;&gt; selector\n  &lt;WidgetSelector \"form-buttons-hello\"&gt;\n\nAs you can see, the system automatically created a widget selector:\n\n  &gt;&gt;&gt; selector.id\n  'form-buttons-hello'\n  &gt;&gt;&gt; selector.widget\n  &lt;JSButtonAction 'form.buttons.hello' u'Hello World!'&gt;\n\nWith the declarations in place, we can now go on.\n\n\nRendering the Form\n------------------\n\nLet's now see what we need to do to make the form render correctly and\ncompletely.\n\n  &gt;&gt;&gt; demoform = Form(None, request)\n\nFirst we need some of the standard ``z3c.form`` registrations:\n\n  &gt;&gt;&gt; from z3c.form import field, button\n  &gt;&gt;&gt; zope.component.provideAdapter(field.FieldWidgets)\n  &gt;&gt;&gt; zope.component.provideAdapter(button.ButtonActions)\n\nNext we need to register the template for our button actions:\n\n  &gt;&gt;&gt; from zope.pagetemplate.interfaces import IPageTemplate\n  &gt;&gt;&gt; from z3c.form import widget\n  &gt;&gt;&gt; from z3c.form.interfaces import IButtonWidget, INPUT_MODE\n  &gt;&gt;&gt; from z3c.form.testing import getPath\n\n  &gt;&gt;&gt; zope.component.provideAdapter(\n  ...     widget.WidgetTemplateFactory(getPath('button_input.pt'), 'text/html'),\n  ...     (None, None, None, None, IButtonWidget),\n  ...     IPageTemplate, name=INPUT_MODE)\n\nWe also need to setup a Javascript viewlet manager and register the\nsubscription viewlet for it, so that the subscriptions actually appear in the\nHTML page. (This is a bit tedious to do using the Python API, but using ZCML\nthis is much simpler.)\n\n* Hook up the \"provider\" TALES expression type:\n\n  &gt;&gt;&gt; from zope.pagetemplate.engine import TrustedEngine\n  &gt;&gt;&gt; from zope.contentprovider import tales\n  &gt;&gt;&gt; TrustedEngine.registerType('provider', tales.TALESProviderExpression)\n\n* Create a viewlet manager that does not require security to be setup:\n\n  &gt;&gt;&gt; from zope.viewlet import manager\n  &gt;&gt;&gt; class JSViewletManager(manager.ViewletManagerBase):\n  ...     def filter(self, viewlets):\n  ...         return viewlets\n\n* Register the viewlet manager as a content provider known as \"javascript\":\n\n  &gt;&gt;&gt; from z3c.form.interfaces import IFormLayer\n  &gt;&gt;&gt; from zope.contentprovider.interfaces import IContentProvider\n  &gt;&gt;&gt; zope.component.provideAdapter(\n  ...     JSViewletManager,\n  ...     (None, IFormLayer, None),\n  ...     IContentProvider,\n  ...     name='javascript')\n\n* Register the JS Subscriber viewlet for this new viewlet manager:\n\n  &gt;&gt;&gt; from zope.viewlet.interfaces import IViewlet\n  &gt;&gt;&gt; zope.component.provideAdapter(\n  ...     jsevent.JSSubscriptionsViewlet,\n  ...     (None, IFormLayer, interfaces.IHaveJSSubscriptions,\n  ...      JSViewletManager), IViewlet, name='subscriptions')\n\nFinally, we need a template for our form:\n\n  &gt;&gt;&gt; testing.addTemplate(demoform, 'buttons_form.pt')\n\nWe can now render the form:\n\n  &gt;&gt;&gt; demoform.update()\n  &gt;&gt;&gt; print demoform.render()\n  &lt;html&gt;\n    &lt;head&gt;\n      &lt;script type=\"text/javascript\"&gt;\n        $(document).ready(function(){\n          $(\"#form-buttons-hello\").bind(\"click\",\n              function(){alert(\"Hello World!\");});\n          $(\"#form-buttons-dblhello\").bind(\"dblclick\",\n              function(){alert(\"Double Hello World!\");});\n          $(\"#form-buttons-436c69636b204d65\").bind(\"click\",\n              function(){alert(\"You clicked the Click Me button.\");});\n        })\n      &lt;/script&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n      &lt;div class=\"action\"&gt;\n        &lt;input type=\"button\" id=\"form-buttons-hello\"\n               name=\"form.buttons.hello\" class=\"button-widget jsbutton-field\"\n               value=\"Hello World!\" /&gt;\n      &lt;/div&gt;\n      &lt;div class=\"action\"&gt;\n        &lt;input type=\"button\" id=\"form-buttons-dblhello\"\n               name=\"form.buttons.dblhello\" class=\"button-widget jsbutton-field\"\n               value=\"Double Hello World!\" /&gt;\n      &lt;/div&gt;\n      &lt;div class=\"action\"&gt;\n        &lt;input type=\"button\" id=\"form-buttons-436c69636b204d65\"\n         name=\"form.buttons.436c69636b204d65\"\n         class=\"button-widget jsbutton-field\" value=\"Click Me\" /&gt;\n      &lt;/div&gt;\n    &lt;/body&gt;\n  &lt;/html&gt;\n\nAs you can see, the subscriptions are correctly placed into the header, while\nthe buttons render as usual with exception to the input type, which is now a\n\"button\".\n\n\nMultiple Handlers\n-----------------\n\nSince there are multiple events in Javascript, one element can have multiple\nhandlers. So let's define a new form that declares two handlers for the same\nbutton:\n\n  &gt;&gt;&gt; class Form(form.Form):\n  ...     buttons = button.Buttons(IButtons).select('hello')\n  ...\n  ...     @jsaction.handler(buttons['hello'])\n  ...     def showHelloWorldMessage(self, event, selector):\n  ...         return 'alert(\"Hello World!\");'\n  ...\n  ...     @jsaction.handler(buttons['hello'], event=jsevent.DBLCLICK)\n  ...     def showDoubleHelloWorldMessage(self, event, selector):\n  ...         return 'alert(\"Hello World! x 2\");'\n\nLet's now instantiate and update the form:\n\n  &gt;&gt;&gt; demoform = Form(None, request)\n  &gt;&gt;&gt; demoform.update()\n\nThe subscriptions are now available:\n\n  &gt;&gt;&gt; list(demoform.jsSubscriptions)\n  [&lt;JSSubscription\n       event=&lt;JSEvent \"click\"&gt;,\n       selector=&lt;WidgetSelector \"form-buttons-hello\"&gt;,\n       handler=&lt;JSHandler &lt;function showHelloWorldMessage ...&gt;&gt;&gt;,\n   &lt;JSSubscription\n       event=&lt;JSEvent \"dblclick\"&gt;,\n       selector=&lt;WidgetSelector \"form-buttons-hello\"&gt;,\n       handler=&lt;JSHandler &lt;function showDoubleHelloWorldMessage ...&gt;&gt;&gt;]\n\nNext we can look at a case where one handler is registered for all buttons and\nevents, and another overrides the click of the \"hello\" button to something\nelse:\n\n  &gt;&gt;&gt; from z3c.form.interfaces import IButton\n  &gt;&gt;&gt; class Form(form.Form):\n  ...     buttons = button.Buttons(IButtons)\n  ...\n  ...     @jsaction.handler(IButton, interfaces.IJSEvent)\n  ...     def showHelloWorldMessage(self, event, selector):\n  ...         return '''alert(\"The event '%s' occured.\");''' %event.name\n  ...\n  ...     @jsaction.handler(buttons['hello'], event=jsevent.CLICK)\n  ...     def showDoubleHelloWorldMessage(self, event, selector):\n  ...         return 'alert(\"Hello World clicked!\");'\n\n  &gt;&gt;&gt; demoform = Form(None, request)\n  &gt;&gt;&gt; demoform.update()\n\nRendering the subscriptions gives the following result:\n\n  &gt;&gt;&gt; renderer = zope.component.getMultiAdapter(\n  ...     (demoform.jsSubscriptions, request), interfaces.IRenderer)\n  &gt;&gt;&gt; renderer.update()\n  &gt;&gt;&gt; print renderer.render()\n  $(document).ready(function(){\n    $(\"#...-hello\").bind(\"dblclick\", function(){alert(\"The ...\");});\n    $(\"#...-hello\").bind(\"change\", function(){alert(\"The ...\");});\n    $(\"#...-hello\").bind(\"load\", function(){alert(\"The ...\");});\n    $(\"#...-hello\").bind(\"blur\", function(){alert(\"The ...\");});\n    $(\"#...-hello\").bind(\"focus\", function(){alert(\"The ...\");});\n    $(\"#...-hello\").bind(\"keydown\", function(){alert(\"The ...\");});\n    $(\"#...-hello\").bind(\"keyup\", function(){alert(\"The ...\");});\n    $(\"#...-hello\").bind(\"mousedown\", function(){alert(\"The ...\");});\n    $(\"#...-hello\").bind(\"mousemove\", function(){alert(\"The ...\");});\n    $(\"#...-hello\").bind(\"mouseout\", function(){alert(\"The ...\");});\n    $(\"#...-hello\").bind(\"mouseover\", function(){alert(\"The ...\");});\n    $(\"#...-hello\").bind(\"mouseup\", function(){alert(\"The ...\");});\n    $(\"#...-hello\").bind(\"resize\", function(){alert(\"The ...\");});\n    $(\"#...-hello\").bind(\"select\", function(){alert(\"The ...\");});\n    $(\"#...-hello\").bind(\"submit\", function(){alert(\"The ...\");});\n    $(\"#...-dblhello\").bind(\"click\", function(){alert(\"The ...\");});\n    $(\"#...-dblhello\").bind(\"dblclick\", function(){alert(\"The ...\");});\n    $(\"#...-dblhello\").bind(\"change\", function(){alert(\"The ...\");});\n    $(\"#...-dblhello\").bind(\"load\", function(){alert(\"The ...\");});\n    $(\"#...-dblhello\").bind(\"blur\", function(){alert(\"The ...\");});\n    $(\"#...-dblhello\").bind(\"focus\", function(){alert(\"The ...\");});\n    $(\"#...-dblhello\").bind(\"keydown\", function(){alert(\"The ...\");});\n    $(\"#...-dblhello\").bind(\"keyup\", function(){alert(\"The ...\");});\n    $(\"#...-dblhello\").bind(\"mousedown\", function(){alert(\"The ...\");});\n    $(\"#...-dblhello\").bind(\"mousemove\", function(){alert(\"The ...\");});\n    $(\"#...-dblhello\").bind(\"mouseout\", function(){alert(\"The ...\");});\n    $(\"#...-dblhello\").bind(\"mouseover\", function(){alert(\"The ...\");});\n    $(\"#...-dblhello\").bind(\"mouseup\", function(){alert(\"The ...\");});\n    $(\"#...-dblhello\").bind(\"resize\", function(){alert(\"The ...\");});\n    $(\"#...-dblhello\").bind(\"select\", function(){alert(\"The ...\");});\n    $(\"#...-dblhello\").bind(\"submit\", function(){alert(\"The ...\");});\n    $(\"#...-hello\").bind(\"click\", function(){alert(\"Hello World clicked!\");});\n  })\n\nWhile this output might seem excessive, it demonstrates that the generic\n``IJSEvent`` subscription truly causes a subscription to all events. Further,\na more specific directive takes precendence over the more generic one. This is\ndue to the built-in adapter registry of the ``JSHandlers`` class.\n\nFinally, handler declarations can also be chained, allowing a handler to be\nregistered for multiple field-event combinations that cannot be expressed by\ncommon interfaces:\n\n  &gt;&gt;&gt; class Form(form.Form):\n  ...     buttons = button.Buttons(IButtons)\n  ...\n  ...     @jsaction.handler(IButtons['hello'], jsevent.CLICK)\n  ...     @jsaction.handler(IButtons['hello'], jsevent.DBLCLICK)\n  ...     def showHelloWorldMessage(self, event, selector):\n  ...         return '''alert(\"The event '%s' occured.\");''' %event.name\n\n  &gt;&gt;&gt; demoform = Form(None, request)\n  &gt;&gt;&gt; demoform.update()\n\nRendering the subscriptions gives the following result:\n\n  &gt;&gt;&gt; renderer = zope.component.getMultiAdapter(\n  ...     (demoform.jsSubscriptions, request), interfaces.IRenderer)\n  &gt;&gt;&gt; renderer.update()\n  &gt;&gt;&gt; print renderer.render()\n  $(document).ready(function(){\n    $(\"#form-buttons-hello\").bind(\"click\", function(){alert(\"The ...\");});\n    $(\"#form-buttons-hello\").bind(\"dblclick\", function(){alert(\"The ...\");});\n  })\n\n\nAttaching Events to Form Fields\n-------------------------------\n\nJavascript handlers do not only work for buttons, but also for fields. Let's\ncreate a simple schema that we can use to create a form:\n\n  &gt;&gt;&gt; import zope.schema\n\n  &gt;&gt;&gt; class IPerson(zope.interface.Interface):\n  ...     name = zope.schema.TextLine(title=u'Name')\n  ...     age = zope.schema.Int(title=u'Age')\n\nEven though somewhat pointless, whenever the \"age\" field is clicked on or the\n\"name\" widget value changed, we would like to get an alert:\n\n  &gt;&gt;&gt; class PersonAddForm(form.AddForm):\n  ...     fields = field.Fields(IPerson)\n  ...\n  ...     @jsaction.handler(fields['age'])\n  ...     def ageClickEvent(self, event, selector):\n  ...         return 'alert(\"The Age was Clicked!\");'\n  ...\n  ...     @jsaction.handler(fields['name'], event=jsevent.CHANGE)\n  ...     def nameChangeEvent(self, event, selector):\n  ...         return 'alert(\"The Name was Changed!\");'\n\nWe also need to register all of the default ``z3c.form`` registrations:\n\n  &gt;&gt;&gt; from z3c.form.testing import setupFormDefaults\n  &gt;&gt;&gt; setupFormDefaults()\n\nAfter adding a simple template for the form, it can be rendered:\n\n  &gt;&gt;&gt; addform = PersonAddForm(None, request)\n  &gt;&gt;&gt; testing.addTemplate(addform, 'simple_edit.pt')\n  &gt;&gt;&gt; addform.update()\n  &gt;&gt;&gt; print addform.render()\n  &lt;html&gt;\n    &lt;head&gt;\n      &lt;script type=\"text/javascript\"&gt;\n  $(document).ready(function(){\n    $(\"#form-widgets-name\").bind(\"change\",\n                                 function(){alert(\"The Name was Changed!\");});\n    $(\"#form-widgets-age\").bind(\"click\",\n                                function(){alert(\"The Age was Clicked!\");});\n  })\n  &lt;/script&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n  &lt;BLANKLINE&gt;\n  &lt;BLANKLINE&gt;\n      &lt;form action=\".\"&gt;\n        &lt;div class=\"row\"&gt;\n          &lt;label for=\"form-widgets-name\"&gt;Name&lt;/label&gt;\n  &lt;BLANKLINE&gt;\n      &lt;input id=\"form-widgets-name\" name=\"form.widgets.name\"\n             class=\"text-widget required textline-field\"\n             value=\"\" type=\"text\" /&gt;\n  &lt;BLANKLINE&gt;\n  &lt;/div&gt;\n        &lt;div class=\"row\"&gt;\n          &lt;label for=\"form-widgets-age\"&gt;Age&lt;/label&gt;\n  &lt;BLANKLINE&gt;\n      &lt;input id=\"form-widgets-age\" name=\"form.widgets.age\"\n             class=\"text-widget required int-field\" value=\"\"\n             type=\"text\" /&gt;\n  &lt;BLANKLINE&gt;\n  &lt;/div&gt;\n        &lt;div class=\"action\"&gt;\n  &lt;BLANKLINE&gt;\n  &lt;input id=\"form-buttons-add\" name=\"form.buttons.add\"\n         class=\"submit-widget button-field\" value=\"Add\"\n         type=\"submit\" /&gt;\n  &lt;BLANKLINE&gt;\n  &lt;/div&gt;\n      &lt;/form&gt;\n    &lt;/body&gt;\n  &lt;/html&gt;\n\nAs you can see, the form rendered perferctly, even allowing classic and\nJavascript handlers to co-exist.\n\n\nAppendix A: Javascript Event Handlers Manager\n---------------------------------------------\n\nThe ``IJSEventHandlers`` implementataion (``JSHandlers`` class) is really an\nadvanced component with great features, so it deserves some additional\nattention.\n\n  &gt;&gt;&gt; handlers = jsaction.JSHandlers()\n  &gt;&gt;&gt; handlers\n  &lt;JSHandlers []&gt;\n\nWhen a handlers component is initialized, it creates an internal adapter\nregistry. If a handler is registered for a button, it simply behaves as an\ninstance-adapter.\n\n  &gt;&gt;&gt; handlers._registry\n  &lt;zope.interface.adapter.AdapterRegistry object at ...&gt;\n\nThe object itself is pretty simple. To add a handler, we first have to create\na handler, ...\n\n  &gt;&gt;&gt; def doSomething(form, event, selector):\n  ...     pass\n  &gt;&gt;&gt; handler = jsaction.JSHandler(doSomething)\n\nThe only special thing about the handler is that it has the same name\nas the function.\n\n  &gt;&gt;&gt; handler.__name__\n  'doSomething'\n\nand a field/button:\n\n  &gt;&gt;&gt; button1 = jsaction.JSButton(name='button1', title=u'Button 1')\n\nLet's now add the handler:\n\n  &gt;&gt;&gt; handlers.addHandler(button1, jsevent.CLICK, handler)\n\nBut you can also register handlers for groups of fields, either by interface\nor class:\n\n  &gt;&gt;&gt; class SpecialButton(jsaction.JSButton):\n  ...     pass\n\n  &gt;&gt;&gt; handlers.addHandler(\n  ...     SpecialButton, jsevent.CLICK, jsaction.JSHandler('specialAction'))\n\n  &gt;&gt;&gt; handlers\n  &lt;JSHandlers\n      [&lt;JSHandler &lt;function doSomething at ...&gt;&gt;,\n       &lt;JSHandler 'specialAction'&gt;]&gt;\n\nNow all special buttons should use that handler:\n\n  &gt;&gt;&gt; button2 = SpecialButton(name='button2', title=u'Button 2')\n  &gt;&gt;&gt; button3 = SpecialButton(name='button3', title=u'Button 3')\n\n  &gt;&gt;&gt; handlers.getHandlers(button2)\n  ((&lt;JSEvent \"click\"&gt;, &lt;JSHandler 'specialAction'&gt;),)\n  &gt;&gt;&gt; handlers.getHandlers(button3)\n  ((&lt;JSEvent \"click\"&gt;, &lt;JSHandler 'specialAction'&gt;),)\n\nHowever, registering a more specific handler for button 2 will override the\ngeneral handler:\n\n  &gt;&gt;&gt; handlers.addHandler(\n  ...     button2, jsevent.CLICK, jsaction.JSHandler('specificAction2'))\n\n  &gt;&gt;&gt; handlers.getHandlers(button2)\n  ((&lt;JSEvent \"click\"&gt;, &lt;JSHandler 'specificAction2'&gt;),)\n  &gt;&gt;&gt; handlers.getHandlers(button3)\n  ((&lt;JSEvent \"click\"&gt;, &lt;JSHandler 'specialAction'&gt;),)\n\nThe same flexibility that is available to the field is also available for the\nevent.\n\n  &gt;&gt;&gt; handlers = jsaction.JSHandlers()\n\nSo let's register a generic handler for all events:\n\n  &gt;&gt;&gt; handlers.addHandler(\n  ...     jsaction.JSButton, jsevent.JSEvent,\n  ...     jsaction.JSHandler('genericEventAction'))\n\nSo when asking for the handlers of button 1, we get a very long list:\n\n  &gt;&gt;&gt; handlers.getHandlers(button1)\n  ((&lt;JSEvent \"click\"&gt;, &lt;JSHandler 'genericEventAction'&gt;),\n   (&lt;JSEvent \"dblclick\"&gt;, &lt;JSHandler 'genericEventAction'&gt;),\n   (&lt;JSEvent \"change\"&gt;, &lt;JSHandler 'genericEventAction'&gt;),\n   (&lt;JSEvent \"load\"&gt;, &lt;JSHandler 'genericEventAction'&gt;),\n   (&lt;JSEvent \"blur\"&gt;, &lt;JSHandler 'genericEventAction'&gt;),\n   (&lt;JSEvent \"focus\"&gt;, &lt;JSHandler 'genericEventAction'&gt;),\n   (&lt;JSEvent \"keydown\"&gt;, &lt;JSHandler 'genericEventAction'&gt;),\n   (&lt;JSEvent \"keyup\"&gt;, &lt;JSHandler 'genericEventAction'&gt;),\n   (&lt;JSEvent \"mousedown\"&gt;, &lt;JSHandler 'genericEventAction'&gt;),\n   (&lt;JSEvent \"mousemove\"&gt;, &lt;JSHandler 'genericEventAction'&gt;),\n   (&lt;JSEvent \"mouseout\"&gt;, &lt;JSHandler 'genericEventAction'&gt;),\n   (&lt;JSEvent \"mouseover\"&gt;, &lt;JSHandler 'genericEventAction'&gt;),\n   (&lt;JSEvent \"mouseup\"&gt;, &lt;JSHandler 'genericEventAction'&gt;),\n   (&lt;JSEvent \"resize\"&gt;, &lt;JSHandler 'genericEventAction'&gt;),\n   (&lt;JSEvent \"select\"&gt;, &lt;JSHandler 'genericEventAction'&gt;),\n   (&lt;JSEvent \"submit\"&gt;, &lt;JSHandler 'genericEventAction'&gt;))\n\nSo at this point you might ask: How is the complete set of events determined?\nAt this point we use the list of all events as listed in the\n``jsevent.EVENTS`` variable.\n\nLet's now register a special handler for the \"click\" event:\n\n  &gt;&gt;&gt; handlers.addHandler(\n  ...     button1, jsevent.CLICK, jsaction.JSHandler('clickEventAction'))\n\nSo this registration takes precedence over the generic one:\n\n  &gt;&gt;&gt; handlers.getHandlers(button1)\n  ((&lt;JSEvent \"click\"&gt;, &lt;JSHandler 'clickEventAction'&gt;),\n   (&lt;JSEvent \"dblclick\"&gt;, &lt;JSHandler 'genericEventAction'&gt;),\n   (&lt;JSEvent \"change\"&gt;, &lt;JSHandler 'genericEventAction'&gt;),\n   (&lt;JSEvent \"load\"&gt;, &lt;JSHandler 'genericEventAction'&gt;),\n   (&lt;JSEvent \"blur\"&gt;, &lt;JSHandler 'genericEventAction'&gt;),\n   (&lt;JSEvent \"focus\"&gt;, &lt;JSHandler 'genericEventAction'&gt;),\n   (&lt;JSEvent \"keydown\"&gt;, &lt;JSHandler 'genericEventAction'&gt;),\n   (&lt;JSEvent \"keyup\"&gt;, &lt;JSHandler 'genericEventAction'&gt;),\n   (&lt;JSEvent \"mousedown\"&gt;, &lt;JSHandler 'genericEventAction'&gt;),\n   (&lt;JSEvent \"mousemove\"&gt;, &lt;JSHandler 'genericEventAction'&gt;),\n   (&lt;JSEvent \"mouseout\"&gt;, &lt;JSHandler 'genericEventAction'&gt;),\n   (&lt;JSEvent \"mouseover\"&gt;, &lt;JSHandler 'genericEventAction'&gt;),\n   (&lt;JSEvent \"mouseup\"&gt;, &lt;JSHandler 'genericEventAction'&gt;),\n   (&lt;JSEvent \"resize\"&gt;, &lt;JSHandler 'genericEventAction'&gt;),\n   (&lt;JSEvent \"select\"&gt;, &lt;JSHandler 'genericEventAction'&gt;),\n   (&lt;JSEvent \"submit\"&gt;, &lt;JSHandler 'genericEventAction'&gt;))\n\nYou can also add handlers objects:\n\n  &gt;&gt;&gt; handlers = jsaction.JSHandlers()\n  &gt;&gt;&gt; handlers.addHandler(\n  ...     button1, jsevent.CLICK, jsaction.JSHandler('button1ClickAction'))\n\n  &gt;&gt;&gt; handlers2 = jsaction.JSHandlers()\n  &gt;&gt;&gt; handlers2.addHandler(\n  ...     button2, jsevent.CLICK, jsaction.JSHandler('button2ClickAction'))\n\n  &gt;&gt;&gt; handlers + handlers2\n  &lt;JSHandlers\n      [&lt;JSHandler 'button1ClickAction'&gt;,\n       &lt;JSHandler 'button2ClickAction'&gt;]&gt;\n\nHowever, adding other components is not supported:\n\n  &gt;&gt;&gt; handlers + 1\n  Traceback (most recent call last):\n  ...\n  NotImplementedError\n\nThe handlers also provide a method to copy the handlers to a new instance:\n\n  &gt;&gt;&gt; copy = handlers.copy()\n  &gt;&gt;&gt; isinstance(copy, jsaction.JSHandlers)\n  True\n  &gt;&gt;&gt; copy is handlers\n  False\n\nThis is commonly needed when one wants to extend the handlers of a super-form.\n\n\nAppendix B: The Subscription-Creating Event Subscriber\n------------------------------------------------------\n\nThe ``createSubscriptionsForWidget(event)`` event subscriber listens to\n``IAfterWidgetUpdateEvent`` events and is responsible for looking up any\nJavascript action handlers and create event subscriptions for them.\n\nSo let's setup the environment:\n\n  &gt;&gt;&gt; class Form(form.Form):\n  ...     buttons = button.Buttons(IButtons)\n  ...\n  ...     @jsaction.handler(buttons['hello'])\n  ...     def showHelloWorldMessage(self, event, selector):\n  ...         return 'alert(\"Hello World!\");'\n\n  &gt;&gt;&gt; form = Form(None, request)\n\nOf course, not just any widget can have Javascript handlers. First of all, the\nwidget must be a field widget:\n\n  &gt;&gt;&gt; from z3c.form import widget\n  &gt;&gt;&gt; simpleWidget = widget.Widget(request)\n\n  &gt;&gt;&gt; jsaction.createSubscriptionsForWidget(\n  ...     widget.AfterWidgetUpdateEvent(simpleWidget))\n\n  &gt;&gt;&gt; interfaces.IHaveJSSubscriptions.providedBy(form)\n  False\n\nAnd even if the widget is a field widget,\n\n  &gt;&gt;&gt; from z3c.form.browser.button import ButtonFieldWidget\n  &gt;&gt;&gt; helloWidget = ButtonFieldWidget(form.buttons['hello'], request)\n\nit still needs to be a form-aware widget:\n\n  &gt;&gt;&gt; jsaction.createSubscriptionsForWidget(\n  ...     widget.AfterWidgetUpdateEvent(helloWidget))\n\n  &gt;&gt;&gt; interfaces.IHaveJSSubscriptions.providedBy(form)\n  False\n\nSo let's now make it work and add the form to the widget:\n\n  &gt;&gt;&gt; from z3c.form.interfaces import IFormAware\n  &gt;&gt;&gt; helloWidget.form = form\n  &gt;&gt;&gt; zope.interface.alsoProvides(helloWidget, IFormAware)\n\nAfter the subscriber successfully completes, we should have a sJavascript\nsubscription attached to the form:\n\n  &gt;&gt;&gt; jsaction.createSubscriptionsForWidget(\n  ...     widget.AfterWidgetUpdateEvent(helloWidget))\n\n  &gt;&gt;&gt; interfaces.IHaveJSSubscriptions.providedBy(form)\n  True\n  &gt;&gt;&gt; len(list(form.jsSubscriptions))\n  1\n  &gt;&gt;&gt; list(form.jsSubscriptions)\n  [&lt;JSSubscription\n       event=&lt;JSEvent \"click\"&gt;, selector=&lt;WidgetSelector \"hello\"&gt;,\n       handler=&lt;JSHandler &lt;function showHelloWorldMessage at ...&gt;&gt;&gt;]\n\nIn the event that the widget is updated multiple times, and the\nsubscriber gets called multiple times, duplicate subscriptions will\nnot be created.\n\n  &gt;&gt;&gt; jsaction.createSubscriptionsForWidget(\n  ...     widget.AfterWidgetUpdateEvent(helloWidget))\n  &gt;&gt;&gt; len(list(form.jsSubscriptions))\n  1\n\nFinally, if the form does not have any Javascript handlers, in other words, it\ndoes not have a ``jsHandlers`` attribute, then the subscriber also aborts:\n\n  &gt;&gt;&gt; form = Form(None, request)\n  &gt;&gt;&gt; helloWidget.form = object()\n\n  &gt;&gt;&gt; jsaction.createSubscriptionsForWidget(\n  ...     widget.AfterWidgetUpdateEvent(helloWidget))\n\n  &gt;&gt;&gt; interfaces.IHaveJSSubscriptions.providedBy(form)\n  False\n\nAnd that's all.\n\n==========================\nJavaScript Form Validation\n==========================\n\nThis package also supports widget value validation via Javascript. In\nparticular, the ``jsvalidator`` module implements server-side validation via\nAJAX.\n\n  &gt;&gt;&gt; from z3c.formjs import jsvalidator\n\nThere are two components to the validation API. The first is the validator, a\nform mix-in class that makes the validation functionality via a URL and\ndefines the communication protocol of the validation; for example, it defines\nwhat path must be accessed for the validation and what data to send and\nreturn. The second component is the validation script, which is responsible\nfor defining the Javascript code that is executed when validation is\nrequested.\n\n\nMessage Validator\n-----------------\n\nThe goal of the specific message validator is to validate a value, then\nconvert any error into a message and insert the message into the page's\ncontent.\n\nSo let's do some necessary setups:\n\n  &gt;&gt;&gt; from z3c.form.testing import setupFormDefaults\n  &gt;&gt;&gt; setupFormDefaults()\n\n  &gt;&gt;&gt; import zope.component\n  &gt;&gt;&gt; from z3c.form import error\n  &gt;&gt;&gt; zope.component.provideAdapter(error.ValueErrorViewSnippet)\n\nWe now create a simple form in which all widgets will be validated:\n\n  &gt;&gt;&gt; import zope.interface\n  &gt;&gt;&gt; import zope.schema\n\n  &gt;&gt;&gt; class IAddress(zope.interface.Interface):\n  ...     zip = zope.schema.Int(title=u\"Zip Code\")\n\n  &gt;&gt;&gt; from z3c.form import form, field\n  &gt;&gt;&gt; from z3c.form.interfaces import IField\n  &gt;&gt;&gt; from z3c.formjs import jsevent, jsaction\n\n  &gt;&gt;&gt; class AddressEditForm(jsvalidator.MessageValidator, form.AddForm):\n  ...     fields = field.Fields(IAddress)\n  ...\n  ...     @jsaction.handler(IField, event=jsevent.CHANGE)\n  ...     def fieldValidator(self, event, selector):\n  ...         return self.ValidationScript(self, selector.widget).render()\n\nAfter instantiating the form, ...\n\n  &gt;&gt;&gt; from z3c.form.testing import TestRequest\n  &gt;&gt;&gt; request = TestRequest()\n  &gt;&gt;&gt; edit = AddressEditForm(None, request)\n  &gt;&gt;&gt; edit.update()\n\nwe can execute the handler to ensure we get some output:\n\n  &gt;&gt;&gt; from z3c.formjs import testing\n  &gt;&gt;&gt; testing.setupRenderers()\n\n  &gt;&gt;&gt; from z3c.formjs import jsaction\n  &gt;&gt;&gt; print edit.fieldValidator(\n  ...     None, jsaction.WidgetSelector(edit.widgets['zip']))\n  $.get('/validate', function(data){ alert(data) })\n\nValidators use AJAX handlers to communicate with the server. Commonly the AJAX\nhandler is looked up via the \"ajax\" view -- see ``ajax.txt`` for more\ndetails. In this case we just create a small helper function:\n\n  &gt;&gt;&gt; from z3c.formjs import ajax\n\n  &gt;&gt;&gt; def AJAXPlugin(view):\n  ...     return ajax.AJAXRequestTraverserPlugin(view, view.request)\n\n\n  &gt;&gt;&gt; from z3c.formjs import ajax, interfaces\n  &gt;&gt;&gt; from zope.publisher.interfaces.browser import IBrowserRequest\n\n  &gt;&gt;&gt; zope.component.provideSubscriptionAdapter(\n  ...     ajax.AJAXRequestTraverserPlugin,\n  ...     (interfaces.IFormTraverser, IBrowserRequest))\n\nwe can traverse to the ``validate`` method from the \"ajax\" view and render\nit. Let's first render some valid input:\n\n  &gt;&gt;&gt; request = TestRequest(form={'widget-name' : 'zip',\n  ...                             'form.widgets.zip' : u'29132'})\n  &gt;&gt;&gt; edit = AddressEditForm(None, request)\n  &gt;&gt;&gt; edit.update()\n  &gt;&gt;&gt; AJAXPlugin(edit).publishTraverse(None, 'validate')()\n  u''\n\nAs you can see there is no error message. Let's now provide an invalid ZIP\ncode. As you can see, we get the expected error message:\n\n  &gt;&gt;&gt; request = TestRequest(form={'widget-name': 'zip',\n  ...                             'form.widgets.zip':'notazipcode'})\n  &gt;&gt;&gt; edit = AddressEditForm(None, request)\n  &gt;&gt;&gt; edit.update()\n  &gt;&gt;&gt; AJAXPlugin(edit).publishTraverse(None, 'validate')()\n  u'The entered value is not a valid integer literal.'\n\nOf course, one cannot just traverse to any attribute in the form:\n\n  &gt;&gt;&gt; AJAXPlugin(edit).publishTraverse(None, 'ValidationScript')()\n  Traceback (most recent call last):\n  ...\n  NotFound: Object: &lt;AddressEditForm ...&gt;, name: 'ValidationScript'\n\nAnd that's it.\n\n===============================\nConnecting to Javascript Events\n===============================\n\nThe ``jsevent`` module of this package implements a mechanism to connect a\nJavascript script to an event of a DOM element. So let's have a look at how\nthis works.\n\n  &gt;&gt;&gt; from z3c.formjs import interfaces, jsevent\n\nTo implement this functionality, we need to model three components: events,\nDOM elements (selector), and the script (handler). We will also need a manager\nto keep track of all the mappings. This is indeed somewhat similar to the Zope\n3 event model, though we do not need DOM elements to connect the events there.\n\n\nSubscription Manager\n--------------------\n\nSo first we need to create a subscription manager in which to collect the\nsubscriptions:\n\n  &gt;&gt;&gt; manager = jsevent.JSSubscriptions()\n\nInitially, we have no registered events:\n\n  &gt;&gt;&gt; list(manager)\n  []\n\nWe now want to subscribe to the \"click\" event of a DOM element with the id\n\"message\". When the event occurs, we would like to display a simple \"Hello\nWorld\" message.\n\nThe events are available in all capital letters, for example:\n\n  &gt;&gt;&gt; jsevent.CLICK\n  &lt;JSEvent \"click\"&gt;\n\nThe DOM element is selected using a selector, in our case an id selector:\n\n  &gt;&gt;&gt; selector = jsevent.IdSelector('message')\n  &gt;&gt;&gt; selector\n  &lt;IdSelector \"message\"&gt;\n\nThe handler of the event is a callable accepting the event, selector and the\nrequest:\n\n  &gt;&gt;&gt; def showHelloWorldAlert(event, selector, request):\n  ...     return u'alert(\"Hello World!\")'\n\nWe have finally all the pieces together to subscribe the event:\n\n  &gt;&gt;&gt; manager.subscribe(jsevent.CLICK, selector, showHelloWorldAlert)\n  &lt;JSSubscription event=&lt;JSEvent \"click\"&gt;,\n                  selector=&lt;IdSelector \"message\"&gt;,\n                  handler=&lt;function showHelloWorldAlert at ...&gt;&gt;\n\nSo now we can see the subscription:\n\n  &gt;&gt;&gt; list(manager)\n  [&lt;JSSubscription event=&lt;JSEvent \"click\"&gt;,\n                   selector=&lt;IdSelector \"message\"&gt;,\n                   handler=&lt;function showHelloWorldAlert at ...&gt;&gt;]\n\nWe can also get a specific subscription from the manager.\n\n  &gt;&gt;&gt; manager['showHelloWorldAlert']\n  [&lt;JSSubscription event=&lt;JSEvent \"click\"&gt;,\n                  selector=&lt;IdSelector \"message\"&gt;,\n                  handler=&lt;function showHelloWorldAlert at ...&gt;&gt;]\n\nSo now, how does this get rendered into Javascript code? Since this package\nstrictly separates definition from rendering, a renderer will be responsible\nto produce the output.\n\n\nRenderers\n---------\n\nSo let's define some renderers for the various components. We have already\nprepared renderers for testing purposes in the ``testing`` support module. The\nfirst one is for the id selector\n\n  &gt;&gt;&gt; import zope.component\n  &gt;&gt;&gt; from z3c.formjs import testing\n  &gt;&gt;&gt; zope.component.provideAdapter(testing.IdSelectorRenderer)\n\nOf course, like all view components, the renderer supports the update/render\npattern. We can now render the selector:\n\n  &gt;&gt;&gt; from zope.publisher.browser import TestRequest\n  &gt;&gt;&gt; request = TestRequest()\n\n  &gt;&gt;&gt; renderer = zope.component.getMultiAdapter(\n  ...     (selector, request), interfaces.IRenderer)\n  &gt;&gt;&gt; renderer.update()\n  &gt;&gt;&gt; renderer.render()\n  u'#message'\n\nNext we need a renderer for the subscription. Let's assume we can bind the\nsubscription as follows: ``$(&lt;selector&gt;).bind(\"&lt;event&gt;\", &lt;script&gt;)``\n\n  &gt;&gt;&gt; zope.component.provideAdapter(testing.SubscriptionRenderer)\n\nRendering the subscription then returns this:\n\n  &gt;&gt;&gt; renderer = zope.component.getMultiAdapter(\n  ...     (list(manager)[0], request), interfaces.IRenderer)\n  &gt;&gt;&gt; renderer.update()\n  &gt;&gt;&gt; print renderer.render()\n  $(\"#message\").bind(\"click\", function(){alert(\"Hello World!\")});\n\nAnd now to the grant finale. We create a renderer for the subscription manager.\n\n  &gt;&gt;&gt; zope.component.provideAdapter(testing.ManagerRenderer)\n\nLet's now render the entire manager.\n\n  &gt;&gt;&gt; renderer = zope.component.getMultiAdapter(\n  ...     (manager, request), interfaces.IRenderer)\n  &gt;&gt;&gt; renderer.update()\n  &gt;&gt;&gt; print renderer.render()\n  $(document).ready(function(){\n    $(\"#message\").bind(\"click\", function(){alert(\"Hello World!\")});\n  })\n\n\nThe Subscription Decorator\n--------------------------\n\nWhen defining JS event subscriptions from within a presentation component,\nusing the low-level subscription API is somewhat cumbersome. Thus, there\nexists a decorator called ``subscribe``, which can convert a component method\nas a subscription handler. Let's have a look:\n\n  &gt;&gt;&gt; class MyView(object):\n  ...\n  ...     @jsevent.subscribe(jsevent.IdSelector('myid'), jsevent.DBLCLICK)\n  ...     def alertUser(event, selector, request):\n  ...         return u\"alert('`%s` event occured on DOM element `%s`');\" %(\n  ...             event.name, selector.id)\n\nAs you can see, the function is never really meant to be a method, but a\nsubscription handler; thus no ``self`` as first argument. The subscription is\nnow available in the subscriptions manager of the view:\n\n  &gt;&gt;&gt; list(MyView.jsSubscriptions)\n  [&lt;JSSubscription event=&lt;JSEvent \"dblclick\"&gt;,\n                   selector=&lt;IdSelector \"myid\"&gt;,\n                   handler=&lt;function alertUser at ...&gt;&gt;]\n\nLet's now render the subscription:\n\n  &gt;&gt;&gt; renderer = zope.component.getMultiAdapter(\n  ...     (list(MyView.jsSubscriptions)[0], request), interfaces.IRenderer)\n  &gt;&gt;&gt; renderer.update()\n  &gt;&gt;&gt; print renderer.render()\n  $(\"#myid\").bind(\"dblclick\",\n       function(){alert('`dblclick` event occured on DOM element `myid`');});\n\nSubscribe-decorators can also be chained, so that the same handler can be used\nfor multiple selectors and events:\n\n  &gt;&gt;&gt; class MyView(object):\n  ...\n  ...     @jsevent.subscribe(jsevent.IdSelector('myid'), jsevent.CLICK)\n  ...     @jsevent.subscribe(jsevent.IdSelector('myid'), jsevent.DBLCLICK)\n  ...     def alertUser(event, selector, request):\n  ...         return u\"alert('`%s` event occured on DOM element `%s`');\" %(\n  ...             event.name, selector.id)\n\nIn this example we register this handler for both the click and double click\nevent for the DOM element with the id \"myid\".\n\n  &gt;&gt;&gt; list(MyView.jsSubscriptions)\n  [&lt;JSSubscription event=&lt;JSEvent \"dblclick\"&gt;,\n                   selector=&lt;IdSelector \"myid\"&gt;,\n                   handler=&lt;function alertUser at ...&gt;&gt;,\n   &lt;JSSubscription event=&lt;JSEvent \"click\"&gt;,\n                   selector=&lt;IdSelector \"myid\"&gt;,\n                   handler=&lt;function alertUser at ...&gt;&gt;]\n\n\nJavascript Viewlet\n------------------\n\nPutting in the Javascript by hand in every layout is a bit lame. Instead we\ncan just register a viewlet for the JS viewlet manager that renders the\nsubscriptions if a manager is found.\n\nTo use the viewlet we need a view that provides a subscription manager:\n\n  &gt;&gt;&gt; class View(object):\n  ...     zope.interface.implements(interfaces.IHaveJSSubscriptions)\n  ...     jsSubscriptions = manager\n\nWe can now initialize, update, and finally render the viewlet:\n\n  &gt;&gt;&gt; viewlet = jsevent.JSSubscriptionsViewlet(\n  ...     object(), request, View(), object())\n  &gt;&gt;&gt; viewlet.update()\n  &gt;&gt;&gt; print viewlet.render()\n  &lt;script type=\"text/javascript\"&gt;\n  $(document).ready(function(){\n    $(\"#message\").bind(\"click\", function(){alert(\"Hello World!\")});\n  })\n  &lt;/script&gt;\n\n\nSelectors\n---------\n\nThe module provides several DOM element selectors. It is the responsibility of\nthe corresponding rednerer to interpret the selector.\n\nId Selector\n~~~~~~~~~~~\n\nThe id selector selects a DOM element by id, as seen above. It is simply\ninitialized using the the id:\n\n  &gt;&gt;&gt; idselect = jsevent.IdSelector('myid')\n  &gt;&gt;&gt; idselect\n  &lt;IdSelector \"myid\"&gt;\n\nThe id is also available as attribute:\n\n  &gt;&gt;&gt; idselect.id\n  'myid'\n\nWe already saw before how it gets rendered:\n\n  &gt;&gt;&gt; renderer = zope.component.getMultiAdapter(\n  ...     (idselect, request), interfaces.IRenderer)\n  &gt;&gt;&gt; renderer.update()\n  &gt;&gt;&gt; renderer.render()\n  u'#myid'\n\nCSS Selector\n~~~~~~~~~~~~\n\nThe CSS selector selects a DOM element using an arbitrary CSS selector\nexpression. This selector is initialized using the expression:\n\n  &gt;&gt;&gt; cssselect = jsevent.CSSSelector('div.myclass')\n  &gt;&gt;&gt; cssselect\n  &lt;CSSSelector \"div.myclass\"&gt;\n\nThe CSS selector expression is also available as attribute:\n\n  &gt;&gt;&gt; cssselect.expr\n  'div.myclass'\n\nLet's now see an example on how the CSS selector can be rendered:\n\n  &gt;&gt;&gt; zope.component.provideAdapter(testing.CSSSelectorRenderer)\n\n  &gt;&gt;&gt; renderer = zope.component.getMultiAdapter(\n  ...     (cssselect, request), interfaces.IRenderer)\n  &gt;&gt;&gt; renderer.update()\n  &gt;&gt;&gt; renderer.render()\n  u'div.myclass'\n\nSince most JS libraries support CSS selectors by default, the renderer simply\nconverts the expression to unicode.\n\n\nAvailable Events\n----------------\n\nThis package maps all of the available JavaScript events. Here is the complete\nlist:\n\n  &gt;&gt;&gt; jsevent.CLICK\n  &lt;JSEvent \"click\"&gt;\n  &gt;&gt;&gt; jsevent.DBLCLICK\n  &lt;JSEvent \"dblclick\"&gt;\n  &gt;&gt;&gt; jsevent.CHANGE\n  &lt;JSEvent \"change\"&gt;\n  &gt;&gt;&gt; jsevent.LOAD\n  &lt;JSEvent \"load\"&gt;\n  &gt;&gt;&gt; jsevent.BLUR\n  &lt;JSEvent \"blur\"&gt;\n  &gt;&gt;&gt; jsevent.FOCUS\n  &lt;JSEvent \"focus\"&gt;\n  &gt;&gt;&gt; jsevent.KEYDOWN\n  &lt;JSEvent \"keydown\"&gt;\n  &gt;&gt;&gt; jsevent.KEYUP\n  &lt;JSEvent \"keyup\"&gt;\n  &gt;&gt;&gt; jsevent.MOUSEDOWN\n  &lt;JSEvent \"mousedown\"&gt;\n  &gt;&gt;&gt; jsevent.MOUSEMOVE\n  &lt;JSEvent \"mousemove\"&gt;\n  &gt;&gt;&gt; jsevent.MOUSEOUT\n  &lt;JSEvent \"mouseout\"&gt;\n  &gt;&gt;&gt; jsevent.MOUSEOVER\n  &lt;JSEvent \"mouseover\"&gt;\n  &gt;&gt;&gt; jsevent.MOUSEUP\n  &lt;JSEvent \"mouseup\"&gt;\n  &gt;&gt;&gt; jsevent.RESIZE\n  &lt;JSEvent \"resize\"&gt;\n  &gt;&gt;&gt; jsevent.SELECT\n  &lt;JSEvent \"select\"&gt;\n  &gt;&gt;&gt; jsevent.SUBMIT\n  &lt;JSEvent \"submit\"&gt;\n\nThese are also provided as utilities so they can be looked up by name.\n\n  &gt;&gt;&gt; import zope.component\n  &gt;&gt;&gt; zope.component.provideUtility(jsevent.CLICK, name='click')\n\nOf course, we can now just look up the utility:\n\n  &gt;&gt;&gt; zope.component.getUtility(interfaces.IJSEvent, 'click')\n  &lt;JSEvent \"click\"&gt;\n\n\n=======\nCHANGES\n=======\n\nVersion 0.5.0 (2009-07-23)\n--------------------------\n\n- Feature: Update to the latest package versions.\n\n- Bug: Avoid ``ForbiddenAttribute`` in ``jsvalidator.MessageValidator``.\n\n\nVersion 0.4.1 (2008-12-16)\n--------------------------\n\n- Restructure: Use WeightOrderedViewletManager from zope.viewlet instead\n  of z3c.viewlet, that removes additional egg requirement.\n\n\nVersion 0.4.0 (2008-08-26)\n--------------------------\n\n- Feature: There is now a special unique prefix generator that uses\n  `z3c.form`'s new ``createCSSId()`` function to generate css selectable\n  prefixes for ajax forms.\n\n- Feature: There is now a viewlet manager already registered with all\n  the viewlets necessary to use `z3c.formjs`.  You can now just do:\n\n    &lt;script tal:replace=\"structure\n                         provider:z3c.formjs.interfaces.IDynamicJavaScript\"&gt;\n    &lt;/script&gt;\n\n- Feature: When AJAX handlers return complex data structures (dictionaries,\n  lists and tuples), the data is automatically converted into JSON\n  format before delivery.\n\n- Restructure: Make package run on latest z3c.form 1.9.0 release.\n\n- Bug: Widgets that were being updated multiple times were generating\n  duplicate javascript event subscriptions. This is now fixed.\n\n\nVersion 0.3.0 (2007-10-03)\n--------------------------\n\n- Feature: Made a JavaScript renderer for calls to JS Functions.\n\n- Feature: Implemented tools to make server side events propagate to\n  the client.\n\n- Feature: Now the ``jsevent.subscribe`` and ``jsaction.handler`` decorators\n  can be chained together, allowing them to be called multiple time for the\n  same methods.\n\n- Feature: Implemented ability to switch widget modes on a form.\n\n\nVersion 0.2.0 (2007-07-18)\n--------------------------\n\n- Feature: Registration of public AJAX server calls via a simple\n  decorator. The calls are made available via a special ``ajax`` view on the\n  original view.\n\n- Feature: Allow registering of JS subscriptions via a decorator within the\n  presentation component.\n\n- Feature: Added a new CSS selector.\n\n- Feature: Implementation of AJAX-driven widget value validation.\n\n- Restructure: Completely overhauled the entire API to be most easy to use and\n  have the most minimal implementation.\n\n- Bug: The package is now 100% tested.\n\n- Feature: Implementation of AJAX request handlers in forms.\n\nVersion 0.1.0 (2007-06-29)\n--------------------------\n\n- Initial Release\n\n  * Feature: JS event association with fields and buttons.\n\n\n====\nTODO\n====\n\n - client side js validators for simple fields.  (maybe we can use an\n   existing library?)", "description_content_type": null, "docs_url": null, "download_url": "UNKNOWN", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "http://pypi.python.org/pypi/z3c.formjs", "keywords": "zope3 form javascript", "license": "ZPL 2.1", "maintainer": null, "maintainer_email": null, "name": "z3c.formjs", "package_url": "https://pypi.org/project/z3c.formjs/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/z3c.formjs/", "project_urls": {"Download": "UNKNOWN", "Homepage": "http://pypi.python.org/pypi/z3c.formjs"}, "release_url": "https://pypi.org/project/z3c.formjs/0.5.0/", "requires_dist": null, "requires_python": null, "summary": "Javascript integration into ``z3c.form``", "version": "0.5.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            This package is going to provide javascript support/enhancements to<br>the z3c.form library.<br><br>Detailed Documentation<br>**********************<br><br>===========================<br>Form Javascript Integration<br>===========================<br><br>This package is designed to provide a Python API to common Javascript<br>features for forms written with the ``z3c.form*`` packages. While the<br>reference backend-implementation is for the JQuery library, any other<br>Javascript library can be hooked into the Python API.<br><br>The documents are ordered in the way they should be read:<br><br>- ``jsaction.txt`` [must read]<br><br>  This document describes how JS scripts can be connected to events on a<br>  any widget, inclduing buttons.<br><br>- ``jsvalidator.txt`` [must read]<br><br>  This document demonstrates how \"live\" widget value validation can be<br>  achieved.<br><br>- ``jsevent.txt`` [advanced users]<br><br>  This documents describes the generalization that allows hooking up script to<br>  events on any field.<br><br>- ``jqueryrenderer.txt`` [advanced users]<br><br>  This document demonstrates all necessary backend renderer components<br>  necessary to accomplish any of the features of this package.<br><br>=============================<br>Javascript Events for Buttons<br>=============================<br><br>In the ``z3c.form`` package, buttons are most commonly rendered as \"submit\"<br>input fields within a form, meaning that the form will always be<br>submitted. When working with Javascript, on the other hand, a click on the<br>button often simply executes a script. The ``jsaction`` module of this package<br>is designed to implement the latter kind.<br><br>  &amp;gt;&amp;gt;&amp;gt; from z3c.formjs import jsaction<br><br><br>Javascript Buttons<br>------------------<br><br>Before we can write a form that uses Javascript buttons, we have to define<br>them first. One common way to define buttons in ``z3c.form`` is to write a<br>schema describing them; so let's do that now:<br><br>  &amp;gt;&amp;gt;&amp;gt; import zope.interface<br>  &amp;gt;&amp;gt;&amp;gt; class IButtons(zope.interface.Interface):<br>  ...     hello = jsaction.JSButton(title=u'Hello World!')<br>  ...     dblhello = jsaction.JSButton(title=u'Double Hello World!')<br><br>Instead of declaring ``z3c.form.button.Button`` fields, we are now using a<br>derived Javascript button field. While there is no difference initially, they<br>will later be rendered differently. (Basically, ``JSButton`` fields render as<br>button widgets.)<br><br><br>Widget Selector<br>---------------<br><br>Like for regular fields, the action of the buttons is defined using handlers,<br>in our case Javascript handler. Selectors are used to determine the DOM<br>element or elements for which a handler is registered. The widget selector<br>uses a widget to provide the selector API:<br><br>  &amp;gt;&amp;gt;&amp;gt; from z3c.form.testing import TestRequest<br>  &amp;gt;&amp;gt;&amp;gt; request = TestRequest()<br><br>  &amp;gt;&amp;gt;&amp;gt; from z3c.form.browser import text<br>  &amp;gt;&amp;gt;&amp;gt; msg = text.TextWidget(request)<br>  &amp;gt;&amp;gt;&amp;gt; msg.id = 'form-msg'<br>  &amp;gt;&amp;gt;&amp;gt; msg.name = 'msg'<br><br>  &amp;gt;&amp;gt;&amp;gt; selector = jsaction.WidgetSelector(msg)<br>  &amp;gt;&amp;gt;&amp;gt; selector<br>  &amp;lt;WidgetSelector \"form-msg\"&amp;gt;<br><br>Since the widget selector can determine the widget's id, it is also an id<br>selector (see ``jsevent.txt``):<br><br>  &amp;gt;&amp;gt;&amp;gt; from z3c.formjs import interfaces<br>  &amp;gt;&amp;gt;&amp;gt; interfaces.IIdSelector.providedBy(selector)<br>  True<br>  &amp;gt;&amp;gt;&amp;gt; selector.id<br>  'form-msg'<br><br>This has the advantage that we can reuse the renderer of the id<br>selector.<br><br><br>Javascript Event Subscriptions<br>------------------------------<br><br>As discussed in ``jsevent.txt``, all the Javascript event subscriptions are<br>stored on the view in a special attribute called ``jsSubscriptions``. While<br>updating the form, one can simply add subscriptions to this registry. So let's<br>say we have the following handler:<br><br>  &amp;gt;&amp;gt;&amp;gt; def showSelectedWidget(event, selector, request):<br>  ...     return 'alert(\"%r\");' %(selector.widget)<br><br>We now want to connect this handler to the ``msg`` widget to be executed when<br>the mouse is clicked within this element:<br><br>  &amp;gt;&amp;gt;&amp;gt; import zope.interface<br>  &amp;gt;&amp;gt;&amp;gt; from z3c.formjs import jsevent<br><br>  &amp;gt;&amp;gt;&amp;gt; class Form(object):<br>  ...     zope.interface.implements(interfaces.IHaveJSSubscriptions)<br>  ...     jsSubscriptions = jsevent.JSSubscriptions()<br>  ...<br>  ...     def update(self):<br>  ...         self.jsSubscriptions.subscribe(<br>  ...             jsevent.CLICK, selector, showSelectedWidget)<br><br>  &amp;gt;&amp;gt;&amp;gt; form = Form()<br>  &amp;gt;&amp;gt;&amp;gt; form.update()<br><br>After registering the subscription-related renderers,<br><br>  &amp;gt;&amp;gt;&amp;gt; from z3c.formjs import testing<br>  &amp;gt;&amp;gt;&amp;gt; testing.setupRenderers()<br><br>we can use the subscription rendering viewlet to check the subscription<br>output:<br><br>  &amp;gt;&amp;gt;&amp;gt; viewlet = jsevent.JSSubscriptionsViewlet(None, request, form, None)<br>  &amp;gt;&amp;gt;&amp;gt; viewlet.update()<br>  &amp;gt;&amp;gt;&amp;gt; print viewlet.render()<br>  &amp;lt;script type=\"text/javascript\"&amp;gt;<br>    $(document).ready(function(){<br>      $(\"#form-msg\").bind(\"click\", function(){alert(\"&amp;lt;TextWidget 'msg'&amp;gt;\");});<br>    })<br>  &amp;lt;/script&amp;gt;<br><br>The z3c.formjs package provides a viewlet manager with this viewlet<br>already registered for it.  The viewlet manager has the name<br>``z3c.formjs.interfaces.IDynamicJavaScript`` and can be rendered in<br>any template with the following:<br><br>  &amp;lt;script tal:replace=\"structure<br>                       provider:z3c.formjs.interfaces.IDynamicJavaScript\"&amp;gt;<br>  &amp;lt;/script&amp;gt;<br><br><br>Forms with Javascript Buttons<br>-----------------------------<br><br>The next step is create the form. Luckily we do not need any fields to<br>render a form. Also, instead of using usual<br>``z3c.form.button.handler()`` function, we now have a special handler<br>decorator that connects a button to a Javascript event, along with an<br>additional decorator that creates the button at the same time. The<br>output of the handler itself is a string that is used as the<br>Javascript script that is executed.<br><br>  &amp;gt;&amp;gt;&amp;gt; from z3c.form import button, form<br><br>  &amp;gt;&amp;gt;&amp;gt; class Form(form.Form):<br>  ...     buttons = button.Buttons(IButtons)<br>  ...<br>  ...     @jsaction.handler(buttons['hello'])<br>  ...     def showHelloWorldMessage(self, event, selector):<br>  ...         return 'alert(\"%s\");' % selector.widget.title<br>  ...<br>  ...     @jsaction.handler(buttons['dblhello'], event=jsevent.DBLCLICK)<br>  ...     def showDoubleHelloWorldMessage(self, event, selector):<br>  ...         return 'alert(\"%s\");' % selector.widget.title<br>  ...<br>  ...     @jsaction.buttonAndHandler(u\"Click Me\")<br>  ...     def handleClickMe(self, event, selector):<br>  ...         return 'alert(\"You clicked the Click Me button.\");'<br><br><br><br>The ``handler()`` decorator takes two arguments, the button (acting as the DOM<br>element selector) and the event to which to bind the action. By default the<br>event is ``jsevent.CLICK``.<br><br>And that is really everything that is required from a user's point of<br>view. Let us now see how those handler declarations are converted into actions<br>and Javascript subscriptions. First we need to initialize the form:<br><br>  &amp;gt;&amp;gt;&amp;gt; from z3c.form.testing import TestRequest<br>  &amp;gt;&amp;gt;&amp;gt; request = TestRequest()<br><br>  &amp;gt;&amp;gt;&amp;gt; demoform = Form(None, request)<br><br>We also need to register an adapter to create an action from a button:<br><br>  &amp;gt;&amp;gt;&amp;gt; from z3c.form.interfaces import IButtonAction<br>  &amp;gt;&amp;gt;&amp;gt; zope.component.provideAdapter(<br>  ...     jsaction.JSButtonAction, provides=IButtonAction)<br><br>Finally, for the Javascript subscriptions to be registered, we need an event<br>listener that reacts to \"after widget/action update\" events:<br><br>  &amp;gt;&amp;gt;&amp;gt; zope.component.provideHandler(jsaction.createSubscriptionsForWidget)<br><br>Action managers are instantiated using the form, request, and<br>context/content. A button-action-manager implementation is avaialble in the<br>``z3c.form.button`` package:<br><br>  &amp;gt;&amp;gt;&amp;gt; actions = button.ButtonActions(demoform, request, None)<br>  &amp;gt;&amp;gt;&amp;gt; actions.update()<br><br>Once the action manager is updated, the buttons should be available as<br>actions:<br><br>  &amp;gt;&amp;gt;&amp;gt; actions.keys()<br>  ['hello', 'dblhello', '436c69636b204d65']<br>  &amp;gt;&amp;gt;&amp;gt; actions['hello']<br>  &amp;lt;JSButtonAction 'form.buttons.hello' u'Hello World!'&amp;gt;<br><br>Since special Javascript handlers were registered for those buttons, creating<br>and updating the actions has also caused the form to become an<br>``IHaveJSSubscriptions`` view:<br><br>  &amp;gt;&amp;gt;&amp;gt; from z3c.formjs import interfaces<br><br>  &amp;gt;&amp;gt;&amp;gt; interfaces.IHaveJSSubscriptions.providedBy(demoform)<br>  True<br>  &amp;gt;&amp;gt;&amp;gt; demoform.jsSubscriptions<br>  &amp;lt;z3c.formjs.jsevent.JSSubscriptions object at ...&amp;gt;<br><br>The interesting part about button subscriptions is the selector.<br><br>  &amp;gt;&amp;gt;&amp;gt; selector = list(demoform.jsSubscriptions)[0].selector<br>  &amp;gt;&amp;gt;&amp;gt; selector<br>  &amp;lt;WidgetSelector \"form-buttons-hello\"&amp;gt;<br><br>As you can see, the system automatically created a widget selector:<br><br>  &amp;gt;&amp;gt;&amp;gt; selector.id<br>  'form-buttons-hello'<br>  &amp;gt;&amp;gt;&amp;gt; selector.widget<br>  &amp;lt;JSButtonAction 'form.buttons.hello' u'Hello World!'&amp;gt;<br><br>With the declarations in place, we can now go on.<br><br><br>Rendering the Form<br>------------------<br><br>Let's now see what we need to do to make the form render correctly and<br>completely.<br><br>  &amp;gt;&amp;gt;&amp;gt; demoform = Form(None, request)<br><br>First we need some of the standard ``z3c.form`` registrations:<br><br>  &amp;gt;&amp;gt;&amp;gt; from z3c.form import field, button<br>  &amp;gt;&amp;gt;&amp;gt; zope.component.provideAdapter(field.FieldWidgets)<br>  &amp;gt;&amp;gt;&amp;gt; zope.component.provideAdapter(button.ButtonActions)<br><br>Next we need to register the template for our button actions:<br><br>  &amp;gt;&amp;gt;&amp;gt; from zope.pagetemplate.interfaces import IPageTemplate<br>  &amp;gt;&amp;gt;&amp;gt; from z3c.form import widget<br>  &amp;gt;&amp;gt;&amp;gt; from z3c.form.interfaces import IButtonWidget, INPUT_MODE<br>  &amp;gt;&amp;gt;&amp;gt; from z3c.form.testing import getPath<br><br>  &amp;gt;&amp;gt;&amp;gt; zope.component.provideAdapter(<br>  ...     widget.WidgetTemplateFactory(getPath('button_input.pt'), 'text/html'),<br>  ...     (None, None, None, None, IButtonWidget),<br>  ...     IPageTemplate, name=INPUT_MODE)<br><br>We also need to setup a Javascript viewlet manager and register the<br>subscription viewlet for it, so that the subscriptions actually appear in the<br>HTML page. (This is a bit tedious to do using the Python API, but using ZCML<br>this is much simpler.)<br><br>* Hook up the \"provider\" TALES expression type:<br><br>  &amp;gt;&amp;gt;&amp;gt; from zope.pagetemplate.engine import TrustedEngine<br>  &amp;gt;&amp;gt;&amp;gt; from zope.contentprovider import tales<br>  &amp;gt;&amp;gt;&amp;gt; TrustedEngine.registerType('provider', tales.TALESProviderExpression)<br><br>* Create a viewlet manager that does not require security to be setup:<br><br>  &amp;gt;&amp;gt;&amp;gt; from zope.viewlet import manager<br>  &amp;gt;&amp;gt;&amp;gt; class JSViewletManager(manager.ViewletManagerBase):<br>  ...     def filter(self, viewlets):<br>  ...         return viewlets<br><br>* Register the viewlet manager as a content provider known as \"javascript\":<br><br>  &amp;gt;&amp;gt;&amp;gt; from z3c.form.interfaces import IFormLayer<br>  &amp;gt;&amp;gt;&amp;gt; from zope.contentprovider.interfaces import IContentProvider<br>  &amp;gt;&amp;gt;&amp;gt; zope.component.provideAdapter(<br>  ...     JSViewletManager,<br>  ...     (None, IFormLayer, None),<br>  ...     IContentProvider,<br>  ...     name='javascript')<br><br>* Register the JS Subscriber viewlet for this new viewlet manager:<br><br>  &amp;gt;&amp;gt;&amp;gt; from zope.viewlet.interfaces import IViewlet<br>  &amp;gt;&amp;gt;&amp;gt; zope.component.provideAdapter(<br>  ...     jsevent.JSSubscriptionsViewlet,<br>  ...     (None, IFormLayer, interfaces.IHaveJSSubscriptions,<br>  ...      JSViewletManager), IViewlet, name='subscriptions')<br><br>Finally, we need a template for our form:<br><br>  &amp;gt;&amp;gt;&amp;gt; testing.addTemplate(demoform, 'buttons_form.pt')<br><br>We can now render the form:<br><br>  &amp;gt;&amp;gt;&amp;gt; demoform.update()<br>  &amp;gt;&amp;gt;&amp;gt; print demoform.render()<br>  &amp;lt;html&amp;gt;<br>    &amp;lt;head&amp;gt;<br>      &amp;lt;script type=\"text/javascript\"&amp;gt;<br>        $(document).ready(function(){<br>          $(\"#form-buttons-hello\").bind(\"click\",<br>              function(){alert(\"Hello World!\");});<br>          $(\"#form-buttons-dblhello\").bind(\"dblclick\",<br>              function(){alert(\"Double Hello World!\");});<br>          $(\"#form-buttons-436c69636b204d65\").bind(\"click\",<br>              function(){alert(\"You clicked the Click Me button.\");});<br>        })<br>      &amp;lt;/script&amp;gt;<br>    &amp;lt;/head&amp;gt;<br>    &amp;lt;body&amp;gt;<br>      &amp;lt;div class=\"action\"&amp;gt;<br>        &amp;lt;input type=\"button\" id=\"form-buttons-hello\"<br>               name=\"form.buttons.hello\" class=\"button-widget jsbutton-field\"<br>               value=\"Hello World!\" /&amp;gt;<br>      &amp;lt;/div&amp;gt;<br>      &amp;lt;div class=\"action\"&amp;gt;<br>        &amp;lt;input type=\"button\" id=\"form-buttons-dblhello\"<br>               name=\"form.buttons.dblhello\" class=\"button-widget jsbutton-field\"<br>               value=\"Double Hello World!\" /&amp;gt;<br>      &amp;lt;/div&amp;gt;<br>      &amp;lt;div class=\"action\"&amp;gt;<br>        &amp;lt;input type=\"button\" id=\"form-buttons-436c69636b204d65\"<br>         name=\"form.buttons.436c69636b204d65\"<br>         class=\"button-widget jsbutton-field\" value=\"Click Me\" /&amp;gt;<br>      &amp;lt;/div&amp;gt;<br>    &amp;lt;/body&amp;gt;<br>  &amp;lt;/html&amp;gt;<br><br>As you can see, the subscriptions are correctly placed into the header, while<br>the buttons render as usual with exception to the input type, which is now a<br>\"button\".<br><br><br>Multiple Handlers<br>-----------------<br><br>Since there are multiple events in Javascript, one element can have multiple<br>handlers. So let's define a new form that declares two handlers for the same<br>button:<br><br>  &amp;gt;&amp;gt;&amp;gt; class Form(form.Form):<br>  ...     buttons = button.Buttons(IButtons).select('hello')<br>  ...<br>  ...     @jsaction.handler(buttons['hello'])<br>  ...     def showHelloWorldMessage(self, event, selector):<br>  ...         return 'alert(\"Hello World!\");'<br>  ...<br>  ...     @jsaction.handler(buttons['hello'], event=jsevent.DBLCLICK)<br>  ...     def showDoubleHelloWorldMessage(self, event, selector):<br>  ...         return 'alert(\"Hello World! x 2\");'<br><br>Let's now instantiate and update the form:<br><br>  &amp;gt;&amp;gt;&amp;gt; demoform = Form(None, request)<br>  &amp;gt;&amp;gt;&amp;gt; demoform.update()<br><br>The subscriptions are now available:<br><br>  &amp;gt;&amp;gt;&amp;gt; list(demoform.jsSubscriptions)<br>  [&amp;lt;JSSubscription<br>       event=&amp;lt;JSEvent \"click\"&amp;gt;,<br>       selector=&amp;lt;WidgetSelector \"form-buttons-hello\"&amp;gt;,<br>       handler=&amp;lt;JSHandler &amp;lt;function showHelloWorldMessage ...&amp;gt;&amp;gt;&amp;gt;,<br>   &amp;lt;JSSubscription<br>       event=&amp;lt;JSEvent \"dblclick\"&amp;gt;,<br>       selector=&amp;lt;WidgetSelector \"form-buttons-hello\"&amp;gt;,<br>       handler=&amp;lt;JSHandler &amp;lt;function showDoubleHelloWorldMessage ...&amp;gt;&amp;gt;&amp;gt;]<br><br>Next we can look at a case where one handler is registered for all buttons and<br>events, and another overrides the click of the \"hello\" button to something<br>else:<br><br>  &amp;gt;&amp;gt;&amp;gt; from z3c.form.interfaces import IButton<br>  &amp;gt;&amp;gt;&amp;gt; class Form(form.Form):<br>  ...     buttons = button.Buttons(IButtons)<br>  ...<br>  ...     @jsaction.handler(IButton, interfaces.IJSEvent)<br>  ...     def showHelloWorldMessage(self, event, selector):<br>  ...         return '''alert(\"The event '%s' occured.\");''' %event.name<br>  ...<br>  ...     @jsaction.handler(buttons['hello'], event=jsevent.CLICK)<br>  ...     def showDoubleHelloWorldMessage(self, event, selector):<br>  ...         return 'alert(\"Hello World clicked!\");'<br><br>  &amp;gt;&amp;gt;&amp;gt; demoform = Form(None, request)<br>  &amp;gt;&amp;gt;&amp;gt; demoform.update()<br><br>Rendering the subscriptions gives the following result:<br><br>  &amp;gt;&amp;gt;&amp;gt; renderer = zope.component.getMultiAdapter(<br>  ...     (demoform.jsSubscriptions, request), interfaces.IRenderer)<br>  &amp;gt;&amp;gt;&amp;gt; renderer.update()<br>  &amp;gt;&amp;gt;&amp;gt; print renderer.render()<br>  $(document).ready(function(){<br>    $(\"#...-hello\").bind(\"dblclick\", function(){alert(\"The ...\");});<br>    $(\"#...-hello\").bind(\"change\", function(){alert(\"The ...\");});<br>    $(\"#...-hello\").bind(\"load\", function(){alert(\"The ...\");});<br>    $(\"#...-hello\").bind(\"blur\", function(){alert(\"The ...\");});<br>    $(\"#...-hello\").bind(\"focus\", function(){alert(\"The ...\");});<br>    $(\"#...-hello\").bind(\"keydown\", function(){alert(\"The ...\");});<br>    $(\"#...-hello\").bind(\"keyup\", function(){alert(\"The ...\");});<br>    $(\"#...-hello\").bind(\"mousedown\", function(){alert(\"The ...\");});<br>    $(\"#...-hello\").bind(\"mousemove\", function(){alert(\"The ...\");});<br>    $(\"#...-hello\").bind(\"mouseout\", function(){alert(\"The ...\");});<br>    $(\"#...-hello\").bind(\"mouseover\", function(){alert(\"The ...\");});<br>    $(\"#...-hello\").bind(\"mouseup\", function(){alert(\"The ...\");});<br>    $(\"#...-hello\").bind(\"resize\", function(){alert(\"The ...\");});<br>    $(\"#...-hello\").bind(\"select\", function(){alert(\"The ...\");});<br>    $(\"#...-hello\").bind(\"submit\", function(){alert(\"The ...\");});<br>    $(\"#...-dblhello\").bind(\"click\", function(){alert(\"The ...\");});<br>    $(\"#...-dblhello\").bind(\"dblclick\", function(){alert(\"The ...\");});<br>    $(\"#...-dblhello\").bind(\"change\", function(){alert(\"The ...\");});<br>    $(\"#...-dblhello\").bind(\"load\", function(){alert(\"The ...\");});<br>    $(\"#...-dblhello\").bind(\"blur\", function(){alert(\"The ...\");});<br>    $(\"#...-dblhello\").bind(\"focus\", function(){alert(\"The ...\");});<br>    $(\"#...-dblhello\").bind(\"keydown\", function(){alert(\"The ...\");});<br>    $(\"#...-dblhello\").bind(\"keyup\", function(){alert(\"The ...\");});<br>    $(\"#...-dblhello\").bind(\"mousedown\", function(){alert(\"The ...\");});<br>    $(\"#...-dblhello\").bind(\"mousemove\", function(){alert(\"The ...\");});<br>    $(\"#...-dblhello\").bind(\"mouseout\", function(){alert(\"The ...\");});<br>    $(\"#...-dblhello\").bind(\"mouseover\", function(){alert(\"The ...\");});<br>    $(\"#...-dblhello\").bind(\"mouseup\", function(){alert(\"The ...\");});<br>    $(\"#...-dblhello\").bind(\"resize\", function(){alert(\"The ...\");});<br>    $(\"#...-dblhello\").bind(\"select\", function(){alert(\"The ...\");});<br>    $(\"#...-dblhello\").bind(\"submit\", function(){alert(\"The ...\");});<br>    $(\"#...-hello\").bind(\"click\", function(){alert(\"Hello World clicked!\");});<br>  })<br><br>While this output might seem excessive, it demonstrates that the generic<br>``IJSEvent`` subscription truly causes a subscription to all events. Further,<br>a more specific directive takes precendence over the more generic one. This is<br>due to the built-in adapter registry of the ``JSHandlers`` class.<br><br>Finally, handler declarations can also be chained, allowing a handler to be<br>registered for multiple field-event combinations that cannot be expressed by<br>common interfaces:<br><br>  &amp;gt;&amp;gt;&amp;gt; class Form(form.Form):<br>  ...     buttons = button.Buttons(IButtons)<br>  ...<br>  ...     @jsaction.handler(IButtons['hello'], jsevent.CLICK)<br>  ...     @jsaction.handler(IButtons['hello'], jsevent.DBLCLICK)<br>  ...     def showHelloWorldMessage(self, event, selector):<br>  ...         return '''alert(\"The event '%s' occured.\");''' %event.name<br><br>  &amp;gt;&amp;gt;&amp;gt; demoform = Form(None, request)<br>  &amp;gt;&amp;gt;&amp;gt; demoform.update()<br><br>Rendering the subscriptions gives the following result:<br><br>  &amp;gt;&amp;gt;&amp;gt; renderer = zope.component.getMultiAdapter(<br>  ...     (demoform.jsSubscriptions, request), interfaces.IRenderer)<br>  &amp;gt;&amp;gt;&amp;gt; renderer.update()<br>  &amp;gt;&amp;gt;&amp;gt; print renderer.render()<br>  $(document).ready(function(){<br>    $(\"#form-buttons-hello\").bind(\"click\", function(){alert(\"The ...\");});<br>    $(\"#form-buttons-hello\").bind(\"dblclick\", function(){alert(\"The ...\");});<br>  })<br><br><br>Attaching Events to Form Fields<br>-------------------------------<br><br>Javascript handlers do not only work for buttons, but also for fields. Let's<br>create a simple schema that we can use to create a form:<br><br>  &amp;gt;&amp;gt;&amp;gt; import zope.schema<br><br>  &amp;gt;&amp;gt;&amp;gt; class IPerson(zope.interface.Interface):<br>  ...     name = zope.schema.TextLine(title=u'Name')<br>  ...     age = zope.schema.Int(title=u'Age')<br><br>Even though somewhat pointless, whenever the \"age\" field is clicked on or the<br>\"name\" widget value changed, we would like to get an alert:<br><br>  &amp;gt;&amp;gt;&amp;gt; class PersonAddForm(form.AddForm):<br>  ...     fields = field.Fields(IPerson)<br>  ...<br>  ...     @jsaction.handler(fields['age'])<br>  ...     def ageClickEvent(self, event, selector):<br>  ...         return 'alert(\"The Age was Clicked!\");'<br>  ...<br>  ...     @jsaction.handler(fields['name'], event=jsevent.CHANGE)<br>  ...     def nameChangeEvent(self, event, selector):<br>  ...         return 'alert(\"The Name was Changed!\");'<br><br>We also need to register all of the default ``z3c.form`` registrations:<br><br>  &amp;gt;&amp;gt;&amp;gt; from z3c.form.testing import setupFormDefaults<br>  &amp;gt;&amp;gt;&amp;gt; setupFormDefaults()<br><br>After adding a simple template for the form, it can be rendered:<br><br>  &amp;gt;&amp;gt;&amp;gt; addform = PersonAddForm(None, request)<br>  &amp;gt;&amp;gt;&amp;gt; testing.addTemplate(addform, 'simple_edit.pt')<br>  &amp;gt;&amp;gt;&amp;gt; addform.update()<br>  &amp;gt;&amp;gt;&amp;gt; print addform.render()<br>  &amp;lt;html&amp;gt;<br>    &amp;lt;head&amp;gt;<br>      &amp;lt;script type=\"text/javascript\"&amp;gt;<br>  $(document).ready(function(){<br>    $(\"#form-widgets-name\").bind(\"change\",<br>                                 function(){alert(\"The Name was Changed!\");});<br>    $(\"#form-widgets-age\").bind(\"click\",<br>                                function(){alert(\"The Age was Clicked!\");});<br>  })<br>  &amp;lt;/script&amp;gt;<br>    &amp;lt;/head&amp;gt;<br>    &amp;lt;body&amp;gt;<br>  &amp;lt;BLANKLINE&amp;gt;<br>  &amp;lt;BLANKLINE&amp;gt;<br>      &amp;lt;form action=\".\"&amp;gt;<br>        &amp;lt;div class=\"row\"&amp;gt;<br>          &amp;lt;label for=\"form-widgets-name\"&amp;gt;Name&amp;lt;/label&amp;gt;<br>  &amp;lt;BLANKLINE&amp;gt;<br>      &amp;lt;input id=\"form-widgets-name\" name=\"form.widgets.name\"<br>             class=\"text-widget required textline-field\"<br>             value=\"\" type=\"text\" /&amp;gt;<br>  &amp;lt;BLANKLINE&amp;gt;<br>  &amp;lt;/div&amp;gt;<br>        &amp;lt;div class=\"row\"&amp;gt;<br>          &amp;lt;label for=\"form-widgets-age\"&amp;gt;Age&amp;lt;/label&amp;gt;<br>  &amp;lt;BLANKLINE&amp;gt;<br>      &amp;lt;input id=\"form-widgets-age\" name=\"form.widgets.age\"<br>             class=\"text-widget required int-field\" value=\"\"<br>             type=\"text\" /&amp;gt;<br>  &amp;lt;BLANKLINE&amp;gt;<br>  &amp;lt;/div&amp;gt;<br>        &amp;lt;div class=\"action\"&amp;gt;<br>  &amp;lt;BLANKLINE&amp;gt;<br>  &amp;lt;input id=\"form-buttons-add\" name=\"form.buttons.add\"<br>         class=\"submit-widget button-field\" value=\"Add\"<br>         type=\"submit\" /&amp;gt;<br>  &amp;lt;BLANKLINE&amp;gt;<br>  &amp;lt;/div&amp;gt;<br>      &amp;lt;/form&amp;gt;<br>    &amp;lt;/body&amp;gt;<br>  &amp;lt;/html&amp;gt;<br><br>As you can see, the form rendered perferctly, even allowing classic and<br>Javascript handlers to co-exist.<br><br><br>Appendix A: Javascript Event Handlers Manager<br>---------------------------------------------<br><br>The ``IJSEventHandlers`` implementataion (``JSHandlers`` class) is really an<br>advanced component with great features, so it deserves some additional<br>attention.<br><br>  &amp;gt;&amp;gt;&amp;gt; handlers = jsaction.JSHandlers()<br>  &amp;gt;&amp;gt;&amp;gt; handlers<br>  &amp;lt;JSHandlers []&amp;gt;<br><br>When a handlers component is initialized, it creates an internal adapter<br>registry. If a handler is registered for a button, it simply behaves as an<br>instance-adapter.<br><br>  &amp;gt;&amp;gt;&amp;gt; handlers._registry<br>  &amp;lt;zope.interface.adapter.AdapterRegistry object at ...&amp;gt;<br><br>The object itself is pretty simple. To add a handler, we first have to create<br>a handler, ...<br><br>  &amp;gt;&amp;gt;&amp;gt; def doSomething(form, event, selector):<br>  ...     pass<br>  &amp;gt;&amp;gt;&amp;gt; handler = jsaction.JSHandler(doSomething)<br><br>The only special thing about the handler is that it has the same name<br>as the function.<br><br>  &amp;gt;&amp;gt;&amp;gt; handler.__name__<br>  'doSomething'<br><br>and a field/button:<br><br>  &amp;gt;&amp;gt;&amp;gt; button1 = jsaction.JSButton(name='button1', title=u'Button 1')<br><br>Let's now add the handler:<br><br>  &amp;gt;&amp;gt;&amp;gt; handlers.addHandler(button1, jsevent.CLICK, handler)<br><br>But you can also register handlers for groups of fields, either by interface<br>or class:<br><br>  &amp;gt;&amp;gt;&amp;gt; class SpecialButton(jsaction.JSButton):<br>  ...     pass<br><br>  &amp;gt;&amp;gt;&amp;gt; handlers.addHandler(<br>  ...     SpecialButton, jsevent.CLICK, jsaction.JSHandler('specialAction'))<br><br>  &amp;gt;&amp;gt;&amp;gt; handlers<br>  &amp;lt;JSHandlers<br>      [&amp;lt;JSHandler &amp;lt;function doSomething at ...&amp;gt;&amp;gt;,<br>       &amp;lt;JSHandler 'specialAction'&amp;gt;]&amp;gt;<br><br>Now all special buttons should use that handler:<br><br>  &amp;gt;&amp;gt;&amp;gt; button2 = SpecialButton(name='button2', title=u'Button 2')<br>  &amp;gt;&amp;gt;&amp;gt; button3 = SpecialButton(name='button3', title=u'Button 3')<br><br>  &amp;gt;&amp;gt;&amp;gt; handlers.getHandlers(button2)<br>  ((&amp;lt;JSEvent \"click\"&amp;gt;, &amp;lt;JSHandler 'specialAction'&amp;gt;),)<br>  &amp;gt;&amp;gt;&amp;gt; handlers.getHandlers(button3)<br>  ((&amp;lt;JSEvent \"click\"&amp;gt;, &amp;lt;JSHandler 'specialAction'&amp;gt;),)<br><br>However, registering a more specific handler for button 2 will override the<br>general handler:<br><br>  &amp;gt;&amp;gt;&amp;gt; handlers.addHandler(<br>  ...     button2, jsevent.CLICK, jsaction.JSHandler('specificAction2'))<br><br>  &amp;gt;&amp;gt;&amp;gt; handlers.getHandlers(button2)<br>  ((&amp;lt;JSEvent \"click\"&amp;gt;, &amp;lt;JSHandler 'specificAction2'&amp;gt;),)<br>  &amp;gt;&amp;gt;&amp;gt; handlers.getHandlers(button3)<br>  ((&amp;lt;JSEvent \"click\"&amp;gt;, &amp;lt;JSHandler 'specialAction'&amp;gt;),)<br><br>The same flexibility that is available to the field is also available for the<br>event.<br><br>  &amp;gt;&amp;gt;&amp;gt; handlers = jsaction.JSHandlers()<br><br>So let's register a generic handler for all events:<br><br>  &amp;gt;&amp;gt;&amp;gt; handlers.addHandler(<br>  ...     jsaction.JSButton, jsevent.JSEvent,<br>  ...     jsaction.JSHandler('genericEventAction'))<br><br>So when asking for the handlers of button 1, we get a very long list:<br><br>  &amp;gt;&amp;gt;&amp;gt; handlers.getHandlers(button1)<br>  ((&amp;lt;JSEvent \"click\"&amp;gt;, &amp;lt;JSHandler 'genericEventAction'&amp;gt;),<br>   (&amp;lt;JSEvent \"dblclick\"&amp;gt;, &amp;lt;JSHandler 'genericEventAction'&amp;gt;),<br>   (&amp;lt;JSEvent \"change\"&amp;gt;, &amp;lt;JSHandler 'genericEventAction'&amp;gt;),<br>   (&amp;lt;JSEvent \"load\"&amp;gt;, &amp;lt;JSHandler 'genericEventAction'&amp;gt;),<br>   (&amp;lt;JSEvent \"blur\"&amp;gt;, &amp;lt;JSHandler 'genericEventAction'&amp;gt;),<br>   (&amp;lt;JSEvent \"focus\"&amp;gt;, &amp;lt;JSHandler 'genericEventAction'&amp;gt;),<br>   (&amp;lt;JSEvent \"keydown\"&amp;gt;, &amp;lt;JSHandler 'genericEventAction'&amp;gt;),<br>   (&amp;lt;JSEvent \"keyup\"&amp;gt;, &amp;lt;JSHandler 'genericEventAction'&amp;gt;),<br>   (&amp;lt;JSEvent \"mousedown\"&amp;gt;, &amp;lt;JSHandler 'genericEventAction'&amp;gt;),<br>   (&amp;lt;JSEvent \"mousemove\"&amp;gt;, &amp;lt;JSHandler 'genericEventAction'&amp;gt;),<br>   (&amp;lt;JSEvent \"mouseout\"&amp;gt;, &amp;lt;JSHandler 'genericEventAction'&amp;gt;),<br>   (&amp;lt;JSEvent \"mouseover\"&amp;gt;, &amp;lt;JSHandler 'genericEventAction'&amp;gt;),<br>   (&amp;lt;JSEvent \"mouseup\"&amp;gt;, &amp;lt;JSHandler 'genericEventAction'&amp;gt;),<br>   (&amp;lt;JSEvent \"resize\"&amp;gt;, &amp;lt;JSHandler 'genericEventAction'&amp;gt;),<br>   (&amp;lt;JSEvent \"select\"&amp;gt;, &amp;lt;JSHandler 'genericEventAction'&amp;gt;),<br>   (&amp;lt;JSEvent \"submit\"&amp;gt;, &amp;lt;JSHandler 'genericEventAction'&amp;gt;))<br><br>So at this point you might ask: How is the complete set of events determined?<br>At this point we use the list of all events as listed in the<br>``jsevent.EVENTS`` variable.<br><br>Let's now register a special handler for the \"click\" event:<br><br>  &amp;gt;&amp;gt;&amp;gt; handlers.addHandler(<br>  ...     button1, jsevent.CLICK, jsaction.JSHandler('clickEventAction'))<br><br>So this registration takes precedence over the generic one:<br><br>  &amp;gt;&amp;gt;&amp;gt; handlers.getHandlers(button1)<br>  ((&amp;lt;JSEvent \"click\"&amp;gt;, &amp;lt;JSHandler 'clickEventAction'&amp;gt;),<br>   (&amp;lt;JSEvent \"dblclick\"&amp;gt;, &amp;lt;JSHandler 'genericEventAction'&amp;gt;),<br>   (&amp;lt;JSEvent \"change\"&amp;gt;, &amp;lt;JSHandler 'genericEventAction'&amp;gt;),<br>   (&amp;lt;JSEvent \"load\"&amp;gt;, &amp;lt;JSHandler 'genericEventAction'&amp;gt;),<br>   (&amp;lt;JSEvent \"blur\"&amp;gt;, &amp;lt;JSHandler 'genericEventAction'&amp;gt;),<br>   (&amp;lt;JSEvent \"focus\"&amp;gt;, &amp;lt;JSHandler 'genericEventAction'&amp;gt;),<br>   (&amp;lt;JSEvent \"keydown\"&amp;gt;, &amp;lt;JSHandler 'genericEventAction'&amp;gt;),<br>   (&amp;lt;JSEvent \"keyup\"&amp;gt;, &amp;lt;JSHandler 'genericEventAction'&amp;gt;),<br>   (&amp;lt;JSEvent \"mousedown\"&amp;gt;, &amp;lt;JSHandler 'genericEventAction'&amp;gt;),<br>   (&amp;lt;JSEvent \"mousemove\"&amp;gt;, &amp;lt;JSHandler 'genericEventAction'&amp;gt;),<br>   (&amp;lt;JSEvent \"mouseout\"&amp;gt;, &amp;lt;JSHandler 'genericEventAction'&amp;gt;),<br>   (&amp;lt;JSEvent \"mouseover\"&amp;gt;, &amp;lt;JSHandler 'genericEventAction'&amp;gt;),<br>   (&amp;lt;JSEvent \"mouseup\"&amp;gt;, &amp;lt;JSHandler 'genericEventAction'&amp;gt;),<br>   (&amp;lt;JSEvent \"resize\"&amp;gt;, &amp;lt;JSHandler 'genericEventAction'&amp;gt;),<br>   (&amp;lt;JSEvent \"select\"&amp;gt;, &amp;lt;JSHandler 'genericEventAction'&amp;gt;),<br>   (&amp;lt;JSEvent \"submit\"&amp;gt;, &amp;lt;JSHandler 'genericEventAction'&amp;gt;))<br><br>You can also add handlers objects:<br><br>  &amp;gt;&amp;gt;&amp;gt; handlers = jsaction.JSHandlers()<br>  &amp;gt;&amp;gt;&amp;gt; handlers.addHandler(<br>  ...     button1, jsevent.CLICK, jsaction.JSHandler('button1ClickAction'))<br><br>  &amp;gt;&amp;gt;&amp;gt; handlers2 = jsaction.JSHandlers()<br>  &amp;gt;&amp;gt;&amp;gt; handlers2.addHandler(<br>  ...     button2, jsevent.CLICK, jsaction.JSHandler('button2ClickAction'))<br><br>  &amp;gt;&amp;gt;&amp;gt; handlers + handlers2<br>  &amp;lt;JSHandlers<br>      [&amp;lt;JSHandler 'button1ClickAction'&amp;gt;,<br>       &amp;lt;JSHandler 'button2ClickAction'&amp;gt;]&amp;gt;<br><br>However, adding other components is not supported:<br><br>  &amp;gt;&amp;gt;&amp;gt; handlers + 1<br>  Traceback (most recent call last):<br>  ...<br>  NotImplementedError<br><br>The handlers also provide a method to copy the handlers to a new instance:<br><br>  &amp;gt;&amp;gt;&amp;gt; copy = handlers.copy()<br>  &amp;gt;&amp;gt;&amp;gt; isinstance(copy, jsaction.JSHandlers)<br>  True<br>  &amp;gt;&amp;gt;&amp;gt; copy is handlers<br>  False<br><br>This is commonly needed when one wants to extend the handlers of a super-form.<br><br><br>Appendix B: The Subscription-Creating Event Subscriber<br>------------------------------------------------------<br><br>The ``createSubscriptionsForWidget(event)`` event subscriber listens to<br>``IAfterWidgetUpdateEvent`` events and is responsible for looking up any<br>Javascript action handlers and create event subscriptions for them.<br><br>So let's setup the environment:<br><br>  &amp;gt;&amp;gt;&amp;gt; class Form(form.Form):<br>  ...     buttons = button.Buttons(IButtons)<br>  ...<br>  ...     @jsaction.handler(buttons['hello'])<br>  ...     def showHelloWorldMessage(self, event, selector):<br>  ...         return 'alert(\"Hello World!\");'<br><br>  &amp;gt;&amp;gt;&amp;gt; form = Form(None, request)<br><br>Of course, not just any widget can have Javascript handlers. First of all, the<br>widget must be a field widget:<br><br>  &amp;gt;&amp;gt;&amp;gt; from z3c.form import widget<br>  &amp;gt;&amp;gt;&amp;gt; simpleWidget = widget.Widget(request)<br><br>  &amp;gt;&amp;gt;&amp;gt; jsaction.createSubscriptionsForWidget(<br>  ...     widget.AfterWidgetUpdateEvent(simpleWidget))<br><br>  &amp;gt;&amp;gt;&amp;gt; interfaces.IHaveJSSubscriptions.providedBy(form)<br>  False<br><br>And even if the widget is a field widget,<br><br>  &amp;gt;&amp;gt;&amp;gt; from z3c.form.browser.button import ButtonFieldWidget<br>  &amp;gt;&amp;gt;&amp;gt; helloWidget = ButtonFieldWidget(form.buttons['hello'], request)<br><br>it still needs to be a form-aware widget:<br><br>  &amp;gt;&amp;gt;&amp;gt; jsaction.createSubscriptionsForWidget(<br>  ...     widget.AfterWidgetUpdateEvent(helloWidget))<br><br>  &amp;gt;&amp;gt;&amp;gt; interfaces.IHaveJSSubscriptions.providedBy(form)<br>  False<br><br>So let's now make it work and add the form to the widget:<br><br>  &amp;gt;&amp;gt;&amp;gt; from z3c.form.interfaces import IFormAware<br>  &amp;gt;&amp;gt;&amp;gt; helloWidget.form = form<br>  &amp;gt;&amp;gt;&amp;gt; zope.interface.alsoProvides(helloWidget, IFormAware)<br><br>After the subscriber successfully completes, we should have a sJavascript<br>subscription attached to the form:<br><br>  &amp;gt;&amp;gt;&amp;gt; jsaction.createSubscriptionsForWidget(<br>  ...     widget.AfterWidgetUpdateEvent(helloWidget))<br><br>  &amp;gt;&amp;gt;&amp;gt; interfaces.IHaveJSSubscriptions.providedBy(form)<br>  True<br>  &amp;gt;&amp;gt;&amp;gt; len(list(form.jsSubscriptions))<br>  1<br>  &amp;gt;&amp;gt;&amp;gt; list(form.jsSubscriptions)<br>  [&amp;lt;JSSubscription<br>       event=&amp;lt;JSEvent \"click\"&amp;gt;, selector=&amp;lt;WidgetSelector \"hello\"&amp;gt;,<br>       handler=&amp;lt;JSHandler &amp;lt;function showHelloWorldMessage at ...&amp;gt;&amp;gt;&amp;gt;]<br><br>In the event that the widget is updated multiple times, and the<br>subscriber gets called multiple times, duplicate subscriptions will<br>not be created.<br><br>  &amp;gt;&amp;gt;&amp;gt; jsaction.createSubscriptionsForWidget(<br>  ...     widget.AfterWidgetUpdateEvent(helloWidget))<br>  &amp;gt;&amp;gt;&amp;gt; len(list(form.jsSubscriptions))<br>  1<br><br>Finally, if the form does not have any Javascript handlers, in other words, it<br>does not have a ``jsHandlers`` attribute, then the subscriber also aborts:<br><br>  &amp;gt;&amp;gt;&amp;gt; form = Form(None, request)<br>  &amp;gt;&amp;gt;&amp;gt; helloWidget.form = object()<br><br>  &amp;gt;&amp;gt;&amp;gt; jsaction.createSubscriptionsForWidget(<br>  ...     widget.AfterWidgetUpdateEvent(helloWidget))<br><br>  &amp;gt;&amp;gt;&amp;gt; interfaces.IHaveJSSubscriptions.providedBy(form)<br>  False<br><br>And that's all.<br><br>==========================<br>JavaScript Form Validation<br>==========================<br><br>This package also supports widget value validation via Javascript. In<br>particular, the ``jsvalidator`` module implements server-side validation via<br>AJAX.<br><br>  &amp;gt;&amp;gt;&amp;gt; from z3c.formjs import jsvalidator<br><br>There are two components to the validation API. The first is the validator, a<br>form mix-in class that makes the validation functionality via a URL and<br>defines the communication protocol of the validation; for example, it defines<br>what path must be accessed for the validation and what data to send and<br>return. The second component is the validation script, which is responsible<br>for defining the Javascript code that is executed when validation is<br>requested.<br><br><br>Message Validator<br>-----------------<br><br>The goal of the specific message validator is to validate a value, then<br>convert any error into a message and insert the message into the page's<br>content.<br><br>So let's do some necessary setups:<br><br>  &amp;gt;&amp;gt;&amp;gt; from z3c.form.testing import setupFormDefaults<br>  &amp;gt;&amp;gt;&amp;gt; setupFormDefaults()<br><br>  &amp;gt;&amp;gt;&amp;gt; import zope.component<br>  &amp;gt;&amp;gt;&amp;gt; from z3c.form import error<br>  &amp;gt;&amp;gt;&amp;gt; zope.component.provideAdapter(error.ValueErrorViewSnippet)<br><br>We now create a simple form in which all widgets will be validated:<br><br>  &amp;gt;&amp;gt;&amp;gt; import zope.interface<br>  &amp;gt;&amp;gt;&amp;gt; import zope.schema<br><br>  &amp;gt;&amp;gt;&amp;gt; class IAddress(zope.interface.Interface):<br>  ...     zip = zope.schema.Int(title=u\"Zip Code\")<br><br>  &amp;gt;&amp;gt;&amp;gt; from z3c.form import form, field<br>  &amp;gt;&amp;gt;&amp;gt; from z3c.form.interfaces import IField<br>  &amp;gt;&amp;gt;&amp;gt; from z3c.formjs import jsevent, jsaction<br><br>  &amp;gt;&amp;gt;&amp;gt; class AddressEditForm(jsvalidator.MessageValidator, form.AddForm):<br>  ...     fields = field.Fields(IAddress)<br>  ...<br>  ...     @jsaction.handler(IField, event=jsevent.CHANGE)<br>  ...     def fieldValidator(self, event, selector):<br>  ...         return self.ValidationScript(self, selector.widget).render()<br><br>After instantiating the form, ...<br><br>  &amp;gt;&amp;gt;&amp;gt; from z3c.form.testing import TestRequest<br>  &amp;gt;&amp;gt;&amp;gt; request = TestRequest()<br>  &amp;gt;&amp;gt;&amp;gt; edit = AddressEditForm(None, request)<br>  &amp;gt;&amp;gt;&amp;gt; edit.update()<br><br>we can execute the handler to ensure we get some output:<br><br>  &amp;gt;&amp;gt;&amp;gt; from z3c.formjs import testing<br>  &amp;gt;&amp;gt;&amp;gt; testing.setupRenderers()<br><br>  &amp;gt;&amp;gt;&amp;gt; from z3c.formjs import jsaction<br>  &amp;gt;&amp;gt;&amp;gt; print edit.fieldValidator(<br>  ...     None, jsaction.WidgetSelector(edit.widgets['zip']))<br>  $.get('/validate', function(data){ alert(data) })<br><br>Validators use AJAX handlers to communicate with the server. Commonly the AJAX<br>handler is looked up via the \"ajax\" view -- see ``ajax.txt`` for more<br>details. In this case we just create a small helper function:<br><br>  &amp;gt;&amp;gt;&amp;gt; from z3c.formjs import ajax<br><br>  &amp;gt;&amp;gt;&amp;gt; def AJAXPlugin(view):<br>  ...     return ajax.AJAXRequestTraverserPlugin(view, view.request)<br><br><br>  &amp;gt;&amp;gt;&amp;gt; from z3c.formjs import ajax, interfaces<br>  &amp;gt;&amp;gt;&amp;gt; from zope.publisher.interfaces.browser import IBrowserRequest<br><br>  &amp;gt;&amp;gt;&amp;gt; zope.component.provideSubscriptionAdapter(<br>  ...     ajax.AJAXRequestTraverserPlugin,<br>  ...     (interfaces.IFormTraverser, IBrowserRequest))<br><br>we can traverse to the ``validate`` method from the \"ajax\" view and render<br>it. Let's first render some valid input:<br><br>  &amp;gt;&amp;gt;&amp;gt; request = TestRequest(form={'widget-name' : 'zip',<br>  ...                             'form.widgets.zip' : u'29132'})<br>  &amp;gt;&amp;gt;&amp;gt; edit = AddressEditForm(None, request)<br>  &amp;gt;&amp;gt;&amp;gt; edit.update()<br>  &amp;gt;&amp;gt;&amp;gt; AJAXPlugin(edit).publishTraverse(None, 'validate')()<br>  u''<br><br>As you can see there is no error message. Let's now provide an invalid ZIP<br>code. As you can see, we get the expected error message:<br><br>  &amp;gt;&amp;gt;&amp;gt; request = TestRequest(form={'widget-name': 'zip',<br>  ...                             'form.widgets.zip':'notazipcode'})<br>  &amp;gt;&amp;gt;&amp;gt; edit = AddressEditForm(None, request)<br>  &amp;gt;&amp;gt;&amp;gt; edit.update()<br>  &amp;gt;&amp;gt;&amp;gt; AJAXPlugin(edit).publishTraverse(None, 'validate')()<br>  u'The entered value is not a valid integer literal.'<br><br>Of course, one cannot just traverse to any attribute in the form:<br><br>  &amp;gt;&amp;gt;&amp;gt; AJAXPlugin(edit).publishTraverse(None, 'ValidationScript')()<br>  Traceback (most recent call last):<br>  ...<br>  NotFound: Object: &amp;lt;AddressEditForm ...&amp;gt;, name: 'ValidationScript'<br><br>And that's it.<br><br>===============================<br>Connecting to Javascript Events<br>===============================<br><br>The ``jsevent`` module of this package implements a mechanism to connect a<br>Javascript script to an event of a DOM element. So let's have a look at how<br>this works.<br><br>  &amp;gt;&amp;gt;&amp;gt; from z3c.formjs import interfaces, jsevent<br><br>To implement this functionality, we need to model three components: events,<br>DOM elements (selector), and the script (handler). We will also need a manager<br>to keep track of all the mappings. This is indeed somewhat similar to the Zope<br>3 event model, though we do not need DOM elements to connect the events there.<br><br><br>Subscription Manager<br>--------------------<br><br>So first we need to create a subscription manager in which to collect the<br>subscriptions:<br><br>  &amp;gt;&amp;gt;&amp;gt; manager = jsevent.JSSubscriptions()<br><br>Initially, we have no registered events:<br><br>  &amp;gt;&amp;gt;&amp;gt; list(manager)<br>  []<br><br>We now want to subscribe to the \"click\" event of a DOM element with the id<br>\"message\". When the event occurs, we would like to display a simple \"Hello<br>World\" message.<br><br>The events are available in all capital letters, for example:<br><br>  &amp;gt;&amp;gt;&amp;gt; jsevent.CLICK<br>  &amp;lt;JSEvent \"click\"&amp;gt;<br><br>The DOM element is selected using a selector, in our case an id selector:<br><br>  &amp;gt;&amp;gt;&amp;gt; selector = jsevent.IdSelector('message')<br>  &amp;gt;&amp;gt;&amp;gt; selector<br>  &amp;lt;IdSelector \"message\"&amp;gt;<br><br>The handler of the event is a callable accepting the event, selector and the<br>request:<br><br>  &amp;gt;&amp;gt;&amp;gt; def showHelloWorldAlert(event, selector, request):<br>  ...     return u'alert(\"Hello World!\")'<br><br>We have finally all the pieces together to subscribe the event:<br><br>  &amp;gt;&amp;gt;&amp;gt; manager.subscribe(jsevent.CLICK, selector, showHelloWorldAlert)<br>  &amp;lt;JSSubscription event=&amp;lt;JSEvent \"click\"&amp;gt;,<br>                  selector=&amp;lt;IdSelector \"message\"&amp;gt;,<br>                  handler=&amp;lt;function showHelloWorldAlert at ...&amp;gt;&amp;gt;<br><br>So now we can see the subscription:<br><br>  &amp;gt;&amp;gt;&amp;gt; list(manager)<br>  [&amp;lt;JSSubscription event=&amp;lt;JSEvent \"click\"&amp;gt;,<br>                   selector=&amp;lt;IdSelector \"message\"&amp;gt;,<br>                   handler=&amp;lt;function showHelloWorldAlert at ...&amp;gt;&amp;gt;]<br><br>We can also get a specific subscription from the manager.<br><br>  &amp;gt;&amp;gt;&amp;gt; manager['showHelloWorldAlert']<br>  [&amp;lt;JSSubscription event=&amp;lt;JSEvent \"click\"&amp;gt;,<br>                  selector=&amp;lt;IdSelector \"message\"&amp;gt;,<br>                  handler=&amp;lt;function showHelloWorldAlert at ...&amp;gt;&amp;gt;]<br><br>So now, how does this get rendered into Javascript code? Since this package<br>strictly separates definition from rendering, a renderer will be responsible<br>to produce the output.<br><br><br>Renderers<br>---------<br><br>So let's define some renderers for the various components. We have already<br>prepared renderers for testing purposes in the ``testing`` support module. The<br>first one is for the id selector<br><br>  &amp;gt;&amp;gt;&amp;gt; import zope.component<br>  &amp;gt;&amp;gt;&amp;gt; from z3c.formjs import testing<br>  &amp;gt;&amp;gt;&amp;gt; zope.component.provideAdapter(testing.IdSelectorRenderer)<br><br>Of course, like all view components, the renderer supports the update/render<br>pattern. We can now render the selector:<br><br>  &amp;gt;&amp;gt;&amp;gt; from zope.publisher.browser import TestRequest<br>  &amp;gt;&amp;gt;&amp;gt; request = TestRequest()<br><br>  &amp;gt;&amp;gt;&amp;gt; renderer = zope.component.getMultiAdapter(<br>  ...     (selector, request), interfaces.IRenderer)<br>  &amp;gt;&amp;gt;&amp;gt; renderer.update()<br>  &amp;gt;&amp;gt;&amp;gt; renderer.render()<br>  u'#message'<br><br>Next we need a renderer for the subscription. Let's assume we can bind the<br>subscription as follows: ``$(&amp;lt;selector&amp;gt;).bind(\"&amp;lt;event&amp;gt;\", &amp;lt;script&amp;gt;)``<br><br>  &amp;gt;&amp;gt;&amp;gt; zope.component.provideAdapter(testing.SubscriptionRenderer)<br><br>Rendering the subscription then returns this:<br><br>  &amp;gt;&amp;gt;&amp;gt; renderer = zope.component.getMultiAdapter(<br>  ...     (list(manager)[0], request), interfaces.IRenderer)<br>  &amp;gt;&amp;gt;&amp;gt; renderer.update()<br>  &amp;gt;&amp;gt;&amp;gt; print renderer.render()<br>  $(\"#message\").bind(\"click\", function(){alert(\"Hello World!\")});<br><br>And now to the grant finale. We create a renderer for the subscription manager.<br><br>  &amp;gt;&amp;gt;&amp;gt; zope.component.provideAdapter(testing.ManagerRenderer)<br><br>Let's now render the entire manager.<br><br>  &amp;gt;&amp;gt;&amp;gt; renderer = zope.component.getMultiAdapter(<br>  ...     (manager, request), interfaces.IRenderer)<br>  &amp;gt;&amp;gt;&amp;gt; renderer.update()<br>  &amp;gt;&amp;gt;&amp;gt; print renderer.render()<br>  $(document).ready(function(){<br>    $(\"#message\").bind(\"click\", function(){alert(\"Hello World!\")});<br>  })<br><br><br>The Subscription Decorator<br>--------------------------<br><br>When defining JS event subscriptions from within a presentation component,<br>using the low-level subscription API is somewhat cumbersome. Thus, there<br>exists a decorator called ``subscribe``, which can convert a component method<br>as a subscription handler. Let's have a look:<br><br>  &amp;gt;&amp;gt;&amp;gt; class MyView(object):<br>  ...<br>  ...     @jsevent.subscribe(jsevent.IdSelector('myid'), jsevent.DBLCLICK)<br>  ...     def alertUser(event, selector, request):<br>  ...         return u\"alert('`%s` event occured on DOM element `%s`');\" %(<br>  ...             event.name, selector.id)<br><br>As you can see, the function is never really meant to be a method, but a<br>subscription handler; thus no ``self`` as first argument. The subscription is<br>now available in the subscriptions manager of the view:<br><br>  &amp;gt;&amp;gt;&amp;gt; list(MyView.jsSubscriptions)<br>  [&amp;lt;JSSubscription event=&amp;lt;JSEvent \"dblclick\"&amp;gt;,<br>                   selector=&amp;lt;IdSelector \"myid\"&amp;gt;,<br>                   handler=&amp;lt;function alertUser at ...&amp;gt;&amp;gt;]<br><br>Let's now render the subscription:<br><br>  &amp;gt;&amp;gt;&amp;gt; renderer = zope.component.getMultiAdapter(<br>  ...     (list(MyView.jsSubscriptions)[0], request), interfaces.IRenderer)<br>  &amp;gt;&amp;gt;&amp;gt; renderer.update()<br>  &amp;gt;&amp;gt;&amp;gt; print renderer.render()<br>  $(\"#myid\").bind(\"dblclick\",<br>       function(){alert('`dblclick` event occured on DOM element `myid`');});<br><br>Subscribe-decorators can also be chained, so that the same handler can be used<br>for multiple selectors and events:<br><br>  &amp;gt;&amp;gt;&amp;gt; class MyView(object):<br>  ...<br>  ...     @jsevent.subscribe(jsevent.IdSelector('myid'), jsevent.CLICK)<br>  ...     @jsevent.subscribe(jsevent.IdSelector('myid'), jsevent.DBLCLICK)<br>  ...     def alertUser(event, selector, request):<br>  ...         return u\"alert('`%s` event occured on DOM element `%s`');\" %(<br>  ...             event.name, selector.id)<br><br>In this example we register this handler for both the click and double click<br>event for the DOM element with the id \"myid\".<br><br>  &amp;gt;&amp;gt;&amp;gt; list(MyView.jsSubscriptions)<br>  [&amp;lt;JSSubscription event=&amp;lt;JSEvent \"dblclick\"&amp;gt;,<br>                   selector=&amp;lt;IdSelector \"myid\"&amp;gt;,<br>                   handler=&amp;lt;function alertUser at ...&amp;gt;&amp;gt;,<br>   &amp;lt;JSSubscription event=&amp;lt;JSEvent \"click\"&amp;gt;,<br>                   selector=&amp;lt;IdSelector \"myid\"&amp;gt;,<br>                   handler=&amp;lt;function alertUser at ...&amp;gt;&amp;gt;]<br><br><br>Javascript Viewlet<br>------------------<br><br>Putting in the Javascript by hand in every layout is a bit lame. Instead we<br>can just register a viewlet for the JS viewlet manager that renders the<br>subscriptions if a manager is found.<br><br>To use the viewlet we need a view that provides a subscription manager:<br><br>  &amp;gt;&amp;gt;&amp;gt; class View(object):<br>  ...     zope.interface.implements(interfaces.IHaveJSSubscriptions)<br>  ...     jsSubscriptions = manager<br><br>We can now initialize, update, and finally render the viewlet:<br><br>  &amp;gt;&amp;gt;&amp;gt; viewlet = jsevent.JSSubscriptionsViewlet(<br>  ...     object(), request, View(), object())<br>  &amp;gt;&amp;gt;&amp;gt; viewlet.update()<br>  &amp;gt;&amp;gt;&amp;gt; print viewlet.render()<br>  &amp;lt;script type=\"text/javascript\"&amp;gt;<br>  $(document).ready(function(){<br>    $(\"#message\").bind(\"click\", function(){alert(\"Hello World!\")});<br>  })<br>  &amp;lt;/script&amp;gt;<br><br><br>Selectors<br>---------<br><br>The module provides several DOM element selectors. It is the responsibility of<br>the corresponding rednerer to interpret the selector.<br><br>Id Selector<br>~~~~~~~~~~~<br><br>The id selector selects a DOM element by id, as seen above. It is simply<br>initialized using the the id:<br><br>  &amp;gt;&amp;gt;&amp;gt; idselect = jsevent.IdSelector('myid')<br>  &amp;gt;&amp;gt;&amp;gt; idselect<br>  &amp;lt;IdSelector \"myid\"&amp;gt;<br><br>The id is also available as attribute:<br><br>  &amp;gt;&amp;gt;&amp;gt; idselect.id<br>  'myid'<br><br>We already saw before how it gets rendered:<br><br>  &amp;gt;&amp;gt;&amp;gt; renderer = zope.component.getMultiAdapter(<br>  ...     (idselect, request), interfaces.IRenderer)<br>  &amp;gt;&amp;gt;&amp;gt; renderer.update()<br>  &amp;gt;&amp;gt;&amp;gt; renderer.render()<br>  u'#myid'<br><br>CSS Selector<br>~~~~~~~~~~~~<br><br>The CSS selector selects a DOM element using an arbitrary CSS selector<br>expression. This selector is initialized using the expression:<br><br>  &amp;gt;&amp;gt;&amp;gt; cssselect = jsevent.CSSSelector('div.myclass')<br>  &amp;gt;&amp;gt;&amp;gt; cssselect<br>  &amp;lt;CSSSelector \"div.myclass\"&amp;gt;<br><br>The CSS selector expression is also available as attribute:<br><br>  &amp;gt;&amp;gt;&amp;gt; cssselect.expr<br>  'div.myclass'<br><br>Let's now see an example on how the CSS selector can be rendered:<br><br>  &amp;gt;&amp;gt;&amp;gt; zope.component.provideAdapter(testing.CSSSelectorRenderer)<br><br>  &amp;gt;&amp;gt;&amp;gt; renderer = zope.component.getMultiAdapter(<br>  ...     (cssselect, request), interfaces.IRenderer)<br>  &amp;gt;&amp;gt;&amp;gt; renderer.update()<br>  &amp;gt;&amp;gt;&amp;gt; renderer.render()<br>  u'div.myclass'<br><br>Since most JS libraries support CSS selectors by default, the renderer simply<br>converts the expression to unicode.<br><br><br>Available Events<br>----------------<br><br>This package maps all of the available JavaScript events. Here is the complete<br>list:<br><br>  &amp;gt;&amp;gt;&amp;gt; jsevent.CLICK<br>  &amp;lt;JSEvent \"click\"&amp;gt;<br>  &amp;gt;&amp;gt;&amp;gt; jsevent.DBLCLICK<br>  &amp;lt;JSEvent \"dblclick\"&amp;gt;<br>  &amp;gt;&amp;gt;&amp;gt; jsevent.CHANGE<br>  &amp;lt;JSEvent \"change\"&amp;gt;<br>  &amp;gt;&amp;gt;&amp;gt; jsevent.LOAD<br>  &amp;lt;JSEvent \"load\"&amp;gt;<br>  &amp;gt;&amp;gt;&amp;gt; jsevent.BLUR<br>  &amp;lt;JSEvent \"blur\"&amp;gt;<br>  &amp;gt;&amp;gt;&amp;gt; jsevent.FOCUS<br>  &amp;lt;JSEvent \"focus\"&amp;gt;<br>  &amp;gt;&amp;gt;&amp;gt; jsevent.KEYDOWN<br>  &amp;lt;JSEvent \"keydown\"&amp;gt;<br>  &amp;gt;&amp;gt;&amp;gt; jsevent.KEYUP<br>  &amp;lt;JSEvent \"keyup\"&amp;gt;<br>  &amp;gt;&amp;gt;&amp;gt; jsevent.MOUSEDOWN<br>  &amp;lt;JSEvent \"mousedown\"&amp;gt;<br>  &amp;gt;&amp;gt;&amp;gt; jsevent.MOUSEMOVE<br>  &amp;lt;JSEvent \"mousemove\"&amp;gt;<br>  &amp;gt;&amp;gt;&amp;gt; jsevent.MOUSEOUT<br>  &amp;lt;JSEvent \"mouseout\"&amp;gt;<br>  &amp;gt;&amp;gt;&amp;gt; jsevent.MOUSEOVER<br>  &amp;lt;JSEvent \"mouseover\"&amp;gt;<br>  &amp;gt;&amp;gt;&amp;gt; jsevent.MOUSEUP<br>  &amp;lt;JSEvent \"mouseup\"&amp;gt;<br>  &amp;gt;&amp;gt;&amp;gt; jsevent.RESIZE<br>  &amp;lt;JSEvent \"resize\"&amp;gt;<br>  &amp;gt;&amp;gt;&amp;gt; jsevent.SELECT<br>  &amp;lt;JSEvent \"select\"&amp;gt;<br>  &amp;gt;&amp;gt;&amp;gt; jsevent.SUBMIT<br>  &amp;lt;JSEvent \"submit\"&amp;gt;<br><br>These are also provided as utilities so they can be looked up by name.<br><br>  &amp;gt;&amp;gt;&amp;gt; import zope.component<br>  &amp;gt;&amp;gt;&amp;gt; zope.component.provideUtility(jsevent.CLICK, name='click')<br><br>Of course, we can now just look up the utility:<br><br>  &amp;gt;&amp;gt;&amp;gt; zope.component.getUtility(interfaces.IJSEvent, 'click')<br>  &amp;lt;JSEvent \"click\"&amp;gt;<br><br><br>=======<br>CHANGES<br>=======<br><br>Version 0.5.0 (2009-07-23)<br>--------------------------<br><br>- Feature: Update to the latest package versions.<br><br>- Bug: Avoid ``ForbiddenAttribute`` in ``jsvalidator.MessageValidator``.<br><br><br>Version 0.4.1 (2008-12-16)<br>--------------------------<br><br>- Restructure: Use WeightOrderedViewletManager from zope.viewlet instead<br>  of z3c.viewlet, that removes additional egg requirement.<br><br><br>Version 0.4.0 (2008-08-26)<br>--------------------------<br><br>- Feature: There is now a special unique prefix generator that uses<br>  `z3c.form`'s new ``createCSSId()`` function to generate css selectable<br>  prefixes for ajax forms.<br><br>- Feature: There is now a viewlet manager already registered with all<br>  the viewlets necessary to use `z3c.formjs`.  You can now just do:<br><br>    &amp;lt;script tal:replace=\"structure<br>                         provider:z3c.formjs.interfaces.IDynamicJavaScript\"&amp;gt;<br>    &amp;lt;/script&amp;gt;<br><br>- Feature: When AJAX handlers return complex data structures (dictionaries,<br>  lists and tuples), the data is automatically converted into JSON<br>  format before delivery.<br><br>- Restructure: Make package run on latest z3c.form 1.9.0 release.<br><br>- Bug: Widgets that were being updated multiple times were generating<br>  duplicate javascript event subscriptions. This is now fixed.<br><br><br>Version 0.3.0 (2007-10-03)<br>--------------------------<br><br>- Feature: Made a JavaScript renderer for calls to JS Functions.<br><br>- Feature: Implemented tools to make server side events propagate to<br>  the client.<br><br>- Feature: Now the ``jsevent.subscribe`` and ``jsaction.handler`` decorators<br>  can be chained together, allowing them to be called multiple time for the<br>  same methods.<br><br>- Feature: Implemented ability to switch widget modes on a form.<br><br><br>Version 0.2.0 (2007-07-18)<br>--------------------------<br><br>- Feature: Registration of public AJAX server calls via a simple<br>  decorator. The calls are made available via a special ``ajax`` view on the<br>  original view.<br><br>- Feature: Allow registering of JS subscriptions via a decorator within the<br>  presentation component.<br><br>- Feature: Added a new CSS selector.<br><br>- Feature: Implementation of AJAX-driven widget value validation.<br><br>- Restructure: Completely overhauled the entire API to be most easy to use and<br>  have the most minimal implementation.<br><br>- Bug: The package is now 100% tested.<br><br>- Feature: Implementation of AJAX request handlers in forms.<br><br>Version 0.1.0 (2007-06-29)<br>--------------------------<br><br>- Initial Release<br><br>  * Feature: JS event association with fields and buttons.<br><br><br>====<br>TODO<br>====<br><br> - client side js validators for simple fields.  (maybe we can use an<br>   existing library?)\n          </div>"}, "last_serial": 731503, "releases": {"0.2.0": [{"comment_text": "", "digests": {"md5": "42ef7f4e79198fab2691a23b1b77f786", "sha256": "2c3ce4e6338c7dddcbeb351d3da682cd72ee4e362c577f1c0fc519209d936710"}, "downloads": -1, "filename": "z3c.formjs-0.2.0-py2.4.egg", "has_sig": false, "md5_digest": "42ef7f4e79198fab2691a23b1b77f786", "packagetype": "bdist_egg", "python_version": "2.4", "requires_python": null, "size": 59841, "upload_time": "2007-07-19T03:40:58", "upload_time_iso_8601": "2007-07-19T03:40:58Z", "url": "https://files.pythonhosted.org/packages/4f/da/f006998c5d776dd148a57a9857495c35335bf0de1b3faf3b60f4de99d5a4/z3c.formjs-0.2.0-py2.4.egg", "yanked": false}, {"comment_text": "", "digests": {"md5": "96798cff5cb7d9c8fc8331be312e690d", "sha256": "d774f7c8274275e91c0de30e3ede28860f19973624613af2ed7d0b5d4332df4b"}, "downloads": -1, "filename": "z3c.formjs-0.2.0.tar.gz", "has_sig": false, "md5_digest": "96798cff5cb7d9c8fc8331be312e690d", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 44890, "upload_time": "2007-07-19T03:40:48", "upload_time_iso_8601": "2007-07-19T03:40:48Z", "url": "https://files.pythonhosted.org/packages/fc/c2/30891948389942dc3f1520b855af64084029ba26edffcfac1054dfa97651/z3c.formjs-0.2.0.tar.gz", "yanked": false}], "0.2.1": [{"comment_text": "", "digests": {"md5": "65fa1c2028d6e16e961d2b29e03b8946", "sha256": "f3a3e93f72a420445cdf141e1db869c7593e0c65eafb6a6df421feaa093b83fd"}, "downloads": -1, "filename": "z3c.formjs-0.2.1-py2.4.egg", "has_sig": false, "md5_digest": "65fa1c2028d6e16e961d2b29e03b8946", "packagetype": "bdist_egg", "python_version": "2.4", "requires_python": null, "size": 59840, "upload_time": "2007-07-30T22:45:40", "upload_time_iso_8601": "2007-07-30T22:45:40Z", "url": "https://files.pythonhosted.org/packages/a9/25/d81d99a8d9ff58aa0277eb33552df1a9567489c7d33432753255cc3956a4/z3c.formjs-0.2.1-py2.4.egg", "yanked": false}, {"comment_text": "", "digests": {"md5": "b0b199682dc682f67faa66e5eab5e94b", "sha256": "122a9e98f3f93d84f12d941d1344f17d6308d6a106aa221c37ad5a62a30937c2"}, "downloads": -1, "filename": "z3c.formjs-0.2.1.tar.gz", "has_sig": false, "md5_digest": "b0b199682dc682f67faa66e5eab5e94b", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 44937, "upload_time": "2007-07-30T22:45:39", "upload_time_iso_8601": "2007-07-30T22:45:39Z", "url": "https://files.pythonhosted.org/packages/3d/63/4b98712142450a72784b979a479bef5df79310b9ebebebe51fa906727df2/z3c.formjs-0.2.1.tar.gz", "yanked": false}], "0.3.0": [{"comment_text": "", "digests": {"md5": "d59ede6b08c6f2901a65561b4d66aeca", "sha256": "3f590923ad4ededf788f53ecd5f973365c9d719d21e81e60e7cdd3c44fb6e7d1"}, "downloads": -1, "filename": "z3c.formjs-0.3.0.tar.gz", "has_sig": false, "md5_digest": "d59ede6b08c6f2901a65561b4d66aeca", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 58161, "upload_time": "2007-10-04T03:16:15", "upload_time_iso_8601": "2007-10-04T03:16:15Z", "url": "https://files.pythonhosted.org/packages/0f/59/8de5113c41ae176c3cf6b037b23754c0b108063530f4a26db5024254a2dd/z3c.formjs-0.3.0.tar.gz", "yanked": false}], "0.4.0": [{"comment_text": "", "digests": {"md5": "6edf3f686e5762d1e5be1fa3c4d7e3ac", "sha256": "7b5df1fc25fd8ef21ab11b5f4cc53114178680e5ed77872a382e656c30d5a268"}, "downloads": -1, "filename": "z3c.formjs-0.4.0.tar.gz", "has_sig": false, "md5_digest": "6edf3f686e5762d1e5be1fa3c4d7e3ac", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 61405, "upload_time": "2008-08-27T04:55:26", "upload_time_iso_8601": "2008-08-27T04:55:26Z", "url": "https://files.pythonhosted.org/packages/93/a9/4cb9d25b3c0ec0b2cd5e3357a451cf445217c188bb8d789e8ba41643b423/z3c.formjs-0.4.0.tar.gz", "yanked": false}], "0.4.1": [{"comment_text": "", "digests": {"md5": "c3c0f2ab5c7a60d596ef763d2c252fca", "sha256": "f8ac151ca67b1029df546c56e62e506019f1dc21d7f4ca3b3d7d8c5ae0d2c7f0"}, "downloads": -1, "filename": "z3c.formjs-0.4.1.tar.gz", "has_sig": false, "md5_digest": "c3c0f2ab5c7a60d596ef763d2c252fca", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 62368, "upload_time": "2008-12-16T09:41:35", "upload_time_iso_8601": "2008-12-16T09:41:35Z", "url": "https://files.pythonhosted.org/packages/f8/b2/f60096c3e7174edcb56030a3a35c7680965f065e5286a85c3621289aa25f/z3c.formjs-0.4.1.tar.gz", "yanked": false}], "0.5.0": [{"comment_text": "", "digests": {"md5": "b31d9513a3233091bda660c83d45d202", "sha256": "d85e7f5297402991154f3512fe5dee5426f9006e6e8b8d8a8bcf01620c9d707c"}, "downloads": -1, "filename": "z3c.formjs-0.5.0.tar.gz", "has_sig": false, "md5_digest": "b31d9513a3233091bda660c83d45d202", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 61603, "upload_time": "2009-07-23T07:03:59", "upload_time_iso_8601": "2009-07-23T07:03:59.493145Z", "url": "https://files.pythonhosted.org/packages/ca/ec/2a9c7a352c4809106e96f4decfaf0b3f3a82c0b76ab67d760523aba6f54d/z3c.formjs-0.5.0.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "b31d9513a3233091bda660c83d45d202", "sha256": "d85e7f5297402991154f3512fe5dee5426f9006e6e8b8d8a8bcf01620c9d707c"}, "downloads": -1, "filename": "z3c.formjs-0.5.0.tar.gz", "has_sig": false, "md5_digest": "b31d9513a3233091bda660c83d45d202", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 61603, "upload_time": "2009-07-23T07:03:59", "upload_time_iso_8601": "2009-07-23T07:03:59.493145Z", "url": "https://files.pythonhosted.org/packages/ca/ec/2a9c7a352c4809106e96f4decfaf0b3f3a82c0b76ab67d760523aba6f54d/z3c.formjs-0.5.0.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:21:01 2020"}