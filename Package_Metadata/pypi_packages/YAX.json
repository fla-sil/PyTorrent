{"info": {"author": "M\u00f3r\u00e9h Tam\u00e1s, MTA-PPKE-NLPG", "author_email": "morta@digitus.itk.ppke.hu", "bugtrack_url": null, "classifiers": ["Development Status :: 5 - Production/Stable", "Environment :: Console", "Intended Audience :: Developers", "Intended Audience :: Information Technology", "Intended Audience :: Science/Research", "License :: OSI Approved :: GNU Lesser General Public License v3 (LGPLv3)", "Programming Language :: Python :: 3", "Topic :: Software Development :: Libraries :: Python Modules", "Topic :: Text Processing :: Markup :: XML"], "description": "===\r\nYAX\r\n===\r\n\r\n**Yet Another XML parser** is a powerful event-based memory-efficient Python module.\r\nIt analyses the XML stream node by node and builds subtrees only if it is really needed.\r\n\r\nIn case of record-oriented XML input (when some subtree structure is repeated many times),\r\nit processes the file in a sequential manner similar to that of *SAX*.\r\nHowever, conditions can be defined which trigger a *DOM* like processing where subtrees are created.\r\n\r\nThis method is also efficient on very large data (which do not fit into the memory)\r\nboth in terms of storage and computational time complexity.\r\n\r\nDependencies\r\n~~~~~~~~~~~~\r\nYAX uses Python 3.x and above. It doesn't depend on any third party module.\r\nHowever, if you have *lxml* installed you can use it as back-end.\r\n(See the documentation about performance.)\r\n\r\nInstallation\r\n~~~~~~~~~~~~\r\n* Download as a zip archive, uncompress and use it.\r\n* ``pip3 install yax``\r\n* (Soon...) Downolad the deb package and install it.\r\n\r\nUsage\r\n~~~~~\r\nA simple example which prints all the elements with tagname \"a\" and containing \"href\" attribute:\r\n\r\n.. code:: python\r\n\r\n    import yax\r\n\r\n    yr = yax.YAXReader(open(\"file.xml\"))\r\n    yr.find(\"a\", {\"href\": True}).calls(\r\n        lambda e, i: print(yax.element_to_string(e, with_tail=False))  # with_tail only whith lxml!\r\n    )\r\n    yr.start()\r\n\r\nA bit more complex example which filters a gpx record.\r\nIt prints the elevation values of the trackpoints in a specified area:\r\n\r\n.. code:: python\r\n\r\n    import yax\r\n\r\n    yr = yax.YAXReader(open(\"route.gpx\"))\r\n    yr.find(\"trkpt\", {\"lat\": lambda v: 47 < float(v) < 48,\r\n                      \"lon\": lambda v: 16 < float(v) < 17},\r\n            keep_children=\"ele\"\r\n            ).calls(lambda e, i: print(e.find(\"ele\").text))\r\n    yr.start()\r\n\r\nThis example shows that it would be erease all unneccessary children from the subtree\r\nto save memory but in this case we need the child called \"ele\".\r\nFor more example or the complete reference see the documentation.\r\n\r\nSee also\r\n~~~~~~~~\r\n\r\n* `External documentation <https://github.com/morta-code/YAX/tree/master/doc>`_\r\n* `Issue tracker <https://github.com/morta-code/YAX/issues>`_ (feel free to use it!)", "description_content_type": null, "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/morta-code/YAX", "keywords": "xml lxml parser event-based record-oriented", "license": "LGPLv3", "maintainer": "", "maintainer_email": "", "name": "YAX", "package_url": "https://pypi.org/project/YAX/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/YAX/", "project_urls": {"Homepage": "https://github.com/morta-code/YAX"}, "release_url": "https://pypi.org/project/YAX/1.2.0/", "requires_dist": null, "requires_python": "", "summary": "Yet Another XML parser with the power of event-based memory-safe mechanism.", "version": "1.2.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p><strong>Yet Another XML parser</strong> is a powerful event-based memory-efficient Python module.\nIt analyses the XML stream node by node and builds subtrees only if it is really needed.</p>\n<p>In case of record-oriented XML input (when some subtree structure is repeated many times),\nit processes the file in a sequential manner similar to that of <em>SAX</em>.\nHowever, conditions can be defined which trigger a <em>DOM</em> like processing where subtrees are created.</p>\n<p>This method is also efficient on very large data (which do not fit into the memory)\nboth in terms of storage and computational time complexity.</p>\n<div id=\"dependencies\">\n<h2>Dependencies</h2>\n<p>YAX uses Python 3.x and above. It doesn\u2019t depend on any third party module.\nHowever, if you have <em>lxml</em> installed you can use it as back-end.\n(See the documentation about performance.)</p>\n</div>\n<div id=\"installation\">\n<h2>Installation</h2>\n<ul>\n<li>Download as a zip archive, uncompress and use it.</li>\n<li><tt>pip3 install yax</tt></li>\n<li>(Soon\u2026) Downolad the deb package and install it.</li>\n</ul>\n</div>\n<div id=\"usage\">\n<h2>Usage</h2>\n<p>A simple example which prints all the elements with tagname \u201ca\u201d and containing \u201chref\u201d attribute:</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">yax</span>\n\n<span class=\"n\">yr</span> <span class=\"o\">=</span> <span class=\"n\">yax</span><span class=\"o\">.</span><span class=\"n\">YAXReader</span><span class=\"p\">(</span><span class=\"nb\">open</span><span class=\"p\">(</span><span class=\"s2\">\"file.xml\"</span><span class=\"p\">))</span>\n<span class=\"n\">yr</span><span class=\"o\">.</span><span class=\"n\">find</span><span class=\"p\">(</span><span class=\"s2\">\"a\"</span><span class=\"p\">,</span> <span class=\"p\">{</span><span class=\"s2\">\"href\"</span><span class=\"p\">:</span> <span class=\"kc\">True</span><span class=\"p\">})</span><span class=\"o\">.</span><span class=\"n\">calls</span><span class=\"p\">(</span>\n    <span class=\"k\">lambda</span> <span class=\"n\">e</span><span class=\"p\">,</span> <span class=\"n\">i</span><span class=\"p\">:</span> <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">yax</span><span class=\"o\">.</span><span class=\"n\">element_to_string</span><span class=\"p\">(</span><span class=\"n\">e</span><span class=\"p\">,</span> <span class=\"n\">with_tail</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">))</span>  <span class=\"c1\"># with_tail only whith lxml!</span>\n<span class=\"p\">)</span>\n<span class=\"n\">yr</span><span class=\"o\">.</span><span class=\"n\">start</span><span class=\"p\">()</span>\n</pre>\n<p>A bit more complex example which filters a gpx record.\nIt prints the elevation values of the trackpoints in a specified area:</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">yax</span>\n\n<span class=\"n\">yr</span> <span class=\"o\">=</span> <span class=\"n\">yax</span><span class=\"o\">.</span><span class=\"n\">YAXReader</span><span class=\"p\">(</span><span class=\"nb\">open</span><span class=\"p\">(</span><span class=\"s2\">\"route.gpx\"</span><span class=\"p\">))</span>\n<span class=\"n\">yr</span><span class=\"o\">.</span><span class=\"n\">find</span><span class=\"p\">(</span><span class=\"s2\">\"trkpt\"</span><span class=\"p\">,</span> <span class=\"p\">{</span><span class=\"s2\">\"lat\"</span><span class=\"p\">:</span> <span class=\"k\">lambda</span> <span class=\"n\">v</span><span class=\"p\">:</span> <span class=\"mi\">47</span> <span class=\"o\">&lt;</span> <span class=\"nb\">float</span><span class=\"p\">(</span><span class=\"n\">v</span><span class=\"p\">)</span> <span class=\"o\">&lt;</span> <span class=\"mi\">48</span><span class=\"p\">,</span>\n                  <span class=\"s2\">\"lon\"</span><span class=\"p\">:</span> <span class=\"k\">lambda</span> <span class=\"n\">v</span><span class=\"p\">:</span> <span class=\"mi\">16</span> <span class=\"o\">&lt;</span> <span class=\"nb\">float</span><span class=\"p\">(</span><span class=\"n\">v</span><span class=\"p\">)</span> <span class=\"o\">&lt;</span> <span class=\"mi\">17</span><span class=\"p\">},</span>\n        <span class=\"n\">keep_children</span><span class=\"o\">=</span><span class=\"s2\">\"ele\"</span>\n        <span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">calls</span><span class=\"p\">(</span><span class=\"k\">lambda</span> <span class=\"n\">e</span><span class=\"p\">,</span> <span class=\"n\">i</span><span class=\"p\">:</span> <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">e</span><span class=\"o\">.</span><span class=\"n\">find</span><span class=\"p\">(</span><span class=\"s2\">\"ele\"</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">text</span><span class=\"p\">))</span>\n<span class=\"n\">yr</span><span class=\"o\">.</span><span class=\"n\">start</span><span class=\"p\">()</span>\n</pre>\n<p>This example shows that it would be erease all unneccessary children from the subtree\nto save memory but in this case we need the child called \u201cele\u201d.\nFor more example or the complete reference see the documentation.</p>\n</div>\n<div id=\"see-also\">\n<h2>See also</h2>\n<ul>\n<li><a href=\"https://github.com/morta-code/YAX/tree/master/doc\" rel=\"nofollow\">External documentation</a></li>\n<li><a href=\"https://github.com/morta-code/YAX/issues\" rel=\"nofollow\">Issue tracker</a> (feel free to use it!)</li>\n</ul>\n</div>\n\n          </div>"}, "last_serial": 2037742, "releases": {"1.2.0": [{"comment_text": "", "digests": {"md5": "b1c2fa47a510640e434231a64c3c421f", "sha256": "ad4c8a706585dd7bdae3dfb0d451268ffd0e3b95b7035caa181c6fcd314ebcec"}, "downloads": -1, "filename": "YAX-1.2.0-py3-none-any.whl", "has_sig": false, "md5_digest": "b1c2fa47a510640e434231a64c3c421f", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 32389, "upload_time": "2016-03-30T14:01:17", "upload_time_iso_8601": "2016-03-30T14:01:17.934200Z", "url": "https://files.pythonhosted.org/packages/61/da/709a36411981d0d5cade5671fb5e7dae6f4df001fbb9e7a98c3c9ea32393/YAX-1.2.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "7231c32d4ead2eb9fcca0e30653af284", "sha256": "76ee620d1b3a0a898e66c8b7e432a14d61db853b2640aa5717a38a50b2305db4"}, "downloads": -1, "filename": "YAX-1.2.0.tar.gz", "has_sig": false, "md5_digest": "7231c32d4ead2eb9fcca0e30653af284", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 7176, "upload_time": "2016-03-30T14:01:41", "upload_time_iso_8601": "2016-03-30T14:01:41.277849Z", "url": "https://files.pythonhosted.org/packages/e2/e4/36d56a0d10ff6ddc0e1d8bd95e4406be65ff6687bcb98ac35fd7a23e885a/YAX-1.2.0.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "b1c2fa47a510640e434231a64c3c421f", "sha256": "ad4c8a706585dd7bdae3dfb0d451268ffd0e3b95b7035caa181c6fcd314ebcec"}, "downloads": -1, "filename": "YAX-1.2.0-py3-none-any.whl", "has_sig": false, "md5_digest": "b1c2fa47a510640e434231a64c3c421f", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 32389, "upload_time": "2016-03-30T14:01:17", "upload_time_iso_8601": "2016-03-30T14:01:17.934200Z", "url": "https://files.pythonhosted.org/packages/61/da/709a36411981d0d5cade5671fb5e7dae6f4df001fbb9e7a98c3c9ea32393/YAX-1.2.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "7231c32d4ead2eb9fcca0e30653af284", "sha256": "76ee620d1b3a0a898e66c8b7e432a14d61db853b2640aa5717a38a50b2305db4"}, "downloads": -1, "filename": "YAX-1.2.0.tar.gz", "has_sig": false, "md5_digest": "7231c32d4ead2eb9fcca0e30653af284", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 7176, "upload_time": "2016-03-30T14:01:41", "upload_time_iso_8601": "2016-03-30T14:01:41.277849Z", "url": "https://files.pythonhosted.org/packages/e2/e4/36d56a0d10ff6ddc0e1d8bd95e4406be65ff6687bcb98ac35fd7a23e885a/YAX-1.2.0.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:22:38 2020"}