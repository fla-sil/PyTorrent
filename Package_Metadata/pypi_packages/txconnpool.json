{"info": {"author": "Eric Florenzano", "author_email": "floguy@gmail.com", "bugtrack_url": null, "classifiers": ["Environment :: Web Environment", "Framework :: Twisted", "Programming Language :: Python", "Topic :: Software Development :: Libraries :: Python Modules"], "description": "txconnpool\n==========\n\nA generalized connection pooling library for Twisted.\n\n\nExample Description\n-------------------\n\nAssume that we've got a web application, which performs some expensive \ncomputations, and then caches them in a memcached_ server.  The simple way to\nachieve this in Twisted is to create a ClientCreator_ for the MemCacheProtocol_\nand whenever we need to communicate with the server, we can simply use that.\n\nThis works for low volumes of queries, but let's say that now we start hitting \nmemcached a lot--several times per web request, of which we are receiving many\nper second.  Very quickly, the connection overhead can become a problem.\n\nInstead of creating a new connection for every query, it would be much better \nto maintain a pool of open connections, and simply reuse those open \nconnections; queuing up any queries if all of the connections are in use.  With\ntxconnpool, setting this up can be quite easy.\n\n\nExample Implementation\n----------------------\n\nFirst we need to create a few classes of boilerplate, to transform a\nMemCacheProtocol_ into a PooledMemcachedProtocol, and then create a pool::\n\n\n    from twisted.protocols.memcache import MemCacheProtocol\n\n    from txconnpool.pool import PooledClientFactory, Pool\n\n    class PooledMemCacheProtocol(MemCacheProtocol):\n        \"\"\"\n        A MemCacheProtocol that will notify a connectionPool that it is ready\n        to accept requests.\n        \"\"\"\n        factory = None\n    \n        def connectionMade(self):\n            \"\"\"\n            Notify our factory that we're ready to accept connections.\n            \"\"\"\n            MemCacheProtocol.connectionMade(self)\n\n            self.factory.connectionPool.clientFree(self)\n\n            if self.factory.deferred is not None:\n                self.factory.deferred.callback(self)\n                self.factory.deferred = None\n\n    class MemCacheClientFactory(PooledClientFactory):\n        protocol = PooledMemCacheProtocol\n\n    class MemCachePool(Pool):\n        clientFactory = MemCacheClientFactory\n    \n        def get(self, *args, **kwargs):\n            return self.performRequest('get', *args, **kwargs)\n\n        def set(self, *args, **kwargs):\n            return self.performRequest('set', *args, **kwargs)\n\n        def delete(self, *args, **kwargs):\n            return self.performRequest('delete', *args, **kwargs)\n\n        def add(self, *args, **kwargs):\n            return self.performRequest('add', *args, **kwargs)\n\n\nNow, with this having been created, we can go ahead and use it::\n\n\n    from twisted.internet.address import IPv4Address\n    \n    addr = IPv4Address('TCP', '127.0.0.1', 11211)\n    mc_pool = MemCachePool(addr, maxClients=20)\n    \n    d = mc_pool.get('cached-data')\n    \n    def gotCachedData(data):\n        flags, value = data\n        if value:\n            print 'Yay, we got a cache hit'\n        else:\n            print 'Boo, it was a cache miss'\n    \n    d.addCallback(gotCachedData)\n\n\n.. _memcached: http://memcached.org/\n.. _ClientCreator: http://twistedmatrix.com/documents/current/api/twisted.internet.protocol.ClientCreator.html\n.. _MemCacheProtocol: http://twistedmatrix.com/documents/current/api/twisted.protocols.memcache.MemCacheProtocol.html", "description_content_type": null, "docs_url": null, "download_url": "UNKNOWN", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "http://github.com/ericflo/txconnpool/", "keywords": "twisted,connection,pool,connpool,txconnpool", "license": "Apache", "maintainer": null, "maintainer_email": null, "name": "txconnpool", "package_url": "https://pypi.org/project/txconnpool/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/txconnpool/", "project_urls": {"Download": "UNKNOWN", "Homepage": "http://github.com/ericflo/txconnpool/"}, "release_url": "https://pypi.org/project/txconnpool/0.1.1/", "requires_dist": null, "requires_python": null, "summary": "A generalized connection pooling library for Twisted", "version": "0.1.1", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p>A generalized connection pooling library for Twisted.</p>\n<div id=\"example-description\">\n<h2>Example Description</h2>\n<p>Assume that we\u2019ve got a web application, which performs some expensive\ncomputations, and then caches them in a <a href=\"http://memcached.org/\" rel=\"nofollow\">memcached</a> server.  The simple way to\nachieve this in Twisted is to create a <a href=\"http://twistedmatrix.com/documents/current/api/twisted.internet.protocol.ClientCreator.html\" rel=\"nofollow\">ClientCreator</a> for the <a href=\"http://twistedmatrix.com/documents/current/api/twisted.protocols.memcache.MemCacheProtocol.html\" rel=\"nofollow\">MemCacheProtocol</a>\nand whenever we need to communicate with the server, we can simply use that.</p>\n<p>This works for low volumes of queries, but let\u2019s say that now we start hitting\nmemcached a lot\u2013several times per web request, of which we are receiving many\nper second.  Very quickly, the connection overhead can become a problem.</p>\n<p>Instead of creating a new connection for every query, it would be much better\nto maintain a pool of open connections, and simply reuse those open\nconnections; queuing up any queries if all of the connections are in use.  With\ntxconnpool, setting this up can be quite easy.</p>\n</div>\n<div id=\"example-implementation\">\n<h2>Example Implementation</h2>\n<p>First we need to create a few classes of boilerplate, to transform a\n<a href=\"http://twistedmatrix.com/documents/current/api/twisted.protocols.memcache.MemCacheProtocol.html\" rel=\"nofollow\">MemCacheProtocol</a> into a PooledMemcachedProtocol, and then create a pool:</p>\n<pre>from twisted.protocols.memcache import MemCacheProtocol\n\nfrom txconnpool.pool import PooledClientFactory, Pool\n\nclass PooledMemCacheProtocol(MemCacheProtocol):\n    \"\"\"\n    A MemCacheProtocol that will notify a connectionPool that it is ready\n    to accept requests.\n    \"\"\"\n    factory = None\n\n    def connectionMade(self):\n        \"\"\"\n        Notify our factory that we're ready to accept connections.\n        \"\"\"\n        MemCacheProtocol.connectionMade(self)\n\n        self.factory.connectionPool.clientFree(self)\n\n        if self.factory.deferred is not None:\n            self.factory.deferred.callback(self)\n            self.factory.deferred = None\n\nclass MemCacheClientFactory(PooledClientFactory):\n    protocol = PooledMemCacheProtocol\n\nclass MemCachePool(Pool):\n    clientFactory = MemCacheClientFactory\n\n    def get(self, *args, **kwargs):\n        return self.performRequest('get', *args, **kwargs)\n\n    def set(self, *args, **kwargs):\n        return self.performRequest('set', *args, **kwargs)\n\n    def delete(self, *args, **kwargs):\n        return self.performRequest('delete', *args, **kwargs)\n\n    def add(self, *args, **kwargs):\n        return self.performRequest('add', *args, **kwargs)\n</pre>\n<p>Now, with this having been created, we can go ahead and use it:</p>\n<pre>from twisted.internet.address import IPv4Address\n\naddr = IPv4Address('TCP', '127.0.0.1', 11211)\nmc_pool = MemCachePool(addr, maxClients=20)\n\nd = mc_pool.get('cached-data')\n\ndef gotCachedData(data):\n    flags, value = data\n    if value:\n        print 'Yay, we got a cache hit'\n    else:\n        print 'Boo, it was a cache miss'\n\nd.addCallback(gotCachedData)\n</pre>\n</div>\n\n          </div>"}, "last_serial": 801118, "releases": {"0.1": [{"comment_text": "", "digests": {"md5": "f4264e8875ec0b5d0bb3c45fb1906bcd", "sha256": "a40a4fffebd4cde05f6dba51532367e764b9e7c679a18fd23b849a11c486a0da"}, "downloads": -1, "filename": "txconnpool-0.1.tar.gz", "has_sig": false, "md5_digest": "f4264e8875ec0b5d0bb3c45fb1906bcd", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 7074, "upload_time": "2010-02-22T21:18:31", "upload_time_iso_8601": "2010-02-22T21:18:31.718577Z", "url": "https://files.pythonhosted.org/packages/06/66/f8b8a9b221eb71fc141181d79cd6ca7f370c1b73a65974cfc8f48857e976/txconnpool-0.1.tar.gz", "yanked": false}], "0.1.1": [{"comment_text": "", "digests": {"md5": "f9fc3689820b10138a6c317f1dcc9083", "sha256": "baf2a39de891049e0255dab80fe67ad14fde5dfd2295e01605dd915729a3eeef"}, "downloads": -1, "filename": "txconnpool-0.1.1.tar.gz", "has_sig": false, "md5_digest": "f9fc3689820b10138a6c317f1dcc9083", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 7060, "upload_time": "2010-02-22T21:33:11", "upload_time_iso_8601": "2010-02-22T21:33:11.271989Z", "url": "https://files.pythonhosted.org/packages/ed/93/a3b82d215b0416ff159a6481c5a4cef3f0d92cec4b07b0f04817e54a9c4f/txconnpool-0.1.1.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "f9fc3689820b10138a6c317f1dcc9083", "sha256": "baf2a39de891049e0255dab80fe67ad14fde5dfd2295e01605dd915729a3eeef"}, "downloads": -1, "filename": "txconnpool-0.1.1.tar.gz", "has_sig": false, "md5_digest": "f9fc3689820b10138a6c317f1dcc9083", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 7060, "upload_time": "2010-02-22T21:33:11", "upload_time_iso_8601": "2010-02-22T21:33:11.271989Z", "url": "https://files.pythonhosted.org/packages/ed/93/a3b82d215b0416ff159a6481c5a4cef3f0d92cec4b07b0f04817e54a9c4f/txconnpool-0.1.1.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:43:17 2020"}