{"info": {"author": "Kyle Cooper", "author_email": "coope149@purdue.edu", "bugtrack_url": null, "classifiers": [], "description": "# PyMOSO\n\nPyMOSO is software for solving multi-objective simulation optimization (MOSO) problems and for creating, comparing, and testing MOSO algorithms.\n\n## Reference\n\nIf you use PyMOSO in work leading to publication, please cite the paper which introduces PyMOSO.\n\nCooper, K., Hunter, S. R. 2019. PyMOSO: Software for Multi-Objective Simulation Optimization with R-PERLE and R-MinRLE. <em>INFORMS Journal on Computing</em>, to appear. Preprint: http://www.optimization-online.org/DB_HTML/2018/10/6876.html.\n\n## Additional Reading\nThe initial release of PyMOSO contains solvers that implement four total algorithms, in alphabetical order: R-MinRLE, R-PE, R-PERLE, and R-SPLINE.  The algorithms R-MinRLE, R-PE, R-PERLE were introduced in the following paper:\n\nCooper, K., Hunter, S. R., and Nagaraj, K. 2019. Bi-objective simulation optimization on integer lattices using the epsilon-constraint method in a retrospective approximation framework. <em>INFORMS Journal on Computing</em>, to appear. Preprint: http://www.optimization-online.org/DB_HTML/2018/06/6649.html.\n\nThe algorithm R-SPLINE was introduced in the following paper:\n\nWang, H., Pasupathy, R., and Schmeiser, B. W. 2013. Integer-ordered simulation optimization using R-SPLINE: Retrospective Search with Piecewise-Linear Interpolation and Neighborhood Enumeration. <em>ACM Transactions on Modeling and Computer Simulation</em>, Vol. 23, No. 3, Article 17 (July 2013), 24 pages.  http://dx.doi.org/10.1145/2499913.2499916\n\nWe recommend reading these papers to understand the algorithms, what they return, and the algorithm parameter options that we describe in the user manual.\n\nTable of Contents\n=================\n\n   * [PyMOSO](#pymoso)\n      * [Reference](#reference)\n      * [Additional Reading](#additional-reading)\n      * [Installation](#installation)\n         * [Install PyMOSO from the Python Packaging Index using pip](#install-pymoso-from-the-python-packaging-index-using-pip)\n         * [Install PyMOSO from the repository using pip](#install-pymoso-from-the-repository-using-pip)\n         * [Install PyMOSO from Source Code](#install-pymoso-from-source-code)\n      * [Command Line Interface (CLI)](#command-line-interface-cli)\n         * [CLI help](#cli-help)\n         * [The listitems command for viewing solvers, testers, and oracles included in PyMOSO](#the-listitems-command-for-viewing-solvers-testers-and-oracles-included-in-pymoso)\n         * [The solve command](#the-solve-command)\n            * [The Example Oracle](#the-example-oracle)\n            * [Table of Algorithm-Specific Parameters](#table-of-algorithm-specific-parameters)\n         * [The testsolve Command](#the-testsolve-command)\n            * [The Example Tester](#the-example-tester)\n      * [Implementing problems, testers, and algorithms in PyMOSO](#implementing-problems-testers-and-algorithms-in-pymoso)\n         * [Implementing PyMOSO Oracles](#implementing-pymoso-oracles)\n            * [Example Oracle that Wraps a C Simulation](#example-oracle-that-wraps-a-c-simulation)\n            * [Example Wrapper with PyMOSO Random Numbers](#example-wrapper-with-pymoso-random-numbers)\n         * [Implementing PyMOSO Testers](#implementing-pymoso-testers)\n            * [Example Metric 1](#example-metric-1)\n            * [Example Metric 2](#example-metric-2)\n         * [Implementing PyMOSO Algorithms](#implementing-pymoso-algorithms)\n            * [Template Accelerator](#template-accelerator)\n            * [Template RA Solver](#template-ra-solver)\n            * [Template MOSO Solver](#template-moso-solver)\n               * [Take Simulation Replications at a Point](#take-simulation-replications-at-a-point)\n               * [Find Neighbors and Take Simulation Replications](#find-neighbors-and-take-simulation-replications)\n               * [Argsort a Dictionary of Points](#argsort-a-dictionary-of-points)\n               * [Select the Minimizer and its Value](#select-the-minimizer-and-its-value)\n               * [Use SPLINE to Retrive a Local Minimizer](#use-spline-to-retrive-a-local-minimizer)\n               * [Find the Non-Dominated Points in a Dictionary](#find-the-non-dominated-points-in-a-dictionary)\n               * [Randomly Select Points in a Set](#randomly-select-points-in-a-set)\n         * [Using solve and <code>testsolve</code> in Python Programs](#using-solve-and-testsolve-in-python-programs)\n            * [Minimal solve Example](#minimal-solve-example)\n            * [Some solve Examples with Options](#some-solve-examples-with-options)\n            * [A testsolve Example](#a-testsolve-example)\n            * [Computing a Metric on testsolve Output](#computing-a-metric-on-testsolve-output)\n      * [PyMOSO Object Reference](#pymoso-object-reference)\n         * [The pymoso.prng.mrg32k3a Module](#the-pymosoprngmrg32k3a-module)\n         * [The pymoso.chnbase Module](#the-pymosochnbase-module)\n         * [The pymoso.chnutils Module](#the-pymosochnutils-module)\n         * [The Oracle Class](#the-oracle-class)\n         * [The MOSOSolver Class](#the-mososolver-class)\n         * [The RASolver Class](#the-rasolver-class)\n         * [The RLESolver Class](#the-rlesolver-class)\n\n## Installation\nSince PyMOSO is programmed in Python, every PyMOSO user must first install Python, which can be downloaded from https://www.python.org/downloads/. PyMOSO is compatible with Python versions 3.6 and higher. In the remainder of this section, we assume an appropriate Python version is installed. We discuss three different methods to install PyMOSO: first, from the Python Packaging Index; second, directly from our source code using git; and third, manually installing PyMOSO from our source code.\n\n### Install PyMOSO from the Python Packaging Index using `pip`\nFor ease of distribution, we keep stable, recent releases of PyMOSO on the Python Packaging Index (PyPI). Since the program `pip` is included in Python versions 3.6 and higher, we recommend using `pip` to install PyMOSO. To do so, open a terminal, type the following command, and press enter.  \n\n`pip install pymoso`  \n\nDepending on how users configure their Python installation and how many version of Python they install, they may need to replace `pip` with `pip3`, or other variants of `pip`.  \n\n### Install PyMOSO from the repository using `pip`\nUsers with `git` installed can use `pip` to install the most current version of PyMOSO directly from our source code:  \n\n`pip install git+https://github.com/pymoso/PyMOSO.git`  \n\nWe consider the latest source to be less stable than the fixed releases we upload to PyPI, and thus we recommend most users install PyMOSO from PyPI.  \n\n### Install PyMOSO from Source Code\nUsers may follow the steps below to manually install PyMOSO from any version of the source code.  \n1. Acquire the PyMOSO source code, for example, by downloading it from the repository https://github.com/HunterResearch/PyMOSO.\n1. Install the `wheel` package, e.g. using the `pip install wheel` command.\n1. Open a terminal and navigate into the main project directory which contains the file `setup.py`.\n1. Build the installable PyMOSO package, called a wheel, using the command `python setup.py bdist_wheel`. As with `pip`, some users may need to replace `python` with `python3` or something similar. The command should create a directory named `dist` containing the PyMOSO wheel.\n1. Install the PyMOSO wheel using pip install `dist/pymoso-x.x.x-py3-none-any.whl`, where users replace `x.x.x` with the appropriate PyMOSO version.\n\n\n## Command Line Interface (CLI)\nPyMOSO users solving MOSO problems and testing MOSO algorithms may do so using the command line interface. First, we show how to access the included help file. Then, we show how to view the lists of solvers, testers, and oracles installed by default with PyMOSO. Finally, we discuss the `solve` and `testsolve` commands.\n\n### CLI help\nPyMOSO includes a command line help file. The help file shows syntax templates for every PyMOSO command, the available options, and a selection of example invocations. The `pymoso --help` invocation prints the file to the terminal. The file is also printed when PyMOSO cannot parse an invocation that begins with `pymoso`. We show the current help file below.  \n\n```\nUsage:\n  pymoso listitems\n  pymoso solve [--budget=B] [--odir=D] [--crn] [--simpar=P]\n    [(--seed <s> <s> <s> <s> <s> <s>)] [(--param <param> <val>)]...\n    <problem> <solver> <x>...\n  pymoso testsolve [--budget=B] [--odir=D] [--crn] [--isp=T] [--proc=Q]\n    [--metric] [(--seed <s> <s> <s> <s> <s> <s>)] [(--param <param> <val>)]...\n    <tester> <solver> [<x>...]\n  pymoso -h | --help\n  pymoso -v | --version\n\nOptions:\n  --budget=B                Set the simulation budget [default: 200]\n  --odir=D                  Set the output file directory name. [default: testrun]\n  --crn                     Set if common random numbers are desired.\n  --seed                    Set the random number seed with 6 spaced integers.\n  --simpar=P                Set number of parallel processes for simulation replications. [default: 1]\n  --isp=T                   Set number of algorithm instances to solve. [default: 1]\n  --proc=Q                  Set number of parallel processes for the algorithm instances. [default: 1]\n  --metric                  Set if metric computation is desired.\n  --param                   Specify a solver-specific parameter <param> <val>.\n  -h --help                 Show this screen.\n  -v --version              Show version.\n\nExamples:\n  pymoso listitems\n  pymoso solve ProbTPA RPERLE 4 14\n  pymoso solve --budget=100000 --odir=test1  ProbTPB RMINRLE 3 12\n  pymoso solve --seed 12345 32123 5322 2 9543 666666666 ProbTPC RPERLE 31 21 11\n  pymoso solve --simpar=4 --param betaeps 0.4 ProbTPA RPERLE 30 30\n  pymoso solve --param radius 3 ProbTPA RPERLE 45 45\n  pymoso testsolve --isp=16 --proc=4 TPATester RPERLE\n  pymoso testsolve --isp=20 --proc=10 --metric --crn TPBTester RMINRLE 9 9\n```\nFor now, PyMOSO has three commands: `listitems`, `solve`, and `testsolve`, which we explain below.\n### The `listitems` command for viewing solvers, testers, and oracles included in PyMOSO\nThe default installation of PyMOSO includes a selection of solvers, testers, and oracles. Users can view the complete lists of included solvers, testers, and oracles using the `pymoso listitems` command. We show the current listing below. Test problems A, B, and C refer to those in Cooper et al (2018).\n\n```\nSolver                         Description\n************************       ************************\nRMINRLE                        A solver using R-MinRLE for integer-ordered MOSO.\nRPE                            A solver using R-Pe for integer-ordered bi-objective MOSO.\nRPERLE                         A solver using RPERLE for integer-ordered bi-objective MOSO.\nRSPLINE                        A solver using R-SPLINE for single objective SO.\n\nProblems                       Description                    Test Name (if available)\n************************       ************************       ************************\nProbSimpleSO                   x^2 + noise.                   SimpleSOTester\nProbTPA                        Test Problem A                 TPATester\nProbTPB                        Test Problem B                 TPBTester\nProbTPC                        Test Problem C                 TPCTester\n```\n\n### The `solve` command\nThe PyMOSO `solve` command is for solving MOSO problems. Users can solve the built-in problems (use the `listitems` command to view the built-in problems), however, PyMOSO `solve` users typically will have their own MOSO problem they wish to solve. Thus, we assume users have implemented a PyMOSO oracle named `MyProblem` in `myproblem.py`.  In the examples that follow, we assume the `MyProblem` implementation below, which is a bi-objective oracle with one-dimensional feasible points. See [Implementing PyMOSO Oracles](#implementing-pymoso-oracles) for instructions on implementing a MOSO problem as a PyMOSO oracle.  \n\n#### The Example Oracle\n```python\n# import the Oracle base class\nfrom pymoso.chnbase import Oracle\n\nclass MyProblem(Oracle):\n    '''Example implementation of a user-defined MOSO problem.'''\n    def __init__(self, rng):\n        '''Specify the number of objectives and dimensionality of points.'''\n        self.num_obj = 2\n        self.dim = 1\n        super().__init__(rng)\n\n    def g(self, x, rng):\n        '''Check feasibility and simulate objective values.'''\n        # feasible values for x in this example\n        feas_range = range(-100, 101)\n        # initialize obj to empty and is_feas to False\n        obj = []\n        is_feas = False\n        # check that dimensions of x match self.dim\n        if len(x) == self.dim:\n            is_feas = True\n            # then check that each component of x is in the range above\n            for i in x:\n                if not i in feas_range:\n                    is_feas = False\n        # if x is feasible, simulate the objectives\n        if is_feas:\n            #use rng to generate random numbers\n            z0 = rng.normalvariate(0, 1)\n            z1 = rng.normalvariate(0, 1)\n            obj1 = x[0]**2 + z0\n            obj2 = (x[0] - 2)**2 + z1\n            obj = (obj1, obj2)\n        return is_feas, obj\n```\n\nThe template `solve` command is `pymoso solve oracle solver x0`, where `oracle` is a built-in or user-defined oracle, `solver` is a built-in or user-defined algorithm, and `x0` is a feasible starting point for the solver, with a space between each component. As a first example, we solve the user-defined `MyProblem` using the built-in R-PERLE starting at the feasible point 97.  \n\n\n`pymoso solve myproblem.py RPERLE 97`  \n\nSimilarly, we can solve built-in problems, such as `ProbTPA` which has two-dimensional feasible points.  \n\n`pymoso solve ProbTPA RPERLE 40 40`  \n\nHenceforth, we present `solve` examples only for solving `MyProblem`.  Since `MyProblem` is bi-objective, we recommend using the `R-PERLE` solver. However, for two or more objectives, PyMOSO implements `R-MinRLE`.  \n\n`pymoso solve myproblem.py RMINRLE 97`  \n\nFor a single objective problem, PyMOSO implements `R-SPLINE`. We remark that if given a multi-objective problem, `R-SPLINE` will simply minimize the first objective. We do not necessarily prohibit such use, but urge that users take care when using R-SPLINE to minimize one objective of a many-objective problem.  \n\n`pymoso solve myproblem.py RSPLNE 97`  \n\nRegardless of the chosen solver, PyMOSO creates a new sub-directory of the working directory containing output. There will be a metadata file, indicating the date, time, solver, problem, and any other specified options. In addition, PyMOSO creates a file containing the solver-generated solution. PyMOSO provides additional options for users solving MOSO problems. We present examples of each option below. First, users can specify the name of the output directory.  \n\n`pymoso solve --odir=OutDirectory myproblem.py RPERLE 45`  \n\nUsers can specify the simulation budget, which is currently set to a default of 200.  \n\n`pymoso solve --budget=100000 myproblem.py RPERLE 12`  \n\nUsers may specify to take simulation replications in parallel. We only recommend doing so if the user has thought through appropriate pseudo-random number stream control issues (see [Implementing PyMOSO Oracles](#implementing-pymoso-oracles)). Furthermore, due to the overhead of parallelization, we only recommend using the parallel simulation replications feature if observations are sufficiently \"expensive\" to compute, e.g. the simulation takes a half second or more to generate a single observation. We remark that the run-time complexity of the simulation oracle may not perfectly indicate when it is appropriate to use parallelization; other factors include, e.g., the total simulation budget.  \n\n`pymoso solve --simpar=4 myproblem.py RPERLE 44`  \n\nCurrently, all PyMOSO solvers support using common random numbers. Users may enable the functionality using the `--crn` option.  \n\n`pymoso solve --crn myproblem.py RMINRLE 62`  \n\nWe do not recommend this option unless the oracle is implemented to be compatible, that is, the oracle uses PyMOSO's pseudo-random number generator to generate pseudo-random numbers or to provide a seed to an external `mrg32k3a` generator (see [Implementing PyMOSO Oracles](#implementing-pymoso-oracles)).   \n\nUsers may specify an initial seed to PyMOSO's `mrg32k3a` pseudo-random number generator. Seeds must be 6 positive integers with spaces. The default is 12345 for each of the 6 components.  \n\n`pymoso solve --seed 1111 2222 3333 4444 5555 6666 myproblem.py RPERLE 23`  \n\nUsers may specify algorithm-specific parameters (see the papers in which the algorithms were introduced for detailed explanations of the parameters.) All parameters are specified in the form `--param name value`. For example, the RLE relaxation parameter can be specified and set as `betadel` to a real number. We refer the reader to [the table](#table-of-algorithm-specific-parameters) for the full list of currently available algorithm-specific parameters.  \n\n`pymoso solve --param betadel 0.2 myproblem.py RPERLE 34`  \n\nFinally, users may specify any number of options in one invocation. However, all options must be specified in after the `solve` command and before the `myproblem.py` argument. Furthermore, any `--param` options must be the last options. (Note that the `\\` at the end of the first line continues the command to the second line.)\n\n`pymoso solve --crn --simpar=4 --budget=10000 --seed 1 2 3 4 5 6 \\`  \n`     --odir=Exp1 --param mconst 4 --param betadel 0.7 myproblem.py RPERLE 97`  \n\n\n#### Table of Algorithm-Specific Parameters  \n\n| Parameter Name | Default Value | Affected Solvers | Description |\n| -------------- | ------------- |  --------------  | ----------- |\n| `mconst`       |    2          |`RPERLE`, `RMINRLE`, `RPE`, `RSPLINE` | Initialize the sample size and subsequent schedule of sample sizes.|  \n| `bconst`       |    8          |`RPERLE`, `RMINRLE`, `RPE`, `RSPLINE` | Initialize the search sampling limit and subsequent schedule of limits. |  \n| `radius`       |   1           |`RPERLE`, `RMINRLE`, `RPE`, `RSPLINE` | Sets radius that determines a point's neighborhood. |  \n| `betadel` | `0.5` | `RPERLE`, `RMINRLE` | Roughly, affects how likely it is for RLE to keep its given solution. |  \n| `betaeps` | `0.5` | `RPERLE`, `RPE` | Roughly, affects how likely PE will perform a search from a point. |   \n\n\n### The `testsolve` Command  \nThe PyMOSO `testsolve` command tests algorithms on problems using a PyMOSO tester. Users can test built-in or user-defined solvers with built-in or user-defined testers. In the examples that follow, we assume users have implemented `MyProblem` as in [The Example Oracle](#the-example-oracle) and the corresponding tester named `MyTester` in `mytester.py`, shown in [The Example Tester](#the-example-tester). See [Implementing PyMOSO Testers](#implementing-pymoso-testers) for instructions on implementing a user-defined tester, including a metric for comparing algorithms, in PyMOSO.  \n\n#### The Example Tester\n```python\nimport sys, os\nsys.path.insert(0,os.path.dirname(__file__))\n# use hausdorff distance (dh) as an example metric\nfrom pymoso.chnutils import dh\n# import the MyProblem oracle\nfrom myproblem import MyProblem\n\n# optionally, define a function to randomly choose a MyProblem feasible x0\ndef get_ranx0(rng):\n    val = rng.choice(range(-100, 101))\n    x0 = (val, )\n    return x0\n\n# compute the true values of x, for computing the metric\ndef true_g(x):\n    '''Compute the objective values.'''\n    obj1 = x[0]**2\n    obj2 = (x[0] - 2)**2\n    return obj1, obj2\n\n# define an answer as appropriate for the metric\nmyanswer = {(0, 4), (4, 0), (1, 1)}\n\nclass MyTester(object):\n    '''Example tester implementation for MyProblem.'''\n    def __init__(self):\n        self.ranorc = MyProblem\n        self.answer = myanswer\n        self.true_g = true_g\n        self.get_ranx0 = get_ranx0\n\n    def metric(self, eles):\n        '''Metric to be computed per retrospective iteration.'''\n        epareto = [self.true_g(point) for point in eles]\n        haus = dh(epareto, self.answer)\n        return haus\n```\n\nThe template `testsolve` command is `pymoso testsolve tester solver` where `tester` is a built-in or user-defined tester, and `solver` is a built-in or user-defined solver. Users may also specify an `x0`, as in the `solve` command, if the `tester` does not implement the function to generate feasible points. As a first example, we test `RPERLE` on `MyProblem` using `MyTester`. Since some options are compatible with both `solve` and `testsolve`, we include those options in this example.  \n\n`pymoso testsolve --budget=999 --odir=exp1 \\`  \n`    --crn --seed 1 2 3 4 5 6 mytester.py RPERLE`  \n\nUsers may want to compute some metric on the algorithm-generated solutions. If a metric is defined as part of the tester, such as in `MyTester`, the `testsolve` command can compute the metric on every algorithm iteration using the `--metric` option.  \n\n`pymoso testsolve  --metric  mytester.py RPERLE`  \n\nThe `testsolve` command cannot perform simulation replications in parallel. However, testers can apply the solvers to independent sample paths of the problems. For example, to test `RPERLE` on 100 independent sample paths of `MyProblem`, compute the metrics for each sample path, and use common random numbers in each sample path, use the following command.  \n\n`pymoso testsolve --crn --metric --isp=100 mytester.py RPERLE`  \n\nPyMOSO can perform independent algorithm runs in parallel. Use the `--proc` option to specify the number of processes available to PyMOSO.  \n\n`pymoso testsolve --crn --metric --isp=100 --proc=20 mytester.py RPERLE`  \n\nWe remark here that, to ensure the algorithm runs remain independent using PyMOSO's pseudo-random number generator (see [Implementing PyMOSO Oracles](#implementing-pymoso-oracles)), researchers should set the total simulation budget so that the included algorithms do not surpass 200 retrospective approximation (RA) iterations. For reference, using the default settings, the sample size at every point in the 200th RA iteration is almost 380 million.  \n\nThe `testsolve` command creates a results file for each independent sample path. The file contains the solutions generated at every algorithm iteration, such that the solution of iteration 2 is on line 2, iteration 10 on line 10, and so forth. If `--metric` is specified, PyMOSO generates a second file for each independent sample path containing the collection of triples (iteration number, simulations used at end of iteration, metric).  \n\n## Implementing problems, testers, and algorithms in PyMOSO\nTo use PyMOSO, users solving MOSO problems must implement a PyMOSO oracle, and users testing MOSO algorithms should implement, at least, a PyMOSO oracle and tester. In this section, we provide template Python code to help users quickly implement oracles, testers, and perhaps solvers in PyMOSO.\n\n### Implementing PyMOSO Oracles\nUsually, implementing a PyMOSO oracle implies implementing a Monte Carlo simulation oracle as a black box function while following the PyMOSO rules put forth in this section. For reference, we discuss the example PyMOSO oracle `MyProblem` in [The Example Oracle](#the-example-oracle). Users may copy the code in [The Example Oracle](#the-example-oracle) and re-implement the function `g` as needed. We now list the basic requirements of every `g` implementation.  \n\n1. The function `g` must be an instance method of an `Oracle` sub-class, and thus take `self` as its first parameter.\n1. The function `g` must take an arbitrarily-named second parameter which is a tuple of length `self.dim` and represents a point. Stylistically, PyMOSO consistently names this parameter `x`.\n1. The function `g` must take an arbitrarily-named third parameter which is a modified Python `random.Random` object. Stylistically, PyMOSO consistently names this parameter `rng`.\n1. The function `g` must return a boolean first and a tuple of length `self.num_obj` second.\n   - The boolean is `True` if `x` is feasible, and `False` otherwise.\n   - If `x` is feasible, the tuple contains a single observation of every objective. If `x` is not feasible, each element in the tuple is `None`.\n\nIf users already have an implemented simulation oracle, they may find it convenient to implement `g` as wrapper which calls that simulation from Python. As an example, suppose a user has implemented a simulation in C which is compiled to a C library called `mysim.so` and placed in the working directory. Suppose further that the simulation function takes the following as parameters: an array of integers representing a point and an unsigned integer representing the number of observations to take at `x`. The function output is defined as `struct Simout` with members `feas` set to 0 or 1, `obj` a double array set to the mean of the observed objective values, and `var` a double array set to the sample variance of the observed objective values. Then users can modify the template to wrap the C function `struct Simout c_func(int x, int n)` as in [the example](#example-oracle-that-wraps-a-c-simulation).  \n\n#### Example Oracle that Wraps a C Simulation\n```python\nfrom ctypes import CDLL, c_double, c_uint, c_int, Structure\nimport os.path\nlibname = 'mysim.so'\nlibabspath = os.path.dirname(os.path.abspath(__file__)) + os.path.sep + dll_name\nlibobj = CDLL(libabspath)\n\nclass Simout(Structure):\n    _fields_ = [(\"feas\", c_int), (\"obj\", c_double*2), (\"var\", c_double*2)]\ncsimout = libobj.c_func\ncsimout.restype = Simout\n\nfrom pymoso.chnbase import Oracle\n\nclass MyProblem(Oracle):\n    '''Example implementation of a user-defined MOSO problem.'''\n    def __init__(self, rng):\n        '''Specify the number of objectives and dimensionality of points.'''\n        self.num_obj = 2\n        self.dim = 1\n        super().__init__(rng)\n\n    def g(self, x, rng):\n        '''Check feasibility and simulate objective values.'''\n        is_feasible = True\n        objective_values = (None, None)\n        # g takes only one observation so set the c_func parameter to 1\n        c_n = c_uint(1)\n        # c_func requires is an integer so convert it -- this is a 1D example\n        c_x = c_int(x[0])\n        # call the C function\n        mysimout = csimout(c_x, c_n)\n        if not mysimout.feas:\n            is_feasible = False\n        else:\n            is_feasible = True\n        if is_feasible:\n            objective_values = tuple(mysimout.obj)\n        return is_feasible, objective_values\n```\n\n\n[The C wrapper example](#example-oracle-that-wraps-a-c-simulation) is a valid PyMOSO oracle which wraps a C function. However, PyMOSO algorithms cannot enable common random numbers on this oracle. Furthermore, PyMOSO cannot guarantee that observations are independent when taken in parallel. To enable these properties, the external simulation must use `mrg32k3a` as the generator and must accept a user-specified seed.  \n\nSuppose the library `mysim.so` also implements the function `set_simseed` which accepts a long array representing an `mrg32k3a` seed. We modify the [wrapper](#example-oracle-that-wraps-a-c-simulation) for compatibility with common random numbers and to guarantee independence of parallel observations.  [The new wrapper](#example-wrapper-with-pymoso-random-numbers) demonstrates using `rng.get_seed()` to return the current `mrg32k3a` seed.\n\n#### Example Wrapper with PyMOSO Random Numbers\n```python\nfrom ctypes import CDLL, c_double, c_uint, c_int, Structure, c_long\nimport os.path\nlibname = 'mysim.so'\nlibabspath = os.path.dirname(os.path.abspath(__file__)) + os.path.sep + dll_name\nlibobj = CDLL(libabspath)\n\nclass Simout(Structure):\n    _fields_ = [(\"feas\", c_int), (\"obj\", c_double*2), (\"var\", c_double*2)]\ncsimout = libobj.c_func\ncsetseed = libobj.set_simseed\ncsimout.restype = Simout\n\nfrom pymoso.chnbase import Oracle\n\nclass MyProblem(Oracle):\n    '''Example implementation of a user-defined MOSO problem.'''\n    def __init__(self, rng):\n        '''Specify the number of objectives and dimensionality of points.'''\n        self.num_obj = 2\n        self.dim = 1\n        super().__init__(rng)\n\n    def g(self, x, rng):\n        '''Check feasibility and simulate objective values.'''\n        is_feasible = True\n        objective_values = (None, None)\n        # get the PyMOSO seed from rng\n        seed = rng.get_seed()\n        # convert the seed to c_long array\n        c_longarr = c_long*6\n        c_seed = c_longarr(seed[0], seed[1], seed[2], seed[3], seed[4], seed[5])\n        # use the library function to set the sim seed\n        csetseed(c_seed)\n        # g takes only one observation so set the c_func parameter to 1\n        c_n = c_uint(1)\n        # c_func requires is an integer so convert it -- this is a 1D example\n        c_x = c_int(x[0])\n        # call the C function\n        mysimout = csimout(c_x, c_n)\n        if not mysimout.feas:\n            is_feasible = False\n        else:\n            is_feasible = True\n        if is_feasible:\n            objective_values = tuple(mysimout.obj)\n        return is_feasible, objective_values\n```\n\nAlternatively, if the number of required pseudo-random numbers is known, users can use `rng.random()` to generate pseudo-random numbers and then pass them to an external simulation if such functionality is supported.\n\nThe `rng` object is implemented as a sub-class of Python's `random.Random` class, thus the official Python documentation for `random` applies to `rng` and is found at https://docs.python.org/3/library/random.html. In addition to `rng` using `mrg32k3a` as its generator, we also implement `rng.normalvariate` such that it uses the Beasley-Springer-Moro algorithm (Law 2015, p. 458) to approximate the inverse of the standard normal cumulative distribution function.\n\nWhen using `rng`, to ensure independent sampling of observations, PyMOSO \"jumps\" forward in the pseudo-random number stream after obtaining every simulation replication. Each jump is of fixed size 2^76 pseudo-random numbers. Thus, we require that every simulation replication use fewer than 2^76 pseudo-random numbers. We ensure independence among parallel replications by \"giving\" each processor a stream (an `rng`), each of which is 2^127 pseudo-random numbers apart. When using the current PyMOSO algorithms that rely on RA, each RA iteration begins the next available independent stream 2^127, where PyMOSO accounts for the possibility of parallel computation within an RA iteration. Thus, in a given RA iteration, a user may simulate 100 million points at a sample size of 1 million, without common random numbers, and easily not reach the limit.\n\n### Implementing PyMOSO Testers  \nConsider again the [example tester](#the-example-tester). As a minimal valid PyMOSO tester, users may do nothing but assign the `MyTester` member `self.ranorc` to a PyMOSO oracle, such as [`MyProblem`](#the-example-oracle), in Line 27. However, we expect most users to leverage PyMOSO features by implementing metrics and  feasible point generators. The function `get_ranx0` allows the tester to generate feasible points to `MyProblem` and `metric` allows the tester to compute a metric on sets returned by a solver. Researchers may implement any number of additional supporting functions, including members and methods of the tester class. The `true_g` function is an example of such a supporting function, which is used to compute the example metric.  \n\nFirst, we list the rules for implementing a feasible point generator.\n1. The function is arbitrarily named but must be set to the `self.get_ranx0` member of a tester.\n1. The function must take a single parameter, an arbitrarily named `random.Random` object we suggest naming `rng`.\n1. The function must return a tuple with length corresponding to the `self.dim` member of the `self.ranorc` member of the tester.\n\nSince a researcher's desired metric depends on the algorithm capabilities and problem complexity, PyMOSO allows researchers to implement any metric they choose. We provide three example metrics, but first, we list the implementation rules of the `metric` function.  \n\n1. The \\inline{metric} function must be an instance method of a tester, and thus take \\inline{self} as its first parameter.\n1. The second parameter of \\inline{metric} is arbitrarily named and is a Python set of tuples.\n1. PyMOSO does not enforce the return value of \\inline{metric}, but we recommend a scalar real number.\n\nThe metric implemented in the [example tester](#the-example-tester) is the Hausdorff distance from (a) the true image of an estimated solution returned by an algorithm, to (b) the true solution hard-coded as `myanswer`.  \n\nFor an example of a different metric, consider a MOSO problem that has more than one local efficient set (LES) and such that each LES contains no members of another LES. Since an algorithm that converges to a LES is may find only one LES, we may define the metric to compute the Hausdorff distance between the true image of the estimated solution and the \"closest\" true LES, as follows. Let `self.answer` be implemented as a list of sets, and assume a `self.true_g` implementation. Then the [following example](#example-metric-1) implements the described metric.  \n\n#### Example Metric 1\n```python\ndef metric(self, eles):\n    # use the distance to the closest set.\n    epareto = [self.true_g(point) for point in eles]\n    # self.soln is a list of sets\n    dist_list = [dh(epareto, les) for les in self.answer]\n    return min(dist_list)\n```\n\nFor single-objective problems with one correct solution `x*`, a simple metric that takes an estimated solution `X` is `|g(X) - g(x*)|`, which we implement in the [second example metric](#example-metric-2) assuming an appropriate implementation of `self.answer` and `self.true_g`.  \n\n#### Example Metric 2\n```python\ndef metric(self, singleton_set):\n    # single objective algorithms still return a set\n    point, = singleton_set\n    # let self.soln be a real number\n    dist = abs(self.true_g(point) - self.answer)\n    return dist\n\n```\n\n### Implementing PyMOSO Algorithms\nResearchers can implement simulation optimization algorithms in the PyMOSO framework. PyMOSO provides support for algorithms in three categories:\n1. PyMOSO provides strong support for implementing new MOSO algorithms that rely on RLE in an RA framework.\n1. PyMOSO provides strong support for implementing general RA algorithms.\n1. PyMOSO provides basic support, such as pseudo-random number control, for implementing other simulation optimization algorithms.\nWe provide templates of algorithms implemented in each of these three categories, along with example code snippets.\n\nIn the first category, programmers can use PyMOSO to create new RA algorithms that use RLE for convergence. The novel part of these algorithms, created by the user, will be the `accel` function which should collect points to send to RLE for certification. Here, we list the rules for `accel`.\n1. The `accel` function must be an instance method of an `RLESolver` object, and thus its first parameter must be `self`.\n1. The second parameter is arbitrarily named and is a set of tuples. We recommend naming the parameter `warm_start`, as it represents the sample-path solution of the previous RA iteration.\n1. The return value must be a set of tuples representing feasible points; we do not recommend any particular name.\nIn every RA iteration, PyMOSO will first call `accel(self, warm_start)` and send the returned set to `rle(self, candidate_les)`. The return value must be a set of tuples. The implementer does not need to implement or call RLE, as in the [template accelerator](#template-accelerator).\n\n#### Template Accelerator\n```python\nfrom pymoso.chnbase import RLESolver\n\n# create a subclass of RLESolver\nclass MyAccel(RLESolver):\n    '''Example implementation of an RLE accelerator.'''\n\n    def accel(self, warm_start):\n        '''Return a collection of points to send to RLE.'''\n        # implement algorithm logic here and return a set\n        return warm_start\n```\n\nIn the second category, algorithm designers can quickly implement any RA algorithm by sub-classing `RASolver` and implementing the `spsolve` function, as shown in the [RA solver template](#template-ra-solver). The algorithm can be a single-objective algorithm. PyMOSO cannot guarantee the convergence of such algorithms. The template is technically valid in PyMOSO but is probably not effective.  \n\n#### Template RA Solver\n```python\nfrom pymoso.chnbase import RASolver\n\nclass MyRAAlg(RASolver):\n    '''Template implementation of an RA solver.'''\n\n    def spsolve(self, warm_start):\n        '''Return the sample path solution.'''\n        # implement algorithm logic here and return a set\n        return warm_start\n```\n\nThough analogous to those of an `RLESolver.accel` method, for completeness, we list the requirements for an `RASolver.spsolve` method.\n1. The `spsolve` function must be an instance method of an `RASolver` object, and thus its first parameter must be `self`.\n1. The second parameter is arbitrarily named and is a set of tuples. We recommend naming the parameter `warm_start` as it represents the sample-path solution of the previous RA iteration.\n1. The return value must be a set of tuples representing feasible points; we do not recommend any particular name.  \n\nIn the third category, PyMOSO can accommodate any simulation optimization algorithm by implementing the `solve` function of a `MOSOSolver` sub-class [as shown](#template-moso-solver). It does not have to be a multi-objective algorithm. PyMOSO will require users to send an initial feasible point `x0` whether or not the algorithm needs it. The initial feasible point `x0` is accessed through `self.x0` which is a tuple. We now list the rules for implementing any `MOSOSolver.solve` function.\n1. The `solve` function must be an instance method of `MOSOSolver`, and thus take `self` as its first parameter.\n1. The second parameter is the simulation budget, a natural number.\n1. The `solve` function must return a dictionary (we name it `results` in our example) with at least 3 keys: `'itersoln'`, `'simcalls'`, `'endseed'`. Researchers may track additional data and add it to `results` as desired.\n   - The `'itersoln'` key itself corresponds to a dictionary with a key for each algorithm iteration labeled {0, 1, ...}. The value at each iteration is a set containing the estimated solution at the end of the iteration.\n   - The `'simcalls'` key itself corresponds to a dictionary with a key for each algorithm iteration labeled {0, 1, ...}. The value at each iteration is a natural number containing the cumulative number of simulation replications taken at the end of the iteration.\n   - The `'endseed'` key corresponds to a tuple of length 6, representing an `mrg32k3a` seed. The algorithm programmer should ensure the stream generated by `results['endseed']` is independent of all streams used by the algorithm.\n\nResearchers may use the [MOSO template](#template-moso-solver)  to implement new simulation optimization algorithms.  \n\n#### Template MOSO Solver\n```python\nfrom pymoso.chnbase import MOSOSolver\n\nclass MyMOSOAlg(MOSOSolver):\n    '''Template implementation of a MOSO solver.'''\n\n    def solve(self, budget):\n        while self.num_calls <= budget:\n            # implement algorithm logic and return the results\n        return results\n```\n\nFor convenience, in the mini-sections below, we also provide some example code snippets that we find useful when implementing algorithms in PyMOSO. They work without modification when using the templates above that inherit \\inline{RLESolver} or \\inline{RASolver}, but some functions may require implementation or modification for use in a `MOSOSolver`. For reference, [this section](#pymoso-object-reference) contains a list of most objects accessible to PyMOSO programmers.\n\n##### Take Simulation Replications at a Point\n```python\nfrom pymoso.chnutils import get_nbors\n# pretend x has not yet been visited in this RA iteration and is feasible\nx = (1, 1, 1)\n\n# self.m is the sample size of the current RA iteration\nm = self.m\n# self.num_calls is the cumulative number of simulations used till now\nstart_num_calls = self.num_calls\n# use estimate to sample x and put results in self.gbar and self.sehat\nisfeas, fx, se = self.estimate(x)\ncalls_used = self.num_calls - start_num_calls\nprint(m == calls_used) # True\nprint(fx == self.gbar[x]) # True\nprint(se == self.sehat[x]) # True\n\n# estimate will not simulate again in subsequent visits to a point\nstart_num_calls = self.num_calls\nisfeas, fx, se = self.estimate(x)\ncalls_used = self.num_calls - start_num_calls\nprint(calls_used == 0) # True\n```\n##### Find Neighbors and Take Simulation Replications\n```python\n# neighborhood radiuss\nr = self.nbor_rad\nnbors = get_nbors(x0, r)\nself.upsample(nbors)\nfor n in nbors:\n  print(n in self.gbar) # True if n feasible else False\n\n# upsample also returns the feasible subset\nnbors = self.upsample(nbors)\n```\n##### Argsort a Dictionary of Points\n```python\n# 0 index for first objective\nsorted_feas = sorted(nbors | {x}, key=lambda t: self.gbar[t][0])\n```\n##### Select the Minimizer and its Value\n```python\nxmin = sorted_feas[0]\nfxmin = self.gbar[x]\n```\n##### Use SPLINE to Retrive a Local Minimizer\n```python\n# no constraints and minimize the 2nd objective\nx0 = (2, 2, 2)\nisfeas, fx, sex = self.estimate(x0)\n# the suppressed value is the set visited along SPLINE's trajectory\n_, xmin, fxmin, sexmin = self.spline(x0, float('inf'), 1, 0)\nprint(self.gbar[xmin] == fxmin) # True\n```\n##### Find the Non-Dominated Points in a Dictionary\n```python\nfrom chnutils import get_nondom\nnondom = get_nondom(self.gbar)\n```\n##### Randomly Select Points in a Set\n```python\nsolver_rng = self.sprn\n# pick 5 points -- returns a list, not a set.\nran_pts = solver_rng.sample(list(nondom), 5)\none_in_five = solver_rng.choice(ran_pts)\n```\n\n### Using `solve` and `testsolve` in Python Programs\nUsers may the `solve` and `testsolve` functions within a Python program.\n\n#### Minimal `solve` Example\n```python\n# import the solve function\nfrom pymoso.chnutils import solve\n# import the module containing the RPERLE implementation\nimport pymoso.solvers.rperle as rp\n# import MyProblem - myproblem.py should usually be in the script directory\nimport myproblem as mp\n\n# specify an x0. In MyProblem, it is a tuple of length 1\nx0 = (97,)\nsoln = solve(mp.MyProblem, rp.RPERLE, x0)\nprint(soln)\n```\n#### Some `solve` Examples with Options\n```python\n# example for specifying budget and seed\nbudget=10000\nseed = (111, 222, 333, 444, 555, 666)\nsoln1 = solve(mp.MyProblem, rp.RPERLE, x0, budget=budget, seed=seed)\n\n# specify crn and simpar\nsoln2 = solve(mp.MyProblem, rp.RPERLE, x0, crn=True, simpar=4)\n\n# specify algorithm specific parameters\nsoln3 = solve(mp.MyProblem, rp.RPERLE, x0, radius=2, betaeps=0.3, betadel=0.4)\n\n# mix them\nsoln4 = solve(mp.MyProblem, rp.RPERLE, x0, crn=True, seed=seed, radius=5)\n```\n\n#### A `testsolve` Example\n```python\n# import the testsolve functions\nfrom pymoso.chnutils import testsolve\n# import the module containing RPERLE\nimport pymoso.solvers.rperle as rp\n# import the MyTester class\nfrom mytester import MyTester\n\n# testsolve needs a \"dummy\" x0 even if MyTester will generate them\nx0 = (1, )\nrun_data = testsolve(MyTester, rp.RPERLE, x0, isp=100, crn=True, radius=2)\n```\n\n#### Computing a Metric on `testsolve` Output\nProgrammers must compute their metric. Here, `run_data` is a dictionary of the form described [here](#implementing-pymoso-algorithms) and we compute the metric on the 5th iteration of of the 12th independent algorithm instance.\n```python\niter5_soln = run_data[11]['itersoln'][4]\nisp12_iter5_metric = MyTester.metric(iter5_soln)\n```\n\n## PyMOSO Object Reference\n### The `pymoso.prng.mrg32k3a` Module\nThe `pymoso.prng.mrg32k3a` module exposes the pseudo-random number generator and functions to manipulate it.\n\n| Object | Description |\n| ------ | ----------- |\n| `MRG32k3a` | Sub-class of random.Random, defines all `rng` objects. |\n| `get_next_prnstream(seed)` | Return an `rng` object seeded 2^127 steps from the input seed.|\n| `jump_substream(rng)` | Seed the input `rng` object 2^76 steps forward. |\n\n### The `pymoso.chnbase` Module\nThe `pymoso.chnbase` module implements the base classes for oracles and solvers. Programmers should sub-class these when creating new PyMOSO implementations.\n| Class | Description |\n| ------ | ----------- |\n| `Oracle` | Base class for implementing oracles. |\n| `RLESolver` | Base class for implementing solvers using RLE. |\n| `RASolver` | Base class for implementing RA solvers.|\n|`MOSOSolver` | Base class for all solvers. |\n\n### The `pymoso.chnutils` Module\nThe `pymoso.chnutils` contains useful functions for implementing and testing algorithms.  \n\n| Function | Description |\n| ------ | ----------- |\n|`solve(oracle, solver, x0, **kwargs)` | [See here](#minimal-solve-example) for instructions. |\n|`testsolve(tester, solver, x0, **kwargs)` | [See here](#a-testsolve-example) for instructions. |\n|`does_weak_dominate(g, h, relg, relh)` | All inputs are tuples of equal length. Returns `True` if `g` weakly dominates `h` with the relaxations. |\n|`does_dominate(g, h, relg, relh)` | Returns `True` if `g` dominates `h` with the relaxations. |\n|`does_strict_dominate(g, h, relg, relh)` | Returns `True` if `g` strictly dominates `h` with the relaxations. |\n|`get_nondom(obj_dict)` | Input: a dictionary with tuples for keys and values. The keys are feasible points; the values are their objective values. Return: a set of tuples representing non-dominated points. |\n|`get_nbors(x, r)` | Input: a tuple `x`, a positive real scalar `r` indicating the neighborhood radius. Return: Set of tuples which are the neighbors.|\n|`get_setnbors(S, r)` | Input: a set of tuples, and the neighborhood radius. Return: the union of `get_nbors(s, r)` for every `s` in `S`. |\n| `dh(A, B)` | Returns the Hausdorff distance between set `A` and set `B`. |\n|`edist(x1, x2)` | Return the Euclidean distance from `x1` to `x2`. |\n|`get_metric(results, tester)` | Input: `results` is a dictionary, the output of each sample path of `testsolve`. `tester` must implement `metric`. Returns: The set of triples (iteration, simulation count, metric) for an algorithm run.|\n\n### The `Oracle` Class\nWhen implementing `RASolver` algorithms, programmers may not need to access `Oracle` objects directly at all. When implementing `MOSOSolver` algorithms, programmers will use (or wrap) `hit` and `crn_advance()`.  \n\n| Member/Method | Description |\n| ------ | ----------- |\n|`num_obj` | A positive integer, the number of objectives.|\n|`dim` | A positive integer, the dimensionality of feasible points. |\n| `rng` | An instance of `MRG32k3a`.|\n|`hit(x, n)` | Take `n` observations of `x`. Return: `True`, and a tuple containing the mean of the observations for each objective, and a tuple containing the standard error for each objective if `x` is feasible. The function handles CRN internally. |\n|`set_crnflag(bool)` | Turn CRN on (`True`) or off. |\n|`set_crnold(state)` | Save the `rng` state as the CRN baseline, e.g. for an algorithm iteration. Get the state using `rng.getstate()`. |\n|`crn_reset()` | Back the oracle `rng` to the CRN baseline. |\n|`crn_advance()` | If CRN is on, reset, and then jump to the next independent pseudo-random stream and save the new baseline, e.g. before starting a new algorithm iteration. |\n|`crn_setobs()` | Set an intermediate CRN for individual oracle observations. |\n|`crn_nextobs()` | Jump the `rng` forward, e.g. after taking an observation, and `crn_setobs` the seed. |\n|`crn_check()` | f CRN is on, return to the baseline. Otherwise, use `crn_nextobs` before taking the next observation. |\n\n### The `MOSOSolver` Class\n\nThe class provides a basic structure for implementing new MOSO algorithms in PyMOSO.  \n\n| Member/Method | Description |\n| ------ | ----------- |\n|`orc` | The oracle object for the solver to solve. |\n|`dim` | Number of dimensions of points in the feasible set. Should match `self.orc`|\n|`num_obj`| Similarly, the number of objectives in `self.orc`. |\n|`num_calls` | A running count of the number of simulation replications taken of `self.orc`.|\n|`x0` | A feasible starting point. This point is additionally supplied to algorithms that don't need one.|\n\n### The `RASolver` Class\n\nThe class implements a common structure for all RA algorithms, including: caching of simulation replications, scheduling and updating of sample sizes and limits, and a wrapper to `Oracle.hit`.  \n\n| Member/Method | Description |\n| ------ | ----------- |\n|`sprn` | An instance of `MRG32k3a` for the solver to use.|\n|`nbor_rad` | The neighborhood radius used by solvers seeking local optimality. |\n| `gbar` | A dictionary where every key and value is a tuple. The keys are feasible points, values are their objective values. `gbar` is \"wiped\" every retrospective iteration. |\n|`sehat` | Exactly like `gbar` except the values are standard errors.|\n|`m` | The sample size of the current iteration. |\n|`calc_m(nu)` | Compute the sample size of the current iteration. RA algorithms automatically do this every iteration and assign the value to `m'.|\n|`b` | The searching sample limit of the current iteration. |\n|`calc_b(nu)` | Exactly as `calc_m` but for the searching sample limit.|\n|`estimate(x, c, obj)`| The `estimate` function is essentially a smart wrapper for `self.orc.hit`. Inputs: tuple `x` to sample, `c` a feasibility constraint, `obj` the objective to constrain. Return: same as `Oracle.hit`. Retrieves or saves the results from/to `gbar` and `sehat` as appropriate. Returns not feasible if the otherwise feasible result is not less than the constraint.|\n|`upsample(S)`| A version of `estimate` for sets. Returns the feasible subset of `S`.|\n|`spline(x, c, obmin, obcon)` | Return a sample path local minimizer. Input: a feasible start, constraint, objective to minimize, objective to constrain. Return: a set of tuples of the trajectory, the minimizer tuple, the minimum tuple, the standard error tuple.|\n\n### The `RLESolver` Class\n\nThe sub-class of \\inlinetwo{RASolver} adds RLE and its relaxation.\n\n| Member/Method | Description |\n| ------ | ----------- |\n|`betadel` | Affects the relaxation values computed in RLE. |\n|`calc_delta(se)` | Computes the RLE relaxation given a standard error, using `self.m` and `self.betadel`. |\n|`rle(candidate_les)` | Input: set of tuples, Returns: set of tuples. Finds the LES at sample size `self.m`.|\n\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/pymoso/PyMOSO", "keywords": "", "license": "", "maintainer": "", "maintainer_email": "", "name": "pymoso", "package_url": "https://pypi.org/project/pymoso/", "platform": "", "project_url": "https://pypi.org/project/pymoso/", "project_urls": {"Homepage": "https://github.com/pymoso/PyMOSO"}, "release_url": "https://pypi.org/project/pymoso/1.0.8/", "requires_dist": ["docopt"], "requires_python": ">=3.6.0", "summary": "Python Multi-Objective Simulation Optimization: a package for using, implementing, and testing simulation optimization algorithms.", "version": "1.0.8", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>PyMOSO</h1>\n<p>PyMOSO is software for solving multi-objective simulation optimization (MOSO) problems and for creating, comparing, and testing MOSO algorithms.</p>\n<h2>Reference</h2>\n<p>If you use PyMOSO in work leading to publication, please cite the paper which introduces PyMOSO.</p>\n<p>Cooper, K., Hunter, S. R. 2019. PyMOSO: Software for Multi-Objective Simulation Optimization with R-PERLE and R-MinRLE. <em>INFORMS Journal on Computing</em>, to appear. Preprint: <a href=\"http://www.optimization-online.org/DB_HTML/2018/10/6876.html\" rel=\"nofollow\">http://www.optimization-online.org/DB_HTML/2018/10/6876.html</a>.</p>\n<h2>Additional Reading</h2>\n<p>The initial release of PyMOSO contains solvers that implement four total algorithms, in alphabetical order: R-MinRLE, R-PE, R-PERLE, and R-SPLINE.  The algorithms R-MinRLE, R-PE, R-PERLE were introduced in the following paper:</p>\n<p>Cooper, K., Hunter, S. R., and Nagaraj, K. 2019. Bi-objective simulation optimization on integer lattices using the epsilon-constraint method in a retrospective approximation framework. <em>INFORMS Journal on Computing</em>, to appear. Preprint: <a href=\"http://www.optimization-online.org/DB_HTML/2018/06/6649.html\" rel=\"nofollow\">http://www.optimization-online.org/DB_HTML/2018/06/6649.html</a>.</p>\n<p>The algorithm R-SPLINE was introduced in the following paper:</p>\n<p>Wang, H., Pasupathy, R., and Schmeiser, B. W. 2013. Integer-ordered simulation optimization using R-SPLINE: Retrospective Search with Piecewise-Linear Interpolation and Neighborhood Enumeration. <em>ACM Transactions on Modeling and Computer Simulation</em>, Vol. 23, No. 3, Article 17 (July 2013), 24 pages.  <a href=\"http://dx.doi.org/10.1145/2499913.2499916\" rel=\"nofollow\">http://dx.doi.org/10.1145/2499913.2499916</a></p>\n<p>We recommend reading these papers to understand the algorithms, what they return, and the algorithm parameter options that we describe in the user manual.</p>\n<h1>Table of Contents</h1>\n<ul>\n<li><a href=\"#pymoso\" rel=\"nofollow\">PyMOSO</a>\n<ul>\n<li><a href=\"#reference\" rel=\"nofollow\">Reference</a></li>\n<li><a href=\"#additional-reading\" rel=\"nofollow\">Additional Reading</a></li>\n<li><a href=\"#installation\" rel=\"nofollow\">Installation</a>\n<ul>\n<li><a href=\"#install-pymoso-from-the-python-packaging-index-using-pip\" rel=\"nofollow\">Install PyMOSO from the Python Packaging Index using pip</a></li>\n<li><a href=\"#install-pymoso-from-the-repository-using-pip\" rel=\"nofollow\">Install PyMOSO from the repository using pip</a></li>\n<li><a href=\"#install-pymoso-from-source-code\" rel=\"nofollow\">Install PyMOSO from Source Code</a></li>\n</ul>\n</li>\n<li><a href=\"#command-line-interface-cli\" rel=\"nofollow\">Command Line Interface (CLI)</a>\n<ul>\n<li><a href=\"#cli-help\" rel=\"nofollow\">CLI help</a></li>\n<li><a href=\"#the-listitems-command-for-viewing-solvers-testers-and-oracles-included-in-pymoso\" rel=\"nofollow\">The listitems command for viewing solvers, testers, and oracles included in PyMOSO</a></li>\n<li><a href=\"#the-solve-command\" rel=\"nofollow\">The solve command</a>\n<ul>\n<li><a href=\"#the-example-oracle\" rel=\"nofollow\">The Example Oracle</a></li>\n<li><a href=\"#table-of-algorithm-specific-parameters\" rel=\"nofollow\">Table of Algorithm-Specific Parameters</a></li>\n</ul>\n</li>\n<li><a href=\"#the-testsolve-command\" rel=\"nofollow\">The testsolve Command</a>\n<ul>\n<li><a href=\"#the-example-tester\" rel=\"nofollow\">The Example Tester</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#implementing-problems-testers-and-algorithms-in-pymoso\" rel=\"nofollow\">Implementing problems, testers, and algorithms in PyMOSO</a>\n<ul>\n<li><a href=\"#implementing-pymoso-oracles\" rel=\"nofollow\">Implementing PyMOSO Oracles</a>\n<ul>\n<li><a href=\"#example-oracle-that-wraps-a-c-simulation\" rel=\"nofollow\">Example Oracle that Wraps a C Simulation</a></li>\n<li><a href=\"#example-wrapper-with-pymoso-random-numbers\" rel=\"nofollow\">Example Wrapper with PyMOSO Random Numbers</a></li>\n</ul>\n</li>\n<li><a href=\"#implementing-pymoso-testers\" rel=\"nofollow\">Implementing PyMOSO Testers</a>\n<ul>\n<li><a href=\"#example-metric-1\" rel=\"nofollow\">Example Metric 1</a></li>\n<li><a href=\"#example-metric-2\" rel=\"nofollow\">Example Metric 2</a></li>\n</ul>\n</li>\n<li><a href=\"#implementing-pymoso-algorithms\" rel=\"nofollow\">Implementing PyMOSO Algorithms</a>\n<ul>\n<li><a href=\"#template-accelerator\" rel=\"nofollow\">Template Accelerator</a></li>\n<li><a href=\"#template-ra-solver\" rel=\"nofollow\">Template RA Solver</a></li>\n<li><a href=\"#template-moso-solver\" rel=\"nofollow\">Template MOSO Solver</a>\n<ul>\n<li><a href=\"#take-simulation-replications-at-a-point\" rel=\"nofollow\">Take Simulation Replications at a Point</a></li>\n<li><a href=\"#find-neighbors-and-take-simulation-replications\" rel=\"nofollow\">Find Neighbors and Take Simulation Replications</a></li>\n<li><a href=\"#argsort-a-dictionary-of-points\" rel=\"nofollow\">Argsort a Dictionary of Points</a></li>\n<li><a href=\"#select-the-minimizer-and-its-value\" rel=\"nofollow\">Select the Minimizer and its Value</a></li>\n<li><a href=\"#use-spline-to-retrive-a-local-minimizer\" rel=\"nofollow\">Use SPLINE to Retrive a Local Minimizer</a></li>\n<li><a href=\"#find-the-non-dominated-points-in-a-dictionary\" rel=\"nofollow\">Find the Non-Dominated Points in a Dictionary</a></li>\n<li><a href=\"#randomly-select-points-in-a-set\" rel=\"nofollow\">Randomly Select Points in a Set</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#using-solve-and-testsolve-in-python-programs\" rel=\"nofollow\">Using solve and <code>testsolve</code> in Python Programs</a>\n<ul>\n<li><a href=\"#minimal-solve-example\" rel=\"nofollow\">Minimal solve Example</a></li>\n<li><a href=\"#some-solve-examples-with-options\" rel=\"nofollow\">Some solve Examples with Options</a></li>\n<li><a href=\"#a-testsolve-example\" rel=\"nofollow\">A testsolve Example</a></li>\n<li><a href=\"#computing-a-metric-on-testsolve-output\" rel=\"nofollow\">Computing a Metric on testsolve Output</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#pymoso-object-reference\" rel=\"nofollow\">PyMOSO Object Reference</a>\n<ul>\n<li><a href=\"#the-pymosoprngmrg32k3a-module\" rel=\"nofollow\">The pymoso.prng.mrg32k3a Module</a></li>\n<li><a href=\"#the-pymosochnbase-module\" rel=\"nofollow\">The pymoso.chnbase Module</a></li>\n<li><a href=\"#the-pymosochnutils-module\" rel=\"nofollow\">The pymoso.chnutils Module</a></li>\n<li><a href=\"#the-oracle-class\" rel=\"nofollow\">The Oracle Class</a></li>\n<li><a href=\"#the-mososolver-class\" rel=\"nofollow\">The MOSOSolver Class</a></li>\n<li><a href=\"#the-rasolver-class\" rel=\"nofollow\">The RASolver Class</a></li>\n<li><a href=\"#the-rlesolver-class\" rel=\"nofollow\">The RLESolver Class</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2>Installation</h2>\n<p>Since PyMOSO is programmed in Python, every PyMOSO user must first install Python, which can be downloaded from <a href=\"https://www.python.org/downloads/\" rel=\"nofollow\">https://www.python.org/downloads/</a>. PyMOSO is compatible with Python versions 3.6 and higher. In the remainder of this section, we assume an appropriate Python version is installed. We discuss three different methods to install PyMOSO: first, from the Python Packaging Index; second, directly from our source code using git; and third, manually installing PyMOSO from our source code.</p>\n<h3>Install PyMOSO from the Python Packaging Index using <code>pip</code></h3>\n<p>For ease of distribution, we keep stable, recent releases of PyMOSO on the Python Packaging Index (PyPI). Since the program <code>pip</code> is included in Python versions 3.6 and higher, we recommend using <code>pip</code> to install PyMOSO. To do so, open a terminal, type the following command, and press enter.</p>\n<p><code>pip install pymoso</code></p>\n<p>Depending on how users configure their Python installation and how many version of Python they install, they may need to replace <code>pip</code> with <code>pip3</code>, or other variants of <code>pip</code>.</p>\n<h3>Install PyMOSO from the repository using <code>pip</code></h3>\n<p>Users with <code>git</code> installed can use <code>pip</code> to install the most current version of PyMOSO directly from our source code:</p>\n<p><code>pip install git+https://github.com/pymoso/PyMOSO.git</code></p>\n<p>We consider the latest source to be less stable than the fixed releases we upload to PyPI, and thus we recommend most users install PyMOSO from PyPI.</p>\n<h3>Install PyMOSO from Source Code</h3>\n<p>Users may follow the steps below to manually install PyMOSO from any version of the source code.</p>\n<ol>\n<li>Acquire the PyMOSO source code, for example, by downloading it from the repository <a href=\"https://github.com/HunterResearch/PyMOSO\" rel=\"nofollow\">https://github.com/HunterResearch/PyMOSO</a>.</li>\n<li>Install the <code>wheel</code> package, e.g. using the <code>pip install wheel</code> command.</li>\n<li>Open a terminal and navigate into the main project directory which contains the file <code>setup.py</code>.</li>\n<li>Build the installable PyMOSO package, called a wheel, using the command <code>python setup.py bdist_wheel</code>. As with <code>pip</code>, some users may need to replace <code>python</code> with <code>python3</code> or something similar. The command should create a directory named <code>dist</code> containing the PyMOSO wheel.</li>\n<li>Install the PyMOSO wheel using pip install <code>dist/pymoso-x.x.x-py3-none-any.whl</code>, where users replace <code>x.x.x</code> with the appropriate PyMOSO version.</li>\n</ol>\n<h2>Command Line Interface (CLI)</h2>\n<p>PyMOSO users solving MOSO problems and testing MOSO algorithms may do so using the command line interface. First, we show how to access the included help file. Then, we show how to view the lists of solvers, testers, and oracles installed by default with PyMOSO. Finally, we discuss the <code>solve</code> and <code>testsolve</code> commands.</p>\n<h3>CLI help</h3>\n<p>PyMOSO includes a command line help file. The help file shows syntax templates for every PyMOSO command, the available options, and a selection of example invocations. The <code>pymoso --help</code> invocation prints the file to the terminal. The file is also printed when PyMOSO cannot parse an invocation that begins with <code>pymoso</code>. We show the current help file below.</p>\n<pre><code>Usage:\n  pymoso listitems\n  pymoso solve [--budget=B] [--odir=D] [--crn] [--simpar=P]\n    [(--seed &lt;s&gt; &lt;s&gt; &lt;s&gt; &lt;s&gt; &lt;s&gt; &lt;s&gt;)] [(--param &lt;param&gt; &lt;val&gt;)]...\n    &lt;problem&gt; &lt;solver&gt; &lt;x&gt;...\n  pymoso testsolve [--budget=B] [--odir=D] [--crn] [--isp=T] [--proc=Q]\n    [--metric] [(--seed &lt;s&gt; &lt;s&gt; &lt;s&gt; &lt;s&gt; &lt;s&gt; &lt;s&gt;)] [(--param &lt;param&gt; &lt;val&gt;)]...\n    &lt;tester&gt; &lt;solver&gt; [&lt;x&gt;...]\n  pymoso -h | --help\n  pymoso -v | --version\n\nOptions:\n  --budget=B                Set the simulation budget [default: 200]\n  --odir=D                  Set the output file directory name. [default: testrun]\n  --crn                     Set if common random numbers are desired.\n  --seed                    Set the random number seed with 6 spaced integers.\n  --simpar=P                Set number of parallel processes for simulation replications. [default: 1]\n  --isp=T                   Set number of algorithm instances to solve. [default: 1]\n  --proc=Q                  Set number of parallel processes for the algorithm instances. [default: 1]\n  --metric                  Set if metric computation is desired.\n  --param                   Specify a solver-specific parameter &lt;param&gt; &lt;val&gt;.\n  -h --help                 Show this screen.\n  -v --version              Show version.\n\nExamples:\n  pymoso listitems\n  pymoso solve ProbTPA RPERLE 4 14\n  pymoso solve --budget=100000 --odir=test1  ProbTPB RMINRLE 3 12\n  pymoso solve --seed 12345 32123 5322 2 9543 666666666 ProbTPC RPERLE 31 21 11\n  pymoso solve --simpar=4 --param betaeps 0.4 ProbTPA RPERLE 30 30\n  pymoso solve --param radius 3 ProbTPA RPERLE 45 45\n  pymoso testsolve --isp=16 --proc=4 TPATester RPERLE\n  pymoso testsolve --isp=20 --proc=10 --metric --crn TPBTester RMINRLE 9 9\n</code></pre>\n<p>For now, PyMOSO has three commands: <code>listitems</code>, <code>solve</code>, and <code>testsolve</code>, which we explain below.</p>\n<h3>The <code>listitems</code> command for viewing solvers, testers, and oracles included in PyMOSO</h3>\n<p>The default installation of PyMOSO includes a selection of solvers, testers, and oracles. Users can view the complete lists of included solvers, testers, and oracles using the <code>pymoso listitems</code> command. We show the current listing below. Test problems A, B, and C refer to those in Cooper et al (2018).</p>\n<pre><code>Solver                         Description\n************************       ************************\nRMINRLE                        A solver using R-MinRLE for integer-ordered MOSO.\nRPE                            A solver using R-Pe for integer-ordered bi-objective MOSO.\nRPERLE                         A solver using RPERLE for integer-ordered bi-objective MOSO.\nRSPLINE                        A solver using R-SPLINE for single objective SO.\n\nProblems                       Description                    Test Name (if available)\n************************       ************************       ************************\nProbSimpleSO                   x^2 + noise.                   SimpleSOTester\nProbTPA                        Test Problem A                 TPATester\nProbTPB                        Test Problem B                 TPBTester\nProbTPC                        Test Problem C                 TPCTester\n</code></pre>\n<h3>The <code>solve</code> command</h3>\n<p>The PyMOSO <code>solve</code> command is for solving MOSO problems. Users can solve the built-in problems (use the <code>listitems</code> command to view the built-in problems), however, PyMOSO <code>solve</code> users typically will have their own MOSO problem they wish to solve. Thus, we assume users have implemented a PyMOSO oracle named <code>MyProblem</code> in <code>myproblem.py</code>.  In the examples that follow, we assume the <code>MyProblem</code> implementation below, which is a bi-objective oracle with one-dimensional feasible points. See <a href=\"#implementing-pymoso-oracles\" rel=\"nofollow\">Implementing PyMOSO Oracles</a> for instructions on implementing a MOSO problem as a PyMOSO oracle.</p>\n<h4>The Example Oracle</h4>\n<pre><span class=\"c1\"># import the Oracle base class</span>\n<span class=\"kn\">from</span> <span class=\"nn\">pymoso.chnbase</span> <span class=\"kn\">import</span> <span class=\"n\">Oracle</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">MyProblem</span><span class=\"p\">(</span><span class=\"n\">Oracle</span><span class=\"p\">):</span>\n    <span class=\"sd\">'''Example implementation of a user-defined MOSO problem.'''</span>\n    <span class=\"k\">def</span> <span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">rng</span><span class=\"p\">):</span>\n        <span class=\"sd\">'''Specify the number of objectives and dimensionality of points.'''</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">num_obj</span> <span class=\"o\">=</span> <span class=\"mi\">2</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">dim</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>\n        <span class=\"nb\">super</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"n\">rng</span><span class=\"p\">)</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">g</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">rng</span><span class=\"p\">):</span>\n        <span class=\"sd\">'''Check feasibility and simulate objective values.'''</span>\n        <span class=\"c1\"># feasible values for x in this example</span>\n        <span class=\"n\">feas_range</span> <span class=\"o\">=</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"o\">-</span><span class=\"mi\">100</span><span class=\"p\">,</span> <span class=\"mi\">101</span><span class=\"p\">)</span>\n        <span class=\"c1\"># initialize obj to empty and is_feas to False</span>\n        <span class=\"n\">obj</span> <span class=\"o\">=</span> <span class=\"p\">[]</span>\n        <span class=\"n\">is_feas</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>\n        <span class=\"c1\"># check that dimensions of x match self.dim</span>\n        <span class=\"k\">if</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">dim</span><span class=\"p\">:</span>\n            <span class=\"n\">is_feas</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>\n            <span class=\"c1\"># then check that each component of x is in the range above</span>\n            <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"n\">x</span><span class=\"p\">:</span>\n                <span class=\"k\">if</span> <span class=\"ow\">not</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"n\">feas_range</span><span class=\"p\">:</span>\n                    <span class=\"n\">is_feas</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>\n        <span class=\"c1\"># if x is feasible, simulate the objectives</span>\n        <span class=\"k\">if</span> <span class=\"n\">is_feas</span><span class=\"p\">:</span>\n            <span class=\"c1\">#use rng to generate random numbers</span>\n            <span class=\"n\">z0</span> <span class=\"o\">=</span> <span class=\"n\">rng</span><span class=\"o\">.</span><span class=\"n\">normalvariate</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">)</span>\n            <span class=\"n\">z1</span> <span class=\"o\">=</span> <span class=\"n\">rng</span><span class=\"o\">.</span><span class=\"n\">normalvariate</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">)</span>\n            <span class=\"n\">obj1</span> <span class=\"o\">=</span> <span class=\"n\">x</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">**</span><span class=\"mi\">2</span> <span class=\"o\">+</span> <span class=\"n\">z0</span>\n            <span class=\"n\">obj2</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">-</span> <span class=\"mi\">2</span><span class=\"p\">)</span><span class=\"o\">**</span><span class=\"mi\">2</span> <span class=\"o\">+</span> <span class=\"n\">z1</span>\n            <span class=\"n\">obj</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">obj1</span><span class=\"p\">,</span> <span class=\"n\">obj2</span><span class=\"p\">)</span>\n        <span class=\"k\">return</span> <span class=\"n\">is_feas</span><span class=\"p\">,</span> <span class=\"n\">obj</span>\n</pre>\n<p>The template <code>solve</code> command is <code>pymoso solve oracle solver x0</code>, where <code>oracle</code> is a built-in or user-defined oracle, <code>solver</code> is a built-in or user-defined algorithm, and <code>x0</code> is a feasible starting point for the solver, with a space between each component. As a first example, we solve the user-defined <code>MyProblem</code> using the built-in R-PERLE starting at the feasible point 97.</p>\n<p><code>pymoso solve myproblem.py RPERLE 97</code></p>\n<p>Similarly, we can solve built-in problems, such as <code>ProbTPA</code> which has two-dimensional feasible points.</p>\n<p><code>pymoso solve ProbTPA RPERLE 40 40</code></p>\n<p>Henceforth, we present <code>solve</code> examples only for solving <code>MyProblem</code>.  Since <code>MyProblem</code> is bi-objective, we recommend using the <code>R-PERLE</code> solver. However, for two or more objectives, PyMOSO implements <code>R-MinRLE</code>.</p>\n<p><code>pymoso solve myproblem.py RMINRLE 97</code></p>\n<p>For a single objective problem, PyMOSO implements <code>R-SPLINE</code>. We remark that if given a multi-objective problem, <code>R-SPLINE</code> will simply minimize the first objective. We do not necessarily prohibit such use, but urge that users take care when using R-SPLINE to minimize one objective of a many-objective problem.</p>\n<p><code>pymoso solve myproblem.py RSPLNE 97</code></p>\n<p>Regardless of the chosen solver, PyMOSO creates a new sub-directory of the working directory containing output. There will be a metadata file, indicating the date, time, solver, problem, and any other specified options. In addition, PyMOSO creates a file containing the solver-generated solution. PyMOSO provides additional options for users solving MOSO problems. We present examples of each option below. First, users can specify the name of the output directory.</p>\n<p><code>pymoso solve --odir=OutDirectory myproblem.py RPERLE 45</code></p>\n<p>Users can specify the simulation budget, which is currently set to a default of 200.</p>\n<p><code>pymoso solve --budget=100000 myproblem.py RPERLE 12</code></p>\n<p>Users may specify to take simulation replications in parallel. We only recommend doing so if the user has thought through appropriate pseudo-random number stream control issues (see <a href=\"#implementing-pymoso-oracles\" rel=\"nofollow\">Implementing PyMOSO Oracles</a>). Furthermore, due to the overhead of parallelization, we only recommend using the parallel simulation replications feature if observations are sufficiently \"expensive\" to compute, e.g. the simulation takes a half second or more to generate a single observation. We remark that the run-time complexity of the simulation oracle may not perfectly indicate when it is appropriate to use parallelization; other factors include, e.g., the total simulation budget.</p>\n<p><code>pymoso solve --simpar=4 myproblem.py RPERLE 44</code></p>\n<p>Currently, all PyMOSO solvers support using common random numbers. Users may enable the functionality using the <code>--crn</code> option.</p>\n<p><code>pymoso solve --crn myproblem.py RMINRLE 62</code></p>\n<p>We do not recommend this option unless the oracle is implemented to be compatible, that is, the oracle uses PyMOSO's pseudo-random number generator to generate pseudo-random numbers or to provide a seed to an external <code>mrg32k3a</code> generator (see <a href=\"#implementing-pymoso-oracles\" rel=\"nofollow\">Implementing PyMOSO Oracles</a>).</p>\n<p>Users may specify an initial seed to PyMOSO's <code>mrg32k3a</code> pseudo-random number generator. Seeds must be 6 positive integers with spaces. The default is 12345 for each of the 6 components.</p>\n<p><code>pymoso solve --seed 1111 2222 3333 4444 5555 6666 myproblem.py RPERLE 23</code></p>\n<p>Users may specify algorithm-specific parameters (see the papers in which the algorithms were introduced for detailed explanations of the parameters.) All parameters are specified in the form <code>--param name value</code>. For example, the RLE relaxation parameter can be specified and set as <code>betadel</code> to a real number. We refer the reader to <a href=\"#table-of-algorithm-specific-parameters\" rel=\"nofollow\">the table</a> for the full list of currently available algorithm-specific parameters.</p>\n<p><code>pymoso solve --param betadel 0.2 myproblem.py RPERLE 34</code></p>\n<p>Finally, users may specify any number of options in one invocation. However, all options must be specified in after the <code>solve</code> command and before the <code>myproblem.py</code> argument. Furthermore, any <code>--param</code> options must be the last options. (Note that the <code>\\</code> at the end of the first line continues the command to the second line.)</p>\n<p><code>pymoso solve --crn --simpar=4 --budget=10000 --seed 1 2 3 4 5 6 \\</code><br>\n<code>--odir=Exp1 --param mconst 4 --param betadel 0.7 myproblem.py RPERLE 97</code></p>\n<h4>Table of Algorithm-Specific Parameters</h4>\n<table>\n<thead>\n<tr>\n<th>Parameter Name</th>\n<th>Default Value</th>\n<th>Affected Solvers</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>mconst</code></td>\n<td>2</td>\n<td><code>RPERLE</code>, <code>RMINRLE</code>, <code>RPE</code>, <code>RSPLINE</code></td>\n<td>Initialize the sample size and subsequent schedule of sample sizes.</td>\n</tr>\n<tr>\n<td><code>bconst</code></td>\n<td>8</td>\n<td><code>RPERLE</code>, <code>RMINRLE</code>, <code>RPE</code>, <code>RSPLINE</code></td>\n<td>Initialize the search sampling limit and subsequent schedule of limits.</td>\n</tr>\n<tr>\n<td><code>radius</code></td>\n<td>1</td>\n<td><code>RPERLE</code>, <code>RMINRLE</code>, <code>RPE</code>, <code>RSPLINE</code></td>\n<td>Sets radius that determines a point's neighborhood.</td>\n</tr>\n<tr>\n<td><code>betadel</code></td>\n<td><code>0.5</code></td>\n<td><code>RPERLE</code>, <code>RMINRLE</code></td>\n<td>Roughly, affects how likely it is for RLE to keep its given solution.</td>\n</tr>\n<tr>\n<td><code>betaeps</code></td>\n<td><code>0.5</code></td>\n<td><code>RPERLE</code>, <code>RPE</code></td>\n<td>Roughly, affects how likely PE will perform a search from a point.</td>\n</tr></tbody></table>\n<h3>The <code>testsolve</code> Command</h3>\n<p>The PyMOSO <code>testsolve</code> command tests algorithms on problems using a PyMOSO tester. Users can test built-in or user-defined solvers with built-in or user-defined testers. In the examples that follow, we assume users have implemented <code>MyProblem</code> as in <a href=\"#the-example-oracle\" rel=\"nofollow\">The Example Oracle</a> and the corresponding tester named <code>MyTester</code> in <code>mytester.py</code>, shown in <a href=\"#the-example-tester\" rel=\"nofollow\">The Example Tester</a>. See <a href=\"#implementing-pymoso-testers\" rel=\"nofollow\">Implementing PyMOSO Testers</a> for instructions on implementing a user-defined tester, including a metric for comparing algorithms, in PyMOSO.</p>\n<h4>The Example Tester</h4>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">sys</span><span class=\"o\">,</span> <span class=\"nn\">os</span>\n<span class=\"n\">sys</span><span class=\"o\">.</span><span class=\"n\">path</span><span class=\"o\">.</span><span class=\"n\">insert</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"n\">os</span><span class=\"o\">.</span><span class=\"n\">path</span><span class=\"o\">.</span><span class=\"n\">dirname</span><span class=\"p\">(</span><span class=\"vm\">__file__</span><span class=\"p\">))</span>\n<span class=\"c1\"># use hausdorff distance (dh) as an example metric</span>\n<span class=\"kn\">from</span> <span class=\"nn\">pymoso.chnutils</span> <span class=\"kn\">import</span> <span class=\"n\">dh</span>\n<span class=\"c1\"># import the MyProblem oracle</span>\n<span class=\"kn\">from</span> <span class=\"nn\">myproblem</span> <span class=\"kn\">import</span> <span class=\"n\">MyProblem</span>\n\n<span class=\"c1\"># optionally, define a function to randomly choose a MyProblem feasible x0</span>\n<span class=\"k\">def</span> <span class=\"nf\">get_ranx0</span><span class=\"p\">(</span><span class=\"n\">rng</span><span class=\"p\">):</span>\n    <span class=\"n\">val</span> <span class=\"o\">=</span> <span class=\"n\">rng</span><span class=\"o\">.</span><span class=\"n\">choice</span><span class=\"p\">(</span><span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"o\">-</span><span class=\"mi\">100</span><span class=\"p\">,</span> <span class=\"mi\">101</span><span class=\"p\">))</span>\n    <span class=\"n\">x0</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">val</span><span class=\"p\">,</span> <span class=\"p\">)</span>\n    <span class=\"k\">return</span> <span class=\"n\">x0</span>\n\n<span class=\"c1\"># compute the true values of x, for computing the metric</span>\n<span class=\"k\">def</span> <span class=\"nf\">true_g</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">):</span>\n    <span class=\"sd\">'''Compute the objective values.'''</span>\n    <span class=\"n\">obj1</span> <span class=\"o\">=</span> <span class=\"n\">x</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">**</span><span class=\"mi\">2</span>\n    <span class=\"n\">obj2</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">-</span> <span class=\"mi\">2</span><span class=\"p\">)</span><span class=\"o\">**</span><span class=\"mi\">2</span>\n    <span class=\"k\">return</span> <span class=\"n\">obj1</span><span class=\"p\">,</span> <span class=\"n\">obj2</span>\n\n<span class=\"c1\"># define an answer as appropriate for the metric</span>\n<span class=\"n\">myanswer</span> <span class=\"o\">=</span> <span class=\"p\">{(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">),</span> <span class=\"p\">(</span><span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">),</span> <span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">)}</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">MyTester</span><span class=\"p\">(</span><span class=\"nb\">object</span><span class=\"p\">):</span>\n    <span class=\"sd\">'''Example tester implementation for MyProblem.'''</span>\n    <span class=\"k\">def</span> <span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">ranorc</span> <span class=\"o\">=</span> <span class=\"n\">MyProblem</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">answer</span> <span class=\"o\">=</span> <span class=\"n\">myanswer</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">true_g</span> <span class=\"o\">=</span> <span class=\"n\">true_g</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">get_ranx0</span> <span class=\"o\">=</span> <span class=\"n\">get_ranx0</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">metric</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">eles</span><span class=\"p\">):</span>\n        <span class=\"sd\">'''Metric to be computed per retrospective iteration.'''</span>\n        <span class=\"n\">epareto</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">true_g</span><span class=\"p\">(</span><span class=\"n\">point</span><span class=\"p\">)</span> <span class=\"k\">for</span> <span class=\"n\">point</span> <span class=\"ow\">in</span> <span class=\"n\">eles</span><span class=\"p\">]</span>\n        <span class=\"n\">haus</span> <span class=\"o\">=</span> <span class=\"n\">dh</span><span class=\"p\">(</span><span class=\"n\">epareto</span><span class=\"p\">,</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">answer</span><span class=\"p\">)</span>\n        <span class=\"k\">return</span> <span class=\"n\">haus</span>\n</pre>\n<p>The template <code>testsolve</code> command is <code>pymoso testsolve tester solver</code> where <code>tester</code> is a built-in or user-defined tester, and <code>solver</code> is a built-in or user-defined solver. Users may also specify an <code>x0</code>, as in the <code>solve</code> command, if the <code>tester</code> does not implement the function to generate feasible points. As a first example, we test <code>RPERLE</code> on <code>MyProblem</code> using <code>MyTester</code>. Since some options are compatible with both <code>solve</code> and <code>testsolve</code>, we include those options in this example.</p>\n<p><code>pymoso testsolve --budget=999 --odir=exp1 \\</code><br>\n<code>--crn --seed 1 2 3 4 5 6 mytester.py RPERLE</code></p>\n<p>Users may want to compute some metric on the algorithm-generated solutions. If a metric is defined as part of the tester, such as in <code>MyTester</code>, the <code>testsolve</code> command can compute the metric on every algorithm iteration using the <code>--metric</code> option.</p>\n<p><code>pymoso testsolve --metric mytester.py RPERLE</code></p>\n<p>The <code>testsolve</code> command cannot perform simulation replications in parallel. However, testers can apply the solvers to independent sample paths of the problems. For example, to test <code>RPERLE</code> on 100 independent sample paths of <code>MyProblem</code>, compute the metrics for each sample path, and use common random numbers in each sample path, use the following command.</p>\n<p><code>pymoso testsolve --crn --metric --isp=100 mytester.py RPERLE</code></p>\n<p>PyMOSO can perform independent algorithm runs in parallel. Use the <code>--proc</code> option to specify the number of processes available to PyMOSO.</p>\n<p><code>pymoso testsolve --crn --metric --isp=100 --proc=20 mytester.py RPERLE</code></p>\n<p>We remark here that, to ensure the algorithm runs remain independent using PyMOSO's pseudo-random number generator (see <a href=\"#implementing-pymoso-oracles\" rel=\"nofollow\">Implementing PyMOSO Oracles</a>), researchers should set the total simulation budget so that the included algorithms do not surpass 200 retrospective approximation (RA) iterations. For reference, using the default settings, the sample size at every point in the 200th RA iteration is almost 380 million.</p>\n<p>The <code>testsolve</code> command creates a results file for each independent sample path. The file contains the solutions generated at every algorithm iteration, such that the solution of iteration 2 is on line 2, iteration 10 on line 10, and so forth. If <code>--metric</code> is specified, PyMOSO generates a second file for each independent sample path containing the collection of triples (iteration number, simulations used at end of iteration, metric).</p>\n<h2>Implementing problems, testers, and algorithms in PyMOSO</h2>\n<p>To use PyMOSO, users solving MOSO problems must implement a PyMOSO oracle, and users testing MOSO algorithms should implement, at least, a PyMOSO oracle and tester. In this section, we provide template Python code to help users quickly implement oracles, testers, and perhaps solvers in PyMOSO.</p>\n<h3>Implementing PyMOSO Oracles</h3>\n<p>Usually, implementing a PyMOSO oracle implies implementing a Monte Carlo simulation oracle as a black box function while following the PyMOSO rules put forth in this section. For reference, we discuss the example PyMOSO oracle <code>MyProblem</code> in <a href=\"#the-example-oracle\" rel=\"nofollow\">The Example Oracle</a>. Users may copy the code in <a href=\"#the-example-oracle\" rel=\"nofollow\">The Example Oracle</a> and re-implement the function <code>g</code> as needed. We now list the basic requirements of every <code>g</code> implementation.</p>\n<ol>\n<li>The function <code>g</code> must be an instance method of an <code>Oracle</code> sub-class, and thus take <code>self</code> as its first parameter.</li>\n<li>The function <code>g</code> must take an arbitrarily-named second parameter which is a tuple of length <code>self.dim</code> and represents a point. Stylistically, PyMOSO consistently names this parameter <code>x</code>.</li>\n<li>The function <code>g</code> must take an arbitrarily-named third parameter which is a modified Python <code>random.Random</code> object. Stylistically, PyMOSO consistently names this parameter <code>rng</code>.</li>\n<li>The function <code>g</code> must return a boolean first and a tuple of length <code>self.num_obj</code> second.\n<ul>\n<li>The boolean is <code>True</code> if <code>x</code> is feasible, and <code>False</code> otherwise.</li>\n<li>If <code>x</code> is feasible, the tuple contains a single observation of every objective. If <code>x</code> is not feasible, each element in the tuple is <code>None</code>.</li>\n</ul>\n</li>\n</ol>\n<p>If users already have an implemented simulation oracle, they may find it convenient to implement <code>g</code> as wrapper which calls that simulation from Python. As an example, suppose a user has implemented a simulation in C which is compiled to a C library called <code>mysim.so</code> and placed in the working directory. Suppose further that the simulation function takes the following as parameters: an array of integers representing a point and an unsigned integer representing the number of observations to take at <code>x</code>. The function output is defined as <code>struct Simout</code> with members <code>feas</code> set to 0 or 1, <code>obj</code> a double array set to the mean of the observed objective values, and <code>var</code> a double array set to the sample variance of the observed objective values. Then users can modify the template to wrap the C function <code>struct Simout c_func(int x, int n)</code> as in <a href=\"#example-oracle-that-wraps-a-c-simulation\" rel=\"nofollow\">the example</a>.</p>\n<h4>Example Oracle that Wraps a C Simulation</h4>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">ctypes</span> <span class=\"kn\">import</span> <span class=\"n\">CDLL</span><span class=\"p\">,</span> <span class=\"n\">c_double</span><span class=\"p\">,</span> <span class=\"n\">c_uint</span><span class=\"p\">,</span> <span class=\"n\">c_int</span><span class=\"p\">,</span> <span class=\"n\">Structure</span>\n<span class=\"kn\">import</span> <span class=\"nn\">os.path</span>\n<span class=\"n\">libname</span> <span class=\"o\">=</span> <span class=\"s1\">'mysim.so'</span>\n<span class=\"n\">libabspath</span> <span class=\"o\">=</span> <span class=\"n\">os</span><span class=\"o\">.</span><span class=\"n\">path</span><span class=\"o\">.</span><span class=\"n\">dirname</span><span class=\"p\">(</span><span class=\"n\">os</span><span class=\"o\">.</span><span class=\"n\">path</span><span class=\"o\">.</span><span class=\"n\">abspath</span><span class=\"p\">(</span><span class=\"vm\">__file__</span><span class=\"p\">))</span> <span class=\"o\">+</span> <span class=\"n\">os</span><span class=\"o\">.</span><span class=\"n\">path</span><span class=\"o\">.</span><span class=\"n\">sep</span> <span class=\"o\">+</span> <span class=\"n\">dll_name</span>\n<span class=\"n\">libobj</span> <span class=\"o\">=</span> <span class=\"n\">CDLL</span><span class=\"p\">(</span><span class=\"n\">libabspath</span><span class=\"p\">)</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">Simout</span><span class=\"p\">(</span><span class=\"n\">Structure</span><span class=\"p\">):</span>\n    <span class=\"n\">_fields_</span> <span class=\"o\">=</span> <span class=\"p\">[(</span><span class=\"s2\">\"feas\"</span><span class=\"p\">,</span> <span class=\"n\">c_int</span><span class=\"p\">),</span> <span class=\"p\">(</span><span class=\"s2\">\"obj\"</span><span class=\"p\">,</span> <span class=\"n\">c_double</span><span class=\"o\">*</span><span class=\"mi\">2</span><span class=\"p\">),</span> <span class=\"p\">(</span><span class=\"s2\">\"var\"</span><span class=\"p\">,</span> <span class=\"n\">c_double</span><span class=\"o\">*</span><span class=\"mi\">2</span><span class=\"p\">)]</span>\n<span class=\"n\">csimout</span> <span class=\"o\">=</span> <span class=\"n\">libobj</span><span class=\"o\">.</span><span class=\"n\">c_func</span>\n<span class=\"n\">csimout</span><span class=\"o\">.</span><span class=\"n\">restype</span> <span class=\"o\">=</span> <span class=\"n\">Simout</span>\n\n<span class=\"kn\">from</span> <span class=\"nn\">pymoso.chnbase</span> <span class=\"kn\">import</span> <span class=\"n\">Oracle</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">MyProblem</span><span class=\"p\">(</span><span class=\"n\">Oracle</span><span class=\"p\">):</span>\n    <span class=\"sd\">'''Example implementation of a user-defined MOSO problem.'''</span>\n    <span class=\"k\">def</span> <span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">rng</span><span class=\"p\">):</span>\n        <span class=\"sd\">'''Specify the number of objectives and dimensionality of points.'''</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">num_obj</span> <span class=\"o\">=</span> <span class=\"mi\">2</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">dim</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>\n        <span class=\"nb\">super</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"n\">rng</span><span class=\"p\">)</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">g</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">rng</span><span class=\"p\">):</span>\n        <span class=\"sd\">'''Check feasibility and simulate objective values.'''</span>\n        <span class=\"n\">is_feasible</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>\n        <span class=\"n\">objective_values</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"kc\">None</span><span class=\"p\">)</span>\n        <span class=\"c1\"># g takes only one observation so set the c_func parameter to 1</span>\n        <span class=\"n\">c_n</span> <span class=\"o\">=</span> <span class=\"n\">c_uint</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n        <span class=\"c1\"># c_func requires is an integer so convert it -- this is a 1D example</span>\n        <span class=\"n\">c_x</span> <span class=\"o\">=</span> <span class=\"n\">c_int</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">])</span>\n        <span class=\"c1\"># call the C function</span>\n        <span class=\"n\">mysimout</span> <span class=\"o\">=</span> <span class=\"n\">csimout</span><span class=\"p\">(</span><span class=\"n\">c_x</span><span class=\"p\">,</span> <span class=\"n\">c_n</span><span class=\"p\">)</span>\n        <span class=\"k\">if</span> <span class=\"ow\">not</span> <span class=\"n\">mysimout</span><span class=\"o\">.</span><span class=\"n\">feas</span><span class=\"p\">:</span>\n            <span class=\"n\">is_feasible</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>\n        <span class=\"k\">else</span><span class=\"p\">:</span>\n            <span class=\"n\">is_feasible</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>\n        <span class=\"k\">if</span> <span class=\"n\">is_feasible</span><span class=\"p\">:</span>\n            <span class=\"n\">objective_values</span> <span class=\"o\">=</span> <span class=\"nb\">tuple</span><span class=\"p\">(</span><span class=\"n\">mysimout</span><span class=\"o\">.</span><span class=\"n\">obj</span><span class=\"p\">)</span>\n        <span class=\"k\">return</span> <span class=\"n\">is_feasible</span><span class=\"p\">,</span> <span class=\"n\">objective_values</span>\n</pre>\n<p><a href=\"#example-oracle-that-wraps-a-c-simulation\" rel=\"nofollow\">The C wrapper example</a> is a valid PyMOSO oracle which wraps a C function. However, PyMOSO algorithms cannot enable common random numbers on this oracle. Furthermore, PyMOSO cannot guarantee that observations are independent when taken in parallel. To enable these properties, the external simulation must use <code>mrg32k3a</code> as the generator and must accept a user-specified seed.</p>\n<p>Suppose the library <code>mysim.so</code> also implements the function <code>set_simseed</code> which accepts a long array representing an <code>mrg32k3a</code> seed. We modify the <a href=\"#example-oracle-that-wraps-a-c-simulation\" rel=\"nofollow\">wrapper</a> for compatibility with common random numbers and to guarantee independence of parallel observations.  <a href=\"#example-wrapper-with-pymoso-random-numbers\" rel=\"nofollow\">The new wrapper</a> demonstrates using <code>rng.get_seed()</code> to return the current <code>mrg32k3a</code> seed.</p>\n<h4>Example Wrapper with PyMOSO Random Numbers</h4>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">ctypes</span> <span class=\"kn\">import</span> <span class=\"n\">CDLL</span><span class=\"p\">,</span> <span class=\"n\">c_double</span><span class=\"p\">,</span> <span class=\"n\">c_uint</span><span class=\"p\">,</span> <span class=\"n\">c_int</span><span class=\"p\">,</span> <span class=\"n\">Structure</span><span class=\"p\">,</span> <span class=\"n\">c_long</span>\n<span class=\"kn\">import</span> <span class=\"nn\">os.path</span>\n<span class=\"n\">libname</span> <span class=\"o\">=</span> <span class=\"s1\">'mysim.so'</span>\n<span class=\"n\">libabspath</span> <span class=\"o\">=</span> <span class=\"n\">os</span><span class=\"o\">.</span><span class=\"n\">path</span><span class=\"o\">.</span><span class=\"n\">dirname</span><span class=\"p\">(</span><span class=\"n\">os</span><span class=\"o\">.</span><span class=\"n\">path</span><span class=\"o\">.</span><span class=\"n\">abspath</span><span class=\"p\">(</span><span class=\"vm\">__file__</span><span class=\"p\">))</span> <span class=\"o\">+</span> <span class=\"n\">os</span><span class=\"o\">.</span><span class=\"n\">path</span><span class=\"o\">.</span><span class=\"n\">sep</span> <span class=\"o\">+</span> <span class=\"n\">dll_name</span>\n<span class=\"n\">libobj</span> <span class=\"o\">=</span> <span class=\"n\">CDLL</span><span class=\"p\">(</span><span class=\"n\">libabspath</span><span class=\"p\">)</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">Simout</span><span class=\"p\">(</span><span class=\"n\">Structure</span><span class=\"p\">):</span>\n    <span class=\"n\">_fields_</span> <span class=\"o\">=</span> <span class=\"p\">[(</span><span class=\"s2\">\"feas\"</span><span class=\"p\">,</span> <span class=\"n\">c_int</span><span class=\"p\">),</span> <span class=\"p\">(</span><span class=\"s2\">\"obj\"</span><span class=\"p\">,</span> <span class=\"n\">c_double</span><span class=\"o\">*</span><span class=\"mi\">2</span><span class=\"p\">),</span> <span class=\"p\">(</span><span class=\"s2\">\"var\"</span><span class=\"p\">,</span> <span class=\"n\">c_double</span><span class=\"o\">*</span><span class=\"mi\">2</span><span class=\"p\">)]</span>\n<span class=\"n\">csimout</span> <span class=\"o\">=</span> <span class=\"n\">libobj</span><span class=\"o\">.</span><span class=\"n\">c_func</span>\n<span class=\"n\">csetseed</span> <span class=\"o\">=</span> <span class=\"n\">libobj</span><span class=\"o\">.</span><span class=\"n\">set_simseed</span>\n<span class=\"n\">csimout</span><span class=\"o\">.</span><span class=\"n\">restype</span> <span class=\"o\">=</span> <span class=\"n\">Simout</span>\n\n<span class=\"kn\">from</span> <span class=\"nn\">pymoso.chnbase</span> <span class=\"kn\">import</span> <span class=\"n\">Oracle</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">MyProblem</span><span class=\"p\">(</span><span class=\"n\">Oracle</span><span class=\"p\">):</span>\n    <span class=\"sd\">'''Example implementation of a user-defined MOSO problem.'''</span>\n    <span class=\"k\">def</span> <span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">rng</span><span class=\"p\">):</span>\n        <span class=\"sd\">'''Specify the number of objectives and dimensionality of points.'''</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">num_obj</span> <span class=\"o\">=</span> <span class=\"mi\">2</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">dim</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>\n        <span class=\"nb\">super</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"n\">rng</span><span class=\"p\">)</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">g</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">rng</span><span class=\"p\">):</span>\n        <span class=\"sd\">'''Check feasibility and simulate objective values.'''</span>\n        <span class=\"n\">is_feasible</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>\n        <span class=\"n\">objective_values</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"kc\">None</span><span class=\"p\">)</span>\n        <span class=\"c1\"># get the PyMOSO seed from rng</span>\n        <span class=\"n\">seed</span> <span class=\"o\">=</span> <span class=\"n\">rng</span><span class=\"o\">.</span><span class=\"n\">get_seed</span><span class=\"p\">()</span>\n        <span class=\"c1\"># convert the seed to c_long array</span>\n        <span class=\"n\">c_longarr</span> <span class=\"o\">=</span> <span class=\"n\">c_long</span><span class=\"o\">*</span><span class=\"mi\">6</span>\n        <span class=\"n\">c_seed</span> <span class=\"o\">=</span> <span class=\"n\">c_longarr</span><span class=\"p\">(</span><span class=\"n\">seed</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">],</span> <span class=\"n\">seed</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">],</span> <span class=\"n\">seed</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">],</span> <span class=\"n\">seed</span><span class=\"p\">[</span><span class=\"mi\">3</span><span class=\"p\">],</span> <span class=\"n\">seed</span><span class=\"p\">[</span><span class=\"mi\">4</span><span class=\"p\">],</span> <span class=\"n\">seed</span><span class=\"p\">[</span><span class=\"mi\">5</span><span class=\"p\">])</span>\n        <span class=\"c1\"># use the library function to set the sim seed</span>\n        <span class=\"n\">csetseed</span><span class=\"p\">(</span><span class=\"n\">c_seed</span><span class=\"p\">)</span>\n        <span class=\"c1\"># g takes only one observation so set the c_func parameter to 1</span>\n        <span class=\"n\">c_n</span> <span class=\"o\">=</span> <span class=\"n\">c_uint</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n        <span class=\"c1\"># c_func requires is an integer so convert it -- this is a 1D example</span>\n        <span class=\"n\">c_x</span> <span class=\"o\">=</span> <span class=\"n\">c_int</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">])</span>\n        <span class=\"c1\"># call the C function</span>\n        <span class=\"n\">mysimout</span> <span class=\"o\">=</span> <span class=\"n\">csimout</span><span class=\"p\">(</span><span class=\"n\">c_x</span><span class=\"p\">,</span> <span class=\"n\">c_n</span><span class=\"p\">)</span>\n        <span class=\"k\">if</span> <span class=\"ow\">not</span> <span class=\"n\">mysimout</span><span class=\"o\">.</span><span class=\"n\">feas</span><span class=\"p\">:</span>\n            <span class=\"n\">is_feasible</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>\n        <span class=\"k\">else</span><span class=\"p\">:</span>\n            <span class=\"n\">is_feasible</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>\n        <span class=\"k\">if</span> <span class=\"n\">is_feasible</span><span class=\"p\">:</span>\n            <span class=\"n\">objective_values</span> <span class=\"o\">=</span> <span class=\"nb\">tuple</span><span class=\"p\">(</span><span class=\"n\">mysimout</span><span class=\"o\">.</span><span class=\"n\">obj</span><span class=\"p\">)</span>\n        <span class=\"k\">return</span> <span class=\"n\">is_feasible</span><span class=\"p\">,</span> <span class=\"n\">objective_values</span>\n</pre>\n<p>Alternatively, if the number of required pseudo-random numbers is known, users can use <code>rng.random()</code> to generate pseudo-random numbers and then pass them to an external simulation if such functionality is supported.</p>\n<p>The <code>rng</code> object is implemented as a sub-class of Python's <code>random.Random</code> class, thus the official Python documentation for <code>random</code> applies to <code>rng</code> and is found at <a href=\"https://docs.python.org/3/library/random.html\" rel=\"nofollow\">https://docs.python.org/3/library/random.html</a>. In addition to <code>rng</code> using <code>mrg32k3a</code> as its generator, we also implement <code>rng.normalvariate</code> such that it uses the Beasley-Springer-Moro algorithm (Law 2015, p. 458) to approximate the inverse of the standard normal cumulative distribution function.</p>\n<p>When using <code>rng</code>, to ensure independent sampling of observations, PyMOSO \"jumps\" forward in the pseudo-random number stream after obtaining every simulation replication. Each jump is of fixed size 2^76 pseudo-random numbers. Thus, we require that every simulation replication use fewer than 2^76 pseudo-random numbers. We ensure independence among parallel replications by \"giving\" each processor a stream (an <code>rng</code>), each of which is 2^127 pseudo-random numbers apart. When using the current PyMOSO algorithms that rely on RA, each RA iteration begins the next available independent stream 2^127, where PyMOSO accounts for the possibility of parallel computation within an RA iteration. Thus, in a given RA iteration, a user may simulate 100 million points at a sample size of 1 million, without common random numbers, and easily not reach the limit.</p>\n<h3>Implementing PyMOSO Testers</h3>\n<p>Consider again the <a href=\"#the-example-tester\" rel=\"nofollow\">example tester</a>. As a minimal valid PyMOSO tester, users may do nothing but assign the <code>MyTester</code> member <code>self.ranorc</code> to a PyMOSO oracle, such as <a href=\"#the-example-oracle\" rel=\"nofollow\"><code>MyProblem</code></a>, in Line 27. However, we expect most users to leverage PyMOSO features by implementing metrics and  feasible point generators. The function <code>get_ranx0</code> allows the tester to generate feasible points to <code>MyProblem</code> and <code>metric</code> allows the tester to compute a metric on sets returned by a solver. Researchers may implement any number of additional supporting functions, including members and methods of the tester class. The <code>true_g</code> function is an example of such a supporting function, which is used to compute the example metric.</p>\n<p>First, we list the rules for implementing a feasible point generator.</p>\n<ol>\n<li>The function is arbitrarily named but must be set to the <code>self.get_ranx0</code> member of a tester.</li>\n<li>The function must take a single parameter, an arbitrarily named <code>random.Random</code> object we suggest naming <code>rng</code>.</li>\n<li>The function must return a tuple with length corresponding to the <code>self.dim</code> member of the <code>self.ranorc</code> member of the tester.</li>\n</ol>\n<p>Since a researcher's desired metric depends on the algorithm capabilities and problem complexity, PyMOSO allows researchers to implement any metric they choose. We provide three example metrics, but first, we list the implementation rules of the <code>metric</code> function.</p>\n<ol>\n<li>The \\inline{metric} function must be an instance method of a tester, and thus take \\inline{self} as its first parameter.</li>\n<li>The second parameter of \\inline{metric} is arbitrarily named and is a Python set of tuples.</li>\n<li>PyMOSO does not enforce the return value of \\inline{metric}, but we recommend a scalar real number.</li>\n</ol>\n<p>The metric implemented in the <a href=\"#the-example-tester\" rel=\"nofollow\">example tester</a> is the Hausdorff distance from (a) the true image of an estimated solution returned by an algorithm, to (b) the true solution hard-coded as <code>myanswer</code>.</p>\n<p>For an example of a different metric, consider a MOSO problem that has more than one local efficient set (LES) and such that each LES contains no members of another LES. Since an algorithm that converges to a LES is may find only one LES, we may define the metric to compute the Hausdorff distance between the true image of the estimated solution and the \"closest\" true LES, as follows. Let <code>self.answer</code> be implemented as a list of sets, and assume a <code>self.true_g</code> implementation. Then the <a href=\"#example-metric-1\" rel=\"nofollow\">following example</a> implements the described metric.</p>\n<h4>Example Metric 1</h4>\n<pre><span class=\"k\">def</span> <span class=\"nf\">metric</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">eles</span><span class=\"p\">):</span>\n    <span class=\"c1\"># use the distance to the closest set.</span>\n    <span class=\"n\">epareto</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">true_g</span><span class=\"p\">(</span><span class=\"n\">point</span><span class=\"p\">)</span> <span class=\"k\">for</span> <span class=\"n\">point</span> <span class=\"ow\">in</span> <span class=\"n\">eles</span><span class=\"p\">]</span>\n    <span class=\"c1\"># self.soln is a list of sets</span>\n    <span class=\"n\">dist_list</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">dh</span><span class=\"p\">(</span><span class=\"n\">epareto</span><span class=\"p\">,</span> <span class=\"n\">les</span><span class=\"p\">)</span> <span class=\"k\">for</span> <span class=\"n\">les</span> <span class=\"ow\">in</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">answer</span><span class=\"p\">]</span>\n    <span class=\"k\">return</span> <span class=\"nb\">min</span><span class=\"p\">(</span><span class=\"n\">dist_list</span><span class=\"p\">)</span>\n</pre>\n<p>For single-objective problems with one correct solution <code>x*</code>, a simple metric that takes an estimated solution <code>X</code> is <code>|g(X) - g(x*)|</code>, which we implement in the <a href=\"#example-metric-2\" rel=\"nofollow\">second example metric</a> assuming an appropriate implementation of <code>self.answer</code> and <code>self.true_g</code>.</p>\n<h4>Example Metric 2</h4>\n<pre><span class=\"k\">def</span> <span class=\"nf\">metric</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">singleton_set</span><span class=\"p\">):</span>\n    <span class=\"c1\"># single objective algorithms still return a set</span>\n    <span class=\"n\">point</span><span class=\"p\">,</span> <span class=\"o\">=</span> <span class=\"n\">singleton_set</span>\n    <span class=\"c1\"># let self.soln be a real number</span>\n    <span class=\"n\">dist</span> <span class=\"o\">=</span> <span class=\"nb\">abs</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">true_g</span><span class=\"p\">(</span><span class=\"n\">point</span><span class=\"p\">)</span> <span class=\"o\">-</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">answer</span><span class=\"p\">)</span>\n    <span class=\"k\">return</span> <span class=\"n\">dist</span>\n</pre>\n<h3>Implementing PyMOSO Algorithms</h3>\n<p>Researchers can implement simulation optimization algorithms in the PyMOSO framework. PyMOSO provides support for algorithms in three categories:</p>\n<ol>\n<li>PyMOSO provides strong support for implementing new MOSO algorithms that rely on RLE in an RA framework.</li>\n<li>PyMOSO provides strong support for implementing general RA algorithms.</li>\n<li>PyMOSO provides basic support, such as pseudo-random number control, for implementing other simulation optimization algorithms.\nWe provide templates of algorithms implemented in each of these three categories, along with example code snippets.</li>\n</ol>\n<p>In the first category, programmers can use PyMOSO to create new RA algorithms that use RLE for convergence. The novel part of these algorithms, created by the user, will be the <code>accel</code> function which should collect points to send to RLE for certification. Here, we list the rules for <code>accel</code>.</p>\n<ol>\n<li>The <code>accel</code> function must be an instance method of an <code>RLESolver</code> object, and thus its first parameter must be <code>self</code>.</li>\n<li>The second parameter is arbitrarily named and is a set of tuples. We recommend naming the parameter <code>warm_start</code>, as it represents the sample-path solution of the previous RA iteration.</li>\n<li>The return value must be a set of tuples representing feasible points; we do not recommend any particular name.\nIn every RA iteration, PyMOSO will first call <code>accel(self, warm_start)</code> and send the returned set to <code>rle(self, candidate_les)</code>. The return value must be a set of tuples. The implementer does not need to implement or call RLE, as in the <a href=\"#template-accelerator\" rel=\"nofollow\">template accelerator</a>.</li>\n</ol>\n<h4>Template Accelerator</h4>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">pymoso.chnbase</span> <span class=\"kn\">import</span> <span class=\"n\">RLESolver</span>\n\n<span class=\"c1\"># create a subclass of RLESolver</span>\n<span class=\"k\">class</span> <span class=\"nc\">MyAccel</span><span class=\"p\">(</span><span class=\"n\">RLESolver</span><span class=\"p\">):</span>\n    <span class=\"sd\">'''Example implementation of an RLE accelerator.'''</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">accel</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">warm_start</span><span class=\"p\">):</span>\n        <span class=\"sd\">'''Return a collection of points to send to RLE.'''</span>\n        <span class=\"c1\"># implement algorithm logic here and return a set</span>\n        <span class=\"k\">return</span> <span class=\"n\">warm_start</span>\n</pre>\n<p>In the second category, algorithm designers can quickly implement any RA algorithm by sub-classing <code>RASolver</code> and implementing the <code>spsolve</code> function, as shown in the <a href=\"#template-ra-solver\" rel=\"nofollow\">RA solver template</a>. The algorithm can be a single-objective algorithm. PyMOSO cannot guarantee the convergence of such algorithms. The template is technically valid in PyMOSO but is probably not effective.</p>\n<h4>Template RA Solver</h4>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">pymoso.chnbase</span> <span class=\"kn\">import</span> <span class=\"n\">RASolver</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">MyRAAlg</span><span class=\"p\">(</span><span class=\"n\">RASolver</span><span class=\"p\">):</span>\n    <span class=\"sd\">'''Template implementation of an RA solver.'''</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">spsolve</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">warm_start</span><span class=\"p\">):</span>\n        <span class=\"sd\">'''Return the sample path solution.'''</span>\n        <span class=\"c1\"># implement algorithm logic here and return a set</span>\n        <span class=\"k\">return</span> <span class=\"n\">warm_start</span>\n</pre>\n<p>Though analogous to those of an <code>RLESolver.accel</code> method, for completeness, we list the requirements for an <code>RASolver.spsolve</code> method.</p>\n<ol>\n<li>The <code>spsolve</code> function must be an instance method of an <code>RASolver</code> object, and thus its first parameter must be <code>self</code>.</li>\n<li>The second parameter is arbitrarily named and is a set of tuples. We recommend naming the parameter <code>warm_start</code> as it represents the sample-path solution of the previous RA iteration.</li>\n<li>The return value must be a set of tuples representing feasible points; we do not recommend any particular name.</li>\n</ol>\n<p>In the third category, PyMOSO can accommodate any simulation optimization algorithm by implementing the <code>solve</code> function of a <code>MOSOSolver</code> sub-class <a href=\"#template-moso-solver\" rel=\"nofollow\">as shown</a>. It does not have to be a multi-objective algorithm. PyMOSO will require users to send an initial feasible point <code>x0</code> whether or not the algorithm needs it. The initial feasible point <code>x0</code> is accessed through <code>self.x0</code> which is a tuple. We now list the rules for implementing any <code>MOSOSolver.solve</code> function.</p>\n<ol>\n<li>The <code>solve</code> function must be an instance method of <code>MOSOSolver</code>, and thus take <code>self</code> as its first parameter.</li>\n<li>The second parameter is the simulation budget, a natural number.</li>\n<li>The <code>solve</code> function must return a dictionary (we name it <code>results</code> in our example) with at least 3 keys: <code>'itersoln'</code>, <code>'simcalls'</code>, <code>'endseed'</code>. Researchers may track additional data and add it to <code>results</code> as desired.\n<ul>\n<li>The <code>'itersoln'</code> key itself corresponds to a dictionary with a key for each algorithm iteration labeled {0, 1, ...}. The value at each iteration is a set containing the estimated solution at the end of the iteration.</li>\n<li>The <code>'simcalls'</code> key itself corresponds to a dictionary with a key for each algorithm iteration labeled {0, 1, ...}. The value at each iteration is a natural number containing the cumulative number of simulation replications taken at the end of the iteration.</li>\n<li>The <code>'endseed'</code> key corresponds to a tuple of length 6, representing an <code>mrg32k3a</code> seed. The algorithm programmer should ensure the stream generated by <code>results['endseed']</code> is independent of all streams used by the algorithm.</li>\n</ul>\n</li>\n</ol>\n<p>Researchers may use the <a href=\"#template-moso-solver\" rel=\"nofollow\">MOSO template</a>  to implement new simulation optimization algorithms.</p>\n<h4>Template MOSO Solver</h4>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">pymoso.chnbase</span> <span class=\"kn\">import</span> <span class=\"n\">MOSOSolver</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">MyMOSOAlg</span><span class=\"p\">(</span><span class=\"n\">MOSOSolver</span><span class=\"p\">):</span>\n    <span class=\"sd\">'''Template implementation of a MOSO solver.'''</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">solve</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">budget</span><span class=\"p\">):</span>\n        <span class=\"k\">while</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">num_calls</span> <span class=\"o\">&lt;=</span> <span class=\"n\">budget</span><span class=\"p\">:</span>\n            <span class=\"c1\"># implement algorithm logic and return the results</span>\n        <span class=\"k\">return</span> <span class=\"n\">results</span>\n</pre>\n<p>For convenience, in the mini-sections below, we also provide some example code snippets that we find useful when implementing algorithms in PyMOSO. They work without modification when using the templates above that inherit \\inline{RLESolver} or \\inline{RASolver}, but some functions may require implementation or modification for use in a <code>MOSOSolver</code>. For reference, <a href=\"#pymoso-object-reference\" rel=\"nofollow\">this section</a> contains a list of most objects accessible to PyMOSO programmers.</p>\n<h5>Take Simulation Replications at a Point</h5>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">pymoso.chnutils</span> <span class=\"kn\">import</span> <span class=\"n\">get_nbors</span>\n<span class=\"c1\"># pretend x has not yet been visited in this RA iteration and is feasible</span>\n<span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># self.m is the sample size of the current RA iteration</span>\n<span class=\"n\">m</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">m</span>\n<span class=\"c1\"># self.num_calls is the cumulative number of simulations used till now</span>\n<span class=\"n\">start_num_calls</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">num_calls</span>\n<span class=\"c1\"># use estimate to sample x and put results in self.gbar and self.sehat</span>\n<span class=\"n\">isfeas</span><span class=\"p\">,</span> <span class=\"n\">fx</span><span class=\"p\">,</span> <span class=\"n\">se</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">estimate</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span>\n<span class=\"n\">calls_used</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">num_calls</span> <span class=\"o\">-</span> <span class=\"n\">start_num_calls</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">m</span> <span class=\"o\">==</span> <span class=\"n\">calls_used</span><span class=\"p\">)</span> <span class=\"c1\"># True</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">fx</span> <span class=\"o\">==</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">gbar</span><span class=\"p\">[</span><span class=\"n\">x</span><span class=\"p\">])</span> <span class=\"c1\"># True</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">se</span> <span class=\"o\">==</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">sehat</span><span class=\"p\">[</span><span class=\"n\">x</span><span class=\"p\">])</span> <span class=\"c1\"># True</span>\n\n<span class=\"c1\"># estimate will not simulate again in subsequent visits to a point</span>\n<span class=\"n\">start_num_calls</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">num_calls</span>\n<span class=\"n\">isfeas</span><span class=\"p\">,</span> <span class=\"n\">fx</span><span class=\"p\">,</span> <span class=\"n\">se</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">estimate</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span>\n<span class=\"n\">calls_used</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">num_calls</span> <span class=\"o\">-</span> <span class=\"n\">start_num_calls</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">calls_used</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"p\">)</span> <span class=\"c1\"># True</span>\n</pre>\n<h5>Find Neighbors and Take Simulation Replications</h5>\n<pre><span class=\"c1\"># neighborhood radiuss</span>\n<span class=\"n\">r</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">nbor_rad</span>\n<span class=\"n\">nbors</span> <span class=\"o\">=</span> <span class=\"n\">get_nbors</span><span class=\"p\">(</span><span class=\"n\">x0</span><span class=\"p\">,</span> <span class=\"n\">r</span><span class=\"p\">)</span>\n<span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">upsample</span><span class=\"p\">(</span><span class=\"n\">nbors</span><span class=\"p\">)</span>\n<span class=\"k\">for</span> <span class=\"n\">n</span> <span class=\"ow\">in</span> <span class=\"n\">nbors</span><span class=\"p\">:</span>\n  <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">n</span> <span class=\"ow\">in</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">gbar</span><span class=\"p\">)</span> <span class=\"c1\"># True if n feasible else False</span>\n\n<span class=\"c1\"># upsample also returns the feasible subset</span>\n<span class=\"n\">nbors</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">upsample</span><span class=\"p\">(</span><span class=\"n\">nbors</span><span class=\"p\">)</span>\n</pre>\n<h5>Argsort a Dictionary of Points</h5>\n<pre><span class=\"c1\"># 0 index for first objective</span>\n<span class=\"n\">sorted_feas</span> <span class=\"o\">=</span> <span class=\"nb\">sorted</span><span class=\"p\">(</span><span class=\"n\">nbors</span> <span class=\"o\">|</span> <span class=\"p\">{</span><span class=\"n\">x</span><span class=\"p\">},</span> <span class=\"n\">key</span><span class=\"o\">=</span><span class=\"k\">lambda</span> <span class=\"n\">t</span><span class=\"p\">:</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">gbar</span><span class=\"p\">[</span><span class=\"n\">t</span><span class=\"p\">][</span><span class=\"mi\">0</span><span class=\"p\">])</span>\n</pre>\n<h5>Select the Minimizer and its Value</h5>\n<pre><span class=\"n\">xmin</span> <span class=\"o\">=</span> <span class=\"n\">sorted_feas</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span>\n<span class=\"n\">fxmin</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">gbar</span><span class=\"p\">[</span><span class=\"n\">x</span><span class=\"p\">]</span>\n</pre>\n<h5>Use SPLINE to Retrive a Local Minimizer</h5>\n<pre><span class=\"c1\"># no constraints and minimize the 2nd objective</span>\n<span class=\"n\">x0</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">)</span>\n<span class=\"n\">isfeas</span><span class=\"p\">,</span> <span class=\"n\">fx</span><span class=\"p\">,</span> <span class=\"n\">sex</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">estimate</span><span class=\"p\">(</span><span class=\"n\">x0</span><span class=\"p\">)</span>\n<span class=\"c1\"># the suppressed value is the set visited along SPLINE's trajectory</span>\n<span class=\"n\">_</span><span class=\"p\">,</span> <span class=\"n\">xmin</span><span class=\"p\">,</span> <span class=\"n\">fxmin</span><span class=\"p\">,</span> <span class=\"n\">sexmin</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">spline</span><span class=\"p\">(</span><span class=\"n\">x0</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">(</span><span class=\"s1\">'inf'</span><span class=\"p\">),</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">)</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">gbar</span><span class=\"p\">[</span><span class=\"n\">xmin</span><span class=\"p\">]</span> <span class=\"o\">==</span> <span class=\"n\">fxmin</span><span class=\"p\">)</span> <span class=\"c1\"># True</span>\n</pre>\n<h5>Find the Non-Dominated Points in a Dictionary</h5>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">chnutils</span> <span class=\"kn\">import</span> <span class=\"n\">get_nondom</span>\n<span class=\"n\">nondom</span> <span class=\"o\">=</span> <span class=\"n\">get_nondom</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">gbar</span><span class=\"p\">)</span>\n</pre>\n<h5>Randomly Select Points in a Set</h5>\n<pre><span class=\"n\">solver_rng</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">sprn</span>\n<span class=\"c1\"># pick 5 points -- returns a list, not a set.</span>\n<span class=\"n\">ran_pts</span> <span class=\"o\">=</span> <span class=\"n\">solver_rng</span><span class=\"o\">.</span><span class=\"n\">sample</span><span class=\"p\">(</span><span class=\"nb\">list</span><span class=\"p\">(</span><span class=\"n\">nondom</span><span class=\"p\">),</span> <span class=\"mi\">5</span><span class=\"p\">)</span>\n<span class=\"n\">one_in_five</span> <span class=\"o\">=</span> <span class=\"n\">solver_rng</span><span class=\"o\">.</span><span class=\"n\">choice</span><span class=\"p\">(</span><span class=\"n\">ran_pts</span><span class=\"p\">)</span>\n</pre>\n<h3>Using <code>solve</code> and <code>testsolve</code> in Python Programs</h3>\n<p>Users may the <code>solve</code> and <code>testsolve</code> functions within a Python program.</p>\n<h4>Minimal <code>solve</code> Example</h4>\n<pre><span class=\"c1\"># import the solve function</span>\n<span class=\"kn\">from</span> <span class=\"nn\">pymoso.chnutils</span> <span class=\"kn\">import</span> <span class=\"n\">solve</span>\n<span class=\"c1\"># import the module containing the RPERLE implementation</span>\n<span class=\"kn\">import</span> <span class=\"nn\">pymoso.solvers.rperle</span> <span class=\"k\">as</span> <span class=\"nn\">rp</span>\n<span class=\"c1\"># import MyProblem - myproblem.py should usually be in the script directory</span>\n<span class=\"kn\">import</span> <span class=\"nn\">myproblem</span> <span class=\"k\">as</span> <span class=\"nn\">mp</span>\n\n<span class=\"c1\"># specify an x0. In MyProblem, it is a tuple of length 1</span>\n<span class=\"n\">x0</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"mi\">97</span><span class=\"p\">,)</span>\n<span class=\"n\">soln</span> <span class=\"o\">=</span> <span class=\"n\">solve</span><span class=\"p\">(</span><span class=\"n\">mp</span><span class=\"o\">.</span><span class=\"n\">MyProblem</span><span class=\"p\">,</span> <span class=\"n\">rp</span><span class=\"o\">.</span><span class=\"n\">RPERLE</span><span class=\"p\">,</span> <span class=\"n\">x0</span><span class=\"p\">)</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">soln</span><span class=\"p\">)</span>\n</pre>\n<h4>Some <code>solve</code> Examples with Options</h4>\n<pre><span class=\"c1\"># example for specifying budget and seed</span>\n<span class=\"n\">budget</span><span class=\"o\">=</span><span class=\"mi\">10000</span>\n<span class=\"n\">seed</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"mi\">111</span><span class=\"p\">,</span> <span class=\"mi\">222</span><span class=\"p\">,</span> <span class=\"mi\">333</span><span class=\"p\">,</span> <span class=\"mi\">444</span><span class=\"p\">,</span> <span class=\"mi\">555</span><span class=\"p\">,</span> <span class=\"mi\">666</span><span class=\"p\">)</span>\n<span class=\"n\">soln1</span> <span class=\"o\">=</span> <span class=\"n\">solve</span><span class=\"p\">(</span><span class=\"n\">mp</span><span class=\"o\">.</span><span class=\"n\">MyProblem</span><span class=\"p\">,</span> <span class=\"n\">rp</span><span class=\"o\">.</span><span class=\"n\">RPERLE</span><span class=\"p\">,</span> <span class=\"n\">x0</span><span class=\"p\">,</span> <span class=\"n\">budget</span><span class=\"o\">=</span><span class=\"n\">budget</span><span class=\"p\">,</span> <span class=\"n\">seed</span><span class=\"o\">=</span><span class=\"n\">seed</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># specify crn and simpar</span>\n<span class=\"n\">soln2</span> <span class=\"o\">=</span> <span class=\"n\">solve</span><span class=\"p\">(</span><span class=\"n\">mp</span><span class=\"o\">.</span><span class=\"n\">MyProblem</span><span class=\"p\">,</span> <span class=\"n\">rp</span><span class=\"o\">.</span><span class=\"n\">RPERLE</span><span class=\"p\">,</span> <span class=\"n\">x0</span><span class=\"p\">,</span> <span class=\"n\">crn</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">,</span> <span class=\"n\">simpar</span><span class=\"o\">=</span><span class=\"mi\">4</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># specify algorithm specific parameters</span>\n<span class=\"n\">soln3</span> <span class=\"o\">=</span> <span class=\"n\">solve</span><span class=\"p\">(</span><span class=\"n\">mp</span><span class=\"o\">.</span><span class=\"n\">MyProblem</span><span class=\"p\">,</span> <span class=\"n\">rp</span><span class=\"o\">.</span><span class=\"n\">RPERLE</span><span class=\"p\">,</span> <span class=\"n\">x0</span><span class=\"p\">,</span> <span class=\"n\">radius</span><span class=\"o\">=</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"n\">betaeps</span><span class=\"o\">=</span><span class=\"mf\">0.3</span><span class=\"p\">,</span> <span class=\"n\">betadel</span><span class=\"o\">=</span><span class=\"mf\">0.4</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># mix them</span>\n<span class=\"n\">soln4</span> <span class=\"o\">=</span> <span class=\"n\">solve</span><span class=\"p\">(</span><span class=\"n\">mp</span><span class=\"o\">.</span><span class=\"n\">MyProblem</span><span class=\"p\">,</span> <span class=\"n\">rp</span><span class=\"o\">.</span><span class=\"n\">RPERLE</span><span class=\"p\">,</span> <span class=\"n\">x0</span><span class=\"p\">,</span> <span class=\"n\">crn</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">,</span> <span class=\"n\">seed</span><span class=\"o\">=</span><span class=\"n\">seed</span><span class=\"p\">,</span> <span class=\"n\">radius</span><span class=\"o\">=</span><span class=\"mi\">5</span><span class=\"p\">)</span>\n</pre>\n<h4>A <code>testsolve</code> Example</h4>\n<pre><span class=\"c1\"># import the testsolve functions</span>\n<span class=\"kn\">from</span> <span class=\"nn\">pymoso.chnutils</span> <span class=\"kn\">import</span> <span class=\"n\">testsolve</span>\n<span class=\"c1\"># import the module containing RPERLE</span>\n<span class=\"kn\">import</span> <span class=\"nn\">pymoso.solvers.rperle</span> <span class=\"k\">as</span> <span class=\"nn\">rp</span>\n<span class=\"c1\"># import the MyTester class</span>\n<span class=\"kn\">from</span> <span class=\"nn\">mytester</span> <span class=\"kn\">import</span> <span class=\"n\">MyTester</span>\n\n<span class=\"c1\"># testsolve needs a \"dummy\" x0 even if MyTester will generate them</span>\n<span class=\"n\">x0</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"p\">)</span>\n<span class=\"n\">run_data</span> <span class=\"o\">=</span> <span class=\"n\">testsolve</span><span class=\"p\">(</span><span class=\"n\">MyTester</span><span class=\"p\">,</span> <span class=\"n\">rp</span><span class=\"o\">.</span><span class=\"n\">RPERLE</span><span class=\"p\">,</span> <span class=\"n\">x0</span><span class=\"p\">,</span> <span class=\"n\">isp</span><span class=\"o\">=</span><span class=\"mi\">100</span><span class=\"p\">,</span> <span class=\"n\">crn</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">,</span> <span class=\"n\">radius</span><span class=\"o\">=</span><span class=\"mi\">2</span><span class=\"p\">)</span>\n</pre>\n<h4>Computing a Metric on <code>testsolve</code> Output</h4>\n<p>Programmers must compute their metric. Here, <code>run_data</code> is a dictionary of the form described <a href=\"#implementing-pymoso-algorithms\" rel=\"nofollow\">here</a> and we compute the metric on the 5th iteration of of the 12th independent algorithm instance.</p>\n<pre><span class=\"n\">iter5_soln</span> <span class=\"o\">=</span> <span class=\"n\">run_data</span><span class=\"p\">[</span><span class=\"mi\">11</span><span class=\"p\">][</span><span class=\"s1\">'itersoln'</span><span class=\"p\">][</span><span class=\"mi\">4</span><span class=\"p\">]</span>\n<span class=\"n\">isp12_iter5_metric</span> <span class=\"o\">=</span> <span class=\"n\">MyTester</span><span class=\"o\">.</span><span class=\"n\">metric</span><span class=\"p\">(</span><span class=\"n\">iter5_soln</span><span class=\"p\">)</span>\n</pre>\n<h2>PyMOSO Object Reference</h2>\n<h3>The <code>pymoso.prng.mrg32k3a</code> Module</h3>\n<p>The <code>pymoso.prng.mrg32k3a</code> module exposes the pseudo-random number generator and functions to manipulate it.</p>\n<table>\n<thead>\n<tr>\n<th>Object</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>MRG32k3a</code></td>\n<td>Sub-class of random.Random, defines all <code>rng</code> objects.</td>\n</tr>\n<tr>\n<td><code>get_next_prnstream(seed)</code></td>\n<td>Return an <code>rng</code> object seeded 2^127 steps from the input seed.</td>\n</tr>\n<tr>\n<td><code>jump_substream(rng)</code></td>\n<td>Seed the input <code>rng</code> object 2^76 steps forward.</td>\n</tr></tbody></table>\n<h3>The <code>pymoso.chnbase</code> Module</h3>\n<p>The <code>pymoso.chnbase</code> module implements the base classes for oracles and solvers. Programmers should sub-class these when creating new PyMOSO implementations.\n| Class | Description |\n| ------ | ----------- |\n| <code>Oracle</code> | Base class for implementing oracles. |\n| <code>RLESolver</code> | Base class for implementing solvers using RLE. |\n| <code>RASolver</code> | Base class for implementing RA solvers.|\n|<code>MOSOSolver</code> | Base class for all solvers. |</p>\n<h3>The <code>pymoso.chnutils</code> Module</h3>\n<p>The <code>pymoso.chnutils</code> contains useful functions for implementing and testing algorithms.</p>\n<table>\n<thead>\n<tr>\n<th>Function</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>solve(oracle, solver, x0, **kwargs)</code></td>\n<td><a href=\"#minimal-solve-example\" rel=\"nofollow\">See here</a> for instructions.</td>\n</tr>\n<tr>\n<td><code>testsolve(tester, solver, x0, **kwargs)</code></td>\n<td><a href=\"#a-testsolve-example\" rel=\"nofollow\">See here</a> for instructions.</td>\n</tr>\n<tr>\n<td><code>does_weak_dominate(g, h, relg, relh)</code></td>\n<td>All inputs are tuples of equal length. Returns <code>True</code> if <code>g</code> weakly dominates <code>h</code> with the relaxations.</td>\n</tr>\n<tr>\n<td><code>does_dominate(g, h, relg, relh)</code></td>\n<td>Returns <code>True</code> if <code>g</code> dominates <code>h</code> with the relaxations.</td>\n</tr>\n<tr>\n<td><code>does_strict_dominate(g, h, relg, relh)</code></td>\n<td>Returns <code>True</code> if <code>g</code> strictly dominates <code>h</code> with the relaxations.</td>\n</tr>\n<tr>\n<td><code>get_nondom(obj_dict)</code></td>\n<td>Input: a dictionary with tuples for keys and values. The keys are feasible points; the values are their objective values. Return: a set of tuples representing non-dominated points.</td>\n</tr>\n<tr>\n<td><code>get_nbors(x, r)</code></td>\n<td>Input: a tuple <code>x</code>, a positive real scalar <code>r</code> indicating the neighborhood radius. Return: Set of tuples which are the neighbors.</td>\n</tr>\n<tr>\n<td><code>get_setnbors(S, r)</code></td>\n<td>Input: a set of tuples, and the neighborhood radius. Return: the union of <code>get_nbors(s, r)</code> for every <code>s</code> in <code>S</code>.</td>\n</tr>\n<tr>\n<td><code>dh(A, B)</code></td>\n<td>Returns the Hausdorff distance between set <code>A</code> and set <code>B</code>.</td>\n</tr>\n<tr>\n<td><code>edist(x1, x2)</code></td>\n<td>Return the Euclidean distance from <code>x1</code> to <code>x2</code>.</td>\n</tr>\n<tr>\n<td><code>get_metric(results, tester)</code></td>\n<td>Input: <code>results</code> is a dictionary, the output of each sample path of <code>testsolve</code>. <code>tester</code> must implement <code>metric</code>. Returns: The set of triples (iteration, simulation count, metric) for an algorithm run.</td>\n</tr></tbody></table>\n<h3>The <code>Oracle</code> Class</h3>\n<p>When implementing <code>RASolver</code> algorithms, programmers may not need to access <code>Oracle</code> objects directly at all. When implementing <code>MOSOSolver</code> algorithms, programmers will use (or wrap) <code>hit</code> and <code>crn_advance()</code>.</p>\n<table>\n<thead>\n<tr>\n<th>Member/Method</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>num_obj</code></td>\n<td>A positive integer, the number of objectives.</td>\n</tr>\n<tr>\n<td><code>dim</code></td>\n<td>A positive integer, the dimensionality of feasible points.</td>\n</tr>\n<tr>\n<td><code>rng</code></td>\n<td>An instance of <code>MRG32k3a</code>.</td>\n</tr>\n<tr>\n<td><code>hit(x, n)</code></td>\n<td>Take <code>n</code> observations of <code>x</code>. Return: <code>True</code>, and a tuple containing the mean of the observations for each objective, and a tuple containing the standard error for each objective if <code>x</code> is feasible. The function handles CRN internally.</td>\n</tr>\n<tr>\n<td><code>set_crnflag(bool)</code></td>\n<td>Turn CRN on (<code>True</code>) or off.</td>\n</tr>\n<tr>\n<td><code>set_crnold(state)</code></td>\n<td>Save the <code>rng</code> state as the CRN baseline, e.g. for an algorithm iteration. Get the state using <code>rng.getstate()</code>.</td>\n</tr>\n<tr>\n<td><code>crn_reset()</code></td>\n<td>Back the oracle <code>rng</code> to the CRN baseline.</td>\n</tr>\n<tr>\n<td><code>crn_advance()</code></td>\n<td>If CRN is on, reset, and then jump to the next independent pseudo-random stream and save the new baseline, e.g. before starting a new algorithm iteration.</td>\n</tr>\n<tr>\n<td><code>crn_setobs()</code></td>\n<td>Set an intermediate CRN for individual oracle observations.</td>\n</tr>\n<tr>\n<td><code>crn_nextobs()</code></td>\n<td>Jump the <code>rng</code> forward, e.g. after taking an observation, and <code>crn_setobs</code> the seed.</td>\n</tr>\n<tr>\n<td><code>crn_check()</code></td>\n<td>f CRN is on, return to the baseline. Otherwise, use <code>crn_nextobs</code> before taking the next observation.</td>\n</tr></tbody></table>\n<h3>The <code>MOSOSolver</code> Class</h3>\n<p>The class provides a basic structure for implementing new MOSO algorithms in PyMOSO.</p>\n<table>\n<thead>\n<tr>\n<th>Member/Method</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>orc</code></td>\n<td>The oracle object for the solver to solve.</td>\n</tr>\n<tr>\n<td><code>dim</code></td>\n<td>Number of dimensions of points in the feasible set. Should match <code>self.orc</code></td>\n</tr>\n<tr>\n<td><code>num_obj</code></td>\n<td>Similarly, the number of objectives in <code>self.orc</code>.</td>\n</tr>\n<tr>\n<td><code>num_calls</code></td>\n<td>A running count of the number of simulation replications taken of <code>self.orc</code>.</td>\n</tr>\n<tr>\n<td><code>x0</code></td>\n<td>A feasible starting point. This point is additionally supplied to algorithms that don't need one.</td>\n</tr></tbody></table>\n<h3>The <code>RASolver</code> Class</h3>\n<p>The class implements a common structure for all RA algorithms, including: caching of simulation replications, scheduling and updating of sample sizes and limits, and a wrapper to <code>Oracle.hit</code>.</p>\n<table>\n<thead>\n<tr>\n<th>Member/Method</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>sprn</code></td>\n<td>An instance of <code>MRG32k3a</code> for the solver to use.</td>\n</tr>\n<tr>\n<td><code>nbor_rad</code></td>\n<td>The neighborhood radius used by solvers seeking local optimality.</td>\n</tr>\n<tr>\n<td><code>gbar</code></td>\n<td>A dictionary where every key and value is a tuple. The keys are feasible points, values are their objective values. <code>gbar</code> is \"wiped\" every retrospective iteration.</td>\n</tr>\n<tr>\n<td><code>sehat</code></td>\n<td>Exactly like <code>gbar</code> except the values are standard errors.</td>\n</tr>\n<tr>\n<td><code>m</code></td>\n<td>The sample size of the current iteration.</td>\n</tr>\n<tr>\n<td><code>calc_m(nu)</code></td>\n<td>Compute the sample size of the current iteration. RA algorithms automatically do this every iteration and assign the value to `m'.</td>\n</tr>\n<tr>\n<td><code>b</code></td>\n<td>The searching sample limit of the current iteration.</td>\n</tr>\n<tr>\n<td><code>calc_b(nu)</code></td>\n<td>Exactly as <code>calc_m</code> but for the searching sample limit.</td>\n</tr>\n<tr>\n<td><code>estimate(x, c, obj)</code></td>\n<td>The <code>estimate</code> function is essentially a smart wrapper for <code>self.orc.hit</code>. Inputs: tuple <code>x</code> to sample, <code>c</code> a feasibility constraint, <code>obj</code> the objective to constrain. Return: same as <code>Oracle.hit</code>. Retrieves or saves the results from/to <code>gbar</code> and <code>sehat</code> as appropriate. Returns not feasible if the otherwise feasible result is not less than the constraint.</td>\n</tr>\n<tr>\n<td><code>upsample(S)</code></td>\n<td>A version of <code>estimate</code> for sets. Returns the feasible subset of <code>S</code>.</td>\n</tr>\n<tr>\n<td><code>spline(x, c, obmin, obcon)</code></td>\n<td>Return a sample path local minimizer. Input: a feasible start, constraint, objective to minimize, objective to constrain. Return: a set of tuples of the trajectory, the minimizer tuple, the minimum tuple, the standard error tuple.</td>\n</tr></tbody></table>\n<h3>The <code>RLESolver</code> Class</h3>\n<p>The sub-class of \\inlinetwo{RASolver} adds RLE and its relaxation.</p>\n<table>\n<thead>\n<tr>\n<th>Member/Method</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>betadel</code></td>\n<td>Affects the relaxation values computed in RLE.</td>\n</tr>\n<tr>\n<td><code>calc_delta(se)</code></td>\n<td>Computes the RLE relaxation given a standard error, using <code>self.m</code> and <code>self.betadel</code>.</td>\n</tr>\n<tr>\n<td><code>rle(candidate_les)</code></td>\n<td>Input: set of tuples, Returns: set of tuples. Finds the LES at sample size <code>self.m</code>.</td>\n</tr></tbody></table>\n\n          </div>"}, "last_serial": 6178216, "releases": {"0.1.13": [{"comment_text": "", "digests": {"md5": "e6428b95fdafe0d49097224bf6437e1b", "sha256": "4c3164b5db57da38812d1dcd02f5a6277889f1849ea23f4f7b297293183247c8"}, "downloads": -1, "filename": "pymoso-0.1.13-py3-none-any.whl", "has_sig": false, "md5_digest": "e6428b95fdafe0d49097224bf6437e1b", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6.0", "size": 41634, "upload_time": "2018-10-08T13:33:16", "upload_time_iso_8601": "2018-10-08T13:33:16.632754Z", "url": "https://files.pythonhosted.org/packages/17/f3/cf641bf5ab6e105f22bd1186e156f42f42e7a1b557d92abbae0f1a439689/pymoso-0.1.13-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "0bc05608cdd395aa0f13f7feef9b59f7", "sha256": "e8c5c428e15549bd2fccc6aeec1dafa1fcb9bd3647afa62d6cfde48e59653629"}, "downloads": -1, "filename": "pymoso-0.1.13.tar.gz", "has_sig": false, "md5_digest": "0bc05608cdd395aa0f13f7feef9b59f7", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6.0", "size": 38890, "upload_time": "2018-10-08T13:33:17", "upload_time_iso_8601": "2018-10-08T13:33:17.678783Z", "url": "https://files.pythonhosted.org/packages/80/b6/cb311897c91cf8e74196e1aa4071d512462b1db2ad2e640a85b5db111024/pymoso-0.1.13.tar.gz", "yanked": false}], "0.1.14": [{"comment_text": "", "digests": {"md5": "e05ba9024fd38584bbc9f72995efd0dd", "sha256": "7c086b2796387d75bdc6eb386d1b2f93b976a88f1e868cbd1e4aae6851aceb76"}, "downloads": -1, "filename": "pymoso-0.1.14-py3-none-any.whl", "has_sig": false, "md5_digest": "e05ba9024fd38584bbc9f72995efd0dd", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6.0", "size": 41634, "upload_time": "2018-10-08T13:38:02", "upload_time_iso_8601": "2018-10-08T13:38:02.263960Z", "url": "https://files.pythonhosted.org/packages/fa/ac/5cf02159ef1e51bddf954785a1e28eaaba45933211e314b1a553e4340a2e/pymoso-0.1.14-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "53e5dd21533fe4a88c9c9d2d41290a2d", "sha256": "634c9d3c35992237f3ef5105db37ebb08ebfe100dbeadfc79b10a3f5dcea2aba"}, "downloads": -1, "filename": "pymoso-0.1.14.tar.gz", "has_sig": false, "md5_digest": "53e5dd21533fe4a88c9c9d2d41290a2d", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6.0", "size": 38890, "upload_time": "2018-10-08T13:38:04", "upload_time_iso_8601": "2018-10-08T13:38:04.152005Z", "url": "https://files.pythonhosted.org/packages/ff/bb/db7770ed36c91bf51683a128f5767080801a36c199af88bd98b835a13270/pymoso-0.1.14.tar.gz", "yanked": false}], "0.1.15": [{"comment_text": "", "digests": {"md5": "c66911d5c84e078e99d00dd002fac30b", "sha256": "e1f7e40e1b5616b7a3d029e9f9396aed99e789194be8d774d1279215f70843c2"}, "downloads": -1, "filename": "pymoso-0.1.15-py3-none-any.whl", "has_sig": false, "md5_digest": "c66911d5c84e078e99d00dd002fac30b", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6.0", "size": 41637, "upload_time": "2018-10-08T13:41:42", "upload_time_iso_8601": "2018-10-08T13:41:42.931917Z", "url": "https://files.pythonhosted.org/packages/29/00/8397bf6f5e51e67aaed7f702911868b4191f001890c8384a76e59c970218/pymoso-0.1.15-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "8bb05e19bc8d575ce8dcafe8317e5338", "sha256": "f050ad366d179e38d61f68f645cf7cf0ebdf25e55d73f6277ceeadad459dbd7c"}, "downloads": -1, "filename": "pymoso-0.1.15.tar.gz", "has_sig": false, "md5_digest": "8bb05e19bc8d575ce8dcafe8317e5338", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6.0", "size": 38883, "upload_time": "2018-10-08T13:41:44", "upload_time_iso_8601": "2018-10-08T13:41:44.343278Z", "url": "https://files.pythonhosted.org/packages/77/a9/dc79ea90c89d8692512b4de57a9628dca674cf4a89ae6aa892b1a9343552/pymoso-0.1.15.tar.gz", "yanked": false}], "0.1.16": [{"comment_text": "", "digests": {"md5": "581325699d00efaee2dac5168bd53060", "sha256": "19a35c85d8a5f7b93798595649caee14691145d3c05d44650a1ffa2d65e2768f"}, "downloads": -1, "filename": "pymoso-0.1.16-py3-none-any.whl", "has_sig": false, "md5_digest": "581325699d00efaee2dac5168bd53060", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6.0", "size": 41631, "upload_time": "2018-10-08T13:50:50", "upload_time_iso_8601": "2018-10-08T13:50:50.062370Z", "url": "https://files.pythonhosted.org/packages/1b/4f/488faed06a2d087bfc5fb00032e255e977854ec2ec53dcf9b208cf84c220/pymoso-0.1.16-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "71ff38ee5fcb22e7ac17caa1d0f55122", "sha256": "a4250ca8ec651ab48f0a6373cc79bc3092eb8ce4c5c842d28f5a10adab3143d8"}, "downloads": -1, "filename": "pymoso-0.1.16.tar.gz", "has_sig": false, "md5_digest": "71ff38ee5fcb22e7ac17caa1d0f55122", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6.0", "size": 38879, "upload_time": "2018-10-08T13:50:51", "upload_time_iso_8601": "2018-10-08T13:50:51.354609Z", "url": "https://files.pythonhosted.org/packages/16/ca/46f729b045a3d33befb43df87073f651f6c7acf4a8ba955bace5bbd57614/pymoso-0.1.16.tar.gz", "yanked": false}], "0.1.17": [{"comment_text": "", "digests": {"md5": "7a125243e2c312ec0123574ebd81c810", "sha256": "4d1210d3b5bf103c5879a18e72888f6fef24acd8913d809c800fb981e6f6d527"}, "downloads": -1, "filename": "pymoso-0.1.17-py3-none-any.whl", "has_sig": false, "md5_digest": "7a125243e2c312ec0123574ebd81c810", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6.0", "size": 41685, "upload_time": "2018-10-08T13:57:24", "upload_time_iso_8601": "2018-10-08T13:57:24.966531Z", "url": "https://files.pythonhosted.org/packages/0b/a7/28553aa2d1b250062402be7e4909e70fafc4341876560bfab9a4e65636f0/pymoso-0.1.17-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "4846ff1b04982c7cb20bf8b66bc40068", "sha256": "560d4c0962c290b1762ec0c6f677c24c59633d84e55329fbae2fdb76dae56848"}, "downloads": -1, "filename": "pymoso-0.1.17.tar.gz", "has_sig": false, "md5_digest": "4846ff1b04982c7cb20bf8b66bc40068", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6.0", "size": 38923, "upload_time": "2018-10-08T13:57:26", "upload_time_iso_8601": "2018-10-08T13:57:26.387157Z", "url": "https://files.pythonhosted.org/packages/01/3d/e6745fe18413922ed41d6f287081d4a2ea492865e73e7925ae48caca0bc9/pymoso-0.1.17.tar.gz", "yanked": false}], "0.1.18": [{"comment_text": "", "digests": {"md5": "3df31371c265d5540a4347d665c33d6e", "sha256": "262e3571cf5dadaea32f3bfa4bdc05c22a86bcebbc51c768bf9cd4fffdb48f3d"}, "downloads": -1, "filename": "pymoso-0.1.18-py3-none-any.whl", "has_sig": false, "md5_digest": "3df31371c265d5540a4347d665c33d6e", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6.0", "size": 41774, "upload_time": "2018-10-08T14:42:56", "upload_time_iso_8601": "2018-10-08T14:42:56.126001Z", "url": "https://files.pythonhosted.org/packages/54/92/e0b9523191f28c2792c8a4358fa43afec11b995b48f6949724e0c6676f5c/pymoso-0.1.18-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "32aa342f2edf0d8cf9daf5219f6b666a", "sha256": "1135dce358b2c8dfbfa9d14b6e11372c23938b8472fb2e3ef35a939fc3754583"}, "downloads": -1, "filename": "pymoso-0.1.18.tar.gz", "has_sig": false, "md5_digest": "32aa342f2edf0d8cf9daf5219f6b666a", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6.0", "size": 39061, "upload_time": "2018-10-08T14:42:57", "upload_time_iso_8601": "2018-10-08T14:42:57.591577Z", "url": "https://files.pythonhosted.org/packages/43/d1/cd8d0c5a689c6e642fdc8718ebf2b1c2d66272b81af02b7fb9f2279ec19a/pymoso-0.1.18.tar.gz", "yanked": false}], "0.1.19": [{"comment_text": "", "digests": {"md5": "3e601959ec6db079c0546d6d49c03108", "sha256": "69dbc219d5d4d2536b77ec16814efcd70786f7e3375da5935dfd614b4b210078"}, "downloads": -1, "filename": "pymoso-0.1.19-py3-none-any.whl", "has_sig": false, "md5_digest": "3e601959ec6db079c0546d6d49c03108", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6.0", "size": 41771, "upload_time": "2018-10-08T14:49:09", "upload_time_iso_8601": "2018-10-08T14:49:09.076990Z", "url": "https://files.pythonhosted.org/packages/4d/54/327f2c39e3b76646af3d3a0a689ba92b5bdceae5035440ab93d2506373d7/pymoso-0.1.19-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "82859d5e0befc9a2937f43f63936b62e", "sha256": "2d725f5e33c774211148632c5dbf2da7be1da2f6590599d9b42044908a6838d4"}, "downloads": -1, "filename": "pymoso-0.1.19.tar.gz", "has_sig": false, "md5_digest": "82859d5e0befc9a2937f43f63936b62e", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6.0", "size": 39059, "upload_time": "2018-10-08T14:49:11", "upload_time_iso_8601": "2018-10-08T14:49:11.386715Z", "url": "https://files.pythonhosted.org/packages/87/e9/34ba8398a9384c3d05f9950fc7a22d6d3b234d2bb479ff142aef7d4a0419/pymoso-0.1.19.tar.gz", "yanked": false}], "0.1.20": [{"comment_text": "", "digests": {"md5": "71f7f2becf3506d0b789edbf79fc68d7", "sha256": "e10e1e3f999759ee080bc2c1259b0df47b17695783b284d59b725d5d2a7edf02"}, "downloads": -1, "filename": "pymoso-0.1.20-py3-none-any.whl", "has_sig": false, "md5_digest": "71f7f2becf3506d0b789edbf79fc68d7", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6.0", "size": 50763, "upload_time": "2018-10-12T14:01:55", "upload_time_iso_8601": "2018-10-12T14:01:55.539423Z", "url": "https://files.pythonhosted.org/packages/ad/60/a8083b947c90b6613fc49d25c0b72df4e697f5b840f4f97eeaa5ccbcabaf/pymoso-0.1.20-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "46e8c8f7bbfc2c5ec4fb9e047a07704e", "sha256": "dbe66ac1b2ab0536339a435183641a6968bf038119191c3d645e3d171e3a6199"}, "downloads": -1, "filename": "pymoso-0.1.20.tar.gz", "has_sig": false, "md5_digest": "46e8c8f7bbfc2c5ec4fb9e047a07704e", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6.0", "size": 43297, "upload_time": "2018-10-12T14:01:57", "upload_time_iso_8601": "2018-10-12T14:01:57.270969Z", "url": "https://files.pythonhosted.org/packages/64/c6/fe371b611b499352a81800a4403a7864a753d684d68d8a6ab34ab1a511bf/pymoso-0.1.20.tar.gz", "yanked": false}], "0.1.21": [{"comment_text": "", "digests": {"md5": "ba281381f91193496125b23a7ca7cbb5", "sha256": "3358e1283e3dcca40c06587faaf3f1563fab716b1c0b4e098868874d1b438d95"}, "downloads": -1, "filename": "pymoso-0.1.21-py3-none-any.whl", "has_sig": false, "md5_digest": "ba281381f91193496125b23a7ca7cbb5", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6.0", "size": 52644, "upload_time": "2018-10-13T02:10:33", "upload_time_iso_8601": "2018-10-13T02:10:33.583135Z", "url": "https://files.pythonhosted.org/packages/ce/b0/1bcd6b3c48148ceb0dda9c7f716df48de757ef3420f0946557ad72105c2b/pymoso-0.1.21-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "2ac38c8094cd35dfdbd1b523365b0a7a", "sha256": "2ea3b89bf6d5eb580533e4bc3e8552abbff055a654bbf6d0832ecfb28e20ed16"}, "downloads": -1, "filename": "pymoso-0.1.21.tar.gz", "has_sig": false, "md5_digest": "2ac38c8094cd35dfdbd1b523365b0a7a", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6.0", "size": 51868, "upload_time": "2018-10-13T02:10:35", "upload_time_iso_8601": "2018-10-13T02:10:35.019468Z", "url": "https://files.pythonhosted.org/packages/52/9e/1f9bab36fad5b9c05f7af99895c4af19b48719e0f5fbc2a22389570a5571/pymoso-0.1.21.tar.gz", "yanked": false}], "0.1.22": [{"comment_text": "", "digests": {"md5": "96a7ed5a9e198587ec0ebfedd8562c89", "sha256": "d52c42c8edb4c0c8aa2538226d9022c254b5fd9cb0774a0d08b6612dd2add114"}, "downloads": -1, "filename": "pymoso-0.1.22-py3-none-any.whl", "has_sig": false, "md5_digest": "96a7ed5a9e198587ec0ebfedd8562c89", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6.0", "size": 52687, "upload_time": "2018-10-13T02:31:37", "upload_time_iso_8601": "2018-10-13T02:31:37.898715Z", "url": "https://files.pythonhosted.org/packages/d0/4b/1486dcb95c37ca6fe1ff31e82041f8aaa2b83fdfb9fa052fd2d935171c1d/pymoso-0.1.22-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "c6e82bab8ca19d853a0d78975604faad", "sha256": "8f45d81c389d9a1d514f64614c367bfde1bcb4478c4fbc9a7700d45de0722caf"}, "downloads": -1, "filename": "pymoso-0.1.22.tar.gz", "has_sig": false, "md5_digest": "c6e82bab8ca19d853a0d78975604faad", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6.0", "size": 51911, "upload_time": "2018-10-13T02:31:39", "upload_time_iso_8601": "2018-10-13T02:31:39.056473Z", "url": "https://files.pythonhosted.org/packages/8c/a5/e95e18dccd7ba3f9221e3827cfcb060ce8035986bb01905b82c5d2441657/pymoso-0.1.22.tar.gz", "yanked": false}], "0.1.23": [{"comment_text": "", "digests": {"md5": "5b4c7b95bd1a83fa179c7e79710cc357", "sha256": "5d0350827b464089f845d29fbacf9a73b2d0e105a0ecd9e31a42938c54589f49"}, "downloads": -1, "filename": "pymoso-0.1.23-py3-none-any.whl", "has_sig": false, "md5_digest": "5b4c7b95bd1a83fa179c7e79710cc357", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6.0", "size": 53979, "upload_time": "2018-10-17T21:35:46", "upload_time_iso_8601": "2018-10-17T21:35:46.334019Z", "url": "https://files.pythonhosted.org/packages/32/5c/d20d15607328f66713a384acfa5540b4e5a069b7e6e333a9b9c847a4bd67/pymoso-0.1.23-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "8f39e0aac3c7c971206a0abb96352f3a", "sha256": "c429b73ef0833e43b94e232675a96f47a7e3bd8c06601cfb4c631fecad7bbf8c"}, "downloads": -1, "filename": "pymoso-0.1.23.tar.gz", "has_sig": false, "md5_digest": "8f39e0aac3c7c971206a0abb96352f3a", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6.0", "size": 58823, "upload_time": "2018-10-17T21:35:47", "upload_time_iso_8601": "2018-10-17T21:35:47.995846Z", "url": "https://files.pythonhosted.org/packages/1b/88/b143c0896d42841d927edbff5dbd694cb0fbe71b79afcaf6d7b90bdcd512/pymoso-0.1.23.tar.gz", "yanked": false}], "1.0.0": [{"comment_text": "", "digests": {"md5": "4ef07cd7ea5d8fdc2759cf21dc56751b", "sha256": "949cd4dfa461c4ac5d204aae400c96ab1acbc3e24a45a36a1d800b72660cffc8"}, "downloads": -1, "filename": "pymoso-1.0.0-py3-none-any.whl", "has_sig": false, "md5_digest": "4ef07cd7ea5d8fdc2759cf21dc56751b", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6.0", "size": 53964, "upload_time": "2018-10-22T15:39:56", "upload_time_iso_8601": "2018-10-22T15:39:56.043341Z", "url": "https://files.pythonhosted.org/packages/31/14/2b7d2e06dae6086da8527520cc9c2a039a3606747458463781eac56c784c/pymoso-1.0.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "84b9c023df66119c202c865a2a6cd78f", "sha256": "c00f841de887200dab20e340db42fb10a10acb5a297072b91b34b764c732861d"}, "downloads": -1, "filename": "pymoso-1.0.0.tar.gz", "has_sig": false, "md5_digest": "84b9c023df66119c202c865a2a6cd78f", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6.0", "size": 58828, "upload_time": "2018-10-22T15:39:58", "upload_time_iso_8601": "2018-10-22T15:39:58.114888Z", "url": "https://files.pythonhosted.org/packages/4c/ef/bef89e5fd91f96fb9b594184dfc1f4183aa81453e4cc1ba8c4086ae64e0b/pymoso-1.0.0.tar.gz", "yanked": false}], "1.0.1": [{"comment_text": "", "digests": {"md5": "84b55603b3870ff401298dc594da65d3", "sha256": "bd09ccee68fecfb1567e44b22ec68e9427f7fc993030303f65ee6070d5603405"}, "downloads": -1, "filename": "pymoso-1.0.1-py3-none-any.whl", "has_sig": false, "md5_digest": "84b55603b3870ff401298dc594da65d3", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6.0", "size": 50599, "upload_time": "2018-10-23T14:54:21", "upload_time_iso_8601": "2018-10-23T14:54:21.469990Z", "url": "https://files.pythonhosted.org/packages/ca/0f/5e5e17f009bb6c20cf4c5d1f7155ed1d441314e26dc55634ffe7dc3c5d49/pymoso-1.0.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "ecd04356c52edbba9b7754ab956bdcf3", "sha256": "bcd9f0e5bd0c36e323d91c2c171803c20ecbe772365c90fdf2a9e5e591194dda"}, "downloads": -1, "filename": "pymoso-1.0.1.tar.gz", "has_sig": false, "md5_digest": "ecd04356c52edbba9b7754ab956bdcf3", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6.0", "size": 69578, "upload_time": "2018-10-23T14:54:22", "upload_time_iso_8601": "2018-10-23T14:54:22.959292Z", "url": "https://files.pythonhosted.org/packages/e6/71/dfcd224fbc88649f6274bf7cd0c9ab2d179bf427d176b568c9f38422fa43/pymoso-1.0.1.tar.gz", "yanked": false}], "1.0.2": [{"comment_text": "", "digests": {"md5": "5dc818896572c214f1fe7da9d53d89d6", "sha256": "479e82c82ddc459454510f32079bcc72a397a5e30183a63c8ae633e9ae2ddf69"}, "downloads": -1, "filename": "pymoso-1.0.2-py3-none-any.whl", "has_sig": false, "md5_digest": "5dc818896572c214f1fe7da9d53d89d6", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6.0", "size": 50282, "upload_time": "2018-10-31T00:50:06", "upload_time_iso_8601": "2018-10-31T00:50:06.057941Z", "url": "https://files.pythonhosted.org/packages/bf/3c/d997e9c2f8458b597f60393768b2db53f89d4235f9df83f1f21e6c955a75/pymoso-1.0.2-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "7957bd4a3dd99aee30305c24c72fd5d9", "sha256": "d053b6350e12a119d4592a72d73edf37e42d6ef30979444003a9c35291faf44e"}, "downloads": -1, "filename": "pymoso-1.0.2.tar.gz", "has_sig": false, "md5_digest": "7957bd4a3dd99aee30305c24c72fd5d9", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6.0", "size": 69507, "upload_time": "2018-10-31T00:50:09", "upload_time_iso_8601": "2018-10-31T00:50:09.139850Z", "url": "https://files.pythonhosted.org/packages/e1/b4/20ac8b8437e69f5484d8c6eff489103a08cf74693ceb5bdb04dc5217f69f/pymoso-1.0.2.tar.gz", "yanked": false}], "1.0.3": [{"comment_text": "", "digests": {"md5": "df1ce65d3522104d56b1df5b142c7fda", "sha256": "7e05a6711f5db7c13ef5a9a13c70bc35a965532b87b454f107d7da85462ba08e"}, "downloads": -1, "filename": "pymoso-1.0.3-py3.6.egg", "has_sig": false, "md5_digest": "df1ce65d3522104d56b1df5b142c7fda", "packagetype": "bdist_egg", "python_version": "3.6", "requires_python": ">=3.6.0", "size": 125065, "upload_time": "2019-02-12T22:27:49", "upload_time_iso_8601": "2019-02-12T22:27:49.797338Z", "url": "https://files.pythonhosted.org/packages/bd/fc/be29177440b3c19c885a81378c21832629769acf2f978e86e1ca159710e4/pymoso-1.0.3-py3.6.egg", "yanked": false}, {"comment_text": "", "digests": {"md5": "bd0dcfd8219d1de66b9901598e02f100", "sha256": "e0f6864838fee4de062bd190380ba065e62ddc94fb7a5dfe8401acc3a119b363"}, "downloads": -1, "filename": "pymoso-1.0.3-py3-none-any.whl", "has_sig": false, "md5_digest": "bd0dcfd8219d1de66b9901598e02f100", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6.0", "size": 51231, "upload_time": "2019-02-12T22:27:47", "upload_time_iso_8601": "2019-02-12T22:27:47.239253Z", "url": "https://files.pythonhosted.org/packages/00/57/bd58df7187a1f6e6a5100b2bec1bafde1fa702fc712f5a51044692223a6c/pymoso-1.0.3-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "5ef98396b8963faf25c1cdf0cc28a7c1", "sha256": "a4febd7ff078896216290f6c5abf6a7fca9965b6582890dbb5baa61560a07fba"}, "downloads": -1, "filename": "pymoso-1.0.3.tar.gz", "has_sig": false, "md5_digest": "5ef98396b8963faf25c1cdf0cc28a7c1", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6.0", "size": 69980, "upload_time": "2019-02-12T22:27:51", "upload_time_iso_8601": "2019-02-12T22:27:51.810780Z", "url": "https://files.pythonhosted.org/packages/1f/9d/981474ec7def76a7975ea37713ffcdfb781c4abccff94faf768b37acc655/pymoso-1.0.3.tar.gz", "yanked": false}], "1.0.4": [{"comment_text": "", "digests": {"md5": "46aebee153d70f809677fb6c1cb5013c", "sha256": "161e2be687f28cd26fa0ab4eaaffa19d1a6f8b23dd6924eebd3d5376e4b2f6ff"}, "downloads": -1, "filename": "pymoso-1.0.4-py3.6.egg", "has_sig": false, "md5_digest": "46aebee153d70f809677fb6c1cb5013c", "packagetype": "bdist_egg", "python_version": "3.6", "requires_python": ">=3.6.0", "size": 125377, "upload_time": "2019-02-14T03:01:02", "upload_time_iso_8601": "2019-02-14T03:01:02.036893Z", "url": "https://files.pythonhosted.org/packages/f4/15/d8c62c6a5a82f0446cb6dc20a73822ba1497c0411c67e4e0f8b9e5c85107/pymoso-1.0.4-py3.6.egg", "yanked": false}, {"comment_text": "", "digests": {"md5": "4fbf5ac43bc0782fba346cc4a00f4662", "sha256": "a82d4eef91b793cb377b29bcf7f98715e239b930f9da48f594d6ad2873067e6d"}, "downloads": -1, "filename": "pymoso-1.0.4-py3-none-any.whl", "has_sig": false, "md5_digest": "4fbf5ac43bc0782fba346cc4a00f4662", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6.0", "size": 51411, "upload_time": "2019-02-14T03:00:59", "upload_time_iso_8601": "2019-02-14T03:00:59.269553Z", "url": "https://files.pythonhosted.org/packages/4e/05/2c29c53fdb77b5bbf37c63c4bfe3490db61b7047ebe0265cb090e9476498/pymoso-1.0.4-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "c097ea0ef7e71f9bd590764671068d97", "sha256": "b38ef95b27a37eacf278a40c23d8e9f5d3eb03bb58a0a9c2bf9dcc61d74761af"}, "downloads": -1, "filename": "pymoso-1.0.4.tar.gz", "has_sig": false, "md5_digest": "c097ea0ef7e71f9bd590764671068d97", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6.0", "size": 70154, "upload_time": "2019-02-14T03:01:05", "upload_time_iso_8601": "2019-02-14T03:01:05.383351Z", "url": "https://files.pythonhosted.org/packages/95/52/731e709576f8dd162e46c678539fb11ac9f3938b268ad4dff9d34238f733/pymoso-1.0.4.tar.gz", "yanked": false}], "1.0.5": [{"comment_text": "", "digests": {"md5": "1782428683b914e0761fd4044a949d4c", "sha256": "dacceee5b17fade8e095255d2f2471701d6079c653d191bd1f986364485d2348"}, "downloads": -1, "filename": "pymoso-1.0.5-py3-none-any.whl", "has_sig": false, "md5_digest": "1782428683b914e0761fd4044a949d4c", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6.0", "size": 61482, "upload_time": "2019-03-26T21:25:42", "upload_time_iso_8601": "2019-03-26T21:25:42.111891Z", "url": "https://files.pythonhosted.org/packages/37/60/e889799b2f6ef7f7fe18cea754a5feb2fe4f3afd5c987ea4376b3975bc51/pymoso-1.0.5-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "602779988e8513e9e63d1015a2c49516", "sha256": "79fa7e9bbecb5e21498ffb75dbe330e6187cd01567eab0da94416feef1d7095e"}, "downloads": -1, "filename": "pymoso-1.0.5.tar.gz", "has_sig": false, "md5_digest": "602779988e8513e9e63d1015a2c49516", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6.0", "size": 77009, "upload_time": "2019-03-26T21:25:44", "upload_time_iso_8601": "2019-03-26T21:25:44.041659Z", "url": "https://files.pythonhosted.org/packages/63/cd/b2c7afa02f0417d78649ce869079de577d92d1a11b35bd2c165ddd9cc510/pymoso-1.0.5.tar.gz", "yanked": false}], "1.0.6": [{"comment_text": "", "digests": {"md5": "e74bc297b5b68a86ac24357b5996bac6", "sha256": "c5b36fe5e1b1e5583d3e41e14d1686bbae8600592d73fe024018b60fdf9c0b57"}, "downloads": -1, "filename": "pymoso-1.0.6-py3-none-any.whl", "has_sig": false, "md5_digest": "e74bc297b5b68a86ac24357b5996bac6", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6.0", "size": 61330, "upload_time": "2019-03-27T22:35:38", "upload_time_iso_8601": "2019-03-27T22:35:38.836568Z", "url": "https://files.pythonhosted.org/packages/75/13/a1504788a69131f60f0323a6c9220ea6ff41c15854d8bd92f91d6f99aa85/pymoso-1.0.6-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "d407932bfec9e030b7c1bf86e945a561", "sha256": "933ab23eac542938c783e131393df052150d11e41e78f009d462eb8b001afadc"}, "downloads": -1, "filename": "pymoso-1.0.6.tar.gz", "has_sig": false, "md5_digest": "d407932bfec9e030b7c1bf86e945a561", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6.0", "size": 76821, "upload_time": "2019-03-27T22:35:41", "upload_time_iso_8601": "2019-03-27T22:35:41.102466Z", "url": "https://files.pythonhosted.org/packages/15/d2/96f220b260fdbb43c1d23715b26a5724e154f043ca42767f2cd79ca194eb/pymoso-1.0.6.tar.gz", "yanked": false}], "1.0.7": [{"comment_text": "", "digests": {"md5": "e36576599153c7c751d38d192fa0f7ce", "sha256": "2fbcdb2e29323849aac732a1bb29b195183108c5d3f5bd188465cfae544922a2"}, "downloads": -1, "filename": "pymoso-1.0.7-py3-none-any.whl", "has_sig": false, "md5_digest": "e36576599153c7c751d38d192fa0f7ce", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6.0", "size": 61194, "upload_time": "2019-09-12T20:32:20", "upload_time_iso_8601": "2019-09-12T20:32:20.043106Z", "url": "https://files.pythonhosted.org/packages/3e/02/f3920f394dec8da3692e15a21ed33f8d9751328508ddff390a31d854978a/pymoso-1.0.7-py3-none-any.whl", "yanked": false}], "1.0.8": [{"comment_text": "", "digests": {"md5": "619b8e2677f73b440dafffb3386cc014", "sha256": "d70b3f19f546297f6255a186319ec9cc864decc4015fb31de8f44672f44d39ea"}, "downloads": -1, "filename": "pymoso-1.0.8-py3.6.egg", "has_sig": false, "md5_digest": "619b8e2677f73b440dafffb3386cc014", "packagetype": "bdist_egg", "python_version": "3.6", "requires_python": ">=3.6.0", "size": 147378, "upload_time": "2019-11-22T00:42:33", "upload_time_iso_8601": "2019-11-22T00:42:33.489979Z", "url": "https://files.pythonhosted.org/packages/a1/46/5346f89cf6f874a9a1fc3484f74c3d16cc0bea0985c451cf2f6dcf8726d1/pymoso-1.0.8-py3.6.egg", "yanked": false}, {"comment_text": "", "digests": {"md5": "f7fe4f08dc84745c1d7fe2c90a842bf9", "sha256": "3b276c417b6dac8780051584f4ab5f4ee8757b2ae4561de5749e9aed83038abd"}, "downloads": -1, "filename": "pymoso-1.0.8-py3-none-any.whl", "has_sig": false, "md5_digest": "f7fe4f08dc84745c1d7fe2c90a842bf9", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6.0", "size": 61234, "upload_time": "2019-11-22T00:42:31", "upload_time_iso_8601": "2019-11-22T00:42:31.407262Z", "url": "https://files.pythonhosted.org/packages/41/dd/f216e6ba71049ea88adc9117fedf541253621cde0d67e16bc8b13995ce66/pymoso-1.0.8-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "58b5931df6555ceeec24e332520767a0", "sha256": "e034dbbe8ccf54707273642368e01d27de437ac2b41269ae010f6b191a17e634"}, "downloads": -1, "filename": "pymoso-1.0.8.tar.gz", "has_sig": false, "md5_digest": "58b5931df6555ceeec24e332520767a0", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6.0", "size": 76855, "upload_time": "2019-11-22T00:42:35", "upload_time_iso_8601": "2019-11-22T00:42:35.706275Z", "url": "https://files.pythonhosted.org/packages/70/c3/44442727ceed112b7cc728e8e74a058fd582169fa3309076dfcbb827ae96/pymoso-1.0.8.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "619b8e2677f73b440dafffb3386cc014", "sha256": "d70b3f19f546297f6255a186319ec9cc864decc4015fb31de8f44672f44d39ea"}, "downloads": -1, "filename": "pymoso-1.0.8-py3.6.egg", "has_sig": false, "md5_digest": "619b8e2677f73b440dafffb3386cc014", "packagetype": "bdist_egg", "python_version": "3.6", "requires_python": ">=3.6.0", "size": 147378, "upload_time": "2019-11-22T00:42:33", "upload_time_iso_8601": "2019-11-22T00:42:33.489979Z", "url": "https://files.pythonhosted.org/packages/a1/46/5346f89cf6f874a9a1fc3484f74c3d16cc0bea0985c451cf2f6dcf8726d1/pymoso-1.0.8-py3.6.egg", "yanked": false}, {"comment_text": "", "digests": {"md5": "f7fe4f08dc84745c1d7fe2c90a842bf9", "sha256": "3b276c417b6dac8780051584f4ab5f4ee8757b2ae4561de5749e9aed83038abd"}, "downloads": -1, "filename": "pymoso-1.0.8-py3-none-any.whl", "has_sig": false, "md5_digest": "f7fe4f08dc84745c1d7fe2c90a842bf9", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6.0", "size": 61234, "upload_time": "2019-11-22T00:42:31", "upload_time_iso_8601": "2019-11-22T00:42:31.407262Z", "url": "https://files.pythonhosted.org/packages/41/dd/f216e6ba71049ea88adc9117fedf541253621cde0d67e16bc8b13995ce66/pymoso-1.0.8-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "58b5931df6555ceeec24e332520767a0", "sha256": "e034dbbe8ccf54707273642368e01d27de437ac2b41269ae010f6b191a17e634"}, "downloads": -1, "filename": "pymoso-1.0.8.tar.gz", "has_sig": false, "md5_digest": "58b5931df6555ceeec24e332520767a0", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6.0", "size": 76855, "upload_time": "2019-11-22T00:42:35", "upload_time_iso_8601": "2019-11-22T00:42:35.706275Z", "url": "https://files.pythonhosted.org/packages/70/c3/44442727ceed112b7cc728e8e74a058fd582169fa3309076dfcbb827ae96/pymoso-1.0.8.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:01:42 2020"}