{"info": {"author": "Pavel Panchekha", "author_email": "pavpanchekha@gmail.com", "bugtrack_url": null, "classifiers": ["Development Status :: 4 - Beta", "Intended Audience :: Developers", "License :: OSI Approved :: GNU General Public License (GPL)", "Programming Language :: Python :: 2.6", "Topic :: Software Development :: Libraries :: Python Modules"], "description": "CLIArgs: Absolutely Trivial Command-line Arguments\n==================================================\n\nDoesn't parsing command line arguments suck? At best, you use ``optparse``, and\nthen if that doesn't work you hand-code it. Or, you use ``getargs``, which\nrequires writing your own loops. Don't you wish for something a little bit...\nsmarter? CLIArgs makes argument parsing a piece of cake.\n\nBasics\n------\n\nDefine a few functions, change your ``if __name__ == \"__main__\"`` block, and\nCLIArgs does the rest::\n\n    import cliargs\n    \n    __help__ = \"clone source [destinations] [-v]\"\n    __version__ = \"1.0\"\n\n    def __main__(source, *dest, verbose=False):\n        ...\n\n    if __name__ == \"__main__\":\n        cliargs.main()\n\nIf you run this file (``clone``), the following command lines will all do the\nobvious::\n\n    clone a b c d e\n    clone --source=a b c d e\n    clone a b -v\n    clone --help\n    clone -?\n    clone --version\n\nIn general, all arguments to the function ``__main__`` are examined, based on\nwhich the command line will be intelligently parsed. If necessary, the help and\nversion info will be displayed. Finally, most errors in parsing command-lines\nare caught and a summary prepared for the user.\n\nArgument types\n--------------\n\nThe basic algorithm will examine the arguments of the function (that is, of\n``__main__``) and assign, for each arguments, a short and long argument, and\na type. The long argument is always the name of argument; the short argument\nis, in order, the short name is the first letter of this short argument, or\n(if that is unavailable) the swapcase'd version of that letter, or one of a\nbuilt-in list of exceptions. These are assigned left-to-right.\n\nThe type of any argument is by default assumed to be a string. However, if\nthe argument is given a default value (as is ``verbose`` in the example above),\nthe type of the default argument is used. If the type is a string, the\ncommand-line argument is simply passed to the function. However, integers and\nfloats are converted into true integers and floats, booleans make their\ncorresponding arguments into flags (such as ``verbose`` above), lists\nare created by splitting a single comma-delimited argument (that means that\nthere cannot be spaces between the arguments; use ``--list=1,2,3,4`` or\nsimilar constructions) and dictionaries by splitting by commas, then\nequal signs (e.g. ``--dict=a=1,b=2,c=3``). Of course, list and dictionary\narguments are usually better handled by the ``*args`` and ``**kwargs``\nparameters.\n\nHelp & Version\n--------------\n\nThe help information is taken from a function called ``__help__``, a string named\n``__help__``, or the module documentation. If ``__help`` is a function, it is called,\nwith all of the arguments after the first ``-?`` (or ``-h`` or `--help``) passed as\narguments; thus, it it best that ``__help__`` take a variable number of arguments.\nOtherwise, ``__help__`` is assumed to be a string and is printed. ``__version__`` can\nlikewise be either a string or a function; as a function, it is called without arguments.\n\nUse Beyond Argument Parsing\n---------------------------\n\nSometimes, we want to parse arguments other than those in ``sys.argv``, such as for\na built-in shell. One can use CLIArgs to provide a similarly-shiny tool for this\npurpose as well. Simply use the function ``cliargs.run(function, arguments, help=None,\nversion=None)``.", "description_content_type": null, "docs_url": null, "download_url": "UNKNOWN", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "http://pypi.python.org/pypi/CLIArgs/", "keywords": null, "license": "LICENSE.txt", "maintainer": null, "maintainer_email": null, "name": "CLIArgs", "package_url": "https://pypi.org/project/CLIArgs/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/CLIArgs/", "project_urls": {"Download": "UNKNOWN", "Homepage": "http://pypi.python.org/pypi/CLIArgs/"}, "release_url": "https://pypi.org/project/CLIArgs/1.0/", "requires_dist": null, "requires_python": null, "summary": "Absolutely trivial command line arguments", "version": "1.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p>Doesn\u2019t parsing command line arguments suck? At best, you use <tt>optparse</tt>, and\nthen if that doesn\u2019t work you hand-code it. Or, you use <tt>getargs</tt>, which\nrequires writing your own loops. Don\u2019t you wish for something a little bit\u2026\nsmarter? CLIArgs makes argument parsing a piece of cake.</p>\n<div id=\"basics\">\n<h2>Basics</h2>\n<p>Define a few functions, change your <tt>if __name__ == \"__main__\"</tt> block, and\nCLIArgs does the rest:</p>\n<pre>import cliargs\n\n__help__ = \"clone source [destinations] [-v]\"\n__version__ = \"1.0\"\n\ndef __main__(source, *dest, verbose=False):\n    ...\n\nif __name__ == \"__main__\":\n    cliargs.main()\n</pre>\n<p>If you run this file (<tt>clone</tt>), the following command lines will all do the\nobvious:</p>\n<pre>clone a b c d e\nclone --source=a b c d e\nclone a b -v\nclone --help\nclone -?\nclone --version\n</pre>\n<p>In general, all arguments to the function <tt>__main__</tt> are examined, based on\nwhich the command line will be intelligently parsed. If necessary, the help and\nversion info will be displayed. Finally, most errors in parsing command-lines\nare caught and a summary prepared for the user.</p>\n</div>\n<div id=\"argument-types\">\n<h2>Argument types</h2>\n<p>The basic algorithm will examine the arguments of the function (that is, of\n<tt>__main__</tt>) and assign, for each arguments, a short and long argument, and\na type. The long argument is always the name of argument; the short argument\nis, in order, the short name is the first letter of this short argument, or\n(if that is unavailable) the swapcase\u2019d version of that letter, or one of a\nbuilt-in list of exceptions. These are assigned left-to-right.</p>\n<p>The type of any argument is by default assumed to be a string. However, if\nthe argument is given a default value (as is <tt>verbose</tt> in the example above),\nthe type of the default argument is used. If the type is a string, the\ncommand-line argument is simply passed to the function. However, integers and\nfloats are converted into true integers and floats, booleans make their\ncorresponding arguments into flags (such as <tt>verbose</tt> above), lists\nare created by splitting a single comma-delimited argument (that means that\nthere cannot be spaces between the arguments; use <tt><span class=\"pre\">--list=1,2,3,4</span></tt> or\nsimilar constructions) and dictionaries by splitting by commas, then\nequal signs (e.g. <tt><span class=\"pre\">--dict=a=1,b=2,c=3</span></tt>). Of course, list and dictionary\narguments are usually better handled by the <tt>*args</tt> and <tt>**kwargs</tt>\nparameters.</p>\n</div>\n<div id=\"help-version\">\n<h2>Help &amp; Version</h2>\n<p>The help information is taken from a function called <tt>__help__</tt>, a string named\n<tt>__help__</tt>, or the module documentation. If <tt>__help</tt> is a function, it is called,\nwith all of the arguments after the first <tt><span class=\"pre\">-?</span></tt> (or <tt><span class=\"pre\">-h</span></tt> or <cite>\u2013help`</cite>) passed as\narguments; thus, it it best that <tt>__help__</tt> take a variable number of arguments.\nOtherwise, <tt>__help__</tt> is assumed to be a string and is printed. <tt>__version__</tt> can\nlikewise be either a string or a function; as a function, it is called without arguments.</p>\n</div>\n<div id=\"use-beyond-argument-parsing\">\n<h2>Use Beyond Argument Parsing</h2>\n<p>Sometimes, we want to parse arguments other than those in <tt>sys.argv</tt>, such as for\na built-in shell. One can use CLIArgs to provide a similarly-shiny tool for this\npurpose as well. Simply use the function <tt>cliargs.run(function, arguments, help=None,\nversion=None)</tt>.</p>\n</div>\n\n          </div>"}, "last_serial": 746255, "releases": {"1.0": [{"comment_text": "", "digests": {"md5": "c0ba2f9c38b0f15502995936250f031d", "sha256": "63614e3503330b3d61bdf0a33a61fbe1d0d3ad445e420c1e93f7ab2e86392d1c"}, "downloads": -1, "filename": "CLIArgs-1.0.tar.gz", "has_sig": false, "md5_digest": "c0ba2f9c38b0f15502995936250f031d", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 17615, "upload_time": "2010-04-02T00:33:04", "upload_time_iso_8601": "2010-04-02T00:33:04.934945Z", "url": "https://files.pythonhosted.org/packages/c6/21/fc4919b94def1dc7de73d52a14005310379c912a9401947ed6b619479614/CLIArgs-1.0.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "c0ba2f9c38b0f15502995936250f031d", "sha256": "63614e3503330b3d61bdf0a33a61fbe1d0d3ad445e420c1e93f7ab2e86392d1c"}, "downloads": -1, "filename": "CLIArgs-1.0.tar.gz", "has_sig": false, "md5_digest": "c0ba2f9c38b0f15502995936250f031d", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 17615, "upload_time": "2010-04-02T00:33:04", "upload_time_iso_8601": "2010-04-02T00:33:04.934945Z", "url": "https://files.pythonhosted.org/packages/c6/21/fc4919b94def1dc7de73d52a14005310379c912a9401947ed6b619479614/CLIArgs-1.0.tar.gz", "yanked": false}], "timestamp": "Thu May  7 22:19:03 2020"}