{"info": {"author": "Tim Delaney", "author_email": "tcdelaney@optusnet.com.au", "bugtrack_url": null, "classifiers": ["Development Status :: 4 - Beta", "Intended Audience :: Developers", "License :: OSI Approved :: BSD License", "Operating System :: OS Independent", "Programming Language :: Python", "Topic :: Software Development"], "description": "Automatically determine the correct super object and use it.\n\nThis module defines a mix-in class `autosuper` which has a single property -\n`super`.\n\nThe object returned by `super` can either be called or have attributes accessed.\nIf it is called, a base class method with the same name as the current method\nwill be called with the parameters passed. If an attribute is accessed a base\nclass attribute will be returned.\n\nExample of usage::\n\n    import autosuper\n\n    class A (autosuper.autosuper):\n\n        def __init__ (self, a, b):\n            self.super()\n            print 'A.__init__'\n            print a, b\n\n        def test (self, a, b):\n            print 'A.test'\n            print b, a\n\n    class B (A):\n\n        def __init__ (self):\n            self.super(1, 2)\n            print 'B.__init__'\n            self.super.test(3, 4)\n\n        def test (self, a, b):\n            print 'B.test'\n            print a, b\n\n    B()\n\nproduces::\n\n    A.__init__\n    1 2\n    B.__init__\n    A.test\n    4 3\n\nWe didn't need to call `self.super()` in `A.__init__` because the base class\nis `object`, but we can do so.\n\nNote that `B.test` is never called - the call in `B.__init__` to`self.super.test`\nensures that only methods of classes higher in the MRO will be searched for `test`.\n\nNote also that it is an error to call `self.super.super` - a `TypeError` will\nbe raised.\n\n**Important:** It is assumed that the code objects for each method are unique.\nBreakage is likely if methods share code objects (e.g. the code object for one\nmethod is assigned to another method).\n\n**Note:** For performance reasons, this implementation modifies the bytecode of\nfunctions. To disable bytecode modification, set `__super_modify_bytecode__` to\n`False`.", "description_content_type": null, "docs_url": null, "download_url": "http://members.optusnet.com.au/tcdelaney/autosuper.zip", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "http://members.optusnet.com.au/tcdelaney/python.html#autosuper", "keywords": null, "license": "BSD-style", "maintainer": null, "maintainer_email": null, "name": "Improved-autosuper", "package_url": "https://pypi.org/project/Improved-autosuper/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/Improved-autosuper/", "project_urls": {"Download": "http://members.optusnet.com.au/tcdelaney/autosuper.zip", "Homepage": "http://members.optusnet.com.au/tcdelaney/python.html#autosuper"}, "release_url": "https://pypi.org/project/Improved-autosuper/0.9.6/", "requires_dist": null, "requires_python": null, "summary": "Use self.super(*p, **kw) instead of super(cls, self).func(*p, **kw)", "version": "0.9.6", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p>Automatically determine the correct super object and use it.</p>\n<p>This module defines a mix-in class <cite>autosuper</cite> which has a single property -\n<cite>super</cite>.</p>\n<p>The object returned by <cite>super</cite> can either be called or have attributes accessed.\nIf it is called, a base class method with the same name as the current method\nwill be called with the parameters passed. If an attribute is accessed a base\nclass attribute will be returned.</p>\n<p>Example of usage:</p>\n<pre>import autosuper\n\nclass A (autosuper.autosuper):\n\n    def __init__ (self, a, b):\n        self.super()\n        print 'A.__init__'\n        print a, b\n\n    def test (self, a, b):\n        print 'A.test'\n        print b, a\n\nclass B (A):\n\n    def __init__ (self):\n        self.super(1, 2)\n        print 'B.__init__'\n        self.super.test(3, 4)\n\n    def test (self, a, b):\n        print 'B.test'\n        print a, b\n\nB()\n</pre>\n<p>produces:</p>\n<pre>A.__init__\n1 2\nB.__init__\nA.test\n4 3\n</pre>\n<p>We didn\u2019t need to call <cite>self.super()</cite> in <cite>A.__init__</cite> because the base class\nis <cite>object</cite>, but we can do so.</p>\n<p>Note that <cite>B.test</cite> is never called - the call in <cite>B.__init__</cite> to`self.super.test`\nensures that only methods of classes higher in the MRO will be searched for <cite>test</cite>.</p>\n<p>Note also that it is an error to call <cite>self.super.super</cite> - a <cite>TypeError</cite> will\nbe raised.</p>\n<p><strong>Important:</strong> It is assumed that the code objects for each method are unique.\nBreakage is likely if methods share code objects (e.g. the code object for one\nmethod is assigned to another method).</p>\n<p><strong>Note:</strong> For performance reasons, this implementation modifies the bytecode of\nfunctions. To disable bytecode modification, set <cite>__super_modify_bytecode__</cite> to\n<cite>False</cite>.</p>\n\n          </div>"}, "last_serial": 710301, "releases": {"0.9.0": [], "0.9.1": [], "0.9.2": [], "0.9.3": [], "0.9.4": [], "0.9.5": [], "0.9.6": []}, "urls": [], "timestamp": "Fri May  8 00:56:29 2020"}