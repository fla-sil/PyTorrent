{"info": {"author": "QAM Team", "author_email": "qamteam@gmail.com", "bugtrack_url": null, "classifiers": ["Development Status :: 7 - Inactive"], "description": "=======================================\r\nQAM - A python RPC Framework using AMQP\r\n=======================================\r\n\r\n\r\nIntroduction\r\n------------\r\n \r\n``qam`` is a framework for remote-procedure-calls. It uses the `carrot`_ messaging framework. The RPC specific code is based on `Python XML-RPC`_.\r\n\r\n.. note:: ``qam`` is not actively maintened anymore by the qamteam. The successor of ``qam`` is ``callme`` <http://pypi.python.org/pypi/callme>. ``callme`` uses internally a more simpler approach as ``qam`` due to the improvements the AMQP standard has made since QAM was released. Therefore we made a complete re-design and wrote ``callme`` which has less overhead and is much faster than ``qam``.\r\n\r\n**Key Features:**\r\n\r\n  - uses AMQP as Transport Protocol\r\n  - supports synchronous and asynchrouns remote method calls\r\n  - supports timeouts in synchronous and asynchronous mode\r\n  - JSON marshaling for high interoperatbility (see `Serialization: JSON vs. Pickle`_ for details)\r\n  - Pickle marshaling for Object Transport Support\r\n  - Supports Remote Exception Transfer in JSON/Pickle/Synchronous/Asynchrounus mode\r\n  - Fully Threaded\r\n  - Easy to Use\r\n  - OpenSource BSD-licensed\r\n\r\nThe AMQP messaging system manages the remote-procedure-calls for a client and a server. The client sends a amqp message to the server, where the method is specified which should be called on server.\r\nAfter executing the function the result is packed into a amqp message and sent back to the client.\r\n\r\nThe aim of ``qam`` is to offer a simple RPC framework, which is reliable and secure.\r\n\r\nYou have to install a AMQP message broker. The most popular are:\r\n\r\n  - `RabbitMQ`_\r\n  - `ZeroMQ`_\r\n  - `Apache ActiveMQ`_\r\n  \r\nPersonally we have used RabbitMQ, it is easy to install and to configure.\r\n\r\nBefore you start using the ``qam`` framework you should know a little bit about AMQP. \r\nTherefor we advice you to read `Rabbits and warrens`_ a very good article which introduces the basic ideas of AMQP.\r\nFurther you can look at the `carrot`_ documentation. There you can get also good overview of AMQP.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n.. _`carrot`: http://ask.github.com/carrot/introduction.html\r\n.. _`Python XML-RPC`: http://docs.python.org/library/xmlrpclib.html\r\n.. _`Rabbits and warrens`: http://blogs.digitar.com/jjww/2009/01/rabbits-and-warrens/\r\n.. _`RabbitMQ`: http://www.rabbitmq.com/\r\n.. _`ZeroMQ`: http://www.zeromq.org/\r\n.. _`AMQP`: http://amqp.org\r\n.. _`Apache ActiveMQ`: http://activemq.apache.org/\r\n\r\nDocumentation\r\n-------------\r\n\r\nThe full Documentation including Reference can be found at `pypi documentation`_\r\n\r\n.. _`pypi documentation`: http://packages.python.org/qam/\r\n\r\n\r\nMailing list\r\n------------\r\nJoin the QAM Users mailing list: QAM-Users_\r\n\r\n.. _QAM-Users: http://groups.google.com/group/qam-users\r\n\r\nIf you are developing inside QAM join: QAM-Developers_\r\n\r\n.. _QAM-Developers: http://groups.google.com/group/qam-developers\r\n\r\nBug Tracker:\r\n------------\r\n\r\nIf you find any issues please report them on http://bitbucket.org/qamteam/qam/issues/\r\n\r\n\r\nGetting QAM\r\n-----------\r\n\r\nYou can get the python package on the `Python Package Index`_\r\n\r\n.. _`Python Package Index`: http://pypi.python.org/pypi/qam\r\n\r\nThe Mercurial Repository is available at `bitbucket.org qam`_\r\n\r\n.. _`bitbucket.org qam`: http://bitbucket.org/qamteam/qam/\r\n\r\nInstallation\r\n------------\r\n\r\n\r\n``qam`` can be installed via the Python Package Index of from source.\r\n\r\nUsing ``easy_install`` to install ``qam``::\r\n\r\n  $ easy_install qam\r\n\r\n\r\nIf you have downloaded a source tarball you can install it\r\nby doing the following::\r\n\r\n    $ python setup.py build\r\n    # python setup.py install # as root\r\n\r\n\r\nTutorial\r\n--------\r\n\r\n**Starting the QAMServer**\r\n\r\nFirst it is necessary, to tell the QAMServer which functions are available. Therefore you have to register the functions on the QAMServer.\r\nAfter registering the functions, the QAMServer waits for method-calls from the QAMProxy.\r\n\r\nHere is how you register a function on QAMServer and switch into the serving mode:\r\n\r\n   >>> from qam.qam_server import QAMServer\r\n   >>> qam_server = QAMServer(hostname=\"localhost\",\r\n   ...                    port=5672,\r\n   ...                    username='guest',\r\n   ...                    password='guest',\r\n   ...                    vhost='/',\r\n   ...                    server_id='qamserver')\r\n   ...\r\n   >>> def adder_function(x, y):    \r\n   ...    return x + y\r\n   ...\r\n   >>> qam_server.register_function(adder_function, 'add')\r\n   ...\r\n   ... # it is also possible to register the adder_function as follows:\r\n   ... # qam_server.register_function(adder_function)\r\n   ... # the method-name for registering in this case is adder_function.__name__\r\n   ...\r\n   >>> qam_server.serve()\r\n   \r\nIt is also possible to register whole classes on QAMServer. Therefore you only have to register the class instance on the QAMServer.\r\nIt's not necessary to register all functions of the class, it's enough when you register the class instance. \r\n\r\n*IMPORTANT:* When you register an instance you must specify a name as second argument in the ``register_class()`` method which selects the instance when calling it. \r\nIn the example below you would call the remote method  ``proxy.my_instance.adder_function(1,2)``\r\n\r\nHere is how you register a class instance on QAMServer and switch into the serving mode:\r\n\r\n   >>> from qam.qam_server import QAMServer\r\n   >>> qam_server = QAMServer(hostname=\"localhost\",\r\n   ...                    port=5672,\r\n   ...                    username='guest',\r\n   ...                    password='guest',\r\n   ...                    vhost='/',\r\n   ...                    server_id='qamserver')\r\n   ...\r\n   >>> class TestClass():\r\n   ...    def __init__(self):\r\n   ...        pass\r\n   ...    def adder_function(self,a,b):\r\n   ...        return a+b\r\n   ...\r\n   >>> instance = TestClass()\r\n   >>> qam_server.register_class(instance,'my_instance')\r\n   >>> qam_server.serve()\r\n   \r\n\r\n**Managing RPC with QAMProxy**\r\n\r\nThe QAMProxy sends the RPC-requests to the QAMServer and receives the result. It acts like a client which can call Server Methods and receive their\r\nresults.\r\n\r\nThere are two different ways to receive the result:\r\n\r\n  - *synchronous call*: the QAMProxy blocks until a result arrives\r\n  - *asynchronous call*: it is possible to register a callback-function which will be called when the result arrives. \r\n    In the meantime the QAMProxy can execute other functions or you can go in with your programm to execute.\r\n  \r\n*Synchronous RPC*\r\n  \r\nThis example shows you how to call a simple method registered on the QAMServer. You have to wait for the result, because no callback-function is registered. So it is a synchronous RPC.\r\n\r\n   >>> from qam.qam_proxy import QAMProxy, QAMMethodNotFoundException, QAMException\r\n   ... # create a new QAMProxy-instance\r\n   >>> qam_proxy = QAMProxy(hostname=\"localhost\",\r\n   ...                    port=5672,\r\n   ...                    username='guest',\r\n   ...                    password='guest',\r\n   ...                    vhost='/',\r\n   ...                    server_id='qamserver',\r\n   ...                    client_id='qamproxy')\r\n   ...\r\n   >>> result = qam_proxy.add(2,3) # call method on QAMServer and wait for a result\r\n   ... # close all open AMQP connections and cleanup\r\n   >>> qam_proxy.close()\r\n   \r\nIn case you have registered a class instance on the QAMServer and you want to call a method from this instance you can simple call this instance on QAMProxy. \r\nYou can call the instance with the name you specified with ``qam.qam_server.QAMServer.register_class(instance,name)``.\r\nIn this example it is a synchronous RPC again. You have to wait for the result.\r\n   \r\n   >>> from qam.qam_proxy import QAMProxy, QAMMethodNotFoundException, QAMException\r\n   >>> qam_proxy = QAMProxy(hostname=\"localhost\",\r\n   ...                    port=5672,\r\n   ...                    username='guest',\r\n   ...                    password='guest',\r\n   ...                    vhost='/',\r\n   ...                    server_id='qamserver',\r\n   ...                    client_id='qamproxy')\r\n   ...\r\n   >>> result = qam_proxy.my_instance.adder_function(2,4)\r\n   >>> qam_proxy.close()\r\n   \r\n*Asynchronous RPC*\r\n\r\nIf you don't want to wait for the result it is possible to register a callback-function.\r\nYou can do this by calling ``QAMProxy.callback(callback_function, error_function).method_to_call_on_server(params)``.\r\nThe callback-function takes two parameters as arguments. The first is the callback-function. \r\nThe second is optional and is only called if an error occourd on QAMServer.\r\n\r\n*SIDENOTE:* It is highly recomended that you alway set a error_function as well, as\r\nyou can never know if the remote method will succeed or will throw an exception or if an internal exception will happen. Especially in asynchronous\r\ncalls the only way you will be notified in case of an error WITHOUT an error_function is the qam logging.\r\n\r\nAfter receiving the result from QAMServer the callback-function or the error-function is executed, with the result as parameter.\r\nYou can monitor the state of the callback with ``qam.qam_proxy.get_callback_state(uid)``. Possible States are:\r\n\r\n  - 0: waiting on result\r\n  - 1: processing (result arrived and callback/error function is currently executing)\r\n  - 2: callback finished (callback/error function have finished executing)\r\n\r\nIn the following example you can see how to use callback-functions. In this example a simple method-call on the Server should be executed. \r\nNo class instance is registered on the QAMServer, only the adder_function is registered.\r\n\r\n   >>> from qam.qam_proxy import QAMProxy, QAMMethodNotFoundException, QAMException\r\n   >>> qam_proxy = QAMProxy(hostname=\"localhost\",\r\n   ...                    port=5672,\r\n   ...                    username='guest',\r\n   ...                    password='guest',\r\n   ...                    vhost='/',\r\n   ...                    server_id='qamserver',\r\n   ...                    client_id='qamproxy')\r\n   ...\r\n   ... # defining functions for callback\r\n   >>> def success(arg):\r\n   ...    print arg\r\n   >>> def error(arg):\r\n   ...    # if an error occours on QAMServer\r\n   ...    print arg \r\n   >>> uid = qam_proxy.callback(success, error).add(2,4)\r\n   >>> while True:\r\n   ...    state = qam_proxy.get_callback_state(uid)\r\n   ...    if state == 2 :\r\n   ...        # execution of callback finished\r\n   ...        break\r\n   ...\r\n   >>> qam_proxy.close()\r\n   \r\nThe function success and error are registered as callback and error function. If everything succeeds the success-function will be called. \r\nIf an error occoured on the QAMServer the error-function will be called.\r\nIf no error-function is defined and an error occourd a log-message is written into the logging system.\r\n\r\nIt is also possible to execute asynchronous class-instance-method calls on the QAMServer. In the following example you can see how you can manage that.\r\nYou can call the instance with the name you specified with ``qam.qam_server.QAMServer.register_class(instance,name)``.\r\n\r\n   >>> from qam.qam_proxy import QAMProxy, QAMMethodNotFoundException, QAMException\r\n   >>> qam_proxy = QAMProxy(hostname=\"localhost\",\r\n   ...                    port=5672,\r\n   ...                    username='guest',\r\n   ...                    password='guest',\r\n   ...                    vhost='/',\r\n   ...                    server_id='qamserver',\r\n   ...                    client_id='qamproxy')\r\n   ...\r\n   ... # defining functions for callback\r\n   >>> def success(arg):\r\n   ...    print arg\r\n   >>> def error(arg):\r\n   ...    # if an error occours on QAMServer\r\n   ...    print arg \r\n   >>> uid = qam_proxy.callback(success, error).my_instance.adder_function(2,4)\r\n   >>> while True:\r\n   ...    state = qam_proxy.get_callback_state(uid)\r\n   ...    if state == 2 :\r\n   ...        # execution of callback finished\r\n   ...        break\r\n   ...\r\n   >>> qam_proxy.close()\r\n\r\n\r\nTimeouts\r\n--------\r\n\r\nIt is also possible to set timeouts for remote functions. E.g. you might use timeouts if you don't want to wait longer than for example 10 seconds \r\nfor a function to return because after 10 seconds the result isn't important for you anymore.\r\n\r\nA simple client side synchronous code would look like this:\r\n\r\n   >>> from qam.qam_proxy import QAMProxy, QAMMethodNotFoundException, QAMException, QAMTimeoutException\r\n   ... # create a new QAMProxy-instance\r\n   >>> qam_proxy = QAMProxy(hostname=\"localhost\",\r\n   ...                    port=5672,\r\n   ...                    username='guest',\r\n   ...                    password='guest',\r\n   ...                    vhost='/',\r\n   ...                    server_id='qamserver',\r\n   ...                    client_id='qamproxy')\r\n   ...\r\n   >>> try:\r\n   >>>     result = qam_proxy.set_timeout(10).add(2,3) # call method on QAMServer and wait for a result\r\n   >>> except QAMTimeoutException: \r\n   >>>     print 'Remote function is too slow, timeout occoured.'\r\n   ...# close all open AMQP connections and cleanup\r\n   >>> qam_proxy.close()\r\n\r\nBut we also can set timeouts in asynchronous mode. The Callback/Error function will then only get called if it gets executed before the\r\ntimeout occours. If the timeout occours before the callback/error function gets executed, the error function gets called with a \r\n``qam.qam_proxy.QAMTimeoutException`` as argument. Let's have a look at some sample code, again we assume that after 10 seconds result is \r\nnot anymore important to us.\r\n\r\nA simple client side asynchronous code would look like this:\r\n\r\n   >>> from qam.qam_proxy import QAMProxy, QAMMethodNotFoundException, QAMException, QAMTimeoutException\r\n   >>> qam_proxy = QAMProxy(hostname=\"localhost\",\r\n   ...                    port=5672,\r\n   ...                    username='guest',\r\n   ...                    password='guest',\r\n   ...                    vhost='/',\r\n   ...                    server_id='qamserver',\r\n   ...                    client_id='qamproxy')\r\n   ...\r\n   ... # defining functions for callback\r\n   >>> def success(arg):\r\n   ...    print arg\r\n   >>> def error(arg):\r\n   ...    if isinstance(arg, QAMTimeoutException):\r\n   ...      #timeout occoured \r\n   ...      print 'Timeout occoured'\r\n   ...    else:\r\n   ...      print 'Other error happened' \r\n   >>> uid = qam_proxy.callback(success, error).set_timeout(10).add(2,4)\r\n   >>> while True:\r\n   ...    state = qam_proxy.get_callback_state(uid)\r\n   ...    if state == 2 :\r\n   ...        # execution of callback finished\r\n   ...        break\r\n   ...\r\n   >>> qam_proxy.close()\r\n\r\nInternally, if an timeout occours it doesn't matter if the actual function will return some day or if it will never return.\r\nIn case the remote function returns after the timeout exception has occoured the message will be correctly processed (so that everything stays\r\nclean in the AMQP Subsystem) but the result will be thrown away.\r\n\r\n\r\nSerialization: JSON vs. Pickle\r\n------------------------------\r\n\r\nWhen working with QAM all the remote methods and results will get serialized in the background for you that you don't have to bother about that.\r\nBut for flexibility you can choose between two serializer: JSON and Pickle. Both have their benefits and drawbacks. In most cases you will do fine\r\nwith the default Pickle serializer. But if you have special requirements you might choose the JSON serializer. \r\n\r\nIMPORTANT: Anyway which serializer you choose, you must specify the same serializer on the QAMServer and on the QAMProxy, otherwise\r\nthey can't communicate correctly.\r\n\r\n``SIDENOTE:`` The default serializer is *Pickle*.\r\n\r\nTo set the serializer on the proxy, here e.g. json:\r\n\r\n   >>> from qam.qam_proxy import QAMProxy\r\n   ... # create a new QAMProxy-instance\r\n   >>> qam_proxy = QAMProxy(hostname=\"localhost\",\r\n   ...                    port=5672,\r\n   ...                    username='guest',\r\n   ...                    password='guest',\r\n   ...                    vhost='/',\r\n   ...                    server_id='qamserver',\r\n   ...                    serializer='json')\r\n\r\n\r\nTo set the serializer on the server, again json:\r\n\r\n   >>> from qam.qam_server import QAMServer\r\n   >>> qam_server = QAMServer(hostname=\"localhost\",\r\n   ...                    port=5672,\r\n   ...                    username='guest',\r\n   ...                    password='guest',\r\n   ...                    vhost='/',\r\n   ...                    server_id='qamserver',\r\n   ...                    serializer='json')\r\n\r\n\r\nTo get an slight overview which serializer fits your need best here is a small comparison.\r\nThis comparision is specially trimmed for the use in QAM. In other environments there might be other things to be aware of.\r\n\r\n\r\n+----------------------------------------------+--------------------------------+------------------------------------------+        \r\n| Property                                     |                 Pickle         |         JSON                             |\r\n+==============================================+================================+==========================================+\r\n|Compression                                   |              good              |     no compression                       |\r\n+----------------------------------------------+--------------------------------+------------------------------------------+\r\n|Complex Object Transport                      |              yes               |     only json encodable                  |\r\n|                                              |                                |     objects are supported                |\r\n|                                              |                                |     (dict, list, scalar)                 |\r\n+----------------------------------------------+--------------------------------+------------------------------------------+\r\n|Support for Custom Exception Inheritance      |              yes               |      no, but you can use                 |\r\n|                                              |                                |      Exceptions as well. The             |\r\n|                                              |                                |      only drawback is that you           |\r\n|                                              |                                |      cannot create custom Exceptions     |\r\n|                                              |                                |      with inheritance                    |\r\n+----------------------------------------------+--------------------------------+------------------------------------------+                                                                           \r\n|Interoperability with other languages         |             worse              |      good, as our transport format       |\r\n|                                              |                                |      is quite easy to implement in       |\r\n|                                              |                                |      other languages with json support   |\r\n+----------------------------------------------+--------------------------------+------------------------------------------+\r\n|Needs Complex Type Definitions on             |    yes, because proxy and      |   no, because we can only transfer dict  |\r\n|both sides (Proxy and Server)                 |    the server need to know     |   list, and scalars we don't need to     |\r\n|                                              |    which type they will get.   |   define them seperately.                |\r\n|                                              |    You have to import your     |                                          |\r\n|                                              |    custom Argument Classes or  |                                          |\r\n|                                              |    custom Exceptions you want  |                                          |\r\n|                                              |    to raise on both proxy side |                                          |\r\n|                                              |    and server side.            |                                          |\r\n+----------------------------------------------+--------------------------------+------------------------------------------+                                                                                    \r\n\r\n\r\n\r\nArchitecture\r\n------------\r\n\r\n.. image:: _static/images/qam_arch.png\r\n.. image:: _static/images/qam_proxy_sync.png\r\n.. image:: _static/images/qam_proxy_async.png\r\n\r\nSupported by\r\n------------\r\nWingware - The Python IDE (http://wingware.com)\r\n\r\nContributing\r\n------------\r\n\r\nWe are welcome everyone who wants to contribute to QAM. Development of QAM happens at http://bitbucket.org/qamteam/qam/\r\n\r\nLicense\r\n-------\r\n\r\nQAM is released under the BSD License. The full license text is in the root folder of the QAM Package.", "description_content_type": null, "docs_url": "https://pythonhosted.org/qam/", "download_url": "UNKNOWN", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "http://packages.python.org/qam", "keywords": "rpc amqp", "license": "UNKNOWN", "maintainer": "", "maintainer_email": "", "name": "qam", "package_url": "https://pypi.org/project/qam/", "platform": "any", "project_url": "https://pypi.org/project/qam/", "project_urls": {"Download": "UNKNOWN", "Homepage": "http://packages.python.org/qam"}, "release_url": "https://pypi.org/project/qam/0.2.18/", "requires_dist": null, "requires_python": null, "summary": "QAM is a simple RPC Framework which uses the AMQP Protocol as Transport Protocol.", "version": "0.2.18", "yanked": false, "html_description": "<div class=\"project-description\">\n            <div id=\"introduction\">\n<h2>Introduction</h2>\n<p><tt>qam</tt> is a framework for remote-procedure-calls. It uses the <a href=\"http://ask.github.com/carrot/introduction.html\" rel=\"nofollow\">carrot</a> messaging framework. The RPC specific code is based on <a href=\"http://docs.python.org/library/xmlrpclib.html\" rel=\"nofollow\">Python XML-RPC</a>.</p>\n<div>\n<p>Note</p>\n<p><tt>qam</tt> is not actively maintened anymore by the qamteam. The successor of <tt>qam</tt> is <tt>callme</tt> &lt;<a href=\"http://pypi.python.org/pypi/callme\" rel=\"nofollow\">http://pypi.python.org/pypi/callme</a>&gt;. <tt>callme</tt> uses internally a more simpler approach as <tt>qam</tt> due to the improvements the AMQP standard has made since QAM was released. Therefore we made a complete re-design and wrote <tt>callme</tt> which has less overhead and is much faster than <tt>qam</tt>.</p>\n</div>\n<p><strong>Key Features:</strong></p>\n<blockquote>\n<ul>\n<li>uses AMQP as Transport Protocol</li>\n<li>supports synchronous and asynchrouns remote method calls</li>\n<li>supports timeouts in synchronous and asynchronous mode</li>\n<li>JSON marshaling for high interoperatbility (see <a href=\"#serialization-json-vs-pickle\" rel=\"nofollow\">Serialization: JSON vs. Pickle</a> for details)</li>\n<li>Pickle marshaling for Object Transport Support</li>\n<li>Supports Remote Exception Transfer in JSON/Pickle/Synchronous/Asynchrounus mode</li>\n<li>Fully Threaded</li>\n<li>Easy to Use</li>\n<li>OpenSource BSD-licensed</li>\n</ul>\n</blockquote>\n<p>The AMQP messaging system manages the remote-procedure-calls for a client and a server. The client sends a amqp message to the server, where the method is specified which should be called on server.\nAfter executing the function the result is packed into a amqp message and sent back to the client.</p>\n<p>The aim of <tt>qam</tt> is to offer a simple RPC framework, which is reliable and secure.</p>\n<p>You have to install a AMQP message broker. The most popular are:</p>\n<blockquote>\n<ul>\n<li><a href=\"http://www.rabbitmq.com/\" rel=\"nofollow\">RabbitMQ</a></li>\n<li><a href=\"http://www.zeromq.org/\" rel=\"nofollow\">ZeroMQ</a></li>\n<li><a href=\"http://activemq.apache.org/\" rel=\"nofollow\">Apache ActiveMQ</a></li>\n</ul>\n</blockquote>\n<p>Personally we have used RabbitMQ, it is easy to install and to configure.</p>\n<p>Before you start using the <tt>qam</tt> framework you should know a little bit about AMQP.\nTherefor we advice you to read <a href=\"http://blogs.digitar.com/jjww/2009/01/rabbits-and-warrens/\" rel=\"nofollow\">Rabbits and warrens</a> a very good article which introduces the basic ideas of AMQP.\nFurther you can look at the <a href=\"http://ask.github.com/carrot/introduction.html\" rel=\"nofollow\">carrot</a> documentation. There you can get also good overview of AMQP.</p>\n</div>\n<div id=\"documentation\">\n<h2>Documentation</h2>\n<p>The full Documentation including Reference can be found at <a href=\"http://packages.python.org/qam/\" rel=\"nofollow\">pypi documentation</a></p>\n</div>\n<div id=\"mailing-list\">\n<h2>Mailing list</h2>\n<p>Join the QAM Users mailing list: <a href=\"http://groups.google.com/group/qam-users\" rel=\"nofollow\">QAM-Users</a></p>\n<p>If you are developing inside QAM join: <a href=\"http://groups.google.com/group/qam-developers\" rel=\"nofollow\">QAM-Developers</a></p>\n</div>\n<div id=\"bug-tracker\">\n<h2>Bug Tracker:</h2>\n<p>If you find any issues please report them on <a href=\"http://bitbucket.org/qamteam/qam/issues/\" rel=\"nofollow\">http://bitbucket.org/qamteam/qam/issues/</a></p>\n</div>\n<div id=\"getting-qam\">\n<h2>Getting QAM</h2>\n<p>You can get the python package on the <a href=\"http://pypi.python.org/pypi/qam\" rel=\"nofollow\">Python Package Index</a></p>\n<p>The Mercurial Repository is available at <a href=\"http://bitbucket.org/qamteam/qam/\" rel=\"nofollow\">bitbucket.org qam</a></p>\n</div>\n<div id=\"installation\">\n<h2>Installation</h2>\n<p><tt>qam</tt> can be installed via the Python Package Index of from source.</p>\n<p>Using <tt>easy_install</tt> to install <tt>qam</tt>:</p>\n<pre>$ easy_install qam\n</pre>\n<p>If you have downloaded a source tarball you can install it\nby doing the following:</p>\n<pre>$ python setup.py build\n# python setup.py install # as root\n</pre>\n</div>\n<div id=\"tutorial\">\n<h2>Tutorial</h2>\n<p><strong>Starting the QAMServer</strong></p>\n<p>First it is necessary, to tell the QAMServer which functions are available. Therefore you have to register the functions on the QAMServer.\nAfter registering the functions, the QAMServer waits for method-calls from the QAMProxy.</p>\n<p>Here is how you register a function on QAMServer and switch into the serving mode:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from qam.qam_server import QAMServer\n&gt;&gt;&gt; qam_server = QAMServer(hostname=\"localhost\",\n...                    port=5672,\n...                    username='guest',\n...                    password='guest',\n...                    vhost='/',\n...                    server_id='qamserver')\n...\n&gt;&gt;&gt; def adder_function(x, y):\n...    return x + y\n...\n&gt;&gt;&gt; qam_server.register_function(adder_function, 'add')\n...\n... # it is also possible to register the adder_function as follows:\n... # qam_server.register_function(adder_function)\n... # the method-name for registering in this case is adder_function.__name__\n...\n&gt;&gt;&gt; qam_server.serve()\n</pre>\n</blockquote>\n<p>It is also possible to register whole classes on QAMServer. Therefore you only have to register the class instance on the QAMServer.\nIt\u2019s not necessary to register all functions of the class, it\u2019s enough when you register the class instance.</p>\n<p><em>IMPORTANT:</em> When you register an instance you must specify a name as second argument in the <tt>register_class()</tt> method which selects the instance when calling it.\nIn the example below you would call the remote method  <tt>proxy.my_instance.adder_function(1,2)</tt></p>\n<p>Here is how you register a class instance on QAMServer and switch into the serving mode:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from qam.qam_server import QAMServer\n&gt;&gt;&gt; qam_server = QAMServer(hostname=\"localhost\",\n...                    port=5672,\n...                    username='guest',\n...                    password='guest',\n...                    vhost='/',\n...                    server_id='qamserver')\n...\n&gt;&gt;&gt; class TestClass():\n...    def __init__(self):\n...        pass\n...    def adder_function(self,a,b):\n...        return a+b\n...\n&gt;&gt;&gt; instance = TestClass()\n&gt;&gt;&gt; qam_server.register_class(instance,'my_instance')\n&gt;&gt;&gt; qam_server.serve()\n</pre>\n</blockquote>\n<p><strong>Managing RPC with QAMProxy</strong></p>\n<p>The QAMProxy sends the RPC-requests to the QAMServer and receives the result. It acts like a client which can call Server Methods and receive their\nresults.</p>\n<p>There are two different ways to receive the result:</p>\n<blockquote>\n<ul>\n<li><em>synchronous call</em>: the QAMProxy blocks until a result arrives</li>\n<li><em>asynchronous call</em>: it is possible to register a callback-function which will be called when the result arrives.\nIn the meantime the QAMProxy can execute other functions or you can go in with your programm to execute.</li>\n</ul>\n</blockquote>\n<p><em>Synchronous RPC</em></p>\n<p>This example shows you how to call a simple method registered on the QAMServer. You have to wait for the result, because no callback-function is registered. So it is a synchronous RPC.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from qam.qam_proxy import QAMProxy, QAMMethodNotFoundException, QAMException\n... # create a new QAMProxy-instance\n&gt;&gt;&gt; qam_proxy = QAMProxy(hostname=\"localhost\",\n...                    port=5672,\n...                    username='guest',\n...                    password='guest',\n...                    vhost='/',\n...                    server_id='qamserver',\n...                    client_id='qamproxy')\n...\n&gt;&gt;&gt; result = qam_proxy.add(2,3) # call method on QAMServer and wait for a result\n... # close all open AMQP connections and cleanup\n&gt;&gt;&gt; qam_proxy.close()\n</pre>\n</blockquote>\n<p>In case you have registered a class instance on the QAMServer and you want to call a method from this instance you can simple call this instance on QAMProxy.\nYou can call the instance with the name you specified with <tt>qam.qam_server.QAMServer.register_class(instance,name)</tt>.\nIn this example it is a synchronous RPC again. You have to wait for the result.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from qam.qam_proxy import QAMProxy, QAMMethodNotFoundException, QAMException\n&gt;&gt;&gt; qam_proxy = QAMProxy(hostname=\"localhost\",\n...                    port=5672,\n...                    username='guest',\n...                    password='guest',\n...                    vhost='/',\n...                    server_id='qamserver',\n...                    client_id='qamproxy')\n...\n&gt;&gt;&gt; result = qam_proxy.my_instance.adder_function(2,4)\n&gt;&gt;&gt; qam_proxy.close()\n</pre>\n</blockquote>\n<p><em>Asynchronous RPC</em></p>\n<p>If you don\u2019t want to wait for the result it is possible to register a callback-function.\nYou can do this by calling <tt>QAMProxy.callback(callback_function, <span class=\"pre\">error_function).method_to_call_on_server(params)</span></tt>.\nThe callback-function takes two parameters as arguments. The first is the callback-function.\nThe second is optional and is only called if an error occourd on QAMServer.</p>\n<p><em>SIDENOTE:</em> It is highly recomended that you alway set a error_function as well, as\nyou can never know if the remote method will succeed or will throw an exception or if an internal exception will happen. Especially in asynchronous\ncalls the only way you will be notified in case of an error WITHOUT an error_function is the qam logging.</p>\n<p>After receiving the result from QAMServer the callback-function or the error-function is executed, with the result as parameter.\nYou can monitor the state of the callback with <tt>qam.qam_proxy.get_callback_state(uid)</tt>. Possible States are:</p>\n<blockquote>\n<ul>\n<li>0: waiting on result</li>\n<li>1: processing (result arrived and callback/error function is currently executing)</li>\n<li>2: callback finished (callback/error function have finished executing)</li>\n</ul>\n</blockquote>\n<p>In the following example you can see how to use callback-functions. In this example a simple method-call on the Server should be executed.\nNo class instance is registered on the QAMServer, only the adder_function is registered.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from qam.qam_proxy import QAMProxy, QAMMethodNotFoundException, QAMException\n&gt;&gt;&gt; qam_proxy = QAMProxy(hostname=\"localhost\",\n...                    port=5672,\n...                    username='guest',\n...                    password='guest',\n...                    vhost='/',\n...                    server_id='qamserver',\n...                    client_id='qamproxy')\n...\n... # defining functions for callback\n&gt;&gt;&gt; def success(arg):\n...    print arg\n&gt;&gt;&gt; def error(arg):\n...    # if an error occours on QAMServer\n...    print arg\n&gt;&gt;&gt; uid = qam_proxy.callback(success, error).add(2,4)\n&gt;&gt;&gt; while True:\n...    state = qam_proxy.get_callback_state(uid)\n...    if state == 2 :\n...        # execution of callback finished\n...        break\n...\n&gt;&gt;&gt; qam_proxy.close()\n</pre>\n</blockquote>\n<p>The function success and error are registered as callback and error function. If everything succeeds the success-function will be called.\nIf an error occoured on the QAMServer the error-function will be called.\nIf no error-function is defined and an error occourd a log-message is written into the logging system.</p>\n<p>It is also possible to execute asynchronous class-instance-method calls on the QAMServer. In the following example you can see how you can manage that.\nYou can call the instance with the name you specified with <tt>qam.qam_server.QAMServer.register_class(instance,name)</tt>.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from qam.qam_proxy import QAMProxy, QAMMethodNotFoundException, QAMException\n&gt;&gt;&gt; qam_proxy = QAMProxy(hostname=\"localhost\",\n...                    port=5672,\n...                    username='guest',\n...                    password='guest',\n...                    vhost='/',\n...                    server_id='qamserver',\n...                    client_id='qamproxy')\n...\n... # defining functions for callback\n&gt;&gt;&gt; def success(arg):\n...    print arg\n&gt;&gt;&gt; def error(arg):\n...    # if an error occours on QAMServer\n...    print arg\n&gt;&gt;&gt; uid = qam_proxy.callback(success, error).my_instance.adder_function(2,4)\n&gt;&gt;&gt; while True:\n...    state = qam_proxy.get_callback_state(uid)\n...    if state == 2 :\n...        # execution of callback finished\n...        break\n...\n&gt;&gt;&gt; qam_proxy.close()\n</pre>\n</blockquote>\n</div>\n<div id=\"timeouts\">\n<h2>Timeouts</h2>\n<p>It is also possible to set timeouts for remote functions. E.g. you might use timeouts if you don\u2019t want to wait longer than for example 10 seconds\nfor a function to return because after 10 seconds the result isn\u2019t important for you anymore.</p>\n<p>A simple client side synchronous code would look like this:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from qam.qam_proxy import QAMProxy, QAMMethodNotFoundException, QAMException, QAMTimeoutException\n... # create a new QAMProxy-instance\n&gt;&gt;&gt; qam_proxy = QAMProxy(hostname=\"localhost\",\n...                    port=5672,\n...                    username='guest',\n...                    password='guest',\n...                    vhost='/',\n...                    server_id='qamserver',\n...                    client_id='qamproxy')\n...\n&gt;&gt;&gt; try:\n&gt;&gt;&gt;     result = qam_proxy.set_timeout(10).add(2,3) # call method on QAMServer and wait for a result\n&gt;&gt;&gt; except QAMTimeoutException:\n&gt;&gt;&gt;     print 'Remote function is too slow, timeout occoured.'\n...# close all open AMQP connections and cleanup\n&gt;&gt;&gt; qam_proxy.close()\n</pre>\n</blockquote>\n<p>But we also can set timeouts in asynchronous mode. The Callback/Error function will then only get called if it gets executed before the\ntimeout occours. If the timeout occours before the callback/error function gets executed, the error function gets called with a\n<tt>qam.qam_proxy.QAMTimeoutException</tt> as argument. Let\u2019s have a look at some sample code, again we assume that after 10 seconds result is\nnot anymore important to us.</p>\n<p>A simple client side asynchronous code would look like this:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from qam.qam_proxy import QAMProxy, QAMMethodNotFoundException, QAMException, QAMTimeoutException\n&gt;&gt;&gt; qam_proxy = QAMProxy(hostname=\"localhost\",\n...                    port=5672,\n...                    username='guest',\n...                    password='guest',\n...                    vhost='/',\n...                    server_id='qamserver',\n...                    client_id='qamproxy')\n...\n... # defining functions for callback\n&gt;&gt;&gt; def success(arg):\n...    print arg\n&gt;&gt;&gt; def error(arg):\n...    if isinstance(arg, QAMTimeoutException):\n...      #timeout occoured\n...      print 'Timeout occoured'\n...    else:\n...      print 'Other error happened'\n&gt;&gt;&gt; uid = qam_proxy.callback(success, error).set_timeout(10).add(2,4)\n&gt;&gt;&gt; while True:\n...    state = qam_proxy.get_callback_state(uid)\n...    if state == 2 :\n...        # execution of callback finished\n...        break\n...\n&gt;&gt;&gt; qam_proxy.close()\n</pre>\n</blockquote>\n<p>Internally, if an timeout occours it doesn\u2019t matter if the actual function will return some day or if it will never return.\nIn case the remote function returns after the timeout exception has occoured the message will be correctly processed (so that everything stays\nclean in the AMQP Subsystem) but the result will be thrown away.</p>\n</div>\n<div id=\"serialization-json-vs-pickle\">\n<h2>Serialization: JSON vs. Pickle</h2>\n<p>When working with QAM all the remote methods and results will get serialized in the background for you that you don\u2019t have to bother about that.\nBut for flexibility you can choose between two serializer: JSON and Pickle. Both have their benefits and drawbacks. In most cases you will do fine\nwith the default Pickle serializer. But if you have special requirements you might choose the JSON serializer.</p>\n<p>IMPORTANT: Anyway which serializer you choose, you must specify the same serializer on the QAMServer and on the QAMProxy, otherwise\nthey can\u2019t communicate correctly.</p>\n<p><tt>SIDENOTE:</tt> The default serializer is <em>Pickle</em>.</p>\n<p>To set the serializer on the proxy, here e.g. json:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from qam.qam_proxy import QAMProxy\n... # create a new QAMProxy-instance\n&gt;&gt;&gt; qam_proxy = QAMProxy(hostname=\"localhost\",\n...                    port=5672,\n...                    username='guest',\n...                    password='guest',\n...                    vhost='/',\n...                    server_id='qamserver',\n...                    serializer='json')\n</pre>\n</blockquote>\n<p>To set the serializer on the server, again json:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from qam.qam_server import QAMServer\n&gt;&gt;&gt; qam_server = QAMServer(hostname=\"localhost\",\n...                    port=5672,\n...                    username='guest',\n...                    password='guest',\n...                    vhost='/',\n...                    server_id='qamserver',\n...                    serializer='json')\n</pre>\n</blockquote>\n<p>To get an slight overview which serializer fits your need best here is a small comparison.\nThis comparision is specially trimmed for the use in QAM. In other environments there might be other things to be aware of.</p>\n<table>\n<colgroup>\n<col>\n<col>\n<col>\n</colgroup>\n<thead>\n<tr><th>Property</th>\n<th>Pickle</th>\n<th>JSON</th>\n</tr>\n</thead>\n<tbody>\n<tr><td>Compression</td>\n<td>good</td>\n<td>no compression</td>\n</tr>\n<tr><td>Complex Object Transport</td>\n<td>yes</td>\n<td>only json encodable\nobjects are supported\n(dict, list, scalar)</td>\n</tr>\n<tr><td>Support for Custom Exception Inheritance</td>\n<td>yes</td>\n<td>no, but you can use\nExceptions as well. The\nonly drawback is that you\ncannot create custom Exceptions\nwith inheritance</td>\n</tr>\n<tr><td>Interoperability with other languages</td>\n<td>worse</td>\n<td>good, as our transport format\nis quite easy to implement in\nother languages with json support</td>\n</tr>\n<tr><td>Needs Complex Type Definitions on\nboth sides (Proxy and Server)</td>\n<td>yes, because proxy and\nthe server need to know\nwhich type they will get.\nYou have to import your\ncustom Argument Classes or\ncustom Exceptions you want\nto raise on both proxy side\nand server side.</td>\n<td>no, because we can only transfer dict\nlist, and scalars we don\u2019t need to\ndefine them seperately.</td>\n</tr>\n</tbody>\n</table>\n</div>\n<div id=\"architecture\">\n<h2>Architecture</h2>\n<img alt=\"_static/images/qam_arch.png\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/d2149c5832aeab73895885a122f809ef50fed6eb/5f7374617469632f696d616765732f71616d5f617263682e706e67\">\n<img alt=\"_static/images/qam_proxy_sync.png\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/085151758d0dbe2cd6fc36c6b24386d782c5047e/5f7374617469632f696d616765732f71616d5f70726f78795f73796e632e706e67\">\n<img alt=\"_static/images/qam_proxy_async.png\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/a3ffa577c3fac1c1583d6993b56de917acad209b/5f7374617469632f696d616765732f71616d5f70726f78795f6173796e632e706e67\">\n</div>\n<div id=\"supported-by\">\n<h2>Supported by</h2>\n<p>Wingware - The Python IDE (<a href=\"http://wingware.com\" rel=\"nofollow\">http://wingware.com</a>)</p>\n</div>\n<div id=\"contributing\">\n<h2>Contributing</h2>\n<p>We are welcome everyone who wants to contribute to QAM. Development of QAM happens at <a href=\"http://bitbucket.org/qamteam/qam/\" rel=\"nofollow\">http://bitbucket.org/qamteam/qam/</a></p>\n</div>\n<div id=\"license\">\n<h2>License</h2>\n<p>QAM is released under the BSD License. The full license text is in the root folder of the QAM Package.</p>\n</div>\n\n          </div>"}, "last_serial": 798301, "releases": {"0.1.0": [{"comment_text": "", "digests": {"md5": "0b77b207da107c6c6f44dac995997b40", "sha256": "e639267df014ebf71264569e144e55412f2181d983d7193d61398a5269992a90"}, "downloads": -1, "filename": "qam-0.1.0.tar.gz", "has_sig": false, "md5_digest": "0b77b207da107c6c6f44dac995997b40", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 10198, "upload_time": "2009-08-21T23:19:55", "upload_time_iso_8601": "2009-08-21T23:19:55.214201Z", "url": "https://files.pythonhosted.org/packages/be/61/3dd060eb4945a8a3ea63e1b487490ad758b1b6ef2f6bfdd3556c73b89a40/qam-0.1.0.tar.gz", "yanked": false}], "0.1.1": [{"comment_text": "", "digests": {"md5": "435ea479feabdfd3e066373045400f51", "sha256": "2e1892956ab349f3f4e37bd7106603d45a058d324fbf90767e1fce5c9ce17f57"}, "downloads": -1, "filename": "qam-0.1.1.tar.gz", "has_sig": false, "md5_digest": "435ea479feabdfd3e066373045400f51", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 49883, "upload_time": "2009-08-21T23:50:00", "upload_time_iso_8601": "2009-08-21T23:50:00.360118Z", "url": "https://files.pythonhosted.org/packages/04/ef/c8abefba927eee1344b3fa3299d29db3c064bda00da6e057630e0de6ff6f/qam-0.1.1.tar.gz", "yanked": false}], "0.1.2": [{"comment_text": "", "digests": {"md5": "29672c3b6cee3a420c323c82ce5a34d3", "sha256": "3e2d1795787b15e6decbe459bb96d550a01d00c090adc63f614a5a3acf741c83"}, "downloads": -1, "filename": "qam-0.1.2.tar.gz", "has_sig": false, "md5_digest": "29672c3b6cee3a420c323c82ce5a34d3", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 49919, "upload_time": "2009-08-22T00:01:51", "upload_time_iso_8601": "2009-08-22T00:01:51.509247Z", "url": "https://files.pythonhosted.org/packages/77/4e/9b57e211b43bbd01110b4ed2954df99d042a81f23bae873f8566f3a9b007/qam-0.1.2.tar.gz", "yanked": false}], "0.1.3": [{"comment_text": "", "digests": {"md5": "14ddd7da4a563337aa5e445df11e5e59", "sha256": "f7b04b0c21cab31af8c9dc0c0f4864ba91d8a720fe7d387852e86f5facb2d0f7"}, "downloads": -1, "filename": "qam-0.1.3.tar.gz", "has_sig": false, "md5_digest": "14ddd7da4a563337aa5e445df11e5e59", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 15112, "upload_time": "2009-08-22T15:52:03", "upload_time_iso_8601": "2009-08-22T15:52:03.058726Z", "url": "https://files.pythonhosted.org/packages/0d/3e/5982591bf7eb968bd68dadf1dc164099c9717d99f65fc2cfead7aefea6ea/qam-0.1.3.tar.gz", "yanked": false}], "0.1.4": [{"comment_text": "", "digests": {"md5": "5f142004f77f552f23d6dddf3d1031b8", "sha256": "972beb1271561aabbc4eb4ded222349cebe96c2f843ee1f16a99eda08b9eb042"}, "downloads": -1, "filename": "qam-0.1.4.tar.gz", "has_sig": false, "md5_digest": "5f142004f77f552f23d6dddf3d1031b8", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 17085, "upload_time": "2009-08-22T15:56:20", "upload_time_iso_8601": "2009-08-22T15:56:20.186136Z", "url": "https://files.pythonhosted.org/packages/29/66/fc91bbb737bd3acb11a08c9dec53adbd6b929b3d2396a436b005dac25a3c/qam-0.1.4.tar.gz", "yanked": false}], "0.2.0": [{"comment_text": "", "digests": {"md5": "e475e4798cccee6f209b872d859af11e", "sha256": "b0bf712a4c48f380a2dbba6e78c4759727f700c94e1015e2fb5ccd287ce33fa0"}, "downloads": -1, "filename": "qam-0.2.0.tar.gz", "has_sig": false, "md5_digest": "e475e4798cccee6f209b872d859af11e", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 45646, "upload_time": "2009-08-24T01:02:10", "upload_time_iso_8601": "2009-08-24T01:02:10.047415Z", "url": "https://files.pythonhosted.org/packages/29/0a/630ec3a80b25c15e8acecdf3b7ec65c0a9bdfa8d4f1ab25a3c2fda70b31c/qam-0.2.0.tar.gz", "yanked": false}], "0.2.1": [{"comment_text": "", "digests": {"md5": "85b7e80eea2ce39d18d2a6a98148dffe", "sha256": "39def67f319eb6cf7258749b24086f80e025b30536b980ec13d09f2db01c5759"}, "downloads": -1, "filename": "qam-0.2.1.tar.gz", "has_sig": false, "md5_digest": "85b7e80eea2ce39d18d2a6a98148dffe", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 22922, "upload_time": "2009-08-29T05:56:32", "upload_time_iso_8601": "2009-08-29T05:56:32.722466Z", "url": "https://files.pythonhosted.org/packages/77/29/e88df26ac1bb340020b8bbbf9caad3e3017fdfcf8ed74514f8f5f6221fbe/qam-0.2.1.tar.gz", "yanked": false}], "0.2.10": [{"comment_text": "", "digests": {"md5": "b54e30a03cc5125e2142c02cf0706528", "sha256": "63946767bb1297e48609df0026e3a733a0d0a98a53d4b4202f3991c3842e6ad1"}, "downloads": -1, "filename": "qam-0.2.10.tar.gz", "has_sig": false, "md5_digest": "b54e30a03cc5125e2142c02cf0706528", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 104718, "upload_time": "2009-11-19T16:21:18", "upload_time_iso_8601": "2009-11-19T16:21:18.065121Z", "url": "https://files.pythonhosted.org/packages/fb/70/42d3e50db1719962cee8ccbda5b7c993be555262c61131a13ac28619bb38/qam-0.2.10.tar.gz", "yanked": false}], "0.2.11": [{"comment_text": "", "digests": {"md5": "0360f92f848a6faf5f4ee81b1202888a", "sha256": "ea3776dc9ff0548d601c41a84e060dcf7f1a5b3ad9e545f67affc7679841dcd8"}, "downloads": -1, "filename": "qam-0.2.11.tar.gz", "has_sig": false, "md5_digest": "0360f92f848a6faf5f4ee81b1202888a", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 93271, "upload_time": "2009-11-20T10:22:40", "upload_time_iso_8601": "2009-11-20T10:22:40.769251Z", "url": "https://files.pythonhosted.org/packages/31/09/7de8c860fbaf2a467dd19f613b5f9accd121035f847fa3b72f9f1e630659/qam-0.2.11.tar.gz", "yanked": false}], "0.2.12": [{"comment_text": "", "digests": {"md5": "f88c94966f250b6bc4fdc9cbdf697c12", "sha256": "88ee38249f89e88eecf8141d981da8d431dc9404915612a7ce5c2c3934f47351"}, "downloads": -1, "filename": "qam-0.2.12.tar.gz", "has_sig": false, "md5_digest": "f88c94966f250b6bc4fdc9cbdf697c12", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 96924, "upload_time": "2009-11-20T10:28:47", "upload_time_iso_8601": "2009-11-20T10:28:47.274179Z", "url": "https://files.pythonhosted.org/packages/eb/f4/781f5bc36841f4ee7a77c2e7a44403cd4cca7f4ae1fbc5a2a51db9be65c0/qam-0.2.12.tar.gz", "yanked": false}], "0.2.13": [{"comment_text": "", "digests": {"md5": "3f15248abe5ccc353cd0429ce90f5544", "sha256": "1c28031666bb1fe6acb313f49741f47a8c8d2b4783c6e0f8c74606f2676f83cc"}, "downloads": -1, "filename": "qam-0.2.13.tar.gz", "has_sig": false, "md5_digest": "3f15248abe5ccc353cd0429ce90f5544", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 101681, "upload_time": "2009-11-20T10:35:59", "upload_time_iso_8601": "2009-11-20T10:35:59.604436Z", "url": "https://files.pythonhosted.org/packages/7f/e7/a24cfb14256c739aeacf8a3d8ba4c02ba743ce20b890a2d13f10c2af2d49/qam-0.2.13.tar.gz", "yanked": false}], "0.2.14": [{"comment_text": "", "digests": {"md5": "09ae58b2bae85b608d7c67204a7cc721", "sha256": "6391d6b7773161d0297209eec7857580aebf7dcf7816eca1bbcfb6bb548992e7"}, "downloads": -1, "filename": "qam-0.2.14.tar.gz", "has_sig": false, "md5_digest": "09ae58b2bae85b608d7c67204a7cc721", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 101689, "upload_time": "2009-11-20T10:40:24", "upload_time_iso_8601": "2009-11-20T10:40:24.728720Z", "url": "https://files.pythonhosted.org/packages/f5/a1/dbdbff8417b63612fa870e3844e463ad5a4b908cf2ee914132edb3aa8448/qam-0.2.14.tar.gz", "yanked": false}], "0.2.15": [{"comment_text": "", "digests": {"md5": "5cd28eeb244bdb6df8b8f85e7d8bccb9", "sha256": "f82c7d26770b33dc75544bc19d9c1851b25787846b93c6c5aacad8b0456723b5"}, "downloads": -1, "filename": "qam-0.2.15.tar.gz", "has_sig": false, "md5_digest": "5cd28eeb244bdb6df8b8f85e7d8bccb9", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 101686, "upload_time": "2009-11-20T10:43:09", "upload_time_iso_8601": "2009-11-20T10:43:09.914212Z", "url": "https://files.pythonhosted.org/packages/73/74/e3a67d104165315013a13a9e6ebf873c19b0b1d35545a71c629e9023b3ba/qam-0.2.15.tar.gz", "yanked": false}], "0.2.16": [{"comment_text": "", "digests": {"md5": "cf5992f4cead649dcac34c9928e1b215", "sha256": "5dc2dfb6542ff336ea5d67bc47685b84ff14619f5e73e948caf924ab99886b23"}, "downloads": -1, "filename": "qam-0.2.16.tar.gz", "has_sig": false, "md5_digest": "cf5992f4cead649dcac34c9928e1b215", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 101685, "upload_time": "2009-11-20T10:46:34", "upload_time_iso_8601": "2009-11-20T10:46:34.296810Z", "url": "https://files.pythonhosted.org/packages/21/3e/1f3de799c247df9fa16a9ecd91830022b5e5d38ef1db12278a9731ace95f/qam-0.2.16.tar.gz", "yanked": false}], "0.2.17": [{"comment_text": "", "digests": {"md5": "8b663099898e65971fb7f8b22991ea65", "sha256": "2612ae2ef526d906dbab4fc235bbc17968ed592460a0e5285d912a4b109b66b5"}, "downloads": -1, "filename": "qam-0.2.17.tar.gz", "has_sig": false, "md5_digest": "8b663099898e65971fb7f8b22991ea65", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 101686, "upload_time": "2009-11-20T10:52:05", "upload_time_iso_8601": "2009-11-20T10:52:05.456256Z", "url": "https://files.pythonhosted.org/packages/65/25/5320f2c6c24ed2cf3295ba0ee9cfbb1444af663729ef310f6899fa53f797/qam-0.2.17.tar.gz", "yanked": false}], "0.2.18": [{"comment_text": "", "digests": {"md5": "91f6519cc7506a288a6111bb632058e8", "sha256": "29469e6b2b807cbd448bb0b0ee34ed0ff7d15dfc23288b51bc03c6632d8fc03f"}, "downloads": -1, "filename": "qam-0.2.18.tar.gz", "has_sig": false, "md5_digest": "91f6519cc7506a288a6111bb632058e8", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 101687, "upload_time": "2009-11-20T10:55:43", "upload_time_iso_8601": "2009-11-20T10:55:43.367672Z", "url": "https://files.pythonhosted.org/packages/9a/13/c5745ca3cd25aafa4be849467d3920490a0c0ad227061e630051724335a8/qam-0.2.18.tar.gz", "yanked": false}], "0.2.2": [{"comment_text": "", "digests": {"md5": "4324522c6f86435edfec003e036999b9", "sha256": "671873aab78a77fcf28efa648784fea06e32ebbd600c5451f691189700dda173"}, "downloads": -1, "filename": "qam-0.2.2.tar.gz", "has_sig": false, "md5_digest": "4324522c6f86435edfec003e036999b9", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 64350, "upload_time": "2009-09-16T19:45:03", "upload_time_iso_8601": "2009-09-16T19:45:03.822952Z", "url": "https://files.pythonhosted.org/packages/9a/ce/79b782d068a85a5e37e7e877eef937cde3e6d5f6becbed403a6dfcc17116/qam-0.2.2.tar.gz", "yanked": false}], "0.2.3": [{"comment_text": "", "digests": {"md5": "b509237cc6e073c7880be86e4c0f994c", "sha256": "fff4f477af53a3904289e75a7e7d0ecac35b7fd922b8026af398e92a36e683ba"}, "downloads": -1, "filename": "qam-0.2.3.tar.gz", "has_sig": false, "md5_digest": "b509237cc6e073c7880be86e4c0f994c", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 75298, "upload_time": "2009-09-16T20:21:15", "upload_time_iso_8601": "2009-09-16T20:21:15.701715Z", "url": "https://files.pythonhosted.org/packages/83/53/8d92eedfb84d10cf385ba96ec3ee9636d395762e321daf4dedb3096b860c/qam-0.2.3.tar.gz", "yanked": false}], "0.2.4": [{"comment_text": "", "digests": {"md5": "a38c5fcd3576a29301d3053902908e0f", "sha256": "f3a1b70a06d25006271fa870052c8b1893f24c578cb05db600cf33c804ead324"}, "downloads": -1, "filename": "qam-0.2.4.tar.gz", "has_sig": false, "md5_digest": "a38c5fcd3576a29301d3053902908e0f", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 78158, "upload_time": "2009-10-17T00:01:36", "upload_time_iso_8601": "2009-10-17T00:01:36.421325Z", "url": "https://files.pythonhosted.org/packages/06/05/70517f5172ea0d6c04a3ad199b6604cd51f82e9694093f7f09e282fdb0b5/qam-0.2.4.tar.gz", "yanked": false}], "0.2.5": [{"comment_text": "", "digests": {"md5": "f2dc0f96451fe07d9366cf53297076d2", "sha256": "bfdf3d6011911a847976eb9016eb77c72e158c8af25ce55715bc562142ac985d"}, "downloads": -1, "filename": "qam-0.2.5.tar.gz", "has_sig": false, "md5_digest": "f2dc0f96451fe07d9366cf53297076d2", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 56059, "upload_time": "2009-11-19T14:27:41", "upload_time_iso_8601": "2009-11-19T14:27:41.517172Z", "url": "https://files.pythonhosted.org/packages/73/34/4254a60aa1bf3d01d9177625cfbc87fb430020c604d4e5286d70398273c2/qam-0.2.5.tar.gz", "yanked": false}], "0.2.6": [{"comment_text": "", "digests": {"md5": "ba0bc151f93797157f1bfffc8ce36cfc", "sha256": "169ef5c9c3d5e04b347c8cff6bf407008ea23115a3b0c6708de11675b330fa06"}, "downloads": -1, "filename": "qam-0.2.6.tar.gz", "has_sig": false, "md5_digest": "ba0bc151f93797157f1bfffc8ce36cfc", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 70722, "upload_time": "2009-11-19T14:51:16", "upload_time_iso_8601": "2009-11-19T14:51:16.927428Z", "url": "https://files.pythonhosted.org/packages/db/9a/cff0f3a1e87474f45dd4fbdbb9dee62876fe17bc4505162a86d7bf3a47c7/qam-0.2.6.tar.gz", "yanked": false}], "0.2.7": [{"comment_text": "", "digests": {"md5": "281f850fd8b38878b88a2b9e41d6525d", "sha256": "bb5d4bc2430d2f56b9d82650b5a3e7d174ed409b8999a431543704e7fe11d686"}, "downloads": -1, "filename": "qam-0.2.7.tar.gz", "has_sig": false, "md5_digest": "281f850fd8b38878b88a2b9e41d6525d", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 84840, "upload_time": "2009-11-19T15:08:01", "upload_time_iso_8601": "2009-11-19T15:08:01.449768Z", "url": "https://files.pythonhosted.org/packages/03/07/fbf4c84c9ff2e1ada128a6604acf7712331e27cf26dca48abb82d70805d8/qam-0.2.7.tar.gz", "yanked": false}], "0.2.8": [{"comment_text": "", "digests": {"md5": "4c6ffd29d90f32851290a438c1cd4e0a", "sha256": "a4a8e23029cc7746931d7a30ee8f1dacf45326d821b3cbf9c49947ea7b900c89"}, "downloads": -1, "filename": "qam-0.2.8.tar.gz", "has_sig": false, "md5_digest": "4c6ffd29d90f32851290a438c1cd4e0a", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 97909, "upload_time": "2009-11-19T15:53:44", "upload_time_iso_8601": "2009-11-19T15:53:44.775168Z", "url": "https://files.pythonhosted.org/packages/3b/51/5b120ae9adc75aa3cd465c0f2270a11c28c984edf7b61d84a2ddf8afa8af/qam-0.2.8.tar.gz", "yanked": false}], "0.2.9": [{"comment_text": "", "digests": {"md5": "e8ef21ec9f63c1f2408d9a4ada76b550", "sha256": "c244d73d9829f2fe061f42da3fec992efd27527f942a7cf0422485bf382f002f"}, "downloads": -1, "filename": "qam-0.2.9.tar.gz", "has_sig": false, "md5_digest": "e8ef21ec9f63c1f2408d9a4ada76b550", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 101423, "upload_time": "2009-11-19T16:14:04", "upload_time_iso_8601": "2009-11-19T16:14:04.695766Z", "url": "https://files.pythonhosted.org/packages/32/10/cdae793496fb667db022740e313c23821d25b5d6785917962484cf2d0981/qam-0.2.9.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "91f6519cc7506a288a6111bb632058e8", "sha256": "29469e6b2b807cbd448bb0b0ee34ed0ff7d15dfc23288b51bc03c6632d8fc03f"}, "downloads": -1, "filename": "qam-0.2.18.tar.gz", "has_sig": false, "md5_digest": "91f6519cc7506a288a6111bb632058e8", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 101687, "upload_time": "2009-11-20T10:55:43", "upload_time_iso_8601": "2009-11-20T10:55:43.367672Z", "url": "https://files.pythonhosted.org/packages/9a/13/c5745ca3cd25aafa4be849467d3920490a0c0ad227061e630051724335a8/qam-0.2.18.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:10:18 2020"}