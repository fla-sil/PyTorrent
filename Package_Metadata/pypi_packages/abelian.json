{"info": {"author": "Tommy Odland", "author_email": "tommy.odland@student.uib.no", "bugtrack_url": null, "classifiers": [], "description": "=======\nabelian\n=======\n\n.. image:: https://readthedocs.org/projects/abelian/badge/?version=latest\n   :target: http://abelian.readthedocs.io/en/latest/?badge=latest\n   :alt: Documentation Status\n\n``abelian`` is a Python library for computations on elementary locally compact abelian groups (LCAs).\nThe elementary LCAs are the groups R, Z, T = R/Z, Z_n and direct sums of these.\nThe Fourier transformation is defined on these groups.\nWith ``abelian`` it is possible to sample, periodize and perform Fourier\nanalysis on elementary LCAs using homomorphisms between groups.\n\n.. image:: http://tommyodland.com/abelian/intro_figure_75.png\n\nClasses and methods\n^^^^^^^^^^^^^^^^^^^^^\n\nThe most important classes are listed below. The software contains many other functions and methods not listed.\n\n* The ``LCA`` class represents elementary LCAs, i.e. R, Z, T = R/Z, Z_n and direct sums of these groups.\n   * Fundamental methods: identity LCA, direct sums, equality, isomorphic, element projection, Pontryagin dual.\n\n* The ``HomLCA`` class represents homomorphisms between LCAs.\n   * Fundamental methods: identity morphism, zero morphism, equality, composition, evaluation, stacking, element-wise operations, kernel,    cokernel, image, coimage, dual (adjoint) morphism.\n\n* The ``LCAFunc`` class represents functions from LCAs to complex numbers.\n   * Fundamental methods: evaluation, composition, shift (translation), pullback, pushforward, point-wise operators (i.e. addition).\n\nExample\n^^^^^^^^^^^^^^^^^^^^^\n\n.. image:: http://tommyodland.com/abelian/fourier_hexa_33.png\n\nThe following example shows Fourier analysis on a hexagonal lattice.\n\nWe create a Gaussian on R^2 and a homomorphism for sampling.\n\n.. code:: python\n\n    from abelian import LCA, HomLCA, LCAFunc, voronoi\n    from math import exp, pi, sqrt\n    Z = LCA(orders = [0], discrete = [True])\n    R = LCA(orders = [0], discrete = [False])\n\n    # Create the Gaussian function on R^2\n    function = LCAFunc(lambda x: exp(-pi*sum(j**2 for j in x)), domain = R**2)\n\n    # Create an hexagonal sampling homomorphism (lattice on R^2)\n    phi = HomLCA([[1, 1/2], [0, sqrt(3)/2]], source = Z**2, target = R**2)\n    phi = phi * (1/7) # Downcale the hexagon\n    function_sampled = function.pullback(phi)\n\nNext we approximate the two-dimensional integral of the Gaussian.\n\n.. code:: python\n\n    # Approximate the two dimensional integral of the Gaussian\n    scaling_factor = phi.A.det()\n    integral_sum = 0\n    for element in phi.source.elements_by_maxnorm(list(range(20))):\n        integral_sum += function_sampled(element)\n    print(integral_sum * scaling_factor) # 0.999999997457763\n\n\nWe use the FFT to move approximate the Fourier transform of the Gaussian.\n\n.. code:: python\n\n    # Sample, periodize and take DFT of the Gaussian\n    phi_p = HomLCA([[10, 0], [0, 10]], source = Z**2, target = Z**2)\n    periodized = function_sampled.pushforward(phi_p.cokernel())\n    dual_func = periodized.dft()\n\n    # Interpret the output of the DFT on R^2\n    phi_periodize_ann = phi_p.annihilator()\n\n    # Compute a Voronoi transversal function, interpret on R^2\n    sigma = voronoi(phi.dual(), norm_p=2)\n    factor = phi_p.A.det() * scaling_factor\n    total_error = 0\n    for element in dual_func.domain.elements_by_maxnorm():\n        value = dual_func(element)\n        coords_on_R = sigma(phi_periodize_ann(element))\n\n        # The Gaussian is invariant under Fourier transformation, so we can\n        # compare the error using the analytical expression\n        true_val = function(coords_on_R)\n        approximated_val = abs(value)\n        total_error += abs(true_val - approximated_val*factor)\n\n    assert total_error < 10e-15\n\nPlease see `the documentation <http://abelian.readthedocs.io/en/latest/>`_ for more examples and information.\n\n", "description_content_type": null, "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/tommyod/abelian/", "keywords": "", "license": "", "maintainer": "", "maintainer_email": "", "name": "abelian", "package_url": "https://pypi.org/project/abelian/", "platform": "", "project_url": "https://pypi.org/project/abelian/", "project_urls": {"Homepage": "https://github.com/tommyod/abelian/"}, "release_url": "https://pypi.org/project/abelian/1.0.1/", "requires_dist": null, "requires_python": "", "summary": "Computations on abelian groups.", "version": "1.0.1", "yanked": false, "html_description": "<div class=\"project-description\">\n            <a href=\"http://abelian.readthedocs.io/en/latest/?badge=latest\" rel=\"nofollow\"><img alt=\"Documentation Status\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/d135e285caf0970a730adfce760ff8e73ad26c91/68747470733a2f2f72656164746865646f63732e6f72672f70726f6a656374732f6162656c69616e2f62616467652f3f76657273696f6e3d6c6174657374\"></a>\n<p><tt>abelian</tt> is a Python library for computations on elementary locally compact abelian groups (LCAs).\nThe elementary LCAs are the groups R, Z, T = R/Z, Z_n and direct sums of these.\nThe Fourier transformation is defined on these groups.\nWith <tt>abelian</tt> it is possible to sample, periodize and perform Fourier\nanalysis on elementary LCAs using homomorphisms between groups.</p>\n<img alt=\"http://tommyodland.com/abelian/intro_figure_75.png\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/a9985073d0730c131eea005e783929180357bffb/687474703a2f2f746f6d6d796f646c616e642e636f6d2f6162656c69616e2f696e74726f5f6669677572655f37352e706e67\">\n<div id=\"classes-and-methods\">\n<h2>Classes and methods</h2>\n<p>The most important classes are listed below. The software contains many other functions and methods not listed.</p>\n<ul>\n<li><dl>\n<dt>The <tt>LCA</tt> class represents elementary LCAs, i.e. R, Z, T = R/Z, Z_n and direct sums of these groups.</dt>\n<dd><ul>\n<li>Fundamental methods: identity LCA, direct sums, equality, isomorphic, element projection, Pontryagin dual.</li>\n</ul>\n</dd>\n</dl>\n</li>\n<li><dl>\n<dt>The <tt>HomLCA</tt> class represents homomorphisms between LCAs.</dt>\n<dd><ul>\n<li>Fundamental methods: identity morphism, zero morphism, equality, composition, evaluation, stacking, element-wise operations, kernel,    cokernel, image, coimage, dual (adjoint) morphism.</li>\n</ul>\n</dd>\n</dl>\n</li>\n<li><dl>\n<dt>The <tt>LCAFunc</tt> class represents functions from LCAs to complex numbers.</dt>\n<dd><ul>\n<li>Fundamental methods: evaluation, composition, shift (translation), pullback, pushforward, point-wise operators (i.e. addition).</li>\n</ul>\n</dd>\n</dl>\n</li>\n</ul>\n</div>\n<div id=\"example\">\n<h2>Example</h2>\n<img alt=\"http://tommyodland.com/abelian/fourier_hexa_33.png\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/1575186193a46c46280dd12e62027cb0572e77fb/687474703a2f2f746f6d6d796f646c616e642e636f6d2f6162656c69616e2f666f75726965725f686578615f33332e706e67\">\n<p>The following example shows Fourier analysis on a hexagonal lattice.</p>\n<p>We create a Gaussian on R^2 and a homomorphism for sampling.</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">abelian</span> <span class=\"kn\">import</span> <span class=\"n\">LCA</span><span class=\"p\">,</span> <span class=\"n\">HomLCA</span><span class=\"p\">,</span> <span class=\"n\">LCAFunc</span><span class=\"p\">,</span> <span class=\"n\">voronoi</span>\n<span class=\"kn\">from</span> <span class=\"nn\">math</span> <span class=\"kn\">import</span> <span class=\"n\">exp</span><span class=\"p\">,</span> <span class=\"n\">pi</span><span class=\"p\">,</span> <span class=\"n\">sqrt</span>\n<span class=\"n\">Z</span> <span class=\"o\">=</span> <span class=\"n\">LCA</span><span class=\"p\">(</span><span class=\"n\">orders</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">],</span> <span class=\"n\">discrete</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"kc\">True</span><span class=\"p\">])</span>\n<span class=\"n\">R</span> <span class=\"o\">=</span> <span class=\"n\">LCA</span><span class=\"p\">(</span><span class=\"n\">orders</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">],</span> <span class=\"n\">discrete</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"kc\">False</span><span class=\"p\">])</span>\n\n<span class=\"c1\"># Create the Gaussian function on R^2</span>\n<span class=\"n\">function</span> <span class=\"o\">=</span> <span class=\"n\">LCAFunc</span><span class=\"p\">(</span><span class=\"k\">lambda</span> <span class=\"n\">x</span><span class=\"p\">:</span> <span class=\"n\">exp</span><span class=\"p\">(</span><span class=\"o\">-</span><span class=\"n\">pi</span><span class=\"o\">*</span><span class=\"nb\">sum</span><span class=\"p\">(</span><span class=\"n\">j</span><span class=\"o\">**</span><span class=\"mi\">2</span> <span class=\"k\">for</span> <span class=\"n\">j</span> <span class=\"ow\">in</span> <span class=\"n\">x</span><span class=\"p\">)),</span> <span class=\"n\">domain</span> <span class=\"o\">=</span> <span class=\"n\">R</span><span class=\"o\">**</span><span class=\"mi\">2</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Create an hexagonal sampling homomorphism (lattice on R^2)</span>\n<span class=\"n\">phi</span> <span class=\"o\">=</span> <span class=\"n\">HomLCA</span><span class=\"p\">([[</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"o\">/</span><span class=\"mi\">2</span><span class=\"p\">],</span> <span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">sqrt</span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">)</span><span class=\"o\">/</span><span class=\"mi\">2</span><span class=\"p\">]],</span> <span class=\"n\">source</span> <span class=\"o\">=</span> <span class=\"n\">Z</span><span class=\"o\">**</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"n\">target</span> <span class=\"o\">=</span> <span class=\"n\">R</span><span class=\"o\">**</span><span class=\"mi\">2</span><span class=\"p\">)</span>\n<span class=\"n\">phi</span> <span class=\"o\">=</span> <span class=\"n\">phi</span> <span class=\"o\">*</span> <span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"o\">/</span><span class=\"mi\">7</span><span class=\"p\">)</span> <span class=\"c1\"># Downcale the hexagon</span>\n<span class=\"n\">function_sampled</span> <span class=\"o\">=</span> <span class=\"n\">function</span><span class=\"o\">.</span><span class=\"n\">pullback</span><span class=\"p\">(</span><span class=\"n\">phi</span><span class=\"p\">)</span>\n</pre>\n<p>Next we approximate the two-dimensional integral of the Gaussian.</p>\n<pre><span class=\"c1\"># Approximate the two dimensional integral of the Gaussian</span>\n<span class=\"n\">scaling_factor</span> <span class=\"o\">=</span> <span class=\"n\">phi</span><span class=\"o\">.</span><span class=\"n\">A</span><span class=\"o\">.</span><span class=\"n\">det</span><span class=\"p\">()</span>\n<span class=\"n\">integral_sum</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n<span class=\"k\">for</span> <span class=\"n\">element</span> <span class=\"ow\">in</span> <span class=\"n\">phi</span><span class=\"o\">.</span><span class=\"n\">source</span><span class=\"o\">.</span><span class=\"n\">elements_by_maxnorm</span><span class=\"p\">(</span><span class=\"nb\">list</span><span class=\"p\">(</span><span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"mi\">20</span><span class=\"p\">))):</span>\n    <span class=\"n\">integral_sum</span> <span class=\"o\">+=</span> <span class=\"n\">function_sampled</span><span class=\"p\">(</span><span class=\"n\">element</span><span class=\"p\">)</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">integral_sum</span> <span class=\"o\">*</span> <span class=\"n\">scaling_factor</span><span class=\"p\">)</span> <span class=\"c1\"># 0.999999997457763</span>\n</pre>\n<p>We use the FFT to move approximate the Fourier transform of the Gaussian.</p>\n<pre><span class=\"c1\"># Sample, periodize and take DFT of the Gaussian</span>\n<span class=\"n\">phi_p</span> <span class=\"o\">=</span> <span class=\"n\">HomLCA</span><span class=\"p\">([[</span><span class=\"mi\">10</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">],</span> <span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">10</span><span class=\"p\">]],</span> <span class=\"n\">source</span> <span class=\"o\">=</span> <span class=\"n\">Z</span><span class=\"o\">**</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"n\">target</span> <span class=\"o\">=</span> <span class=\"n\">Z</span><span class=\"o\">**</span><span class=\"mi\">2</span><span class=\"p\">)</span>\n<span class=\"n\">periodized</span> <span class=\"o\">=</span> <span class=\"n\">function_sampled</span><span class=\"o\">.</span><span class=\"n\">pushforward</span><span class=\"p\">(</span><span class=\"n\">phi_p</span><span class=\"o\">.</span><span class=\"n\">cokernel</span><span class=\"p\">())</span>\n<span class=\"n\">dual_func</span> <span class=\"o\">=</span> <span class=\"n\">periodized</span><span class=\"o\">.</span><span class=\"n\">dft</span><span class=\"p\">()</span>\n\n<span class=\"c1\"># Interpret the output of the DFT on R^2</span>\n<span class=\"n\">phi_periodize_ann</span> <span class=\"o\">=</span> <span class=\"n\">phi_p</span><span class=\"o\">.</span><span class=\"n\">annihilator</span><span class=\"p\">()</span>\n\n<span class=\"c1\"># Compute a Voronoi transversal function, interpret on R^2</span>\n<span class=\"n\">sigma</span> <span class=\"o\">=</span> <span class=\"n\">voronoi</span><span class=\"p\">(</span><span class=\"n\">phi</span><span class=\"o\">.</span><span class=\"n\">dual</span><span class=\"p\">(),</span> <span class=\"n\">norm_p</span><span class=\"o\">=</span><span class=\"mi\">2</span><span class=\"p\">)</span>\n<span class=\"n\">factor</span> <span class=\"o\">=</span> <span class=\"n\">phi_p</span><span class=\"o\">.</span><span class=\"n\">A</span><span class=\"o\">.</span><span class=\"n\">det</span><span class=\"p\">()</span> <span class=\"o\">*</span> <span class=\"n\">scaling_factor</span>\n<span class=\"n\">total_error</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n<span class=\"k\">for</span> <span class=\"n\">element</span> <span class=\"ow\">in</span> <span class=\"n\">dual_func</span><span class=\"o\">.</span><span class=\"n\">domain</span><span class=\"o\">.</span><span class=\"n\">elements_by_maxnorm</span><span class=\"p\">():</span>\n    <span class=\"n\">value</span> <span class=\"o\">=</span> <span class=\"n\">dual_func</span><span class=\"p\">(</span><span class=\"n\">element</span><span class=\"p\">)</span>\n    <span class=\"n\">coords_on_R</span> <span class=\"o\">=</span> <span class=\"n\">sigma</span><span class=\"p\">(</span><span class=\"n\">phi_periodize_ann</span><span class=\"p\">(</span><span class=\"n\">element</span><span class=\"p\">))</span>\n\n    <span class=\"c1\"># The Gaussian is invariant under Fourier transformation, so we can</span>\n    <span class=\"c1\"># compare the error using the analytical expression</span>\n    <span class=\"n\">true_val</span> <span class=\"o\">=</span> <span class=\"n\">function</span><span class=\"p\">(</span><span class=\"n\">coords_on_R</span><span class=\"p\">)</span>\n    <span class=\"n\">approximated_val</span> <span class=\"o\">=</span> <span class=\"nb\">abs</span><span class=\"p\">(</span><span class=\"n\">value</span><span class=\"p\">)</span>\n    <span class=\"n\">total_error</span> <span class=\"o\">+=</span> <span class=\"nb\">abs</span><span class=\"p\">(</span><span class=\"n\">true_val</span> <span class=\"o\">-</span> <span class=\"n\">approximated_val</span><span class=\"o\">*</span><span class=\"n\">factor</span><span class=\"p\">)</span>\n\n<span class=\"k\">assert</span> <span class=\"n\">total_error</span> <span class=\"o\">&lt;</span> <span class=\"mf\">10e-15</span>\n</pre>\n<p>Please see <a href=\"http://abelian.readthedocs.io/en/latest/\" rel=\"nofollow\">the documentation</a> for more examples and information.</p>\n</div>\n\n          </div>"}, "last_serial": 3335261, "releases": {"0.0.1": [{"comment_text": "", "digests": {"md5": "ec647a88da1900f1d0650b0ef9435f8b", "sha256": "4a50911acbf3258da511b7fd1cc421df82c2d29c40af8931acf65ba61e5a3a03"}, "downloads": -1, "filename": "abelian-0.0.1.tar.gz", "has_sig": false, "md5_digest": "ec647a88da1900f1d0650b0ef9435f8b", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 38797, "upload_time": "2017-08-13T15:56:57", "upload_time_iso_8601": "2017-08-13T15:56:57.762718Z", "url": "https://files.pythonhosted.org/packages/39/d6/5d8666269e802fc0c9aa976fe6f4190983972e7b6b8c9e68768b43888619/abelian-0.0.1.tar.gz", "yanked": false}], "0.0.2": [{"comment_text": "", "digests": {"md5": "f066d6d5af0333f138b540d96c2091b5", "sha256": "a17360d85bf42324680b83eea7a3fabbb93a78e487e2d8f5d25f4862f69abcbc"}, "downloads": -1, "filename": "abelian-0.0.2.tar.gz", "has_sig": false, "md5_digest": "f066d6d5af0333f138b540d96c2091b5", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 38937, "upload_time": "2017-08-13T16:16:58", "upload_time_iso_8601": "2017-08-13T16:16:58.010577Z", "url": "https://files.pythonhosted.org/packages/33/06/965ca138f46def323a131c26598a8880e83e422d38d3c0b53a7e9f1a9a25/abelian-0.0.2.tar.gz", "yanked": false}], "0.0.3": [{"comment_text": "", "digests": {"md5": "df315945725e59c500e30cc4a359460a", "sha256": "a2648fdeabee0143f0261bf71d701ecea94a76bd70f2fe0c721d5b9085a3fe0c"}, "downloads": -1, "filename": "abelian-0.0.3.tar.gz", "has_sig": false, "md5_digest": "df315945725e59c500e30cc4a359460a", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 39581, "upload_time": "2017-08-13T16:23:11", "upload_time_iso_8601": "2017-08-13T16:23:11.370759Z", "url": "https://files.pythonhosted.org/packages/a3/57/0a7f7cafad54292253edc68c3ce2e703b4285953d148c97fd0b1b5d752c8/abelian-0.0.3.tar.gz", "yanked": false}], "0.0.4": [{"comment_text": "", "digests": {"md5": "b98c0abf2ccfb860513d3c6450457842", "sha256": "6b43fcbfc72203b8af8bcd8c8b3858cdb25970dfb2c3a622bb240cd346b66e37"}, "downloads": -1, "filename": "abelian-0.0.4.tar.gz", "has_sig": false, "md5_digest": "b98c0abf2ccfb860513d3c6450457842", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 39147, "upload_time": "2017-08-13T16:26:11", "upload_time_iso_8601": "2017-08-13T16:26:11.226550Z", "url": "https://files.pythonhosted.org/packages/88/49/a5ab4a297cdd7c49a765395f3f30bfa04c59028307b5a0b5bea504410bbd/abelian-0.0.4.tar.gz", "yanked": false}], "0.2.0": [{"comment_text": "", "digests": {"md5": "b7bc7d3960506a20716e5438c79a37d0", "sha256": "8d125515745588e8fb16339aba0ec6e2f24aa6af5bca13b2d9fe242fe5ef4e00"}, "downloads": -1, "filename": "abelian-0.2.0.tar.gz", "has_sig": false, "md5_digest": "b7bc7d3960506a20716e5438c79a37d0", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 542176, "upload_time": "2017-10-29T12:44:20", "upload_time_iso_8601": "2017-10-29T12:44:20.238001Z", "url": "https://files.pythonhosted.org/packages/6a/36/4387de06c8339ad5b712b55bf05008a01b5cd80fe8be7ed517da80fde293/abelian-0.2.0.tar.gz", "yanked": false}], "1.0.0": [{"comment_text": "", "digests": {"md5": "6a9c094eb3c0cd423bd3c307d8d943c3", "sha256": "ec17c6c8fff71d0cbad0c7dc351a124d1748cdae125deb66eb0533531c64abb9"}, "downloads": -1, "filename": "abelian-1.0.0-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "6a9c094eb3c0cd423bd3c307d8d943c3", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 41805, "upload_time": "2017-11-15T13:40:33", "upload_time_iso_8601": "2017-11-15T13:40:33.229779Z", "url": "https://files.pythonhosted.org/packages/18/5c/2d88b60340b4dcb796818afe650295461e4327aaee75230efa572f165aaa/abelian-1.0.0-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "db8d9dd2f69a96d5e167e99d63780d14", "sha256": "f72b6116c23bf4903b709b523915fcf1687395fec7dad258aa0802e55489b06b"}, "downloads": -1, "filename": "abelian-1.0.0-py3.6.egg", "has_sig": false, "md5_digest": "db8d9dd2f69a96d5e167e99d63780d14", "packagetype": "bdist_egg", "python_version": "3.6", "requires_python": null, "size": 86654, "upload_time": "2017-11-15T13:40:34", "upload_time_iso_8601": "2017-11-15T13:40:34.987227Z", "url": "https://files.pythonhosted.org/packages/09/fb/ade2a2985b9fd9bb2d103b2cd4de60856b31b4d8e7ae4c0dcc193b7b6685/abelian-1.0.0-py3.6.egg", "yanked": false}], "1.0.1": [{"comment_text": "", "digests": {"md5": "3c92cb2089318f497e13b4afc1b3f9b1", "sha256": "59398440bb2d97e89fd6c3653a64f092c6a47205555b692337bdb7d2aede7f58"}, "downloads": -1, "filename": "abelian-1.0.1-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "3c92cb2089318f497e13b4afc1b3f9b1", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 41960, "upload_time": "2017-11-15T13:54:05", "upload_time_iso_8601": "2017-11-15T13:54:05.218181Z", "url": "https://files.pythonhosted.org/packages/09/97/af1c191089833eb492afab0974bc34570729324badece2737c931966831e/abelian-1.0.1-py2.py3-none-any.whl", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "3c92cb2089318f497e13b4afc1b3f9b1", "sha256": "59398440bb2d97e89fd6c3653a64f092c6a47205555b692337bdb7d2aede7f58"}, "downloads": -1, "filename": "abelian-1.0.1-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "3c92cb2089318f497e13b4afc1b3f9b1", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 41960, "upload_time": "2017-11-15T13:54:05", "upload_time_iso_8601": "2017-11-15T13:54:05.218181Z", "url": "https://files.pythonhosted.org/packages/09/97/af1c191089833eb492afab0974bc34570729324badece2737c931966831e/abelian-1.0.1-py2.py3-none-any.whl", "yanked": false}], "timestamp": "Thu May  7 15:55:17 2020"}