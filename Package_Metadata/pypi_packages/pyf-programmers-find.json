{"info": {"author": "Simon Blanchard", "author_email": "bnomis@gmail.com", "bugtrack_url": null, "classifiers": ["Development Status :: 5 - Production/Stable", "Environment :: Console", "Intended Audience :: Developers", "Intended Audience :: System Administrators", "License :: OSI Approved :: MIT License", "Natural Language :: English", "Operating System :: POSIX", "Programming Language :: Python :: 2.7", "Programming Language :: Python :: 3.4", "Topic :: Software Development :: Build Tools", "Topic :: System :: Systems Administration", "Topic :: Text Processing", "Topic :: Utilities"], "description": "pyf: Programmers find\n=====================\n\nIt's pronounced \"pif\".\n\n.. code:: shell\n\n    pyf [options] [search-pattern [filename-pattern [start-directory]]]\n\nRecursively search for files whose contents matches search-pattern.\n\n-  Optionally restrict the search to files whose name matches\n   filename-pattern.\n-  Optionally chdir to start-directory before starting the search.\n-  Patterns are Python regular expressions.\n\nWritten because I got tired of writing:\n\n.. code:: shell\n\n    find . -name '*.py' -exec egrep -l regex {} \\;\n\nThe above with pyf would be:\n\n.. code:: shell\n\n    pyf regex '\\.py$'\n\nor\n\n.. code:: shell\n\n    pyf regex 'py$'\n\nor just\n\n.. code:: shell\n\n    pyf regex py\n\nIf you don't pass in a regex as the file name pattern, pyf assumes it is\na file extension match and adds a $ on the end.\n\nFile name patterns and the search patterns inside of files are both\n`Python regular\nexpressions <https://docs.python.org/3/library/re.html>`__.\n\nExamples\n--------\n\nFind Files Containing A Regex\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n.. code:: shell\n\n    pyf regex\n\nThe above example will recursively find files and search for 'regex' in\nthe file.\n\nRestrict The Search To Certain File Extensions\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n.. code:: shell\n\n    pyf regex py\n\nThe above example will recursively find files whose name ends in 'py'\nand search for 'regex' in the file.\n\nFinding Files Which Contain One Thing But Not Another\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n.. code:: shell\n\n    pyf post html | pyf -v -f - csrf_token\n\nAbove finds all files whose name ends in 'html' and contain 'post' but\ndo not contain 'csrf\\_token'.\n\nRunning A Command On A Matched File\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n.. code:: shell\n\n    pyf -r \"sed -i '' -e 's/yajogo\\.core\\.debug/yajogo.core.logging/g'\" 'yajogo\\.core\\.debug' py\n\nAbove finds files with extention 'py' that contain the string\n'yajogo.core.debug' and runs a sed command on them.\n\nPrinting Regex Matches\n~~~~~~~~~~~~~~~~~~~~~~\n\n.. code:: shell\n\n    pyf -s -m '\\d+x\\d+' html\n\nAbove will print all matches of the pattern '+x+' in files whose names\nends in 'html'. The -s option suppresses printing of the filename for\nthe match. The -m option causes the matched regex to be printed. So,\nwith the above you might get an output like this:\n\n::\n\n    57x57\n    72x72\n    114x114\n    512x512\n    200x200\n    150x150\n    150x150\n    150x150\n    500x500\n    800x600\n    150x150\n    150x150\n\nWe could pipe the output of this command to another program. For\nexample:\n\n.. code:: shell\n\n    pyf -s -m html '(\\d+x\\d+)' | sort | uniq\n\nWould give us a sorted and unique list of matches:\n\n::\n\n    114x114\n    150x150\n    200x200\n    500x500\n    512x512\n    57x57\n    72x72\n    800x600\n\nInstallation\n------------\n\n.. code:: shell\n\n    pip install pyf-programmers-find\n\nUsage\n-----\n\n.. code:: shell\n\n    $ pyf -h\n    usage: pyf [options] [search-pattern [filename-pattern [start-directory]]]\n\n    pyf: programmers find\n\n    Recursively search for files whose contents matches search-pattern.\n    Optionally restrict the search to files whose name matches filename-pattern.\n    Patterns are Python regular expressions.\n\n    It's pronounced \"pif\".\n\n    positional arguments:\n      search-pattern        Match this pattern in files.\n      filename-pattern      Only search files whose name matches this pattern.\n      start-directory       Change to this directory before findind and searching\n                            files.\n\n    optional arguments:\n      -h, --help            show this help message and exit\n      --version             show program's version number and exit\n      --debug               Turn on debug logging.\n      --debug-log FILE      Save debug logging to FILE.\n      -c COUNT, --context COUNT\n                            Show COUNT surrounding context lines of the matches.\n                            Only makes sense when printing matched lines with the\n                            -p option. Default 0.\n      -d START_DIRECTORY, --chdir START_DIRECTORY\n                            Change to directory START_DIRECTORY before starting\n                            the search. Can also be given as the third positional\n                            argument.\n      -e SEARCH_PATTERN, --regexp SEARCH_PATTERN\n                            Use SEARCH_PATTERN as the pattern to match in a file;\n                            use when defining patterns beginning with -. Can also\n                            be given as the first positional argument.\n      -f FILE, --file FILE  File to search for a match. Instead of recursively\n                            searching all files. Can be given multiple times. If\n                            argument is - reads a list of files to match from\n                            stdin.\n      -i, --ignore-case     Ignore case. Default False.\n      -l, --line-number     Print the matching line number. Default False.\n      -m, --matches         Print the matching regex group. Default False.\n      -n FILENAME_PATTERN, --filename FILENAME_PATTERN\n                            Recursively find files whose name matches\n                            FILENAME_PATTERN. Only search in those files. Can also\n                            be given as the second positional argument. Default:\n                            .+\n      -p, --print-lines     Print the matching line. Default False.\n      -r CMD, --run CMD     Run a program CMD for each matching file, passing the\n                            path name of the matching file as an argument. Ignored\n                            if the -p or -l options are given.\n      -s, --no-filename     Do not print the file name when printing matched\n                            lines. Only makes sense with the -p option. Default\n                            False.\n      -v, --invert-match    Invert the sense of the match. Print non-matching\n                            files and lines. Default False.\n      -A, --suppress-file-access-errors\n                            Do not print file/directory access errors.\n      -B, --no-binary-check\n                            Ignore (heuristic) binary file check, do not skip\n                            probably binary files.\n      -N, --no-pager        Do not pipe output to a pager when stdout it detected\n                            as a tty.\n      --force-pager         Always try to pipe output to a pager, do not check if\n                            stdout is a tty. Ignored when running with the -r\n                            option.\n      --skip-dirs-pattern SKIP_DIRS_PATTERN\n                            Regex of directories to skip. Default\n                            '(^\\..+|CVS|RCS|__pycache__)'.\n      --skip-files-pattern SKIP_FILES_PATTERN\n                            Regex of files to skip. Default '(^\\..+|\\.pyc$)'.", "description_content_type": null, "docs_url": null, "download_url": "UNKNOWN", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/bnomis/pyf", "keywords": "search,text,find", "license": "MIT", "maintainer": "", "maintainer_email": "", "name": "pyf-programmers-find", "package_url": "https://pypi.org/project/pyf-programmers-find/", "platform": "macosx,linux,unix", "project_url": "https://pypi.org/project/pyf-programmers-find/", "project_urls": {"Download": "UNKNOWN", "Homepage": "https://github.com/bnomis/pyf"}, "release_url": "https://pypi.org/project/pyf-programmers-find/0.9.0/", "requires_dist": null, "requires_python": null, "summary": "pyf: programmers find", "version": "0.9.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p>It\u2019s pronounced \u201cpif\u201d.</p>\n<pre>pyf <span class=\"o\">[</span>options<span class=\"o\">]</span> <span class=\"o\">[</span>search-pattern <span class=\"o\">[</span>filename-pattern <span class=\"o\">[</span>start-directory<span class=\"o\">]]]</span>\n</pre>\n<p>Recursively search for files whose contents matches search-pattern.</p>\n<ul>\n<li>Optionally restrict the search to files whose name matches\nfilename-pattern.</li>\n<li>Optionally chdir to start-directory before starting the search.</li>\n<li>Patterns are Python regular expressions.</li>\n</ul>\n<p>Written because I got tired of writing:</p>\n<pre>find . -name <span class=\"s1\">'*.py'</span> -exec egrep -l regex <span class=\"o\">{}</span> <span class=\"se\">\\;</span>\n</pre>\n<p>The above with pyf would be:</p>\n<pre>pyf regex <span class=\"s1\">'\\.py$'</span>\n</pre>\n<p>or</p>\n<pre>pyf regex <span class=\"s1\">'py$'</span>\n</pre>\n<p>or just</p>\n<pre>pyf regex py\n</pre>\n<p>If you don\u2019t pass in a regex as the file name pattern, pyf assumes it is\na file extension match and adds a $ on the end.</p>\n<p>File name patterns and the search patterns inside of files are both\n<a href=\"https://docs.python.org/3/library/re.html\" rel=\"nofollow\">Python regular\nexpressions</a>.</p>\n<div id=\"examples\">\n<h2>Examples</h2>\n<div id=\"find-files-containing-a-regex\">\n<h3>Find Files Containing A Regex</h3>\n<pre>pyf regex\n</pre>\n<p>The above example will recursively find files and search for \u2018regex\u2019 in\nthe file.</p>\n</div>\n<div id=\"restrict-the-search-to-certain-file-extensions\">\n<h3>Restrict The Search To Certain File Extensions</h3>\n<pre>pyf regex py\n</pre>\n<p>The above example will recursively find files whose name ends in \u2018py\u2019\nand search for \u2018regex\u2019 in the file.</p>\n</div>\n<div id=\"finding-files-which-contain-one-thing-but-not-another\">\n<h3>Finding Files Which Contain One Thing But Not Another</h3>\n<pre>pyf post html <span class=\"p\">|</span> pyf -v -f - csrf_token\n</pre>\n<p>Above finds all files whose name ends in \u2018html\u2019 and contain \u2018post\u2019 but\ndo not contain \u2018csrf_token\u2019.</p>\n</div>\n<div id=\"running-a-command-on-a-matched-file\">\n<h3>Running A Command On A Matched File</h3>\n<pre>pyf -r <span class=\"s2\">\"sed -i '' -e 's/yajogo\\.core\\.debug/yajogo.core.logging/g'\"</span> <span class=\"s1\">'yajogo\\.core\\.debug'</span> py\n</pre>\n<p>Above finds files with extention \u2018py\u2019 that contain the string\n\u2018yajogo.core.debug\u2019 and runs a sed command on them.</p>\n</div>\n<div id=\"printing-regex-matches\">\n<h3>Printing Regex Matches</h3>\n<pre>pyf -s -m <span class=\"s1\">'\\d+x\\d+'</span> html\n</pre>\n<p>Above will print all matches of the pattern \u2018+x+\u2019 in files whose names\nends in \u2018html\u2019. The -s option suppresses printing of the filename for\nthe match. The -m option causes the matched regex to be printed. So,\nwith the above you might get an output like this:</p>\n<pre>57x57\n72x72\n114x114\n512x512\n200x200\n150x150\n150x150\n150x150\n500x500\n800x600\n150x150\n150x150\n</pre>\n<p>We could pipe the output of this command to another program. For\nexample:</p>\n<pre>pyf -s -m html <span class=\"s1\">'(\\d+x\\d+)'</span> <span class=\"p\">|</span> sort <span class=\"p\">|</span> uniq\n</pre>\n<p>Would give us a sorted and unique list of matches:</p>\n<pre>114x114\n150x150\n200x200\n500x500\n512x512\n57x57\n72x72\n800x600\n</pre>\n</div>\n</div>\n<div id=\"installation\">\n<h2>Installation</h2>\n<pre>pip install pyf-programmers-find\n</pre>\n</div>\n<div id=\"usage\">\n<h2>Usage</h2>\n<pre>$ pyf -h\nusage: pyf <span class=\"o\">[</span>options<span class=\"o\">]</span> <span class=\"o\">[</span>search-pattern <span class=\"o\">[</span>filename-pattern <span class=\"o\">[</span>start-directory<span class=\"o\">]]]</span>\n\npyf: programmers find\n\nRecursively search <span class=\"k\">for</span> files whose contents matches search-pattern.\nOptionally restrict the search to files whose name matches filename-pattern.\nPatterns are Python regular expressions.\n\nIt<span class=\"s1\">'s pronounced \"pif\".\n\npositional arguments:\n  search-pattern        Match this pattern in files.\n  filename-pattern      Only search files whose name matches this pattern.\n  start-directory       Change to this directory before findind and searching\n                        files.\n\noptional arguments:\n  -h, --help            show this help message and exit\n  --version             show program'</span>s version number and <span class=\"nb\">exit</span>\n  --debug               Turn on debug logging.\n  --debug-log FILE      Save debug logging to FILE.\n  -c COUNT, --context COUNT\n                        Show COUNT surrounding context lines of the matches.\n                        Only makes sense when printing matched lines with the\n                        -p option. Default <span class=\"m\">0</span>.\n  -d START_DIRECTORY, --chdir START_DIRECTORY\n                        Change to directory START_DIRECTORY before starting\n                        the search. Can also be given as the third positional\n                        argument.\n  -e SEARCH_PATTERN, --regexp SEARCH_PATTERN\n                        Use SEARCH_PATTERN as the pattern to match in a file<span class=\"p\">;</span>\n                        use when defining patterns beginning with -. Can also\n                        be given as the first positional argument.\n  -f FILE, --file FILE  File to search <span class=\"k\">for</span> a match. Instead of recursively\n                        searching all files. Can be given multiple times. If\n                        argument is - reads a list of files to match from\n                        stdin.\n  -i, --ignore-case     Ignore <span class=\"k\">case</span>. Default False.\n  -l, --line-number     Print the matching line number. Default False.\n  -m, --matches         Print the matching regex group. Default False.\n  -n FILENAME_PATTERN, --filename FILENAME_PATTERN\n                        Recursively find files whose name matches\n                        FILENAME_PATTERN. Only search in those files. Can also\n                        be given as the second positional argument. Default:\n                        .+\n  -p, --print-lines     Print the matching line. Default False.\n  -r CMD, --run CMD     Run a program CMD <span class=\"k\">for</span> each matching file, passing the\n                        path name of the matching file as an argument. Ignored\n                        <span class=\"k\">if</span> the -p or -l options are given.\n  -s, --no-filename     Do not print the file name when printing matched\n                        lines. Only makes sense with the -p option. Default\n                        False.\n  -v, --invert-match    Invert the sense of the match. Print non-matching\n                        files and lines. Default False.\n  -A, --suppress-file-access-errors\n                        Do not print file/directory access errors.\n  -B, --no-binary-check\n                        Ignore <span class=\"o\">(</span>heuristic<span class=\"o\">)</span> binary file check, <span class=\"k\">do</span> not skip\n                        probably binary files.\n  -N, --no-pager        Do not pipe output to a pager when stdout it detected\n                        as a tty.\n  --force-pager         Always try to pipe output to a pager, <span class=\"k\">do</span> not check <span class=\"k\">if</span>\n                        stdout is a tty. Ignored when running with the -r\n                        option.\n  --skip-dirs-pattern SKIP_DIRS_PATTERN\n                        Regex of directories to skip. Default\n                        <span class=\"s1\">'(^\\..+|CVS|RCS|__pycache__)'</span>.\n  --skip-files-pattern SKIP_FILES_PATTERN\n                        Regex of files to skip. Default <span class=\"s1\">'(^\\..+|\\.pyc$)'</span>.\n</pre>\n</div>\n\n          </div>"}, "last_serial": 1495621, "releases": {"0.9.0": [{"comment_text": "", "digests": {"md5": "9dedbbce078e70c2308a6ae92e965613", "sha256": "b3882ddaab01d906ce36db6fe0ab2a0536316f11a0cf6142635f6d0e8d9def08"}, "downloads": -1, "filename": "pyf_programmers_find-0.9.0-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "9dedbbce078e70c2308a6ae92e965613", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 14879, "upload_time": "2015-04-08T11:30:52", "upload_time_iso_8601": "2015-04-08T11:30:52.793806Z", "url": "https://files.pythonhosted.org/packages/a4/b4/41bc86d2102e14cf2d862bf87bf5c80cbb28a16a126bc23139fd9a2a03c9/pyf_programmers_find-0.9.0-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "3d58c482a0c0e31f61f7c5f75acfa837", "sha256": "684646523cfc90c12ec99b3252855753417089911db672c506dc400c1fe537fc"}, "downloads": -1, "filename": "pyf-programmers-find-0.9.0.tar.gz", "has_sig": false, "md5_digest": "3d58c482a0c0e31f61f7c5f75acfa837", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 17482, "upload_time": "2015-04-08T11:30:41", "upload_time_iso_8601": "2015-04-08T11:30:41.836096Z", "url": "https://files.pythonhosted.org/packages/82/87/af14f60ad60b06893e7f5d5969481135d07d73f0815e32f619199d96b0f4/pyf-programmers-find-0.9.0.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "9dedbbce078e70c2308a6ae92e965613", "sha256": "b3882ddaab01d906ce36db6fe0ab2a0536316f11a0cf6142635f6d0e8d9def08"}, "downloads": -1, "filename": "pyf_programmers_find-0.9.0-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "9dedbbce078e70c2308a6ae92e965613", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 14879, "upload_time": "2015-04-08T11:30:52", "upload_time_iso_8601": "2015-04-08T11:30:52.793806Z", "url": "https://files.pythonhosted.org/packages/a4/b4/41bc86d2102e14cf2d862bf87bf5c80cbb28a16a126bc23139fd9a2a03c9/pyf_programmers_find-0.9.0-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "3d58c482a0c0e31f61f7c5f75acfa837", "sha256": "684646523cfc90c12ec99b3252855753417089911db672c506dc400c1fe537fc"}, "downloads": -1, "filename": "pyf-programmers-find-0.9.0.tar.gz", "has_sig": false, "md5_digest": "3d58c482a0c0e31f61f7c5f75acfa837", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 17482, "upload_time": "2015-04-08T11:30:41", "upload_time_iso_8601": "2015-04-08T11:30:41.836096Z", "url": "https://files.pythonhosted.org/packages/82/87/af14f60ad60b06893e7f5d5969481135d07d73f0815e32f619199d96b0f4/pyf-programmers-find-0.9.0.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:05:33 2020"}