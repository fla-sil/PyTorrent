{"info": {"author": "Daniel Richman, Adam Greig", "author_email": "main@danielrichman.co.uk", "bugtrack_url": null, "classifiers": ["Development Status :: 4 - Beta", "Intended Audience :: Developers", "License :: OSI Approved :: GNU General Public License v3 (GPLv3)", "Operating System :: OS Independent", "Programming Language :: Python", "Programming Language :: Python :: 2", "Programming Language :: Python :: 3"], "description": "Strict, simple, lightweight RFC3339 functions\n=============================================\n\nGoals\n-----\n\n - Convert unix timestamps to and from RFC3339.\n - Either produce RFC3339 strings with a UTC offset (Z) or with the offset\n   that the C time module reports is the local timezone offset.\n - Simple with minimal dependencies/libraries.\n - Avoid timezones as much as possible.\n - Be very strict and follow RFC3339.\n\nCaveats\n-------\n\n - Leap seconds are not quite supported, since timestamps do not support them,\n   and it requires access to timezone data.\n - You may be limited by the size of `time_t` on 32 bit systems.\n\nIn both cases, see 'Notes' below.\n\nRationale\n---------\n\n - A lot of libraries have trouble with DST transitions and ambiguous times.\n - Generally, using the python datetime object causes trouble, introducing\n   problems with timezones.\n - The excellent `pytz` library seems to achieve timezone perfection, however\n   it didn't (at the time of writing) have a method for getting the local\n   timezone or the 'now' time in the local zone.\n - I saw a lot of problems ultimately due to information lost when converting\n   or transferring between two libraries (e.g., `time` -> `datetime` loses DST\n   info in the tuple)\n\nUsage\n-----\n\nValidation:\n\n    >>> strict_rfc3339.validate_rfc3339(\"some rubbish\")\n    False\n    >>> strict_rfc3339.validate_rfc3339(\"2013-03-25T12:42:31+00:32\")\n    True\n\nIndeed, we can then:\n\n    >>> strict_rfc3339.rfc3339_to_timestamp(\"2013-03-25T12:42:31+00:32\")\n    1364213431\n    >>> tuple(time.gmtime(1364213431))[:6]\n    (2013, 3, 25, 12, 10, 31)\n\nNo need for two function calls:\n\n    >>> strict_rfc3339.rfc3339_to_timestamp(\"some rubbish\")\n    Traceback [...]\n    strict_rfc3339.InvalidRFC3339Error\n\nProducing strings (for this example `TZ=America/New_York`):\n\n    >>> strict_rfc3339.timestamp_to_rfc3339_utcoffset(1364213431)\n    '2013-03-25T12:10:31Z'\n    >>> strict_rfc3339.timestamp_to_rfc3339_localoffset(1364213431)\n    '2013-03-25T08:10:31-04:00'\n\nAnd with `TZ=Europe/London`:\n\n    >>> strict_rfc3339.timestamp_to_rfc3339_localoffset(1364213431)\n    '2013-03-25T12:10:31+00:00'\n\nConvenience functions:\n\n    >>> strict_rfc3339.now_to_rfc3339_utcoffset()\n    '2013-03-25T21:39:35Z'\n    >>> strict_rfc3339.now_to_rfc3339_localoffset()\n    '2013-03-25T17:39:39-04:00'\n\nFloats:\n\n    >>> strict_rfc3339.now_to_rfc3339_utcoffset(integer=True) # The default\n    '2013-03-25T22:04:01Z'\n    >>> strict_rfc3339.now_to_rfc3339_utcoffset(integer=False)\n    '2013-03-25T22:04:01.04399Z'\n    >>> strict_rfc3339.rfc3339_to_timestamp(\"2013-03-25T22:04:10.04399Z\")\n    1364249050.0439899\n\nBehind the scenes\n-----------------\n\nThese functions are essentially string formatting and arithmetic only.  A very\nsmall number of functions do the heavy lifting. These come from two modules:\n`time` and `calendar`.\n\n`time` is a thin wrapper around the C time functions. I'm working on the\nassumption that these are usually of high quality and are correct. From the\n`time` module, `strict_rfc3339` uses:\n\n - `time`: (actually calls `gettimeofday`) to get the current timestamp / \"now\"\n - `gmtime`: splits a timestamp into a UTC time tuple\n - `localtime`: splits a timestamp into a local time tuple\n\nBased on the assumption that they are correct, we can use the difference\nbetween the values returned by `gmtime` and `localtime` to find the local\noffset.  As clunky as it sounds, it's far easier than using a fully fledged\ntimezone library.\n\n`calendar` is implemented in python. From `calendar`, `strict_rfc3339` uses:\n\n - `timegm`: turns a UTC time tuple into a timestamp. This essentially just\n   multiplies each number in the tuple by the number of seconds in it. It does\n   use `datetime.date` to work out the number of days between Jan 1 1970 and the\n   Y-M-D in the tuple, but this is fine. It does not perform much validation at\n   all.\n - `monthrange`: gives the number of days in a (year, month). I checked and\n   (at least in my copy of python 2.6) the function used for leap years is\n   identical to the one specified in RFC3339 itself.\n\nNotes\n-----\n\n - RFC3339 specifies an offset, not a timezone, and the difference is\n   important. Timezones are evil.\n - It is perhaps simpler to think of a RFC3339 string as a human readable\n   method of specifying a moment in time (only). These functions merely provide\n   access to the one-to-many timestamp-to-RFC3339 mapping.\n - Timestamps don't support leap seconds: a day is always 86400 \"long\".\n   Also, validating leap seconds is particularly fiddly, because not only do\n   you need some data, but it must be kept up to date.\n   For this reason, `strict_rfc3339` does not support leap seconds: in validation,\n   `seconds == 60` or `seconds == 61` is rejected.\n   In the case of reverse leap seconds, calendar.timegm will blissfully accept\n   it. The result would be about as correct as you could get.\n - RFC3339 generation using `gmtime` or `localtime` may be limited by the size\n   of `time_t` on the system: if it is 32 bit, you're limited to dates between\n   (approx) 1901 and 2038. This does not affect `rfc3339_to_timestamp`.", "description_content_type": null, "docs_url": null, "download_url": "UNKNOWN", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "http://www.danielrichman.co.uk/libraries/strict-rfc3339.html", "keywords": null, "license": "GNU General Public License Version 3", "maintainer": null, "maintainer_email": null, "name": "strict-rfc3339", "package_url": "https://pypi.org/project/strict-rfc3339/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/strict-rfc3339/", "project_urls": {"Download": "UNKNOWN", "Homepage": "http://www.danielrichman.co.uk/libraries/strict-rfc3339.html"}, "release_url": "https://pypi.org/project/strict-rfc3339/0.7/", "requires_dist": null, "requires_python": null, "summary": "Strict, simple, lightweight RFC3339 functions", "version": "0.7", "yanked": false, "html_description": "<div class=\"project-description\">\n            <div id=\"goals\">\n<h2>Goals</h2>\n<blockquote>\n<ul>\n<li>Convert unix timestamps to and from RFC3339.</li>\n<li>Either produce RFC3339 strings with a UTC offset (Z) or with the offset\nthat the C time module reports is the local timezone offset.</li>\n<li>Simple with minimal dependencies/libraries.</li>\n<li>Avoid timezones as much as possible.</li>\n<li>Be very strict and follow RFC3339.</li>\n</ul>\n</blockquote>\n</div>\n<div id=\"caveats\">\n<h2>Caveats</h2>\n<blockquote>\n<ul>\n<li>Leap seconds are not quite supported, since timestamps do not support them,\nand it requires access to timezone data.</li>\n<li>You may be limited by the size of <cite>time_t</cite> on 32 bit systems.</li>\n</ul>\n</blockquote>\n<p>In both cases, see \u2018Notes\u2019 below.</p>\n</div>\n<div id=\"rationale\">\n<h2>Rationale</h2>\n<blockquote>\n<ul>\n<li>A lot of libraries have trouble with DST transitions and ambiguous times.</li>\n<li>Generally, using the python datetime object causes trouble, introducing\nproblems with timezones.</li>\n<li>The excellent <cite>pytz</cite> library seems to achieve timezone perfection, however\nit didn\u2019t (at the time of writing) have a method for getting the local\ntimezone or the \u2018now\u2019 time in the local zone.</li>\n<li>I saw a lot of problems ultimately due to information lost when converting\nor transferring between two libraries (e.g., <cite>time</cite> -&gt; <cite>datetime</cite> loses DST\ninfo in the tuple)</li>\n</ul>\n</blockquote>\n</div>\n<div id=\"usage\">\n<h2>Usage</h2>\n<p>Validation:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; strict_rfc3339.validate_rfc3339(\"some rubbish\")\nFalse\n&gt;&gt;&gt; strict_rfc3339.validate_rfc3339(\"2013-03-25T12:42:31+00:32\")\nTrue\n</pre>\n</blockquote>\n<p>Indeed, we can then:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; strict_rfc3339.rfc3339_to_timestamp(\"2013-03-25T12:42:31+00:32\")\n1364213431\n&gt;&gt;&gt; tuple(time.gmtime(1364213431))[:6]\n(2013, 3, 25, 12, 10, 31)\n</pre>\n</blockquote>\n<p>No need for two function calls:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; strict_rfc3339.rfc3339_to_timestamp(\"some rubbish\")\nTraceback [...]\nstrict_rfc3339.InvalidRFC3339Error\n</pre>\n</blockquote>\n<p>Producing strings (for this example <cite>TZ=America/New_York</cite>):</p>\n<blockquote>\n<pre>&gt;&gt;&gt; strict_rfc3339.timestamp_to_rfc3339_utcoffset(1364213431)\n'2013-03-25T12:10:31Z'\n&gt;&gt;&gt; strict_rfc3339.timestamp_to_rfc3339_localoffset(1364213431)\n'2013-03-25T08:10:31-04:00'\n</pre>\n</blockquote>\n<p>And with <cite>TZ=Europe/London</cite>:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; strict_rfc3339.timestamp_to_rfc3339_localoffset(1364213431)\n'2013-03-25T12:10:31+00:00'\n</pre>\n</blockquote>\n<p>Convenience functions:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; strict_rfc3339.now_to_rfc3339_utcoffset()\n'2013-03-25T21:39:35Z'\n&gt;&gt;&gt; strict_rfc3339.now_to_rfc3339_localoffset()\n'2013-03-25T17:39:39-04:00'\n</pre>\n</blockquote>\n<p>Floats:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; strict_rfc3339.now_to_rfc3339_utcoffset(integer=True) # The default\n'2013-03-25T22:04:01Z'\n&gt;&gt;&gt; strict_rfc3339.now_to_rfc3339_utcoffset(integer=False)\n'2013-03-25T22:04:01.04399Z'\n&gt;&gt;&gt; strict_rfc3339.rfc3339_to_timestamp(\"2013-03-25T22:04:10.04399Z\")\n1364249050.0439899\n</pre>\n</blockquote>\n</div>\n<div id=\"behind-the-scenes\">\n<h2>Behind the scenes</h2>\n<p>These functions are essentially string formatting and arithmetic only.  A very\nsmall number of functions do the heavy lifting. These come from two modules:\n<cite>time</cite> and <cite>calendar</cite>.</p>\n<p><cite>time</cite> is a thin wrapper around the C time functions. I\u2019m working on the\nassumption that these are usually of high quality and are correct. From the\n<cite>time</cite> module, <cite>strict_rfc3339</cite> uses:</p>\n<blockquote>\n<ul>\n<li><cite>time</cite>: (actually calls <cite>gettimeofday</cite>) to get the current timestamp / \u201cnow\u201d</li>\n<li><cite>gmtime</cite>: splits a timestamp into a UTC time tuple</li>\n<li><cite>localtime</cite>: splits a timestamp into a local time tuple</li>\n</ul>\n</blockquote>\n<p>Based on the assumption that they are correct, we can use the difference\nbetween the values returned by <cite>gmtime</cite> and <cite>localtime</cite> to find the local\noffset.  As clunky as it sounds, it\u2019s far easier than using a fully fledged\ntimezone library.</p>\n<p><cite>calendar</cite> is implemented in python. From <cite>calendar</cite>, <cite>strict_rfc3339</cite> uses:</p>\n<blockquote>\n<ul>\n<li><cite>timegm</cite>: turns a UTC time tuple into a timestamp. This essentially just\nmultiplies each number in the tuple by the number of seconds in it. It does\nuse <cite>datetime.date</cite> to work out the number of days between Jan 1 1970 and the\nY-M-D in the tuple, but this is fine. It does not perform much validation at\nall.</li>\n<li><cite>monthrange</cite>: gives the number of days in a (year, month). I checked and\n(at least in my copy of python 2.6) the function used for leap years is\nidentical to the one specified in RFC3339 itself.</li>\n</ul>\n</blockquote>\n</div>\n<div id=\"notes\">\n<h2>Notes</h2>\n<blockquote>\n<ul>\n<li>RFC3339 specifies an offset, not a timezone, and the difference is\nimportant. Timezones are evil.</li>\n<li>It is perhaps simpler to think of a RFC3339 string as a human readable\nmethod of specifying a moment in time (only). These functions merely provide\naccess to the one-to-many timestamp-to-RFC3339 mapping.</li>\n<li>Timestamps don\u2019t support leap seconds: a day is always 86400 \u201clong\u201d.\nAlso, validating leap seconds is particularly fiddly, because not only do\nyou need some data, but it must be kept up to date.\nFor this reason, <cite>strict_rfc3339</cite> does not support leap seconds: in validation,\n<cite>seconds == 60</cite> or <cite>seconds == 61</cite> is rejected.\nIn the case of reverse leap seconds, calendar.timegm will blissfully accept\nit. The result would be about as correct as you could get.</li>\n<li>RFC3339 generation using <cite>gmtime</cite> or <cite>localtime</cite> may be limited by the size\nof <cite>time_t</cite> on the system: if it is 32 bit, you\u2019re limited to dates between\n(approx) 1901 and 2038. This does not affect <cite>rfc3339_to_timestamp</cite>.</li>\n</ul>\n</blockquote>\n</div>\n\n          </div>"}, "last_serial": 2080575, "releases": {"0.1": [{"comment_text": "", "digests": {"md5": "d22ee0bb43450b4ae7148e6b68b97b23", "sha256": "75b3a237ec5fbda5ca3f60b3f12a3647fb822c7c3f3387a586cbe3bce12f9640"}, "downloads": -1, "filename": "strict-rfc3339-0.1.tar.gz", "has_sig": false, "md5_digest": "d22ee0bb43450b4ae7148e6b68b97b23", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 16350, "upload_time": "2013-03-25T21:12:34", "upload_time_iso_8601": "2013-03-25T21:12:34.457022Z", "url": "https://files.pythonhosted.org/packages/db/3d/f01851da52a720f8aa4de327e11db1ec66352e701ac92b7313b447de19c7/strict-rfc3339-0.1.tar.gz", "yanked": false}], "0.2": [{"comment_text": "", "digests": {"md5": "3d628ad03189e37a67ca972f2d679c64", "sha256": "5094629568fd74738b6f891edee537bbe190e761da0c8179a9a45fa5b206c349"}, "downloads": -1, "filename": "strict-rfc3339-0.2.tar.gz", "has_sig": false, "md5_digest": "3d628ad03189e37a67ca972f2d679c64", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 17184, "upload_time": "2013-03-25T22:16:42", "upload_time_iso_8601": "2013-03-25T22:16:42.373012Z", "url": "https://files.pythonhosted.org/packages/e8/d4/dbe139558524763f530a6266f74d83691d78f722fc9492bfeaca6a22c8e1/strict-rfc3339-0.2.tar.gz", "yanked": false}], "0.3": [{"comment_text": "", "digests": {"md5": "06c7d759dbb1b17e96f883125850afed", "sha256": "b6279fa8de2adbb6166798700e3e5426d12e0a088dc541eccc9f4da15785547c"}, "downloads": -1, "filename": "strict-rfc3339-0.3.tar.gz", "has_sig": false, "md5_digest": "06c7d759dbb1b17e96f883125850afed", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 17179, "upload_time": "2013-03-25T22:43:41", "upload_time_iso_8601": "2013-03-25T22:43:41.463102Z", "url": "https://files.pythonhosted.org/packages/fc/c5/9aa5936aafc3e5f903e59e286b6a1f8b086701a060d386c4540315f7bf23/strict-rfc3339-0.3.tar.gz", "yanked": false}], "0.4": [{"comment_text": "", "digests": {"md5": "0c053b7c62b1b8fc7111826d0515eefd", "sha256": "ad82146f8bfaa45a474862ed8ab8ee896a1aed008371615478e8f8fada0a8219"}, "downloads": -1, "filename": "strict-rfc3339-0.4.tar.gz", "has_sig": false, "md5_digest": "0c053b7c62b1b8fc7111826d0515eefd", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 17150, "upload_time": "2013-03-26T00:54:19", "upload_time_iso_8601": "2013-03-26T00:54:19.176933Z", "url": "https://files.pythonhosted.org/packages/66/87/bc7ff7bbe14b2aa043da06654b3e4d05684b97d344024f9656f57b6fc090/strict-rfc3339-0.4.tar.gz", "yanked": false}], "0.5": [{"comment_text": "", "digests": {"md5": "00a51064d1bbc49566ce471c39325906", "sha256": "a5e891e5669ddeff5fb1d2d006c96858e3ecfac180eb9a4efa9b019655f12518"}, "downloads": -1, "filename": "strict-rfc3339-0.5.tar.gz", "has_sig": false, "md5_digest": "00a51064d1bbc49566ce471c39325906", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 17195, "upload_time": "2014-10-11T08:44:14", "upload_time_iso_8601": "2014-10-11T08:44:14.762316Z", "url": "https://files.pythonhosted.org/packages/6c/8f/843319e54530a90f454f047fb6b41c53544a21c01de7059609957daf781f/strict-rfc3339-0.5.tar.gz", "yanked": false}], "0.6": [{"comment_text": "", "digests": {"md5": "308a4bfce4930e69526d0770116cdc12", "sha256": "8d505093cff2a65144eecee09a171ec3401a4d725438381c22011eceddf549df"}, "downloads": -1, "filename": "strict-rfc3339-0.6.tar.gz", "has_sig": false, "md5_digest": "308a4bfce4930e69526d0770116cdc12", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 16856, "upload_time": "2015-08-29T22:04:17", "upload_time_iso_8601": "2015-08-29T22:04:17.546511Z", "url": "https://files.pythonhosted.org/packages/29/2c/464cb5739c0c048bf519980f71f6530d42b27b3a48e4bf208ee2a3149f65/strict-rfc3339-0.6.tar.gz", "yanked": false}], "0.7": [{"comment_text": "", "digests": {"md5": "4d9b635b4df885bc37bc1189d66c9abc", "sha256": "5cad17bedfc3af57b399db0fed32771f18fc54bbd917e85546088607ac5e1277"}, "downloads": -1, "filename": "strict-rfc3339-0.7.tar.gz", "has_sig": false, "md5_digest": "4d9b635b4df885bc37bc1189d66c9abc", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 17552, "upload_time": "2016-04-24T04:24:04", "upload_time_iso_8601": "2016-04-24T04:24:04.403344Z", "url": "https://files.pythonhosted.org/packages/56/e4/879ef1dbd6ddea1c77c0078cd59b503368b0456bcca7d063a870ca2119d3/strict-rfc3339-0.7.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "4d9b635b4df885bc37bc1189d66c9abc", "sha256": "5cad17bedfc3af57b399db0fed32771f18fc54bbd917e85546088607ac5e1277"}, "downloads": -1, "filename": "strict-rfc3339-0.7.tar.gz", "has_sig": false, "md5_digest": "4d9b635b4df885bc37bc1189d66c9abc", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 17552, "upload_time": "2016-04-24T04:24:04", "upload_time_iso_8601": "2016-04-24T04:24:04.403344Z", "url": "https://files.pythonhosted.org/packages/56/e4/879ef1dbd6ddea1c77c0078cd59b503368b0456bcca7d063a870ca2119d3/strict-rfc3339-0.7.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:01:13 2020"}