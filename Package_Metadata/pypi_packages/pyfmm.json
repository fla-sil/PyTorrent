{"info": {"author": "Vegard Kvernelv", "author_email": "vkvernelv@gmail.com", "bugtrack_url": null, "classifiers": [], "description": "# pyfmm\r\nPython module implementing the Fast Marching Method, written in pure Python. Only dependency is numpy 1.8+.\r\n\r\nThe implementation uses mostly boolean arrays for accessing and updating values. Instead of accepting only the smallest value at each iteration (step 3, https://en.wikipedia.org/wiki/Fast_marching_method), one may accept an arbitrary number of values at each step. This can speed up the computations considerably, but may in some cases be inaccurate (especially if the speed varies alot).\r\n\r\n## Installation\r\n\r\n## Interface\r\n\r\nThere are two ways to compute the distances: \r\n\r\na) Using a boolean array that specifies the exact points that defines the boundary,\r\n\r\nb) Using an array of known distances to the boundary, in addition to a boolean array marking which values are certain.\r\n\r\nMethod a)\r\n```python\r\nimport pyfmm, numpy\r\n\r\nmy_boundary = numpy.array(..., dtype=numpy.bool)  # All boundary points marked as \"True\"\r\nsolution = pyfmm.march(my_boundary)\r\n```\r\n\r\nMethod b)\r\n```python\r\nimport pyfmm, numpy\r\n\r\nknown_distances = np.array(...)  # Unknown values could for instance be set to np.inf\r\nsolution = pyfmm.march(numpy.argwhere(known_distances != numpy.inf), known_distances))\r\n```\r\n\r\nThe number of values that are accepted at each iteration can be set using `batch_size`, and an array of speeds can be given using `speed`.\r\n\r\n## Examples\r\n\r\nThe examples illustrate the following:\r\n\r\n* `circle.py`: Distance from a ring boundary in the upper left part of the image. `batch_size` is varied to see how it affects computation time and result. In this case, the difference between the results from `batch_size=1` and `batch_size=100` seems negligible.\r\n* `race_to_middle.py`: Straight boundary on left and right hand side, and two different `speed` fields. The examples illustrates what might happen if care is not taken when choosing a `batch_size`.\r\n* `irregular.py`: Simply a less regular boundary shape than the two above.\r\n\r\nThe example boundary defined by examples/irregular_boundary.png:\r\n\r\n![](examples/irregular.png)\r\n", "description_content_type": null, "docs_url": null, "download_url": "https://github.com/vegardkv/pyfmm/tarball/0.2.1", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/vegardkv/pyfmm", "keywords": "fast marching method,eikonal,fmm,distance", "license": "MIT", "maintainer": null, "maintainer_email": null, "name": "pyfmm", "package_url": "https://pypi.org/project/pyfmm/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/pyfmm/", "project_urls": {"Download": "https://github.com/vegardkv/pyfmm/tarball/0.2.1", "Homepage": "https://github.com/vegardkv/pyfmm"}, "release_url": "https://pypi.org/project/pyfmm/0.3/", "requires_dist": null, "requires_python": null, "summary": "Python module implementing the Fast Marching Method.", "version": "0.3", "yanked": false, "html_description": "<div class=\"project-description\">\n            # pyfmm\n<br>Python module implementing the Fast Marching Method, written in pure Python. Only dependency is numpy 1.8+.\n<br>\n<br>The implementation uses mostly boolean arrays for accessing and updating values. Instead of accepting only the smallest value at each iteration (step 3, https://en.wikipedia.org/wiki/Fast_marching_method), one may accept an arbitrary number of values at each step. This can speed up the computations considerably, but may in some cases be inaccurate (especially if the speed varies alot).\n<br>\n<br>## Installation\n<br>\n<br>## Interface\n<br>\n<br>There are two ways to compute the distances: \n<br>\n<br>a) Using a boolean array that specifies the exact points that defines the boundary,\n<br>\n<br>b) Using an array of known distances to the boundary, in addition to a boolean array marking which values are certain.\n<br>\n<br>Method a)\n<br>```python\n<br>import pyfmm, numpy\n<br>\n<br>my_boundary = numpy.array(..., dtype=numpy.bool)  # All boundary points marked as \"True\"\n<br>solution = pyfmm.march(my_boundary)\n<br>```\n<br>\n<br>Method b)\n<br>```python\n<br>import pyfmm, numpy\n<br>\n<br>known_distances = np.array(...)  # Unknown values could for instance be set to np.inf\n<br>solution = pyfmm.march(numpy.argwhere(known_distances != numpy.inf), known_distances))\n<br>```\n<br>\n<br>The number of values that are accepted at each iteration can be set using `batch_size`, and an array of speeds can be given using `speed`.\n<br>\n<br>## Examples\n<br>\n<br>The examples illustrate the following:\n<br>\n<br>* `circle.py`: Distance from a ring boundary in the upper left part of the image. `batch_size` is varied to see how it affects computation time and result. In this case, the difference between the results from `batch_size=1` and `batch_size=100` seems negligible.\n<br>* `race_to_middle.py`: Straight boundary on left and right hand side, and two different `speed` fields. The examples illustrates what might happen if care is not taken when choosing a `batch_size`.\n<br>* `irregular.py`: Simply a less regular boundary shape than the two above.\n<br>\n<br>The example boundary defined by examples/irregular_boundary.png:\n<br>\n<br>![](examples/irregular.png)\n<br>\n          </div>"}, "last_serial": 2393847, "releases": {"0.3": [{"comment_text": "", "digests": {"md5": "35d71e4ed4940efb4557491478c9e288", "sha256": "5744de41f5ace0180efa499e2e3deb3bb88c2e559340ed79a4e0af817725e4df"}, "downloads": -1, "filename": "pyfmm-0.3.tar.gz", "has_sig": false, "md5_digest": "35d71e4ed4940efb4557491478c9e288", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 4172, "upload_time": "2016-10-11T18:16:34", "upload_time_iso_8601": "2016-10-11T18:16:34.585430Z", "url": "https://files.pythonhosted.org/packages/6d/d0/9da893cb1b488bf246325a1f847c975a62d8d2e9865718febba302622f1f/pyfmm-0.3.tar.gz", "yanked": false}, {"comment_text": "", "digests": {"md5": "458ad990bb2576ffb49349d53f7149fd", "sha256": "8f5495483a72d46e32e8cfc8f3871008dc74f301e83d134bb8270b7932058f1c"}, "downloads": -1, "filename": "pyfmm-0.3.zip", "has_sig": false, "md5_digest": "458ad990bb2576ffb49349d53f7149fd", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 5548, "upload_time": "2016-10-11T18:16:31", "upload_time_iso_8601": "2016-10-11T18:16:31.822835Z", "url": "https://files.pythonhosted.org/packages/f3/fc/fc3d4277bdc6451c5b7a33762afebf71e2457628c25f7dae51cb06bbc6b5/pyfmm-0.3.zip", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "35d71e4ed4940efb4557491478c9e288", "sha256": "5744de41f5ace0180efa499e2e3deb3bb88c2e559340ed79a4e0af817725e4df"}, "downloads": -1, "filename": "pyfmm-0.3.tar.gz", "has_sig": false, "md5_digest": "35d71e4ed4940efb4557491478c9e288", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 4172, "upload_time": "2016-10-11T18:16:34", "upload_time_iso_8601": "2016-10-11T18:16:34.585430Z", "url": "https://files.pythonhosted.org/packages/6d/d0/9da893cb1b488bf246325a1f847c975a62d8d2e9865718febba302622f1f/pyfmm-0.3.tar.gz", "yanked": false}, {"comment_text": "", "digests": {"md5": "458ad990bb2576ffb49349d53f7149fd", "sha256": "8f5495483a72d46e32e8cfc8f3871008dc74f301e83d134bb8270b7932058f1c"}, "downloads": -1, "filename": "pyfmm-0.3.zip", "has_sig": false, "md5_digest": "458ad990bb2576ffb49349d53f7149fd", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 5548, "upload_time": "2016-10-11T18:16:31", "upload_time_iso_8601": "2016-10-11T18:16:31.822835Z", "url": "https://files.pythonhosted.org/packages/f3/fc/fc3d4277bdc6451c5b7a33762afebf71e2457628c25f7dae51cb06bbc6b5/pyfmm-0.3.zip", "yanked": false}], "timestamp": "Fri May  8 03:05:39 2020"}