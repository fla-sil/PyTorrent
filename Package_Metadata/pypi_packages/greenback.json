{"info": {"author": "Joshua Oreman", "author_email": "oremanj@gmail.com", "bugtrack_url": null, "classifiers": ["Development Status :: 4 - Beta", "Framework :: AsyncIO", "Framework :: Trio", "License :: OSI Approved :: Apache Software License", "License :: OSI Approved :: MIT License", "Operating System :: MacOS :: MacOS X", "Operating System :: Microsoft :: Windows", "Operating System :: POSIX :: Linux", "Programming Language :: Python :: 3 :: Only", "Programming Language :: Python :: Implementation :: CPython", "Programming Language :: Python :: Implementation :: PyPy"], "description": "greenback: reenter an asyncio or Trio event loop from synchronous code\n======================================================================\n\n.. image:: https://img.shields.io/pypi/v/greenback.svg\n   :target: https://pypi.org/project/greenback\n   :alt: Latest PyPI version\n\n.. image:: https://img.shields.io/badge/docs-read%20now-blue.svg\n   :target: https://greenback.readthedocs.io/en/latest/?badge=latest\n   :alt: Documentation status\n\n.. image:: https://travis-ci.org/oremanj/greenback.svg?branch=master\n   :target: https://travis-ci.org/oremanj/greenback\n   :alt: Automated test status\n\n.. image:: https://codecov.io/gh/oremanj/greenback/branch/master/graph/badge.svg\n   :target: https://codecov.io/gh/oremanj/greenback\n   :alt: Test coverage\n\n.. image:: https://img.shields.io/badge/code%20style-black-000000.svg\n   :target: https://github.com/ambv/black\n   :alt: Code style: black\n\n.. image:: http://www.mypy-lang.org/static/mypy_badge.svg\n   :target: http://www.mypy-lang.org/\n   :alt: Checked with mypy\n\n\nPython 3.5 introduced ``async``/``await`` syntax for defining\nfunctions that can run concurrently in a cooperative multitasking\nframework such as ``asyncio`` or `Trio\n<https://trio.readthedocs.io/>`__. Such frameworks have a number of advantages\nover previous approaches to concurrency: they scale better than threads and are\n`clearer about control flow <https://glyph.twistedmatrix.com/2014/02/unyielding.html>`__\nthan the implicit cooperative multitasking provided by ``gevent``. They're also being\nactively developed to explore some `exciting new ideas about concurrent programming\n<https://vorpus.org/blog/notes-on-structured-concurrency-or-go-statement-considered-harmful/>`__.\n\nPorting an existing codebase to ``async``/``await`` syntax can be\nchallenging, though, since it's somewhat \"viral\": only an async\nfunction can call another async function. That means you don't just have\nto modify the functions that actually perform I/O; you also need to\n(trivially) modify every function that directly or indirectly calls a\nfunction that performs I/O. While the results are generally an improvement\n(\"explicit is better than implicit\"), getting there in one big step is not\nalways feasible.\n\n``greenback`` is a small library that attempts to bridge this gap. It\nallows you to **call back into async code from a syntactically\nsynchronous function**, as long as the synchronous function was\noriginally called from an async task (running in an asyncio or Trio\nevent loop) that set up a ``greenback`` trampoline as explained\nbelow. That way, you can migrate your program to ``async``/``await``\nsyntax one layer at a time instead of all at once.\n\n``greenback`` requires Python 3.6 or later and an implementation that\nsupports the ``greenlet`` library. Either CPython or PyPy should work.\nThere are no known OS dependencies.\n\nQuickstart\n----------\n\n* Call ``await greenback.ensure_portal()`` at least once in each task that will be\n  using ``greenback``. (Additional calls in the same task do nothing.) You can think\n  of this as creating a portal that will be used by future calls to\n  ``greenback.await_()`` in the same task.\n\n* Later, use ``greenback.await_(foo())`` as a replacement for\n  ``await foo()`` in places where you can't write ``await``.\n\n* For more details and additional helper methods, see the\n  `documentation <https://greenback.readthedocs.io>`__.\n\nExample\n-------\n\nSuppose you start with this async-unaware program::\n\n    import subprocess\n\n    def main():\n        print_fact(10)\n\n    def print_fact(n, mult=1):\n        \"\"\"Print the value of *n* factorial times *mult*.\"\"\"\n        if n <= 1:\n            print_value(mult)\n        else:\n            print_fact(n - 1, mult * n)\n\n    def print_value(n):\n        \"\"\"Print the value *n* in an unreasonably convoluted way.\"\"\"\n        assert isinstance(n, int)\n        subprocess.run(f\"echo {n}\", shell=True)\n\n    if __name__ == \"__main__\":\n        main()\n\nUsing ``greenback``, you can change it to run in a Trio event loop by\nchanging only the top and bottom layers, with no change to ``print_fact()``. ::\n\n    import trio\n    import greenback\n\n    async def main():\n        await greenback.ensure_portal()\n        print_fact(10)\n\n    def print_fact(n, mult=1):\n        \"\"\"Print the value of *n* factorial times *mult*.\"\"\"\n        if n <= 1:\n            print_value(mult)\n        else:\n            print_fact(n - 1, mult * n)\n\n    def print_value(n):\n        \"\"\"Print the value *n* in an unreasonably convoluted way.\"\"\"\n        assert isinstance(n, int)\n        greenback.await_(trio.run_process(f\"echo {n}\", shell=True))\n\n    if __name__ == \"__main__\":\n        trio.run(main)\n\nFAQ\n---\n\n**Why is it called \"greenback\"?** It uses the `greenlet\n<https://greenlet.readthedocs.io/en/latest/>`__ library to get you\n*back* to an enclosing async context. Also, maybe it saves you `money\n<https://www.dictionary.com/browse/greenback>`__ (engineering time) or\nsomething.\n\n**How does it work?** After you run ``await greenback.ensure_portal()``\nin a certain task, each step of that task will run inside a greenlet.\n(This is achieved by interposing a \"shim\" coroutine in between the event\nloop and the coroutine for your task; see the source code for details.)\nCalls to ``greenback.await_()`` are then able to switch from that greenlet\nback to the parent greenlet, which can easily perform the necessary\n``await`` since it has direct access to the async environment. The\nper-task-step greenlet is then resumed with the value or exception\nproduced by the ``await``.\n\n**Should I trust this in production?** Maybe; try it and see. The\ntechnique is in some ways an awful hack, and certainly has performance\nimplications (any task in which you call ``await\ngreenback.ensure_portal()`` will run somewhat slower).  ``greenback``\nitself is a fairly small amount of pure-Python code on top of\n``greenlet``.  (There is one reasonably safe ctypes hack that is necessary\nto work around a knob that's not exposed by the asyncio acceleration\nextension module on CPython.) ``greenlet`` is a C module full of arcane\nplatform-specific hacks, but it's been around for a very long time and\npopular production-quality concurrency systems such as ``gevent`` rely\nheavily on it.\n\n**What won't work?** A few things:\n\n* Greenlet switching works by moving parts of the C stack to different\n  memory addresses, relying on the assumption that Python objects are\n  fully heap-allocated and don't contain any pointers into the C\n  stack. Poorly-behaved C extension modules might violate this\n  assumption and are likely to crash if used with ``greenback``.\n  Such extension modules are buggy and could be made to crash without\n  ``greenback`` too, but perhaps only under an obscure or unlikely\n  series of operations.\n\n* Calling ``greenback.run()`` inside a finalizer (``__del__`` method)\n  or weakref callback is unsupported. It might work most of the time,\n  or even all the time, but the environment in which such methods run\n  is weird enough that the author isn't prepared to make any guarantees.\n  (Not that you have any guarantees about the rest of it, just some\n  better theoretical grounding.)\n\n\nLicense\n-------\n\n``greenback`` is licensed under your choice of the MIT or Apache 2.0 license.\nSee `LICENSE <https://github.com/oremanj/greenback/blob/master/LICENSE>`__\nfor details.\n\n\n", "description_content_type": "", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/oremanj/greenback", "keywords": "async,io,trio,asyncio", "license": "MIT -or- Apache License 2.0", "maintainer": "", "maintainer_email": "", "name": "greenback", "package_url": "https://pypi.org/project/greenback/", "platform": "", "project_url": "https://pypi.org/project/greenback/", "project_urls": {"Homepage": "https://github.com/oremanj/greenback"}, "release_url": "https://pypi.org/project/greenback/0.1.0/", "requires_dist": ["greenlet", "outcome", "sniffio"], "requires_python": ">=3.6", "summary": "Reenter an async event loop from synchronous code", "version": "0.1.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            <a href=\"https://pypi.org/project/greenback\" rel=\"nofollow\"><img alt=\"Latest PyPI version\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/9377a0cc755eaadc411e93dc0fc2d8d8b9ee13a1/68747470733a2f2f696d672e736869656c64732e696f2f707970692f762f677265656e6261636b2e737667\"></a>\n<a href=\"https://greenback.readthedocs.io/en/latest/?badge=latest\" rel=\"nofollow\"><img alt=\"Documentation status\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/f289deae3f3244b6f31fe0240e6d70a9bf7f4fa3/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f646f63732d726561642532306e6f772d626c75652e737667\"></a>\n<a href=\"https://travis-ci.org/oremanj/greenback\" rel=\"nofollow\"><img alt=\"Automated test status\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/9035e0275574944e0127a449965affa7a3a2729c/68747470733a2f2f7472617669732d63692e6f72672f6f72656d616e6a2f677265656e6261636b2e7376673f6272616e63683d6d6173746572\"></a>\n<a href=\"https://codecov.io/gh/oremanj/greenback\" rel=\"nofollow\"><img alt=\"Test coverage\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/586b808cf782ff09f4daff0ea4e6dc531b8dd3e3/68747470733a2f2f636f6465636f762e696f2f67682f6f72656d616e6a2f677265656e6261636b2f6272616e63682f6d61737465722f67726170682f62616467652e737667\"></a>\n<a href=\"https://github.com/ambv/black\" rel=\"nofollow\"><img alt=\"Code style: black\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/fbfdc7754183ecf079bc71ddeabaf88f6cbc5c00/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f636f64652532307374796c652d626c61636b2d3030303030302e737667\"></a>\n<a href=\"http://www.mypy-lang.org/\" rel=\"nofollow\"><img alt=\"Checked with mypy\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/d0db8f5dcbf5f340f278004d5db3d16b4cdf33ba/687474703a2f2f7777772e6d7970792d6c616e672e6f72672f7374617469632f6d7970795f62616467652e737667\"></a>\n<p>Python 3.5 introduced <tt>async</tt>/<tt>await</tt> syntax for defining\nfunctions that can run concurrently in a cooperative multitasking\nframework such as <tt>asyncio</tt> or <a href=\"https://trio.readthedocs.io/\" rel=\"nofollow\">Trio</a>. Such frameworks have a number of advantages\nover previous approaches to concurrency: they scale better than threads and are\n<a href=\"https://glyph.twistedmatrix.com/2014/02/unyielding.html\" rel=\"nofollow\">clearer about control flow</a>\nthan the implicit cooperative multitasking provided by <tt>gevent</tt>. They\u2019re also being\nactively developed to explore some <a href=\"https://vorpus.org/blog/notes-on-structured-concurrency-or-go-statement-considered-harmful/\" rel=\"nofollow\">exciting new ideas about concurrent programming</a>.</p>\n<p>Porting an existing codebase to <tt>async</tt>/<tt>await</tt> syntax can be\nchallenging, though, since it\u2019s somewhat \u201cviral\u201d: only an async\nfunction can call another async function. That means you don\u2019t just have\nto modify the functions that actually perform I/O; you also need to\n(trivially) modify every function that directly or indirectly calls a\nfunction that performs I/O. While the results are generally an improvement\n(\u201cexplicit is better than implicit\u201d), getting there in one big step is not\nalways feasible.</p>\n<p><tt>greenback</tt> is a small library that attempts to bridge this gap. It\nallows you to <strong>call back into async code from a syntactically\nsynchronous function</strong>, as long as the synchronous function was\noriginally called from an async task (running in an asyncio or Trio\nevent loop) that set up a <tt>greenback</tt> trampoline as explained\nbelow. That way, you can migrate your program to <tt>async</tt>/<tt>await</tt>\nsyntax one layer at a time instead of all at once.</p>\n<p><tt>greenback</tt> requires Python 3.6 or later and an implementation that\nsupports the <tt>greenlet</tt> library. Either CPython or PyPy should work.\nThere are no known OS dependencies.</p>\n<div id=\"quickstart\">\n<h2>Quickstart</h2>\n<ul>\n<li>Call <tt>await greenback.ensure_portal()</tt> at least once in each task that will be\nusing <tt>greenback</tt>. (Additional calls in the same task do nothing.) You can think\nof this as creating a portal that will be used by future calls to\n<tt>greenback.await_()</tt> in the same task.</li>\n<li>Later, use <tt><span class=\"pre\">greenback.await_(foo())</span></tt> as a replacement for\n<tt>await foo()</tt> in places where you can\u2019t write <tt>await</tt>.</li>\n<li>For more details and additional helper methods, see the\n<a href=\"https://greenback.readthedocs.io\" rel=\"nofollow\">documentation</a>.</li>\n</ul>\n</div>\n<div id=\"example\">\n<h2>Example</h2>\n<p>Suppose you start with this async-unaware program:</p>\n<pre>import subprocess\n\ndef main():\n    print_fact(10)\n\ndef print_fact(n, mult=1):\n    \"\"\"Print the value of *n* factorial times *mult*.\"\"\"\n    if n &lt;= 1:\n        print_value(mult)\n    else:\n        print_fact(n - 1, mult * n)\n\ndef print_value(n):\n    \"\"\"Print the value *n* in an unreasonably convoluted way.\"\"\"\n    assert isinstance(n, int)\n    subprocess.run(f\"echo {n}\", shell=True)\n\nif __name__ == \"__main__\":\n    main()\n</pre>\n<p>Using <tt>greenback</tt>, you can change it to run in a Trio event loop by\nchanging only the top and bottom layers, with no change to <tt>print_fact()</tt>.</p>\n<pre>import trio\nimport greenback\n\nasync def main():\n    await greenback.ensure_portal()\n    print_fact(10)\n\ndef print_fact(n, mult=1):\n    \"\"\"Print the value of *n* factorial times *mult*.\"\"\"\n    if n &lt;= 1:\n        print_value(mult)\n    else:\n        print_fact(n - 1, mult * n)\n\ndef print_value(n):\n    \"\"\"Print the value *n* in an unreasonably convoluted way.\"\"\"\n    assert isinstance(n, int)\n    greenback.await_(trio.run_process(f\"echo {n}\", shell=True))\n\nif __name__ == \"__main__\":\n    trio.run(main)\n</pre>\n</div>\n<div id=\"faq\">\n<h2>FAQ</h2>\n<p><strong>Why is it called \u201cgreenback\u201d?</strong> It uses the <a href=\"https://greenlet.readthedocs.io/en/latest/\" rel=\"nofollow\">greenlet</a> library to get you\n<em>back</em> to an enclosing async context. Also, maybe it saves you <a href=\"https://www.dictionary.com/browse/greenback\" rel=\"nofollow\">money</a> (engineering time) or\nsomething.</p>\n<p><strong>How does it work?</strong> After you run <tt>await greenback.ensure_portal()</tt>\nin a certain task, each step of that task will run inside a greenlet.\n(This is achieved by interposing a \u201cshim\u201d coroutine in between the event\nloop and the coroutine for your task; see the source code for details.)\nCalls to <tt>greenback.await_()</tt> are then able to switch from that greenlet\nback to the parent greenlet, which can easily perform the necessary\n<tt>await</tt> since it has direct access to the async environment. The\nper-task-step greenlet is then resumed with the value or exception\nproduced by the <tt>await</tt>.</p>\n<p><strong>Should I trust this in production?</strong> Maybe; try it and see. The\ntechnique is in some ways an awful hack, and certainly has performance\nimplications (any task in which you call <tt>await\ngreenback.ensure_portal()</tt> will run somewhat slower).  <tt>greenback</tt>\nitself is a fairly small amount of pure-Python code on top of\n<tt>greenlet</tt>.  (There is one reasonably safe ctypes hack that is necessary\nto work around a knob that\u2019s not exposed by the asyncio acceleration\nextension module on CPython.) <tt>greenlet</tt> is a C module full of arcane\nplatform-specific hacks, but it\u2019s been around for a very long time and\npopular production-quality concurrency systems such as <tt>gevent</tt> rely\nheavily on it.</p>\n<p><strong>What won\u2019t work?</strong> A few things:</p>\n<ul>\n<li>Greenlet switching works by moving parts of the C stack to different\nmemory addresses, relying on the assumption that Python objects are\nfully heap-allocated and don\u2019t contain any pointers into the C\nstack. Poorly-behaved C extension modules might violate this\nassumption and are likely to crash if used with <tt>greenback</tt>.\nSuch extension modules are buggy and could be made to crash without\n<tt>greenback</tt> too, but perhaps only under an obscure or unlikely\nseries of operations.</li>\n<li>Calling <tt>greenback.run()</tt> inside a finalizer (<tt>__del__</tt> method)\nor weakref callback is unsupported. It might work most of the time,\nor even all the time, but the environment in which such methods run\nis weird enough that the author isn\u2019t prepared to make any guarantees.\n(Not that you have any guarantees about the rest of it, just some\nbetter theoretical grounding.)</li>\n</ul>\n</div>\n<div id=\"license\">\n<h2>License</h2>\n<p><tt>greenback</tt> is licensed under your choice of the MIT or Apache 2.0 license.\nSee <a href=\"https://github.com/oremanj/greenback/blob/master/LICENSE\" rel=\"nofollow\">LICENSE</a>\nfor details.</p>\n</div>\n\n          </div>"}, "last_serial": 7153640, "releases": {"0.1.0": [{"comment_text": "", "digests": {"md5": "cf27ff7760f08fee266b808c11629cb8", "sha256": "7f43fc7fd38b9ef0ab0e8a052e78729df10173a2b86f1e05962361f9fa2e3884"}, "downloads": -1, "filename": "greenback-0.1.0-py3-none-any.whl", "has_sig": false, "md5_digest": "cf27ff7760f08fee266b808c11629cb8", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 19939, "upload_time": "2020-05-02T21:51:44", "upload_time_iso_8601": "2020-05-02T21:51:44.170550Z", "url": "https://files.pythonhosted.org/packages/d7/21/a1f2b8c53f5fd896db5def82f98e5d4133ee807026fcbb7b8e5bce7eb4aa/greenback-0.1.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "bb7d923080d8da0198d0179dc8e070da", "sha256": "9c31fc5a40824068fe5550cf13913455563927d62e9d619160301d78fd583413"}, "downloads": -1, "filename": "greenback-0.1.0.tar.gz", "has_sig": false, "md5_digest": "bb7d923080d8da0198d0179dc8e070da", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 31123, "upload_time": "2020-05-02T21:51:46", "upload_time_iso_8601": "2020-05-02T21:51:46.523137Z", "url": "https://files.pythonhosted.org/packages/d4/34/ec728d4d442494345484dad0b54c70dc682c6ecc75414843cf2508e0465d/greenback-0.1.0.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "cf27ff7760f08fee266b808c11629cb8", "sha256": "7f43fc7fd38b9ef0ab0e8a052e78729df10173a2b86f1e05962361f9fa2e3884"}, "downloads": -1, "filename": "greenback-0.1.0-py3-none-any.whl", "has_sig": false, "md5_digest": "cf27ff7760f08fee266b808c11629cb8", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 19939, "upload_time": "2020-05-02T21:51:44", "upload_time_iso_8601": "2020-05-02T21:51:44.170550Z", "url": "https://files.pythonhosted.org/packages/d7/21/a1f2b8c53f5fd896db5def82f98e5d4133ee807026fcbb7b8e5bce7eb4aa/greenback-0.1.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "bb7d923080d8da0198d0179dc8e070da", "sha256": "9c31fc5a40824068fe5550cf13913455563927d62e9d619160301d78fd583413"}, "downloads": -1, "filename": "greenback-0.1.0.tar.gz", "has_sig": false, "md5_digest": "bb7d923080d8da0198d0179dc8e070da", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 31123, "upload_time": "2020-05-02T21:51:46", "upload_time_iso_8601": "2020-05-02T21:51:46.523137Z", "url": "https://files.pythonhosted.org/packages/d4/34/ec728d4d442494345484dad0b54c70dc682c6ecc75414843cf2508e0465d/greenback-0.1.0.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:54:21 2020"}