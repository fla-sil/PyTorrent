{"info": {"author": "ZHANG Jun-Jie, WU Hong-Zhong", "author_email": "zjacob@mail.ustc.edu.cn", "bugtrack_url": null, "classifiers": ["License :: OSI Approved :: Apache Software License", "Operating System :: POSIX :: Linux", "Programming Language :: Python :: 3"], "description": "# ZMCintegral\n\nZMCintegral (Numba backened) is an easy to use python package which uses Monte Carlo Evaluation Method to do numerical integrations on Multi-GPU devices. \nIt supports integrations with up to 16 multi-variables, and it is capable of even more than 16 variables if time is not of the priori concern. \n\n> **To understand how ZMCintegral works, please refer to**\n\n  **https://arxiv.org/pdf/1902.07916v2.pdf**\n\n> **This new version supports parameter grid search, for this new functionality please refer to**\n\n  **??????????**\n\nZMCintegral usually takes a few minutes to finish the task.\n\n## ![#1589F0](https://placehold.it/15/1589F0/000000?text=+) Newest Features\n\n  - Full flexibility of user defined functions\n  - Multi-dimension integration\n  - Multi-GPU supports\n  - Stratified sampling\n  - Heuristic tree search\n  - Parameter grid search\n\n## ![#1589F0](https://placehold.it/15/1589F0/000000?text=+) Installation\n\nTo run ZMCintegral (Numba-Ray version), the following packages needs to be pre-installed:\n  - Numba\n  - Ray\n  - cudatoolkit\n```\n$: conda install numba\n$: conda install cudatoolkit (make sure it is compatable with your driver verison)\n$: pip install -U ray==0.7.1\n```\nZMCintegral can be installed simply via\n```\n$: pip install ZMCintegral\n```\n\n#### Prepare for running ZMCintegral\nFirst of all, prepare machines with Nvidia GPU devices. choose one of them as a head node:\n```\n# for head node\n$: ray start --head --redis-port=6789 --num-cpus=10 --num-gpus=4\n#for other nodes, here the redis-address is the ip of head node.\n$: ray start --redis-address=210.45.78.43:6789 --num-cpus=5 --num-gpus=2\n```\n\n## ![#1589F0](https://placehold.it/15/1589F0/000000?text=+) Integration of 6-dimensionals\n\n#### The integration is of the form\n\n![An image](./pics/sin6d.PNG) <!-- .element height=\"20%\" width=\"20%\" -->\n\n#### whose result can be obtained via\n\n\n![Image of expression 1](./pics/sin6d_theoretical.PNG)\n\n#### In ZMCintegral this is done via\n\n```\nfrom ZMC.ZMCintegral_normal import MCintegral_normal\nimport math\nimport numpy as np\n\nimport time\nstart = time.time()\n\n# user defined function\nfun = \"\"\" \nimport math\n# define a device function that should be used by cuda kernel\n@cuda.jit(device=True)\ndef fun(x):\n    return math.sin(x[0]+x[1]+x[2]+x[3]+x[4]+x[5]+x[6])\n\"\"\"\n\n# define arguments that MCintegral_normal requires\ndepth = 1\nsigma_multiplier = 5\nnum_trials = 5\nnum_chunks_in_one_dimension = 12\n\n# call MCintegral_normal\nMC = MCintegral_normal(my_func = fun, \n                       domain = [[0,10],[0,10],[0,10],[0,10],[0,10],[0,10]], \n                       head_node_address = \"210.45.78.19:1234\",\n                       depth = depth, \n                       sigma_multiplier = sigma_multiplier, \n                       num_trials = num_trials,\n                       num_chunks_in_one_dimension = num_chunks_in_one_dimension)\n\n\n# obtaining the result\nresult = MC.evaluate()\n\n\n# print the formatted result\nprint('result = %s    std = %s' % (result[0], result[1]))\nprint('evaluation time {}'.format(time.time()-start))\n```\n#### The output is\n\n```\ntotal number of GPUs:  1\n140 hypercube(s) need(s) to be recalculated, to save time, try increasing sigma_multiplier.\nresult = -49.47563512703137    std = 1.9873890591413763\nevaluation time 37.8058066368103\n```\n\n## ![#1589F0](https://placehold.it/15/1589F0/000000?text=+) Integration of 4-dimensionals with parameters\n\n#### The integration is of the form\n\n![Image of expression 1](./pics/parameter%20integration.PNG)\n\n#### wohse results can be obtained via\n\n![Image of expression 1](./pics/parameter%20integration%20theoretical.PNG)\n\n#### In ZMCintegral this is done via\n\n```\nfrom ZMC.ZMCintegral_functional import MCintegral_functional\nimport math\nimport numpy as np\n\nimport time\nstart = time.time()\n\n\n# user defined function\nfun = \"\"\" \nimport math\n# define a device function that should be used by cuda kernel\n@cuda.jit(device=True)\ndef fun(x,para):\n    return math.sin(x[0]+x[1]+x[2]+x[3]+para[0]+para[1])\n\"\"\"\n\n# para contains two parameters\npara = [[1,2,3,4,5],[1.1,2.2,3.1]]\n\n\n# sample points is taken to 10**6\nsample_points = 10**6\n\n# the parameter grid has totally 5*3=15 points\n# we choose 3 batches as an example\nbatch_size = 5\n\n# call MCintegral_functional\nMC = MCintegral_functional(my_func = fun, \n                           domain = [[0,1],[0,1],[0,1],[0,1]], \n                           parameters = para, \n                           head_node_address = \"210.45.78.19:1234\",\n                           num_points = sample_points, \n                           batch_size = batch_size)\n\n# obtaining the result\nresult = MC.evaluate()\nresult = print(np.reshape(result,[3,5]))\nprint('evaluation time {}'.format(time.time()-start))\n\n```\n#### The output is (which can be conpared with Mathematica's results)\n```\n<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\nDetected total number of GPUs: 1\nTotal parameter grid size: 15, Each GPU cycle will cover 5 grid values, Total GPU cycles: 3\nEvaluating, please wait...\n[[-0.64027657 -0.81054914 -0.23614549  0.55573641  0.83644859]\n [-0.8100885  -0.23610632  0.55550291  0.83625073  0.34960498]\n [-0.23645369  0.55572789  0.83633015  0.34781143 -0.45968675]]\nevaluation time 4.728282690048218\n```\n\n## ![#1589F0](https://placehold.it/15/1589F0/000000?text=+) - tuning parameters\n\nThe following four parameters can be tuned to fit special cases.\n\n| parameter        | usage           | example           | default  |\n|:-------------:|:-------------:|:-------------:|:-----:|\n| num_trials     | Evaluate the integration for num_trials times. Better kept within 10. | 10 | 5 |\n| depth | For importance sampling. A domain is magnified for depth times. Better kept within 3. |3|2|\n| num_chunks_in_one_dimension     | The number of chunks users want to set along one dimension | 10 | 4 |\n| sigma_multiplier | Only domains that have very large standardand deviations (hence, very unstable) should be magnified and re-evaluated. Domains which are beyond sigma_multiplication * &sigma; should be recalculated.|3|4|\n\n#### Attention\nThe user defined function must be organized in string format as shown in the following example. And the function name in the string mutst be `fun`, something like:\n```\n# user defined function\nfun = \"\"\" \nimport math\n# define a device function that should be used by cuda kernel\n@cuda.jit(device=True)\ndef fun(x): # here the function name must be set as `fun`\n    return xxx\n\"\"\"\n```\n\n## ![#1589F0](https://placehold.it/15/1589F0/000000?text=+) More Help\n\n**One should read the [documentation](https://numba.pydata.org/numba-doc/dev/cuda/index.html) for the Numba package's CUDA capabilities when trying to use this package.** ZMCintegral is only compatible with device functions as Numba does not support dynamic parallelism. This is important when designing the integrated function.\n\nIssues with CUDA should first be resolved by looking at the [CUDA documentation](https://docs.nvidia.com/cuda/index.html).\n\n\n## ![#1589F0](https://placehold.it/15/1589F0/000000?text=+) License\n----\n\nThe package is coded by Jun-Jie Zhang and checked by Hong-Zhong Wu of University of Science and Technology of China.\n\n**This package is free**\nyou can redistribute it and/or modify it under the terms of \nthe Apache License Version 2.0, January 2004 (http://www.apache.org/licenses/).\n\n**File Structure**\n```\nZMCintegral\n\u2502   README.md \n\u2502   LICENSE\n\u2502   setup.py \n\u2502\n\u2514\u2500\u2500\u2500ZMC\n\u2502   \u2502   ZMCintegral_functional.py\n\u2502   \u2502   ZMCintegral_normal.py\n\u2502   \u2502   __init__.py\n\u2502\n\u2514\u2500\u2500\u2500pics\n    \u2502   sin6d.PNG \n    \u2502   sin6d_theoretical.PNG \n\t\u2502   parameter integration.PNG\n\t\u2502   parameter integration theoretical.PNG\n```\n\n[//]: # (These are reference links used in the body of this note and get stripped out when the markdown processor does its job. There is no need to format nicely because it shouldn't be seen. Thanks SO - http://stackoverflow.com/questions/4823468/store-comments-in-markdown-syntax)\n\n\n   [dill]: <https://github.com/joemccann/dillinger>\n   [git-repo-url]: <https://github.com/joemccann/dillinger.git>\n   [john gruber]: <http://daringfireball.net>\n   [df1]: <http://daringfireball.net/projects/markdown/>\n   [markdown-it]: <https://github.com/markdown-it/markdown-it>\n   [Ace Editor]: <http://ace.ajax.org>\n   [node.js]: <http://nodejs.org>\n   [Twitter Bootstrap]: <http://twitter.github.com/bootstrap/>\n   [jQuery]: <http://jquery.com>\n   [@tjholowaychuk]: <http://twitter.com/tjholowaychuk>\n   [express]: <http://expressjs.com>\n   [AngularJS]: <http://angularjs.org>\n   [Gulp]: <http://gulpjs.com>\n\n   [PlDb]: <https://github.com/joemccann/dillinger/tree/master/plugins/dropbox/README.md>\n   [PlGh]: <https://github.com/joemccann/dillinger/tree/master/plugins/github/README.md>\n   [PlGd]: <https://github.com/joemccann/dillinger/tree/master/plugins/googledrive/README.md>\n   [PlOd]: <https://github.com/joemccann/dillinger/tree/master/plugins/onedrive/README.md>\n   [PlMe]: <https://github.com/joemccann/dillinger/tree/master/plugins/medium/README.md>\n   [PlGa]: <https://github.com/RahulHP/dillinger/blob/master/plugins/googleanalytics/README.md>\n\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/Letianwu/ZMCintegral", "keywords": "", "license": "", "maintainer": "", "maintainer_email": "", "name": "ZMCintegral", "package_url": "https://pypi.org/project/ZMCintegral/", "platform": "", "project_url": "https://pypi.org/project/ZMCintegral/", "project_urls": {"Homepage": "https://github.com/Letianwu/ZMCintegral"}, "release_url": "https://pypi.org/project/ZMCintegral/5.0/", "requires_dist": null, "requires_python": ">=3.7", "summary": "An easy way to use multi-GPUs to calculate multi-dimensional integration", "version": "5.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>ZMCintegral</h1>\n<p>ZMCintegral (Numba backened) is an easy to use python package which uses Monte Carlo Evaluation Method to do numerical integrations on Multi-GPU devices.\nIt supports integrations with up to 16 multi-variables, and it is capable of even more than 16 variables if time is not of the priori concern.</p>\n<blockquote>\n<p><strong>To understand how ZMCintegral works, please refer to</strong></p>\n</blockquote>\n<p><strong><a href=\"https://arxiv.org/pdf/1902.07916v2.pdf\" rel=\"nofollow\">https://arxiv.org/pdf/1902.07916v2.pdf</a></strong></p>\n<blockquote>\n<p><strong>This new version supports parameter grid search, for this new functionality please refer to</strong></p>\n</blockquote>\n<p><strong>??????????</strong></p>\n<p>ZMCintegral usually takes a few minutes to finish the task.</p>\n<h2><img alt=\"#1589F0\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/fe93fb0c6854c7a5101b456b3684a682669677e7/68747470733a2f2f706c616365686f6c642e69742f31352f3135383946302f3030303030303f746578743d2b\"> Newest Features</h2>\n<ul>\n<li>Full flexibility of user defined functions</li>\n<li>Multi-dimension integration</li>\n<li>Multi-GPU supports</li>\n<li>Stratified sampling</li>\n<li>Heuristic tree search</li>\n<li>Parameter grid search</li>\n</ul>\n<h2><img alt=\"#1589F0\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/fe93fb0c6854c7a5101b456b3684a682669677e7/68747470733a2f2f706c616365686f6c642e69742f31352f3135383946302f3030303030303f746578743d2b\"> Installation</h2>\n<p>To run ZMCintegral (Numba-Ray version), the following packages needs to be pre-installed:</p>\n<ul>\n<li>Numba</li>\n<li>Ray</li>\n<li>cudatoolkit</li>\n</ul>\n<pre><code>$: conda install numba\n$: conda install cudatoolkit (make sure it is compatable with your driver verison)\n$: pip install -U ray==0.7.1\n</code></pre>\n<p>ZMCintegral can be installed simply via</p>\n<pre><code>$: pip install ZMCintegral\n</code></pre>\n<h4>Prepare for running ZMCintegral</h4>\n<p>First of all, prepare machines with Nvidia GPU devices. choose one of them as a head node:</p>\n<pre><code># for head node\n$: ray start --head --redis-port=6789 --num-cpus=10 --num-gpus=4\n#for other nodes, here the redis-address is the ip of head node.\n$: ray start --redis-address=210.45.78.43:6789 --num-cpus=5 --num-gpus=2\n</code></pre>\n<h2><img alt=\"#1589F0\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/fe93fb0c6854c7a5101b456b3684a682669677e7/68747470733a2f2f706c616365686f6c642e69742f31352f3135383946302f3030303030303f746578743d2b\"> Integration of 6-dimensionals</h2>\n<h4>The integration is of the form</h4>\n<p><img alt=\"An image\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/1065f5339e93997d037ca96b4046ed3cb1e6bf25/2e2f706963732f73696e36642e504e47\"> </p>\n<h4>whose result can be obtained via</h4>\n<p><img alt=\"Image of expression 1\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/eeea07ae8f360639bfedaf77315411e2a49ea086/2e2f706963732f73696e36645f7468656f7265746963616c2e504e47\"></p>\n<h4>In ZMCintegral this is done via</h4>\n<pre><code>from ZMC.ZMCintegral_normal import MCintegral_normal\nimport math\nimport numpy as np\n\nimport time\nstart = time.time()\n\n# user defined function\nfun = \"\"\" \nimport math\n# define a device function that should be used by cuda kernel\n@cuda.jit(device=True)\ndef fun(x):\n    return math.sin(x[0]+x[1]+x[2]+x[3]+x[4]+x[5]+x[6])\n\"\"\"\n\n# define arguments that MCintegral_normal requires\ndepth = 1\nsigma_multiplier = 5\nnum_trials = 5\nnum_chunks_in_one_dimension = 12\n\n# call MCintegral_normal\nMC = MCintegral_normal(my_func = fun, \n                       domain = [[0,10],[0,10],[0,10],[0,10],[0,10],[0,10]], \n                       head_node_address = \"210.45.78.19:1234\",\n                       depth = depth, \n                       sigma_multiplier = sigma_multiplier, \n                       num_trials = num_trials,\n                       num_chunks_in_one_dimension = num_chunks_in_one_dimension)\n\n\n# obtaining the result\nresult = MC.evaluate()\n\n\n# print the formatted result\nprint('result = %s    std = %s' % (result[0], result[1]))\nprint('evaluation time {}'.format(time.time()-start))\n</code></pre>\n<h4>The output is</h4>\n<pre><code>total number of GPUs:  1\n140 hypercube(s) need(s) to be recalculated, to save time, try increasing sigma_multiplier.\nresult = -49.47563512703137    std = 1.9873890591413763\nevaluation time 37.8058066368103\n</code></pre>\n<h2><img alt=\"#1589F0\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/fe93fb0c6854c7a5101b456b3684a682669677e7/68747470733a2f2f706c616365686f6c642e69742f31352f3135383946302f3030303030303f746578743d2b\"> Integration of 4-dimensionals with parameters</h2>\n<h4>The integration is of the form</h4>\n<p><img alt=\"Image of expression 1\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/e380b2bfa442fdea851389f6470df18a04c53465/2e2f706963732f706172616d65746572253230696e746567726174696f6e2e504e47\"></p>\n<h4>wohse results can be obtained via</h4>\n<p><img alt=\"Image of expression 1\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/baf75d4b7bf4f010a785cd6c5ee4989e029bf286/2e2f706963732f706172616d65746572253230696e746567726174696f6e2532307468656f7265746963616c2e504e47\"></p>\n<h4>In ZMCintegral this is done via</h4>\n<pre><code>from ZMC.ZMCintegral_functional import MCintegral_functional\nimport math\nimport numpy as np\n\nimport time\nstart = time.time()\n\n\n# user defined function\nfun = \"\"\" \nimport math\n# define a device function that should be used by cuda kernel\n@cuda.jit(device=True)\ndef fun(x,para):\n    return math.sin(x[0]+x[1]+x[2]+x[3]+para[0]+para[1])\n\"\"\"\n\n# para contains two parameters\npara = [[1,2,3,4,5],[1.1,2.2,3.1]]\n\n\n# sample points is taken to 10**6\nsample_points = 10**6\n\n# the parameter grid has totally 5*3=15 points\n# we choose 3 batches as an example\nbatch_size = 5\n\n# call MCintegral_functional\nMC = MCintegral_functional(my_func = fun, \n                           domain = [[0,1],[0,1],[0,1],[0,1]], \n                           parameters = para, \n                           head_node_address = \"210.45.78.19:1234\",\n                           num_points = sample_points, \n                           batch_size = batch_size)\n\n# obtaining the result\nresult = MC.evaluate()\nresult = print(np.reshape(result,[3,5]))\nprint('evaluation time {}'.format(time.time()-start))\n\n</code></pre>\n<h4>The output is (which can be conpared with Mathematica's results)</h4>\n<pre><code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\nDetected total number of GPUs: 1\nTotal parameter grid size: 15, Each GPU cycle will cover 5 grid values, Total GPU cycles: 3\nEvaluating, please wait...\n[[-0.64027657 -0.81054914 -0.23614549  0.55573641  0.83644859]\n [-0.8100885  -0.23610632  0.55550291  0.83625073  0.34960498]\n [-0.23645369  0.55572789  0.83633015  0.34781143 -0.45968675]]\nevaluation time 4.728282690048218\n</code></pre>\n<h2><img alt=\"#1589F0\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/fe93fb0c6854c7a5101b456b3684a682669677e7/68747470733a2f2f706c616365686f6c642e69742f31352f3135383946302f3030303030303f746578743d2b\"> - tuning parameters</h2>\n<p>The following four parameters can be tuned to fit special cases.</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">parameter</th>\n<th align=\"center\">usage</th>\n<th align=\"center\">example</th>\n<th align=\"center\">default</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"center\">num_trials</td>\n<td align=\"center\">Evaluate the integration for num_trials times. Better kept within 10.</td>\n<td align=\"center\">10</td>\n<td align=\"center\">5</td>\n</tr>\n<tr>\n<td align=\"center\">depth</td>\n<td align=\"center\">For importance sampling. A domain is magnified for depth times. Better kept within 3.</td>\n<td align=\"center\">3</td>\n<td align=\"center\">2</td>\n</tr>\n<tr>\n<td align=\"center\">num_chunks_in_one_dimension</td>\n<td align=\"center\">The number of chunks users want to set along one dimension</td>\n<td align=\"center\">10</td>\n<td align=\"center\">4</td>\n</tr>\n<tr>\n<td align=\"center\">sigma_multiplier</td>\n<td align=\"center\">Only domains that have very large standardand deviations (hence, very unstable) should be magnified and re-evaluated. Domains which are beyond sigma_multiplication * \u03c3 should be recalculated.</td>\n<td align=\"center\">3</td>\n<td align=\"center\">4</td>\n</tr></tbody></table>\n<h4>Attention</h4>\n<p>The user defined function must be organized in string format as shown in the following example. And the function name in the string mutst be <code>fun</code>, something like:</p>\n<pre><code># user defined function\nfun = \"\"\" \nimport math\n# define a device function that should be used by cuda kernel\n@cuda.jit(device=True)\ndef fun(x): # here the function name must be set as `fun`\n    return xxx\n\"\"\"\n</code></pre>\n<h2><img alt=\"#1589F0\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/fe93fb0c6854c7a5101b456b3684a682669677e7/68747470733a2f2f706c616365686f6c642e69742f31352f3135383946302f3030303030303f746578743d2b\"> More Help</h2>\n<p><strong>One should read the <a href=\"https://numba.pydata.org/numba-doc/dev/cuda/index.html\" rel=\"nofollow\">documentation</a> for the Numba package's CUDA capabilities when trying to use this package.</strong> ZMCintegral is only compatible with device functions as Numba does not support dynamic parallelism. This is important when designing the integrated function.</p>\n<p>Issues with CUDA should first be resolved by looking at the <a href=\"https://docs.nvidia.com/cuda/index.html\" rel=\"nofollow\">CUDA documentation</a>.</p>\n<h2><img alt=\"#1589F0\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/fe93fb0c6854c7a5101b456b3684a682669677e7/68747470733a2f2f706c616365686f6c642e69742f31352f3135383946302f3030303030303f746578743d2b\"> License</h2>\n<hr>\n<p>The package is coded by Jun-Jie Zhang and checked by Hong-Zhong Wu of University of Science and Technology of China.</p>\n<p><strong>This package is free</strong>\nyou can redistribute it and/or modify it under the terms of\nthe Apache License Version 2.0, January 2004 (<a href=\"http://www.apache.org/licenses/\" rel=\"nofollow\">http://www.apache.org/licenses/</a>).</p>\n<p><strong>File Structure</strong></p>\n<pre><code>ZMCintegral\n\u2502   README.md \n\u2502   LICENSE\n\u2502   setup.py \n\u2502\n\u2514\u2500\u2500\u2500ZMC\n\u2502   \u2502   ZMCintegral_functional.py\n\u2502   \u2502   ZMCintegral_normal.py\n\u2502   \u2502   __init__.py\n\u2502\n\u2514\u2500\u2500\u2500pics\n    \u2502   sin6d.PNG \n    \u2502   sin6d_theoretical.PNG \n\t\u2502   parameter integration.PNG\n\t\u2502   parameter integration theoretical.PNG\n</code></pre>\n\n          </div>"}, "last_serial": 5928730, "releases": {"5.0": [{"comment_text": "", "digests": {"md5": "b73690bcd88d517586aa312c45cd1510", "sha256": "94cad54724d492e378025c5c5ffd838fa625c520d6b59767cc902b340a5809ca"}, "downloads": -1, "filename": "ZMCintegral-5.0-py3-none-any.whl", "has_sig": false, "md5_digest": "b73690bcd88d517586aa312c45cd1510", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.7", "size": 15317, "upload_time": "2019-10-04T14:39:33", "upload_time_iso_8601": "2019-10-04T14:39:33.102779Z", "url": "https://files.pythonhosted.org/packages/30/60/71ef3afb93472fd0453bbf7ee386136e68c020f1372964ea344f5af9c0e7/ZMCintegral-5.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "4b6062abbbfd4b4e7f32e690b7647671", "sha256": "2401e5c19b15db849520e9937afc9a8b9d7681d7ed4b4fa2984806d66ccc1e04"}, "downloads": -1, "filename": "ZMCintegral-5.0.tar.gz", "has_sig": false, "md5_digest": "4b6062abbbfd4b4e7f32e690b7647671", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.7", "size": 12975, "upload_time": "2019-10-04T14:39:36", "upload_time_iso_8601": "2019-10-04T14:39:36.025230Z", "url": "https://files.pythonhosted.org/packages/d2/f9/78e3f0d73c2dbeb7f36bef9a81d4b4d9fa308538536cd5228a857f399938/ZMCintegral-5.0.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "b73690bcd88d517586aa312c45cd1510", "sha256": "94cad54724d492e378025c5c5ffd838fa625c520d6b59767cc902b340a5809ca"}, "downloads": -1, "filename": "ZMCintegral-5.0-py3-none-any.whl", "has_sig": false, "md5_digest": "b73690bcd88d517586aa312c45cd1510", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.7", "size": 15317, "upload_time": "2019-10-04T14:39:33", "upload_time_iso_8601": "2019-10-04T14:39:33.102779Z", "url": "https://files.pythonhosted.org/packages/30/60/71ef3afb93472fd0453bbf7ee386136e68c020f1372964ea344f5af9c0e7/ZMCintegral-5.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "4b6062abbbfd4b4e7f32e690b7647671", "sha256": "2401e5c19b15db849520e9937afc9a8b9d7681d7ed4b4fa2984806d66ccc1e04"}, "downloads": -1, "filename": "ZMCintegral-5.0.tar.gz", "has_sig": false, "md5_digest": "4b6062abbbfd4b4e7f32e690b7647671", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.7", "size": 12975, "upload_time": "2019-10-04T14:39:36", "upload_time_iso_8601": "2019-10-04T14:39:36.025230Z", "url": "https://files.pythonhosted.org/packages/d2/f9/78e3f0d73c2dbeb7f36bef9a81d4b4d9fa308538536cd5228a857f399938/ZMCintegral-5.0.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:15:32 2020"}