{"info": {"author": "Philip J Grabner, Canary Health Inc", "author_email": "oss-pypi@canary.md", "bugtrack_url": null, "classifiers": ["Environment :: Console", "Environment :: Web Environment", "Framework :: Pyramid", "Intended Audience :: Developers", "License :: OSI Approved :: MIT License", "License :: Public Domain", "Natural Language :: English", "Operating System :: OS Independent", "Programming Language :: Python", "Topic :: Internet", "Topic :: Internet :: WWW/HTTP", "Topic :: Internet :: WWW/HTTP :: WSGI", "Topic :: Software Development", "Topic :: Software Development :: Libraries :: Application Frameworks"], "description": "=============\nPyramid Input\n=============\n\nThe ``pyramid_input`` package is a pyramid plugin that adds a \"tween\"\nthat parses and combines all data presented in the HTTP request in one\nstandardized request attribute. The following data is currently accepted\n(in increasing order of precedence):\n\n* Query string parameters\n* Request payload (i.e. the \"request body\") in several different formats\n\nSee `Example`_ for a detailed example.\n\n\nProject\n=======\n\n* Homepage: https://github.com/canaryhealth/pyramid_input\n* Bugs: https://github.com/canaryhealth/pyramid_input/issues\n\n\nInstallation\n============\n\n.. code:: bash\n\n  $ pip install pyramid_input\n\n\nUsage\n=====\n\nEnable the tween either in your INI file via:\n\n.. code:: ini\n\n  pyramid.includes = pyramid_input\n\nor in code in your package's application initialization via:\n\n.. code:: python\n\n  def main(global_config, **settings):\n    # ...\n    config.include('pyramid_input')\n    # ...\n\nIf needed, adjust pyramid_input's behaviour by setting the various\n`Configuration`_ options in your INI file.\n\nThen, access a request's input parameters, regardless of their\norigin or encoding, simply as:\n\n.. code:: python\n\n  def request_handler(request):\n\n    if request.input.somekey == 'some-value':\n      ...\n\n\nExample\n=======\n\nThe pyramid_input tween makes all of the following requests present\nthe identical structure in the `request.input` attribute:\n\nInterpreting GET data:\n\n.. code:: text\n\n  GET /path?foo=bar&zig.zag=zog&zig.zen-0=mig&zig.zen-1=mag\n\nInterpreting and merging GET and POST form data:\n\n.. code:: text\n\n  POST /path?foo=bar\n  Content-Type: application/x-www-form-urlencoded\n\n  zig.zag=zog&zig.zen-0=mig&zig.zen-1=mag\n\nInterpreting and merging GET and JSON payload data:\n\n.. code:: text\n\n  POST /path?foo=bar\n  Content-Type: application/json\n\n  {\"zig\": {\"zag\": \"zog\", \"zen\": [\"mig\", \"mag\"]}}\n\nInterpreting and merging GET and YAML payload data:\n\n.. code:: text\n\n  POST /path?foo=bar\n  Content-Type: application/yaml\n\n  zig:\n    zag: zog\n    zen:\n      - mig\n      - mag\n\nInterpreting and merging GET and XML payload data:\n\n.. code:: text\n\n  POST /path?foo=bar\n  Content-Type: application/xml\n\n  <zig>\n    <zag>zog</zag>\n    <zen>mig</zen>\n    <zen>mag</zen>\n  </zig>\n\nAll of the above will result in the identical data structure being\ncontained in the `request.input` attribute:\n\n.. code:: python\n\n  request.input = {\n    'foo': 'bar',\n    'zig': {\n      'zag': 'zog',\n      'zen': ['mig', 'mag']\n    }\n  }\n\nPlease note that in all cases the original parameters (in\n`request.GET`, `request.POST`, `request.params`, `request.body` and\n`request.json_body`) are left as-is, so if the raw data is needed, it\ncan be accessed directly.\n\n\nQuery String Parsing\n====================\n\nThe HTTP query string parameters are \"unflattened\" using FormEncode's\n`variable_decode` implementation, which converts the key-value pairs\ninto a nested tree structure. For example, the following query string\nparameters:\n\n.. code:: text\n\n  ?simple=val1&dict.subkey=val2&dict.list-0=el0&dict.list-1=el1\n\nis transformed into the structure:\n\n.. code:: yaml\n\n   {\n     simple: val1\n     dict: {\n       subkey: val2\n       list: [ el0, el1 ]\n     }\n   }\n\nNote that query string parameters are by default overwritten by any\nHTTP request payload data.\n\n\nPayload Parsing\n===============\n\nThe request payload (aka. request body) is parsed when the request's\n``Content-Type`` is one of the following values:\n\n* ``application/x-www-form-urlencoded``, ``multipart/form-data``\n\n  The standard HTTP `POST` encoding; the key-value pairs are parsed\n  exactly the same way as the query string, i.e. they are unflattened\n  using FormEncode's `variable_decode` implementation. Note that for\n  ``multipart/form-data`` (the content-type used for standard\n  HTTP-based file uploading), nothing special is done: the `file`\n  object that is in `request.POST` is simply referenced as-is in\n  `request.input` as well.\n\n* ``application/json``, ``application/x-json``, ``text/json``, ``text/x-json``, ``...+json``\n\n  The payload is parsed using the built-in JSON parser, and no further\n  processing is done. The data is required to be a dictionary unless\n  the `pyramid_input.require-dict` is set to false, and if this is\n  violated, request processing is aborted with a 400 \"Bad Request\"\n  response error.\n\n* ``application/yaml``, ``application/x-yaml``, ``text/yaml``, ``text/x-yaml``, ``...+yaml``\n\n  If the `PyYAML` package is available, the payload is parsed using\n  the YAML parser, and no further processing is done. The data is\n  required to be a dictionary unless the `pyramid_input.require-dict`\n  is set to false, and if this is violated, request processing is\n  aborted with a 400 \"Bad Request\" response error.\n\n* ``application/xml``, ``application/x-xml``, ``text/xml``, ``text/x-xml``, ``...+xml``\n\n  The payload is parsed using the built-in ElementTree parser and the\n  XML document is converted to a tree via a fairly simplistic mapping\n  process. Note that this mapping process is \"lossy\", i.e. some\n  aspects of the XML serialization (such as order of interleaved\n  non-similar children nodes) are lost in the convertion.\n\n\nCombination\n===========\n\nWhen both query string paramaters and a payload is specified in the\nrequest, the output of parsing both data sources are then combined\ntogether to form a single data tree. By default (i.e. when\n`pyramid_input.combine.deep` is true), the payload data overrides the\nquery string data by overlaying and merging the two tree structures\nrecursively.\n\nA recursive deep merge basically means that dict keys get merged with\ndict keys, and all other type combinations turn into lists.\n\nThe deep merge can be disabled by setting the\n`pyramid_input.combine.deep` option to false, in which case the\npayload top-level dict keys completely override the query string\ntop-level keys, without any inspection of sub-keys.\n\nFor example, given the following query string tree structure:\n\n.. code:: yaml\n\n  foo: bar\n  dict:\n    list: [a, b]\n    item: c\n\nand the following payload tree structure:\n\n.. code:: yaml\n\n  bar: foo\n  dict:\n    list: d  \n    item: e\n\na deep merge will result in:\n\n.. code:: yaml\n\n  foo: bar\n  bar: foo\n  dict:\n    list: [a, b, d]\n    item: [c, e]\n\nand a non-deep merge will result in:\n\n.. code:: yaml\n\n  foo: bar\n  bar: foo\n  dict:\n    list: d\n    item: e\n\n\nConfiguration\n=============\n\nThe following configuration settings can be set in your application's\n``main`` section:\n\n* ``pyramid_input.enabled`` : bool, default: true\n\n* ``pyramid_input.attribute-name`` : str, default: 'input'\n\n* ``pyramid_input.combine.deep`` : bool, default: true\n\n* ``pyramid_input.include`` : list(glob), default: `/**`\n\n* ``pyramid_input.exclude`` : list(glob), default: null\n\n* ``pyramid_input.require-dict`` : bool, default: true\n\n* ``pyramid_input.fail-unknown`` : bool, default: true\n\n  If the request's Content-Type is unknown (or its parser disabled)\n  and `pyramid_input.fail-unknown` is true, a 400 \"bad request\" error\n  is returned.  If set to false, the payload is ignored.\n\n* ``pyramid_input.native-dict`` : bool, default: false\n\n  If true, `request.input` will be a standard python `dict` object.\n  If false (the default), then it will be a recursive `aadict` object\n  (which is a subclass of dict that supports attribute-based access to\n  its items).\n\n* ``pyramid_input.error-handler`` : symbol-spec, default: null\n\n  On error (such as a 400 \"Bad Request\" for invalid JSON), this\n  function is called with the `pyramid.httpexceptions.Exception`\n  subclass that caused the error. The default implementation has\n  this function signature equivalent:\n\n  .. code:: python\n\n    def function(request, error):\n      return error\n\n* ``pyramid_input.reparse-methods`` : list(str), default: 'PATCH'\n\n  Enable a workaround for pyramid 1.4.2+ that does not properly parse\n  the `application/x-www-form-urlencoded` request body if the request\n  method is PATCH. It is unknown if other methods have this issue or\n  if it has been fixed.\n\n* ``pyramid_input.json.enable`` : bool, default: true\n\n* ``pyramid_input.json.parser`` : symbol-spec, default: null\n\n  Specifies the JSON parser. If not specified, uses Pyramid's\n  pre-existing ``Request.json_body`` attribute.\n\n* ``pyramid_input.yaml.enable`` : bool, default: true\n\n* ``pyramid_input.yaml.parser`` : symbol-spec, default: 'yaml.load'\n\n* ``pyramid_input.xml.enable`` : bool, default: true\n\n* ``pyramid_input.xml.parser`` : symbol-spec, default: 'xml.etree.ElementTree.fromstring'\n", "description_content_type": null, "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "http://github.com/canaryhealth/pyramid_input", "keywords": "web wsgi pyramid http input data normalize get post json yaml xml", "license": "MIT (http://opensource.org/licenses/MIT)", "maintainer": "", "maintainer_email": "", "name": "pyramid_input", "package_url": "https://pypi.org/project/pyramid_input/", "platform": "", "project_url": "https://pypi.org/project/pyramid_input/", "project_urls": {"Homepage": "http://github.com/canaryhealth/pyramid_input"}, "release_url": "https://pypi.org/project/pyramid_input/0.2.3/", "requires_dist": null, "requires_python": "", "summary": "A Pyramid tween that normalizes HTTP request input data.", "version": "0.2.3", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p>The <tt>pyramid_input</tt> package is a pyramid plugin that adds a \u201ctween\u201d\nthat parses and combines all data presented in the HTTP request in one\nstandardized request attribute. The following data is currently accepted\n(in increasing order of precedence):</p>\n<ul>\n<li>Query string parameters</li>\n<li>Request payload (i.e. the \u201crequest body\u201d) in several different formats</li>\n</ul>\n<p>See <a href=\"#example\" rel=\"nofollow\">Example</a> for a detailed example.</p>\n<div id=\"project\">\n<h2>Project</h2>\n<ul>\n<li>Homepage: <a href=\"https://github.com/canaryhealth/pyramid_input\" rel=\"nofollow\">https://github.com/canaryhealth/pyramid_input</a></li>\n<li>Bugs: <a href=\"https://github.com/canaryhealth/pyramid_input/issues\" rel=\"nofollow\">https://github.com/canaryhealth/pyramid_input/issues</a></li>\n</ul>\n</div>\n<div id=\"installation\">\n<h2>Installation</h2>\n<pre>$ pip install pyramid_input\n</pre>\n</div>\n<div id=\"usage\">\n<h2>Usage</h2>\n<p>Enable the tween either in your INI file via:</p>\n<pre><span class=\"na\">pyramid.includes</span> <span class=\"o\">=</span> <span class=\"s\">pyramid_input</span>\n</pre>\n<p>or in code in your package\u2019s application initialization via:</p>\n<pre><span class=\"k\">def</span> <span class=\"nf\">main</span><span class=\"p\">(</span><span class=\"n\">global_config</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">settings</span><span class=\"p\">):</span>\n  <span class=\"c1\"># ...</span>\n  <span class=\"n\">config</span><span class=\"o\">.</span><span class=\"n\">include</span><span class=\"p\">(</span><span class=\"s1\">'pyramid_input'</span><span class=\"p\">)</span>\n  <span class=\"c1\"># ...</span>\n</pre>\n<p>If needed, adjust pyramid_input\u2019s behaviour by setting the various\n<a href=\"#configuration\" rel=\"nofollow\">Configuration</a> options in your INI file.</p>\n<p>Then, access a request\u2019s input parameters, regardless of their\norigin or encoding, simply as:</p>\n<pre><span class=\"k\">def</span> <span class=\"nf\">request_handler</span><span class=\"p\">(</span><span class=\"n\">request</span><span class=\"p\">):</span>\n\n  <span class=\"k\">if</span> <span class=\"n\">request</span><span class=\"o\">.</span><span class=\"n\">input</span><span class=\"o\">.</span><span class=\"n\">somekey</span> <span class=\"o\">==</span> <span class=\"s1\">'some-value'</span><span class=\"p\">:</span>\n    <span class=\"o\">...</span>\n</pre>\n</div>\n<div id=\"example\">\n<h2>Example</h2>\n<p>The pyramid_input tween makes all of the following requests present\nthe identical structure in the <cite>request.input</cite> attribute:</p>\n<p>Interpreting GET data:</p>\n<pre>GET /path?foo=bar&amp;zig.zag=zog&amp;zig.zen-0=mig&amp;zig.zen-1=mag\n</pre>\n<p>Interpreting and merging GET and POST form data:</p>\n<pre>POST /path?foo=bar\nContent-Type: application/x-www-form-urlencoded\n\nzig.zag=zog&amp;zig.zen-0=mig&amp;zig.zen-1=mag\n</pre>\n<p>Interpreting and merging GET and JSON payload data:</p>\n<pre>POST /path?foo=bar\nContent-Type: application/json\n\n{\"zig\": {\"zag\": \"zog\", \"zen\": [\"mig\", \"mag\"]}}\n</pre>\n<p>Interpreting and merging GET and YAML payload data:</p>\n<pre>POST /path?foo=bar\nContent-Type: application/yaml\n\nzig:\n  zag: zog\n  zen:\n    - mig\n    - mag\n</pre>\n<p>Interpreting and merging GET and XML payload data:</p>\n<pre>POST /path?foo=bar\nContent-Type: application/xml\n\n&lt;zig&gt;\n  &lt;zag&gt;zog&lt;/zag&gt;\n  &lt;zen&gt;mig&lt;/zen&gt;\n  &lt;zen&gt;mag&lt;/zen&gt;\n&lt;/zig&gt;\n</pre>\n<p>All of the above will result in the identical data structure being\ncontained in the <cite>request.input</cite> attribute:</p>\n<pre><span class=\"n\">request</span><span class=\"o\">.</span><span class=\"n\">input</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n  <span class=\"s1\">'foo'</span><span class=\"p\">:</span> <span class=\"s1\">'bar'</span><span class=\"p\">,</span>\n  <span class=\"s1\">'zig'</span><span class=\"p\">:</span> <span class=\"p\">{</span>\n    <span class=\"s1\">'zag'</span><span class=\"p\">:</span> <span class=\"s1\">'zog'</span><span class=\"p\">,</span>\n    <span class=\"s1\">'zen'</span><span class=\"p\">:</span> <span class=\"p\">[</span><span class=\"s1\">'mig'</span><span class=\"p\">,</span> <span class=\"s1\">'mag'</span><span class=\"p\">]</span>\n  <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</pre>\n<p>Please note that in all cases the original parameters (in\n<cite>request.GET</cite>, <cite>request.POST</cite>, <cite>request.params</cite>, <cite>request.body</cite> and\n<cite>request.json_body</cite>) are left as-is, so if the raw data is needed, it\ncan be accessed directly.</p>\n</div>\n<div id=\"query-string-parsing\">\n<h2>Query String Parsing</h2>\n<p>The HTTP query string parameters are \u201cunflattened\u201d using FormEncode\u2019s\n<cite>variable_decode</cite> implementation, which converts the key-value pairs\ninto a nested tree structure. For example, the following query string\nparameters:</p>\n<pre>?simple=val1&amp;dict.subkey=val2&amp;dict.list-0=el0&amp;dict.list-1=el1\n</pre>\n<p>is transformed into the structure:</p>\n<pre><span class=\"p-Indicator\">{</span>\n<span class=\"nt\">  simple</span><span class=\"p\">:</span> <span class=\"nv\">val1</span>\n  <span class=\"nv\">dict</span><span class=\"p-Indicator\">:</span> <span class=\"p-Indicator\">{</span>\n<span class=\"nt\">    subkey</span><span class=\"p\">:</span> <span class=\"nv\">val2</span>\n    <span class=\"nv\">list</span><span class=\"p-Indicator\">:</span> <span class=\"p-Indicator\">[</span> <span class=\"nv\">el0</span><span class=\"p-Indicator\">,</span> <span class=\"nv\">el1</span> <span class=\"p-Indicator\">]</span>\n  <span class=\"p-Indicator\">}</span>\n<span class=\"p-Indicator\">}</span>\n</pre>\n<p>Note that query string parameters are by default overwritten by any\nHTTP request payload data.</p>\n</div>\n<div id=\"payload-parsing\">\n<h2>Payload Parsing</h2>\n<p>The request payload (aka. request body) is parsed when the request\u2019s\n<tt><span class=\"pre\">Content-Type</span></tt> is one of the following values:</p>\n<ul>\n<li><p><tt><span class=\"pre\">application/x-www-form-urlencoded</span></tt>, <tt><span class=\"pre\">multipart/form-data</span></tt></p>\n<p>The standard HTTP <cite>POST</cite> encoding; the key-value pairs are parsed\nexactly the same way as the query string, i.e. they are unflattened\nusing FormEncode\u2019s <cite>variable_decode</cite> implementation. Note that for\n<tt><span class=\"pre\">multipart/form-data</span></tt> (the content-type used for standard\nHTTP-based file uploading), nothing special is done: the <cite>file</cite>\nobject that is in <cite>request.POST</cite> is simply referenced as-is in\n<cite>request.input</cite> as well.</p>\n</li>\n<li><p><tt>application/json</tt>, <tt><span class=\"pre\">application/x-json</span></tt>, <tt>text/json</tt>, <tt><span class=\"pre\">text/x-json</span></tt>, <tt><span class=\"pre\">...+json</span></tt></p>\n<p>The payload is parsed using the built-in JSON parser, and no further\nprocessing is done. The data is required to be a dictionary unless\nthe <cite>pyramid_input.require-dict</cite> is set to false, and if this is\nviolated, request processing is aborted with a 400 \u201cBad Request\u201d\nresponse error.</p>\n</li>\n<li><p><tt>application/yaml</tt>, <tt><span class=\"pre\">application/x-yaml</span></tt>, <tt>text/yaml</tt>, <tt><span class=\"pre\">text/x-yaml</span></tt>, <tt><span class=\"pre\">...+yaml</span></tt></p>\n<p>If the <cite>PyYAML</cite> package is available, the payload is parsed using\nthe YAML parser, and no further processing is done. The data is\nrequired to be a dictionary unless the <cite>pyramid_input.require-dict</cite>\nis set to false, and if this is violated, request processing is\naborted with a 400 \u201cBad Request\u201d response error.</p>\n</li>\n<li><p><tt>application/xml</tt>, <tt><span class=\"pre\">application/x-xml</span></tt>, <tt>text/xml</tt>, <tt><span class=\"pre\">text/x-xml</span></tt>, <tt><span class=\"pre\">...+xml</span></tt></p>\n<p>The payload is parsed using the built-in ElementTree parser and the\nXML document is converted to a tree via a fairly simplistic mapping\nprocess. Note that this mapping process is \u201clossy\u201d, i.e. some\naspects of the XML serialization (such as order of interleaved\nnon-similar children nodes) are lost in the convertion.</p>\n</li>\n</ul>\n</div>\n<div id=\"combination\">\n<h2>Combination</h2>\n<p>When both query string paramaters and a payload is specified in the\nrequest, the output of parsing both data sources are then combined\ntogether to form a single data tree. By default (i.e. when\n<cite>pyramid_input.combine.deep</cite> is true), the payload data overrides the\nquery string data by overlaying and merging the two tree structures\nrecursively.</p>\n<p>A recursive deep merge basically means that dict keys get merged with\ndict keys, and all other type combinations turn into lists.</p>\n<p>The deep merge can be disabled by setting the\n<cite>pyramid_input.combine.deep</cite> option to false, in which case the\npayload top-level dict keys completely override the query string\ntop-level keys, without any inspection of sub-keys.</p>\n<p>For example, given the following query string tree structure:</p>\n<pre><span class=\"nt\">foo</span><span class=\"p\">:</span> <span class=\"l-Scalar-Plain\">bar</span>\n<span class=\"nt\">dict</span><span class=\"p\">:</span>\n  <span class=\"nt\">list</span><span class=\"p\">:</span> <span class=\"p-Indicator\">[</span><span class=\"nv\">a</span><span class=\"p-Indicator\">,</span> <span class=\"nv\">b</span><span class=\"p-Indicator\">]</span>\n  <span class=\"nt\">item</span><span class=\"p\">:</span> <span class=\"l-Scalar-Plain\">c</span>\n</pre>\n<p>and the following payload tree structure:</p>\n<pre><span class=\"nt\">bar</span><span class=\"p\">:</span> <span class=\"l-Scalar-Plain\">foo</span>\n<span class=\"nt\">dict</span><span class=\"p\">:</span>\n  <span class=\"nt\">list</span><span class=\"p\">:</span> <span class=\"l-Scalar-Plain\">d</span>\n  <span class=\"nt\">item</span><span class=\"p\">:</span> <span class=\"l-Scalar-Plain\">e</span>\n</pre>\n<p>a deep merge will result in:</p>\n<pre><span class=\"nt\">foo</span><span class=\"p\">:</span> <span class=\"l-Scalar-Plain\">bar</span>\n<span class=\"nt\">bar</span><span class=\"p\">:</span> <span class=\"l-Scalar-Plain\">foo</span>\n<span class=\"nt\">dict</span><span class=\"p\">:</span>\n  <span class=\"nt\">list</span><span class=\"p\">:</span> <span class=\"p-Indicator\">[</span><span class=\"nv\">a</span><span class=\"p-Indicator\">,</span> <span class=\"nv\">b</span><span class=\"p-Indicator\">,</span> <span class=\"nv\">d</span><span class=\"p-Indicator\">]</span>\n  <span class=\"nt\">item</span><span class=\"p\">:</span> <span class=\"p-Indicator\">[</span><span class=\"nv\">c</span><span class=\"p-Indicator\">,</span> <span class=\"nv\">e</span><span class=\"p-Indicator\">]</span>\n</pre>\n<p>and a non-deep merge will result in:</p>\n<pre><span class=\"nt\">foo</span><span class=\"p\">:</span> <span class=\"l-Scalar-Plain\">bar</span>\n<span class=\"nt\">bar</span><span class=\"p\">:</span> <span class=\"l-Scalar-Plain\">foo</span>\n<span class=\"nt\">dict</span><span class=\"p\">:</span>\n  <span class=\"nt\">list</span><span class=\"p\">:</span> <span class=\"l-Scalar-Plain\">d</span>\n  <span class=\"nt\">item</span><span class=\"p\">:</span> <span class=\"l-Scalar-Plain\">e</span>\n</pre>\n</div>\n<div id=\"configuration\">\n<h2>Configuration</h2>\n<p>The following configuration settings can be set in your application\u2019s\n<tt>main</tt> section:</p>\n<ul>\n<li><p><tt>pyramid_input.enabled</tt> : bool, default: true</p>\n</li>\n<li><p><tt><span class=\"pre\">pyramid_input.attribute-name</span></tt> : str, default: \u2018input\u2019</p>\n</li>\n<li><p><tt>pyramid_input.combine.deep</tt> : bool, default: true</p>\n</li>\n<li><p><tt>pyramid_input.include</tt> : list(glob), default: <cite>/**</cite></p>\n</li>\n<li><p><tt>pyramid_input.exclude</tt> : list(glob), default: null</p>\n</li>\n<li><p><tt><span class=\"pre\">pyramid_input.require-dict</span></tt> : bool, default: true</p>\n</li>\n<li><p><tt><span class=\"pre\">pyramid_input.fail-unknown</span></tt> : bool, default: true</p>\n<p>If the request\u2019s Content-Type is unknown (or its parser disabled)\nand <cite>pyramid_input.fail-unknown</cite> is true, a 400 \u201cbad request\u201d error\nis returned.  If set to false, the payload is ignored.</p>\n</li>\n<li><p><tt><span class=\"pre\">pyramid_input.native-dict</span></tt> : bool, default: false</p>\n<p>If true, <cite>request.input</cite> will be a standard python <cite>dict</cite> object.\nIf false (the default), then it will be a recursive <cite>aadict</cite> object\n(which is a subclass of dict that supports attribute-based access to\nits items).</p>\n</li>\n<li><p><tt><span class=\"pre\">pyramid_input.error-handler</span></tt> : symbol-spec, default: null</p>\n<p>On error (such as a 400 \u201cBad Request\u201d for invalid JSON), this\nfunction is called with the <cite>pyramid.httpexceptions.Exception</cite>\nsubclass that caused the error. The default implementation has\nthis function signature equivalent:</p>\n<pre><span class=\"k\">def</span> <span class=\"nf\">function</span><span class=\"p\">(</span><span class=\"n\">request</span><span class=\"p\">,</span> <span class=\"n\">error</span><span class=\"p\">):</span>\n  <span class=\"k\">return</span> <span class=\"n\">error</span>\n</pre>\n</li>\n<li><p><tt><span class=\"pre\">pyramid_input.reparse-methods</span></tt> : list(str), default: \u2018PATCH\u2019</p>\n<p>Enable a workaround for pyramid 1.4.2+ that does not properly parse\nthe <cite>application/x-www-form-urlencoded</cite> request body if the request\nmethod is PATCH. It is unknown if other methods have this issue or\nif it has been fixed.</p>\n</li>\n<li><p><tt>pyramid_input.json.enable</tt> : bool, default: true</p>\n</li>\n<li><p><tt>pyramid_input.json.parser</tt> : symbol-spec, default: null</p>\n<p>Specifies the JSON parser. If not specified, uses Pyramid\u2019s\npre-existing <tt>Request.json_body</tt> attribute.</p>\n</li>\n<li><p><tt>pyramid_input.yaml.enable</tt> : bool, default: true</p>\n</li>\n<li><p><tt>pyramid_input.yaml.parser</tt> : symbol-spec, default: \u2018yaml.load\u2019</p>\n</li>\n<li><p><tt>pyramid_input.xml.enable</tt> : bool, default: true</p>\n</li>\n<li><p><tt>pyramid_input.xml.parser</tt> : symbol-spec, default: \u2018xml.etree.ElementTree.fromstring\u2019</p>\n</li>\n</ul>\n</div>\n\n          </div>"}, "last_serial": 3094275, "releases": {"0.2.0": [{"comment_text": "", "digests": {"md5": "18df4cc3788607dd8487dee838ef887e", "sha256": "17c88f89cb928658b4a5b16ec3ab18f1204c56a70b9db146f5a869b8e5f49914"}, "downloads": -1, "filename": "pyramid_input-0.2.0.tar.gz", "has_sig": false, "md5_digest": "18df4cc3788607dd8487dee838ef887e", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 10975, "upload_time": "2015-06-18T20:04:16", "upload_time_iso_8601": "2015-06-18T20:04:16.168622Z", "url": "https://files.pythonhosted.org/packages/69/9c/fe977b870dfa431495c7e12315431bb6d07d6904be2204c3a9eb6a07ecba/pyramid_input-0.2.0.tar.gz", "yanked": false}], "0.2.1": [{"comment_text": "", "digests": {"md5": "7550561306fedf7070ac5fbd996db741", "sha256": "f4c71862afd03db0fa116bad32570cecc9adc74695fbc5e936ae381d4901e98e"}, "downloads": -1, "filename": "pyramid_input-0.2.1.tar.gz", "has_sig": false, "md5_digest": "7550561306fedf7070ac5fbd996db741", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 10989, "upload_time": "2015-09-08T16:48:26", "upload_time_iso_8601": "2015-09-08T16:48:26.828182Z", "url": "https://files.pythonhosted.org/packages/31/5c/b8cc779c7311627647547702a3935daead695067e24cfda3d202ca4ebd83/pyramid_input-0.2.1.tar.gz", "yanked": false}], "0.2.2": [{"comment_text": "", "digests": {"md5": "0b2957545d0e4ea78fb3e79a2512494e", "sha256": "9ce10b4b809d5fb8f2deb01247d37703afffac54b5e87e1dfcadf69de9a3397a"}, "downloads": -1, "filename": "pyramid_input-0.2.2.tar.gz", "has_sig": false, "md5_digest": "0b2957545d0e4ea78fb3e79a2512494e", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 11332, "upload_time": "2015-10-07T20:20:31", "upload_time_iso_8601": "2015-10-07T20:20:31.364236Z", "url": "https://files.pythonhosted.org/packages/09/1a/75bdfae24f6cba3d8b278dce4c606278b051c66265c3815365491b748a05/pyramid_input-0.2.2.tar.gz", "yanked": false}], "0.2.3": [{"comment_text": "", "digests": {"md5": "85547aa4710fcf6203265b8e0b2c7a0c", "sha256": "87889a1ba652940ab80ad07cb9476a69ea4bb280c188c4a58e18ce352a1fad9c"}, "downloads": -1, "filename": "pyramid_input-0.2.3.tar.gz", "has_sig": false, "md5_digest": "85547aa4710fcf6203265b8e0b2c7a0c", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 15169, "upload_time": "2017-08-13T22:40:16", "upload_time_iso_8601": "2017-08-13T22:40:16.257506Z", "url": "https://files.pythonhosted.org/packages/a0/c8/75e24b7c4b6082372b8da03f27227d27084580c5936a9b8e3439789c516e/pyramid_input-0.2.3.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "85547aa4710fcf6203265b8e0b2c7a0c", "sha256": "87889a1ba652940ab80ad07cb9476a69ea4bb280c188c4a58e18ce352a1fad9c"}, "downloads": -1, "filename": "pyramid_input-0.2.3.tar.gz", "has_sig": false, "md5_digest": "85547aa4710fcf6203265b8e0b2c7a0c", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 15169, "upload_time": "2017-08-13T22:40:16", "upload_time_iso_8601": "2017-08-13T22:40:16.257506Z", "url": "https://files.pythonhosted.org/packages/a0/c8/75e24b7c4b6082372b8da03f27227d27084580c5936a9b8e3439789c516e/pyramid_input-0.2.3.tar.gz", "yanked": false}], "timestamp": "Fri May  8 02:58:25 2020"}