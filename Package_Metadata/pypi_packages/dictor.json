{"info": {"author": "mike.reider", "author_email": "mike.reider@gmail.com", "bugtrack_url": null, "classifiers": [], "description": "# Dictor - the dictionary doctor\n## An elegant dictionary and JSON handler\n\nVersion 0.1.4\n\nDictor is a Python 2 and 3 compatible JSON/Dictionary handler.\n\nDictor takes a dictionary or JSON data and returns value for a specific key.\n\nIf Dictor doesnt find a value for a key, or if JSON or Dictionary data is missing the key, the return value is either None or whatever fallback value you provide.\n\nDictor is polite with Exception errors commonly encountered when parsing large Dictionaries/JSONs. \n\nUsing Dictor eliminates the repeated use of try/except blocks in your code when dealing with lookups of large JSON structures, as well as providing flexibility for inserting fallback values on missing keys/values.\n\n\n\n---\n\n## Installation\n\n    pip install dictor\n\n\n## Usage\n\n\nsample.json\n\n    {\n        \"characters\": {\n            \"Lonestar\": {\n                \"id\": 55923,\n                \"role\": \"renegade\",\n                \"items\": [\n                    \"space winnebago\",\n                    \"leather jacket\"\n                ]\n            },\n            \"Barfolomew\": {\n                \"id\": 55924,\n                \"role\": \"mawg\",\n                \"items\": [\n                    \"peanut butter jar\",\n                    \"waggy tail\"\n                ]\n            },\n            \"Dark Helmet\": {\n                \"id\": 99999,\n                \"role\": \"Good is dumb\",\n                \"items\": [\n                    \"Shwartz\",\n                    \"helmet\"\n                ]\n            },\n            \"Skroob\": {\n                \"id\": 12345,\n                \"role\": \"Spaceballs CEO\",\n                \"items\": [\n                    \"luggage\"\n                ]\n            }\n        }\n    }\n\n\nnow lets get info on all Characters\n\n    from dictor import dictor\n\n    with open('sample.json') as data: \n        data = json.load(data)\n\n    print(dictor(data, 'characters'))\n\n    {u'Lonestar': {u'items': [u'space winnebago', u'leather jacket'], u'role': u'renegade', u'id': 55923}, u'Dark Helmet': {u'items': [u'Shwartz', u'helmet'], u'role': u'Good is dumb', u'id': 99999}, u'Barfolomew': {u'items': [u'peanut butter jar', u'waggy tail'], u'role': u'mawg', u'id': 55924}, u'Skroob': {u'items': [u'luggage'], u'role': u'Spaceballs CEO', u'id': 12345}}\n\n---\n\nget details for Dark Helmet\n\n    print(dictor(data, 'characters.Dark Helmet.items'))\n\n    [u'Shwartz', u'helmet']\n\n\nyou can also pass a flag to ignore letter Upper/Lower casing,\n\n    print(dictor(data, 'characters.dark helmet.items', ignorecase=True))\n\n\n---\n\nget only the 1st Item of a character\n\n    print(dictor(data, 'characters.Dark Helmet.items.0'))\n\n    Shwartz\n\n---\n\n\n## Fallback Value & Error Handling\nby default, dictor will return a None if a dictionary does not contain your search path,\n\n    print(dictor(data, 'characters.Princess Leia'))\n\n    None\n\nyou can provide a default fallback value either by passing \ndefault=\"fallback value\" or just placing a fallback string,\n\n    print(dictor(data, 'characters.Princess Leia', default='Not in Spaceballs'))\n\n    Not in spaceballs\n\nor just add a fallback string,\n\n    print(dictor(data, 'characters.Princess Leia', 'fallback to this'))\n\n    fallback to this\n\nif you want to error out on a None value, simply provide a CheckNone flag, a ValueError will be raised.\n\n    print(dictor(data, 'characters.Princess Leia', checknone=True))\n\n    Traceback (most recent call last):\n    File \"test.py\", line 14, in <module>\n        print(dictor(data, 'characters.Princess Leia', checknone=True))\n    File \"/github.com/dictor/dictor/__init__.py\", line 77, in dictor\n        raise ValueError('missing value for %s' % path)\n    ValueError: value not found for search path: \"characters.Princess Leia\"\n\n---\n## Passing a variable into search path\nif you need to pass a variable into search path\n\n    who = \"Barfolomew\"\n    print(dictor(data, \"characters.{}.id\".format(who)))\n\n    55924\n\nif using Python 3, you can also use F-strings\n\n\n    who = \"Barfolomew\"\n    print(dictor(data, f\"characters.{who}.id\"))\n\n---\n\n## List of Dicts\nif the entire JSON structure is a list\n\n    [\n        {\n            \"color\": \"red\",\n            \"value\": \"#f00\"\n        },\n        {\n            \"color\": \"green\",\n            \"value\": \"#0f0\"\n        },\n        {\n            \"color\": \"blue\",\n            \"value\": \"#00f\"\n        }\n    ]\n\njust provide the list index into search path\n\n    print(dictor(data, \u20182.color\u2019))\n\n    blue\n\n---\n## Nested List of lists\nto parse a complex nested list of lists and dicts, just provide the list index in the search path\n\n\n    [\n        {\n            \"type\": \"json\",\n            \"message\": [\n                [\n                    {\n                        \"english\": \"apple\",\n                        \"spanish\": \"manzana\"\n                    },\n                    {\n                        \"english\": \"banana\",\n                        \"spanish\": \"platano\"\n                    }\n                ],\n                [\n                    {\n                        \"english\": \"cherry\",\n                        \"spanish\": \"cereza\"\n                    },\n                    {\n                        \"english\": \"durian\",\n                        \"spanish\": \"durian\",\n                        \"color\": [\n                            \"black\",\n                            \"brown\",\n                            \"orange\"\n                        ]\n                    }\n                ]\n            ]\n        }\n]\n\ndictor will parse each lookup element hierarchicly, starting with top and will work down to the last element, reading in each dot-separated list index.\n\n\n    print(dictor(data, '0.message.1.1.color.2'))\n\n    orange\n\n\n---\n## Handling Key lookups with dots or other characters\n\nif you need to look up a key value that has a dot or some other character in the key name, for example\n\n\n    {\n        \"dirty.harry\": {\n            \"year\": 1977,\n            \"genre\": \"romance\"\n        }\n    }\n\n\nsearching for dictor(data, 'dirty.harry') will return a None since Dictor sees the dot-separated entry as 2 separate keys.\n\nTo search for a key with a dot in the name, simply use a Path Separator flag, this allows you to control the separator of keys by using a custom character. (by default, pathsep is set to '.')\n\n    dictor(data, 'dirty.harry/genre', pathsep='/')\n\n    {'romance'}\n\n\n---\n## Testing\ntesting is done using Python Nose. Tests are located in 'tests' directory.\n\n    pip install nose\n\n    shell> nosetests test.py\n\n---\n## Release Notes\n\n### 0.1.5\n- checknone updated to only error out on None values, 0 values are accepted\n\n### 0.1.4\n- lookup engine update\n- ability to provide new type of path separator\n\n### 0.1.3\n- bugfix\n\n### 0.1.2\n- fixed lookup bug\n\n### 0.1.1\n- removed \"eval()\" function for added security\n- entire lookup engine was rewritten for increased speed and simplicy\n- added 'ignorecase' parameter\n- added ability to escape dot character for keys with dots in them\n- looking up lists indexes was modified, \n\n    in previous version, looking up an element looked like this,\n    \n        dictor(data, 'characters.Dark Helmet.items[0]')\n    \n    new syntax is to place everything as a dot-separated path, this creates a single lookup standard, ie,\n    \n        dictor(data, 'characters.Dark Helmet.items.0')\n    \n\n### 0.0.1\n- initial project released\n\n---\n## packaging\n    python setup.py sdist\n    pip install twine\n    twine upload dist/*", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/perfecto25/dictor", "keywords": "", "license": "MIT", "maintainer": "", "maintainer_email": "", "name": "dictor", "package_url": "https://pypi.org/project/dictor/", "platform": "", "project_url": "https://pypi.org/project/dictor/", "project_urls": {"Homepage": "https://github.com/perfecto25/dictor"}, "release_url": "https://pypi.org/project/dictor/0.1.5/", "requires_dist": null, "requires_python": "", "summary": "an elegant dictionary and JSON handler", "version": "0.1.5", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>Dictor - the dictionary doctor</h1>\n<h2>An elegant dictionary and JSON handler</h2>\n<p>Version 0.1.4</p>\n<p>Dictor is a Python 2 and 3 compatible JSON/Dictionary handler.</p>\n<p>Dictor takes a dictionary or JSON data and returns value for a specific key.</p>\n<p>If Dictor doesnt find a value for a key, or if JSON or Dictionary data is missing the key, the return value is either None or whatever fallback value you provide.</p>\n<p>Dictor is polite with Exception errors commonly encountered when parsing large Dictionaries/JSONs.</p>\n<p>Using Dictor eliminates the repeated use of try/except blocks in your code when dealing with lookups of large JSON structures, as well as providing flexibility for inserting fallback values on missing keys/values.</p>\n<hr>\n<h2>Installation</h2>\n<pre><code>pip install dictor\n</code></pre>\n<h2>Usage</h2>\n<p>sample.json</p>\n<pre><code>{\n    \"characters\": {\n        \"Lonestar\": {\n            \"id\": 55923,\n            \"role\": \"renegade\",\n            \"items\": [\n                \"space winnebago\",\n                \"leather jacket\"\n            ]\n        },\n        \"Barfolomew\": {\n            \"id\": 55924,\n            \"role\": \"mawg\",\n            \"items\": [\n                \"peanut butter jar\",\n                \"waggy tail\"\n            ]\n        },\n        \"Dark Helmet\": {\n            \"id\": 99999,\n            \"role\": \"Good is dumb\",\n            \"items\": [\n                \"Shwartz\",\n                \"helmet\"\n            ]\n        },\n        \"Skroob\": {\n            \"id\": 12345,\n            \"role\": \"Spaceballs CEO\",\n            \"items\": [\n                \"luggage\"\n            ]\n        }\n    }\n}\n</code></pre>\n<p>now lets get info on all Characters</p>\n<pre><code>from dictor import dictor\n\nwith open('sample.json') as data: \n    data = json.load(data)\n\nprint(dictor(data, 'characters'))\n\n{u'Lonestar': {u'items': [u'space winnebago', u'leather jacket'], u'role': u'renegade', u'id': 55923}, u'Dark Helmet': {u'items': [u'Shwartz', u'helmet'], u'role': u'Good is dumb', u'id': 99999}, u'Barfolomew': {u'items': [u'peanut butter jar', u'waggy tail'], u'role': u'mawg', u'id': 55924}, u'Skroob': {u'items': [u'luggage'], u'role': u'Spaceballs CEO', u'id': 12345}}\n</code></pre>\n<hr>\n<p>get details for Dark Helmet</p>\n<pre><code>print(dictor(data, 'characters.Dark Helmet.items'))\n\n[u'Shwartz', u'helmet']\n</code></pre>\n<p>you can also pass a flag to ignore letter Upper/Lower casing,</p>\n<pre><code>print(dictor(data, 'characters.dark helmet.items', ignorecase=True))\n</code></pre>\n<hr>\n<p>get only the 1st Item of a character</p>\n<pre><code>print(dictor(data, 'characters.Dark Helmet.items.0'))\n\nShwartz\n</code></pre>\n<hr>\n<h2>Fallback Value &amp; Error Handling</h2>\n<p>by default, dictor will return a None if a dictionary does not contain your search path,</p>\n<pre><code>print(dictor(data, 'characters.Princess Leia'))\n\nNone\n</code></pre>\n<p>you can provide a default fallback value either by passing\ndefault=\"fallback value\" or just placing a fallback string,</p>\n<pre><code>print(dictor(data, 'characters.Princess Leia', default='Not in Spaceballs'))\n\nNot in spaceballs\n</code></pre>\n<p>or just add a fallback string,</p>\n<pre><code>print(dictor(data, 'characters.Princess Leia', 'fallback to this'))\n\nfallback to this\n</code></pre>\n<p>if you want to error out on a None value, simply provide a CheckNone flag, a ValueError will be raised.</p>\n<pre><code>print(dictor(data, 'characters.Princess Leia', checknone=True))\n\nTraceback (most recent call last):\nFile \"test.py\", line 14, in &lt;module&gt;\n    print(dictor(data, 'characters.Princess Leia', checknone=True))\nFile \"/github.com/dictor/dictor/__init__.py\", line 77, in dictor\n    raise ValueError('missing value for %s' % path)\nValueError: value not found for search path: \"characters.Princess Leia\"\n</code></pre>\n<hr>\n<h2>Passing a variable into search path</h2>\n<p>if you need to pass a variable into search path</p>\n<pre><code>who = \"Barfolomew\"\nprint(dictor(data, \"characters.{}.id\".format(who)))\n\n55924\n</code></pre>\n<p>if using Python 3, you can also use F-strings</p>\n<pre><code>who = \"Barfolomew\"\nprint(dictor(data, f\"characters.{who}.id\"))\n</code></pre>\n<hr>\n<h2>List of Dicts</h2>\n<p>if the entire JSON structure is a list</p>\n<pre><code>[\n    {\n        \"color\": \"red\",\n        \"value\": \"#f00\"\n    },\n    {\n        \"color\": \"green\",\n        \"value\": \"#0f0\"\n    },\n    {\n        \"color\": \"blue\",\n        \"value\": \"#00f\"\n    }\n]\n</code></pre>\n<p>just provide the list index into search path</p>\n<pre><code>print(dictor(data, \u20182.color\u2019))\n\nblue\n</code></pre>\n<hr>\n<h2>Nested List of lists</h2>\n<p>to parse a complex nested list of lists and dicts, just provide the list index in the search path</p>\n<pre><code>[\n    {\n        \"type\": \"json\",\n        \"message\": [\n            [\n                {\n                    \"english\": \"apple\",\n                    \"spanish\": \"manzana\"\n                },\n                {\n                    \"english\": \"banana\",\n                    \"spanish\": \"platano\"\n                }\n            ],\n            [\n                {\n                    \"english\": \"cherry\",\n                    \"spanish\": \"cereza\"\n                },\n                {\n                    \"english\": \"durian\",\n                    \"spanish\": \"durian\",\n                    \"color\": [\n                        \"black\",\n                        \"brown\",\n                        \"orange\"\n                    ]\n                }\n            ]\n        ]\n    }\n</code></pre>\n<p>]</p>\n<p>dictor will parse each lookup element hierarchicly, starting with top and will work down to the last element, reading in each dot-separated list index.</p>\n<pre><code>print(dictor(data, '0.message.1.1.color.2'))\n\norange\n</code></pre>\n<hr>\n<h2>Handling Key lookups with dots or other characters</h2>\n<p>if you need to look up a key value that has a dot or some other character in the key name, for example</p>\n<pre><code>{\n    \"dirty.harry\": {\n        \"year\": 1977,\n        \"genre\": \"romance\"\n    }\n}\n</code></pre>\n<p>searching for dictor(data, 'dirty.harry') will return a None since Dictor sees the dot-separated entry as 2 separate keys.</p>\n<p>To search for a key with a dot in the name, simply use a Path Separator flag, this allows you to control the separator of keys by using a custom character. (by default, pathsep is set to '.')</p>\n<pre><code>dictor(data, 'dirty.harry/genre', pathsep='/')\n\n{'romance'}\n</code></pre>\n<hr>\n<h2>Testing</h2>\n<p>testing is done using Python Nose. Tests are located in 'tests' directory.</p>\n<pre><code>pip install nose\n\nshell&gt; nosetests test.py\n</code></pre>\n<hr>\n<h2>Release Notes</h2>\n<h3>0.1.5</h3>\n<ul>\n<li>checknone updated to only error out on None values, 0 values are accepted</li>\n</ul>\n<h3>0.1.4</h3>\n<ul>\n<li>lookup engine update</li>\n<li>ability to provide new type of path separator</li>\n</ul>\n<h3>0.1.3</h3>\n<ul>\n<li>bugfix</li>\n</ul>\n<h3>0.1.2</h3>\n<ul>\n<li>fixed lookup bug</li>\n</ul>\n<h3>0.1.1</h3>\n<ul>\n<li>\n<p>removed \"eval()\" function for added security</p>\n</li>\n<li>\n<p>entire lookup engine was rewritten for increased speed and simplicy</p>\n</li>\n<li>\n<p>added 'ignorecase' parameter</p>\n</li>\n<li>\n<p>added ability to escape dot character for keys with dots in them</p>\n</li>\n<li>\n<p>looking up lists indexes was modified,</p>\n<p>in previous version, looking up an element looked like this,</p>\n<pre><code>  dictor(data, 'characters.Dark Helmet.items[0]')\n</code></pre>\n<p>new syntax is to place everything as a dot-separated path, this creates a single lookup standard, ie,</p>\n<pre><code>  dictor(data, 'characters.Dark Helmet.items.0')\n</code></pre>\n</li>\n</ul>\n<h3>0.0.1</h3>\n<ul>\n<li>initial project released</li>\n</ul>\n<hr>\n<h2>packaging</h2>\n<pre><code>python setup.py sdist\npip install twine\ntwine upload dist/*\n</code></pre>\n\n          </div>"}, "last_serial": 6573914, "releases": {"0.0.1": [{"comment_text": "", "digests": {"md5": "3a337b58930ca7e4a4f6fd472f33d184", "sha256": "c5a2b2821b3973845567be2c78f95e52ba22d7ea552490451e2ba9a9233ebf8d"}, "downloads": -1, "filename": "dictor-0.0.1.tar.gz", "has_sig": false, "md5_digest": "3a337b58930ca7e4a4f6fd472f33d184", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 3217, "upload_time": "2018-11-30T23:33:40", "upload_time_iso_8601": "2018-11-30T23:33:40.522956Z", "url": "https://files.pythonhosted.org/packages/06/ad/bf388cee2ddce24ad83452c6d9d87e87df5404ceab8417c130c0773454d1/dictor-0.0.1.tar.gz", "yanked": false}], "0.1.1": [{"comment_text": "", "digests": {"md5": "23c8cc624d93a41fdbc966327a36211c", "sha256": "42d75aedc4c622a644dcb6c454ab14fba2ec8660e6a19abbd3d9b70258cb9ccb"}, "downloads": -1, "filename": "dictor-0.1.1-py3-none-any.whl", "has_sig": false, "md5_digest": "23c8cc624d93a41fdbc966327a36211c", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 5158, "upload_time": "2019-07-14T02:22:47", "upload_time_iso_8601": "2019-07-14T02:22:47.736708Z", "url": "https://files.pythonhosted.org/packages/c1/d9/540d8e5cff415c0cdbd1135de1ba7e1eac2e1582a573e5f47522f60729b1/dictor-0.1.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "c51823916d229d0f49b4e794c949e146", "sha256": "85e4aa2b7d14b46644bd48129eb0330bce593282414417b4c7023b1447358540"}, "downloads": -1, "filename": "dictor-0.1.1.tar.gz", "has_sig": false, "md5_digest": "c51823916d229d0f49b4e794c949e146", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 4712, "upload_time": "2019-07-14T02:22:49", "upload_time_iso_8601": "2019-07-14T02:22:49.115795Z", "url": "https://files.pythonhosted.org/packages/12/d4/e0ac58e8a29c98178d14ed0cb16a2c992fb3dfa96e62bb3881df91586491/dictor-0.1.1.tar.gz", "yanked": false}], "0.1.2": [{"comment_text": "", "digests": {"md5": "ae3fd344b3ec91b91cac0771db5a1710", "sha256": "16a019817108675dc176b201c35b045478456244078b29949d57636792f864ca"}, "downloads": -1, "filename": "dictor-0.1.2-py3-none-any.whl", "has_sig": false, "md5_digest": "ae3fd344b3ec91b91cac0771db5a1710", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 5401, "upload_time": "2019-08-21T12:06:25", "upload_time_iso_8601": "2019-08-21T12:06:25.815915Z", "url": "https://files.pythonhosted.org/packages/ab/2b/a88d7ea83d89fca79c4d307c5fb9a1bdd5e2459b0cf2d5601ef499edaa69/dictor-0.1.2-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "ed64d52414174df6a5e7a5d97c72acc2", "sha256": "ef379466c4dadd47350bed4affeb84344c935768c22237fa1b9714f8747fcbf4"}, "downloads": -1, "filename": "dictor-0.1.2.tar.gz", "has_sig": false, "md5_digest": "ed64d52414174df6a5e7a5d97c72acc2", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 4770, "upload_time": "2019-08-21T12:06:28", "upload_time_iso_8601": "2019-08-21T12:06:28.174778Z", "url": "https://files.pythonhosted.org/packages/94/0b/19e50f8808c443c3c6737f5a562d48b300a6778d3a3cc83272ea835dacc8/dictor-0.1.2.tar.gz", "yanked": false}], "0.1.3": [{"comment_text": "", "digests": {"md5": "9f4010c194de7011de8a805ac5de9a41", "sha256": "d1bd584697db89f32370d13bdcc3ae235d190e11f0175196b4237a980e4ad278"}, "downloads": -1, "filename": "dictor-0.1.3.tar.gz", "has_sig": false, "md5_digest": "9f4010c194de7011de8a805ac5de9a41", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 4813, "upload_time": "2019-10-21T19:05:42", "upload_time_iso_8601": "2019-10-21T19:05:42.529027Z", "url": "https://files.pythonhosted.org/packages/7e/e1/03c4d8fc666f133e3187f60829a065f60e8b37e4aa65d397470c95f8e04d/dictor-0.1.3.tar.gz", "yanked": false}], "0.1.4": [{"comment_text": "", "digests": {"md5": "11538c82c834f06c43f47f9f76dc7812", "sha256": "6737c08463364c48c3ebcf2f5bcc14498b4c895e1c78154d62cfd24ca1fe3159"}, "downloads": -1, "filename": "dictor-0.1.4.tar.gz", "has_sig": false, "md5_digest": "11538c82c834f06c43f47f9f76dc7812", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 4755, "upload_time": "2019-12-02T04:41:52", "upload_time_iso_8601": "2019-12-02T04:41:52.429788Z", "url": "https://files.pythonhosted.org/packages/63/f7/1d97dd52626613c87a1e4bfea5af450485e730817bfb013e8f7dad9d6d9e/dictor-0.1.4.tar.gz", "yanked": false}], "0.1.5": [{"comment_text": "", "digests": {"md5": "e0fd7537254cc48689e4af968bcd89b7", "sha256": "149d073ef174e19e6713e505ff9fcb90177b264f621810550e34c74a1bc1179f"}, "downloads": -1, "filename": "dictor-0.1.5.tar.gz", "has_sig": false, "md5_digest": "e0fd7537254cc48689e4af968bcd89b7", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 4808, "upload_time": "2020-02-05T04:28:15", "upload_time_iso_8601": "2020-02-05T04:28:15.683504Z", "url": "https://files.pythonhosted.org/packages/d4/3a/dc2273856497b3fcfc23365532dad417049002d804ec46fe10f305e0fe21/dictor-0.1.5.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "e0fd7537254cc48689e4af968bcd89b7", "sha256": "149d073ef174e19e6713e505ff9fcb90177b264f621810550e34c74a1bc1179f"}, "downloads": -1, "filename": "dictor-0.1.5.tar.gz", "has_sig": false, "md5_digest": "e0fd7537254cc48689e4af968bcd89b7", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 4808, "upload_time": "2020-02-05T04:28:15", "upload_time_iso_8601": "2020-02-05T04:28:15.683504Z", "url": "https://files.pythonhosted.org/packages/d4/3a/dc2273856497b3fcfc23365532dad417049002d804ec46fe10f305e0fe21/dictor-0.1.5.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:38:31 2020"}