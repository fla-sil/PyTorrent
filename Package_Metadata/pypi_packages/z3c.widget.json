{"info": {"author": "Zope Community", "author_email": "zope-dev@zope.org", "bugtrack_url": null, "classifiers": ["Development Status :: 4 - Beta", "Environment :: Web Environment", "Framework :: Zope3", "Intended Audience :: Developers", "License :: OSI Approved :: GNU Library or Lesser General Public License (LGPL)", "License :: OSI Approved :: Zope Public License", "Programming Language :: Python", "Topic :: Software Development :: Libraries :: Python Modules"], "description": ".. contents::\n\n\n\n======================\nChanges for z3c.widget\n======================\n\n0.3.0 (2010-11-16)\n==================\n\n - Added translation for french.\n\n - Updated tests to run with `zope.formlib` 4.0 and `zope.schema` 3.6.\n\n - Using Python's ``doctest`` module instead of depreacted\n   ``zope.testing.doctest[unit]``.\n\n - Added doctests to ``long_description`` to be visible on PyPI.\n\n2008/01/29 0.2.1\n================\n\n - add translation for hungarian and romanian languages\n\n2007/09/21 0.2.0\n================\n\n - feature: Added a date-selection widget.\n - feature: Added a social security number widget.\n - feature: Added a US phone number widget.\n\n2007/09/19 0.1.7\n================\n\n - added translation for english to get i18n working in some browsers\n\n\n2007/09/19 0.1.6\n================\n\n - added cheesehop classification, registered there\n - fixed typos\n\n2007/09/05 0.1.5\n================\n\n - bugfix: browse butten will now be enabled after cancel was clicked in\n   the open file dialog\n - do not set the progessbar to 100% before the upload was started\n - bugfix: files will not be uploaded if no limit was set\n\n\n2007/09/05 0.1.4\n================\n\n - dealing file size during upload. If one or more files are bigger than\n   the passed size each one of them will be ignored during upload but listed\n   below the progress bar after the upload of the working files is done.\n - displaying the maximal allowed file size (if it's contained in the config\n   file)\n\n\n2007/09/03 0.1.3\n================\n\n - bugfix: too much quoting.\n\n\n2007/09/03 0.1.2\n================\n\n - using passed config url instead of hard coded flashuploadvars.xml\n\n\n2007/08/06 0.1.1\n================\n\n - flashupload: better skinnability for upload.swf. cleanup folder\n   structure for flash stuff.\n\n\n2007/06/14 0.1.0:\n=================\n\n - z3c.widget.image: added translations for es\n\n - update to newest bootstrap.py version\n\n\n======================\n Autocomplete Widgets\n======================\n\nAutocomplete widgets are an alternative to normal select widgets.\n\n  >>> from z3c.widget.autocomplete.widget import AutoCompleteWidget\n\nLet us create a vocabulary.\n\n  >>> from zope.schema.vocabulary import SimpleVocabulary\n  >>> from zope.publisher.browser import TestRequest\n  >>> from zope import schema, component, interface\n  >>> items = ((u'value1',1,u'Title1'),\n  ...          (u'value2',2,u'Title2'),\n  ...          (u'value3',3,u'Title3'))\n  >>> terms = map(lambda i: SimpleVocabulary.createTerm(*i),items)\n  >>> voc = SimpleVocabulary(terms)\n  >>> [term.title for term in voc]\n  [u'Title1', u'Title2', u'Title3']\n  >>> field = schema.Choice(__name__='foo',\n  ...     missing_value=None,\n  ...     vocabulary=voc)\n  >>> request = TestRequest()\n   >>> widget =  AutoCompleteWidget(field, request)\n  >>> widget\n  <z3c.widget.autocomplete.widget.AutoCompleteWidget object at ...>\n  >>> print widget()\n  <input class=\"textType\" id=\"field.foo\" name=\"field.foo\" type=\"text\" value=\"\"  />\n  <div id=\"field.foo.target\" class=\"autoComplete\"></div>\n  <script type=\"text/javascript\">\n  new Ajax.Autocompleter('field.foo','field.foo.target',\n  'http://127.0.0.1/++widget++field.foo/suggestions'\n  ,options={\n  paramName: 'value'\n  });\n  </script>\n\nLet's add some input. Note that the input must match the title of the\nvocabulary term.\n\n  >>> request.form['field.foo']=u'Title1'\n  >>> widget.getInputValue()\n  u'value1'\n\nIf we have no matching title a ConversionError is raised.\n\n  >>> request.form['field.foo']=u'Unknown'\n  >>> widget.getInputValue()\n  Traceback (most recent call last):\n  ...\n  ConversionError: ('Invalid value', u'Unknown')\n\nAlso the form value is the title of the term with the given value.\n\n  >>> widget._toFormValue('value1')\n  u'Title1'\n\n  >>> suggestions = widget.getSuggestions('Title')\n  >>> [title for title in suggestions]\n  [u'Title1', u'Title2', u'Title3']\n  >>> suggestions = widget.getSuggestions('Title1')\n  >>> [title for title in suggestions]\n  [u'Title1']\n  >>> suggestions = widget.getSuggestions('ABC')\n  >>> [title for title in suggestions]\n  []\n  >>> suggestions = widget.getSuggestions('title')\n  >>> [title for title in suggestions]\n  [u'Title1', u'Title2', u'Title3']\n\n\n=======================\nAutoCompleteWidget Demo\n=======================\n\nThis demo packe provides a simple content class which uses the\nz3c autocomplete widget.\n\n    >>> from zope.testbrowser.testing import Browser\n    >>> browser = Browser()\n    >>> browser.handleErrors = False\n    >>> browser.addHeader('Authorization', 'Basic mgr:mgrpw')\n    >>> browser.open('http://localhost/@@contents.html')\n\nIt can be added by clicking on the \"Autocomplete Widget Demo\" link in the\nadd menu. And giving it a name.\n\n    >>> link = browser.getLink('Autocomplete Widget Demo')\n    >>> link.click()\n    >>> nameCtrl = browser.getControl(name='new_value')\n    >>> nameCtrl.value = 'mydemo'\n    >>> applyCtrl = browser.getControl('Apply')\n    >>> applyCtrl.click()\n    >>> link = browser.getLink('mydemo')\n    >>> link.click()\n    >>> browser.url\n    'http://localhost/mydemo/@@edit.html'\n\nLet us test the widget rendering by direct access.\n\n    >>> browser.open('http://localhost/mydemo/@@edit.html/++widget++country')\n    >>> print browser.contents\n    <input class=\"textType\" ...\n    </script>\n\nThe suggestions are proveded by its own view.    \n\n    >>> browser.open('http://localhost/mydemo/@@edit.html/++widget++country/suggestions')\n    >>> print browser.contents\n\n    >>> browser.open('http://localhost/++lang++en/mydemo/@@edit.html/++widget++country/suggestions?value=a')\n    >>> print browser.contents\n    <BLANKLINE>\n     <ul>\n      <li>Algeria</li>\n      <li>Andorra</li>\n      <li>Antigua and Barbuda</li>\n      <li>Afghanistan</li>\n      <li>Anguilla</li>\n      <li>Armenia</li>\n      <li>Albania</li>\n      <li>Angola</li>\n      <li>Antarctica</li>\n      <li>American Samoa</li>\n      <li>Argentina</li>\n      <li>Australia</li>\n      <li>Austria</li>\n      <li>Aruba</li>\n      <li>Azerbaijan</li>\n     </ul>\n    <BLANKLINE>\n    <BLANKLINE>\n\nSuggestions are translated.\n\n    >>> browser.open('http://localhost/++lang++de/mydemo/@@edit.html/++widget++country/suggestions?value=a')\n    >>> print browser.contents\n    <BLANKLINE>\n     <ul>\n      <li>Amerikanische Jungferninseln</li>\n      <li>Amerikanisch-Ozeanien</li>\n      <li>Algerien</li>\n      <li>Andorra</li>\n      <li>Antigua und Barbuda</li>\n      <li>Afghanistan</li>\n      <li>Anguilla</li>\n      <li>Armenien</li>\n      <li>Albanien</li>\n      <li>Angola</li>\n      <li>Antarktis</li>\n      <li>Amerikanisch-Samoa</li>\n      <li>Argentinien</li>\n      <li>Australien</li>\n      <li>Aruba</li>\n      <li>Aserbaidschan</li>\n     </ul>\n    <BLANKLINE>\n    <BLANKLINE>\n\n\n=========================\nCountry selection Widgets\n=========================\n\nThis package provides widgets to select a country.\nThe dropdown type is registered as a default for the Country schema.\n\nThe pain was to sort the options after the translation.\n\n\n\nBefore we can start, we have to do a little bit of setup:\n\n  >>> import zope.component\n  >>> import zope.schema\n  >>> import zope.app.form.browser\n  >>> from z3c.widget.country.widget import CountryInputDropdown\n  >>> from z3c.widget.country import ICountry\n  >>> from z3c.i18n.iso import territoryVocabularyFactory\n  >>> from zope.publisher.interfaces.browser import IBrowserRequest\n\nFirst we have to create a field and a request:\n\n  >>> from z3c.widget.country import Country\n\n  >>> countryFld = Country(\n  ...     __name__='country',\n  ...     title=u'Country',\n  ...     description=u'Select a Country')\n\n  >>> from zope.publisher.browser import TestRequest\n  >>> request = TestRequest()\n\nNow we can initialize the widget.\n\n  >>> class Content(object):\n  ...     country = None\n  >>> content = Content()\n  >>> boundCountry = countryFld.bind(content)\n\n  >>> widget = CountryInputDropdown(boundCountry,\n  ...   territoryVocabularyFactory(None), request)\n\nLet's make sure that all fields have the correct value:\n\n  >>> widget.name\n  'field.country'\n\n  >>> widget.label\n  u'Country'\n\n  >>> widget.hint\n  u'Select a Country'\n\n  >>> widget.visible\n  True\n\nLet's see how the widget is rendered:\n\n  >>> print widget()\n  <div>\n  <div class=\"value\">\n  <select id=\"field.country\" name=\"field.country\" size=\"1\" >\n  <option value=\"AF\">Afghanistan</option>\n  <option value=\"AL\">Albania</option>\n  <option value=\"DZ\">Algeria</option>\n  ...\n  <option value=\"HU\">Hungary</option>\n  <option value=\"IS\">Iceland</option>\n  <option value=\"IN\">India</option>\n  ...\n  <option value=\"ZM\">Zambia</option>\n  <option value=\"ZW\">Zimbabwe</option>\n  </select>\n  ...\n\n#Let's see the german translation:\n#z3c.i18n registrations required!!!\n#\n#  >>> request = TestRequest(HTTP_ACCEPT_LANGUAGE='de')\n#\n#  >>> widget = CountryInputDropdown(boundCountry,\n#  ...   territoryVocabularyFactory(None), request)\n#\n#  >>> print widget()\n#  <div>\n#  <div class=\"value\">\n#  <select id=\"field.country\" name=\"field.country\" size=\"1\" >\n#  <option value=\"AF\">Afghanistan</option>\n#  <option value=\"AL\">Albania</option>\n#  <option value=\"DZ\">Algeria</option>\n#  ...\n#  <option value=\"HU\">Hungary</option>\n#  <option value=\"IS\">Iceland</option>\n#  <option value=\"IN\">India</option>\n#  ...\n#  <option value=\"ZM\">Zambia</option>\n#  <option value=\"ZW\">Zimbabwe</option>\n#  </select>\n#  ...\n\n\n=====================\nDate Selection Widget\n=====================\n\nThe ``DateSelectWidget`` widget provides three select boxes presenting the\nday, month and year.\n\nFirst we have to create a field and a request. Note that we can set the\nyear range in this widget:\n\n  >>> import datetime\n  >>> from z3c.schema.dateselect import DateSelect\n  >>> from z3c.widget.dateselect.browser import DateSelectWidget\n\n  >>> field = DateSelect(\n  ...     title=u'Birthday',\n  ...     description=u'Somebodys birthday',\n  ...     yearRange=range(1930, 2007),\n  ...     required=True)\n  >>> field.__name__ = 'field'\n\n  >>> from zope.publisher.browser import TestRequest\n  >>> request = TestRequest()\n\nNow we can initialize widget.\n\n  >>> widget = DateSelectWidget(field, request)\n\nLet's make sure that all fields have the correct value:\n\n  >>> widget.name\n  'field.field'\n\n  >>> widget.label\n  u'Birthday'\n\n  >>> widget.hint\n  u'Somebodys birthday'\n\n  >>> widget.visible\n  True\n\n  >>> widget.required\n  True\n\nThe constructor should have also created 3 widgets:\n\n  >>> widget.widgets['year']\n  <z3c.widget.dateselect.browser.DropdownWidget object at ...>\n  >>> widget.widgets['month']\n  <z3c.widget.dateselect.browser.DropdownWidget object at ...>\n  >>> widget.widgets['day']\n  <z3c.widget.dateselect.browser.DropdownWidget object at ...>\n\nlet's also test the year range:\n\n  >>> '1929' in widget.widgets['year'].vocabulary.by_token.keys()\n  False\n  >>> '1930' in widget.widgets['year'].vocabulary.by_token.keys()\n  True\n  >>> '2006' in widget.widgets['year'].vocabulary.by_token.keys()\n  True\n  >>> '2007' in widget.widgets['year'].vocabulary.by_token.keys()\n  False\n\nTest another year range:\n\n  >>> field2 = DateSelect(\n  ...     title=u'Another Birthday',\n  ...     yearRange=range(2000, 2010))\n  >>> field2.__name__ = 'field'\n  >>> widget2 = DateSelectWidget(field2, request)\n\n  >>> '1930' in widget2.widgets['year'].vocabulary.by_token.keys()\n  False\n  >>> '2000' in widget2.widgets['year'].vocabulary.by_token.keys()\n  True\n  >>> '2009' in widget2.widgets['year'].vocabulary.by_token.keys()\n  True\n  >>> '2010' in widget2.widgets['year'].vocabulary.by_token.keys()\n  False\n\n\n``setRenderedValue(value)`` Method\n==================================\n\nThe first method is ``setRenderedValue()``. The widget has two use cases,\nbased on the type of value. If the value is a custom score system, it will\nsend the information to the custom, min and max widget:\n\n  >>> widget = DateSelectWidget(field, request)\n  >>> year = 2000\n  >>> month = 12\n  >>> day = 31\n  >>> data = datetime.date(year, month, day)\n  >>> widget.setRenderedValue(data)\n\n  >>> 'value=\"2000\"' in widget()\n  True\n  >>> 'value=\"12\"' in widget()\n  True\n  >>> 'value=\"31\"' in widget()\n  True\n\n\n``setPrefix(prefix)`` Method\n============================\n\nThe prefix determines the name of the widget and all its sub-widgets.\n\n  >>> widget.name\n  'field.field'\n  >>> widget.widgets['year'].name\n  'field.field.year'\n  >>> widget.widgets['month'].name\n  'field.field.month'\n  >>> widget.widgets['day'].name\n  'field.field.day'\n\n  >>> widget.setPrefix('test.')\n\n  >>> widget.name\n  'test.field'\n  >>> widget.widgets['year'].name\n  'test.field.year'\n  >>> widget.widgets['month'].name\n  'test.field.month'\n  >>> widget.widgets['day'].name\n  'test.field.day'\n\nIf the prefix does not end in a dot, one is added:\n\n  >>> widget.setPrefix('test')\n\n  >>> widget.name\n  'test.field'\n  >>> widget.widgets['year'].name\n  'test.field.year'\n  >>> widget.widgets['month'].name\n  'test.field.month'\n  >>> widget.widgets['day'].name\n  'test.field.day'\n\n\n``getInputValue()`` Method\n==========================\n\nThis method returns a date object:\n\n  >>> request = TestRequest(form={\n  ...     'field.field.year': '2006',\n  ...     'field.field.month': '2',\n  ...     'field.field.day': '24'})\n\n  >>> widget = DateSelectWidget(field, request)\n\n  >>> value = widget.getInputValue()\n  >>> value.year\n  2006\n  >>> value.month\n  2\n  >>> value.day\n  24\n\nIf a set of values does not produce a valid date object, a value error is\nraised:\n\n  >>> request = TestRequest(form={\n  ...     'field.field.year': '2006',\n  ...     'field.field.month': '2',\n  ...     'field.field.day': '29'})\n\n  >>> widget = DateSelectWidget(field, request)\n  >>> widget.getInputValue()\n  Traceback (most recent call last):\n  ...\n  WidgetInputError: ('field', u'Birthday', u'day is out of range for month')\n\n  >>> widget._error.__class__\n  <class 'zope.formlib.interfaces.WidgetInputError'>\n\n\n``applyChanges(content)`` Method\n================================\n\nThis method applies the new date to the passed content. However, it\nmust be smart enough to detect whether the values really changed.\n\n  >>> class Content(object):\n  ...     field = None\n  >>> content = Content()\n\n  >>> request = TestRequest(form={\n  ...     'field.field.year': '2006',\n  ...     'field.field.month': '2',\n  ...     'field.field.day': '24'})\n\n  >>> widget = DateSelectWidget(field, request)\n  >>> widget.applyChanges(content)\n  True\n  >>> content.field\n  datetime.date(2006, 2, 24)\n\n  >>> widget.applyChanges(content)\n  False\n\n\n``hasInput()`` Method\n=====================\n\nThis method checks for any input, but does not validate it.\n\n  >>> request = TestRequest()\n  >>> widget = DateSelectWidget(field, request)\n  >>> widget.hasInput()\n  False\n\n  >>> request = TestRequest(form={\n  ...     'field.field.year': '2006'})\n  >>> widget = DateSelectWidget(field, request)\n  >>> widget.hasInput()\n  False\n\n  >>> request = TestRequest(form={\n  ...     'field.field.month': '2'})\n  >>> widget = DateSelectWidget(field, request)\n  >>> widget.hasInput()\n  False\n\n  >>> request = TestRequest(form={\n  ...     'field.field.day': '24'})\n  >>> widget = DateSelectWidget(field, request)\n  >>> widget.hasInput()\n  False\n\n  >>> request = TestRequest(form={\n  ...     'field.field.year': '2006',\n  ...     'field.field.month': '2',\n  ...     'field.field.day': '24'})\n  >>> widget = DateSelectWidget(field, request)\n  >>> widget.hasInput()\n  True\n\n\n``hasValidInput()`` Method\n==========================\n\nAdditionally to checking for any input, this method also checks whether the\ninput is valid:\n\n  >>> request = TestRequest()\n  >>> widget = DateSelectWidget(field, request)\n  >>> widget.hasValidInput()\n  False\n\n  >>> request = TestRequest(form={\n  ...     'field.field.year': '2006'})\n  >>> widget = DateSelectWidget(field, request)\n  >>> widget.hasValidInput()\n  False\n\n  >>> request = TestRequest(form={\n  ...     'field.field.month': '2'})\n  >>> widget = DateSelectWidget(field, request)\n  >>> widget.hasValidInput()\n  False\n\n  >>> request = TestRequest(form={\n  ...     'field.field.day': '24'})\n  >>> widget = DateSelectWidget(field, request)\n  >>> widget.hasValidInput()\n  False\n\n  >>> request = TestRequest(form={\n  ...     'field.field.year': '2006',\n  ...     'field.field.month': '2',\n  ...     'field.field.day': '24'})\n  >>> widget = DateSelectWidget(field, request)\n  >>> widget.hasValidInput()\n  True\n\n\n``hidden()`` Method\n===================\n\nThis method is renders the output as hidden fields:\n\n  >>> request = TestRequest(form={\n  ...     'field.field.year': '2006',\n  ...     'field.field.month': '2',\n  ...     'field.field.day': '24'})\n  >>> widget = DateSelectWidget(field, request)\n  >>> print widget.hidden()\n  <input class=\"hiddenType\" id=\"field.field.year\" name=\"field.field.year\"\n         type=\"hidden\" value=\"2006\" />\n  <input class=\"hiddenType\" id=\"field.field.month\" name=\"field.field.month\"\n         type=\"hidden\" value=\"2\"  />\n  <input class=\"hiddenType\" id=\"field.field.day\" name=\"field.field.day\"\n         type=\"hidden\" value=\"24\"  />\n\n\n``error()`` Method\n==================\n\nLet's test some bad data and check the error handling.\n\nThe day field contains an invalid value:\n\n  >>> request = TestRequest(form={\n  ...     'field.field.year': '2006',\n  ...     'field.field.month': '2',\n  ...     'field.field.day': '99'})\n  >>> widget = DateSelectWidget(field, request)\n  >>> widget.getInputValue()\n  Traceback (most recent call last):\n  ...\n  ConversionError: (u'Invalid value', InvalidValue(\"token '99' not found in vocabulary\"))\n  >>> print widget.error()\n  <span class=\"error\">Invalid value</span>\n\nThe month field contains an invalid value:\n\n  >>> request = TestRequest(form={\n  ...     'field.field.year': '2006',\n  ...     'field.field.month': '0',\n  ...     'field.field.day': '31'})\n  >>> widget = DateSelectWidget(field, request)\n  >>> widget.getInputValue()\n  Traceback (most recent call last):\n  ...\n  ConversionError: (u'Invalid value', InvalidValue(\"token '0' not found in vocabulary\"))\n  >>> print widget.error()\n  <span class=\"error\">Invalid value</span>\n\nThe year field contains an invalid value:\n\n  >>> request = TestRequest(form={\n  ...     'field.field.year': '1900',\n  ...     'field.field.month': '1',\n  ...     'field.field.day': '31'})\n  >>> widget = DateSelectWidget(field, request)\n  >>> widget.getInputValue()\n  Traceback (most recent call last):\n  ...\n  ConversionError: (u'Invalid value', InvalidValue(\"token '1900' not found in vocabulary\"))\n  >>> print widget.error()\n  <span class=\"error\">Invalid value</span>\n\nThe single inputs were correct, but did not create a valid date.\n\n  >>> request = TestRequest(form={\n  ...     'field.field.year': '1980',\n  ...     'field.field.month': '2',\n  ...     'field.field.day': '31'})\n  >>> widget = DateSelectWidget(field, request)\n  >>> widget.getInputValue()\n  Traceback (most recent call last):\n  ...\n  WidgetInputError: ('field', u'Birthday', u'day is out of range for month')\n\n  >>> print widget.error()\n  <span class=\"error\">day is out of range for month</span>\n\nNo error occurred:\n\n  >>> request = TestRequest(form={\n  ...     'field.field.year': '1980',\n  ...     'field.field.month': '1',\n  ...     'field.field.day': '31'})\n  >>> widget = DateSelectWidget(field, request)\n  >>> widget.getInputValue()\n  datetime.date(1980, 1, 31)\n  >>> widget.error()\n  ''\n\n\n``__call__()`` Method\n=====================\n\nThis method renders the widget using the sub-widgets. Let's see the output:\n\n  >>> request = TestRequest(form={\n  ...     'field.field.year': '2006',\n  ...     'field.field.month': '2',\n  ...     'field.field.day': '24'})\n  >>> widget = DateSelectWidget(field, request)\n  >>> print widget()\n  <select id=\"field.field.day\" name=\"field.field.day\" size=\"1\" >\n  <option value=\"1\">1</option>\n  ...\n  <option value=\"23\">23</option>\n  <option selected=\"selected\" value=\"24\">24</option>\n  <option value=\"25\">25</option>\n  ...\n  <option value=\"31\">31</option>\n  </select><input name=\"field.field.day-empty-marker\" type=\"hidden\"\n                  value=\"1\" />&nbsp;\n  <select id=\"field.field.month\" name=\"field.field.month\" size=\"1\" >\n  <option value=\"1\">1</option>\n  <option selected=\"selected\" value=\"2\">2</option>\n  <option value=\"3\">3</option>\n  ...\n  <option value=\"12\">12</option>\n  </select><input name=\"field.field.month-empty-marker\" type=\"hidden\"\n                  value=\"1\" />&nbsp;\n  <select id=\"field.field.year\" name=\"field.field.year\" size=\"1\" >\n  <option value=\"1930\">1930</option>\n  ...\n  <option value=\"2005\">2005</option>\n  <option selected=\"selected\" value=\"2006\">2006</option>\n  </select><input\n      name=\"field.field.year-empty-marker\" type=\"hidden\" value=\"1\" />\n  <BLANKLINE>\n\n\nDropDownDateWidget\n==================\n\n  >>> from z3c.widget.dropdowndatewidget.widget import DropDownDateWidget\n\n  >>> from zope.publisher.browser import TestRequest\n  >>> request = TestRequest()\n\nWidgets are use for fields.\n\n  >>> from zope.schema import Date\n  >>> dateField = Date(__name__='foo', title=u'Foo')\n\n  >>> widget = DropDownDateWidget(dateField, request)\n\n  >>> widget.name\n  'field.foo'\n  >>> widget.label\n  u'Foo'\n  >>> widget.hasInput()\n  False\n\nWe need to provide some input.\n\n  >>> request.form['field.foo.day'] = '1'\n  >>> widget.hasInput()\n  False\n  >>> request.form['field.foo.month'] = '6'\n  >>> widget.hasInput()\n  False\n  >>> request.form['field.foo.year'] = '1963'\n  >>> widget.hasInput()\n  True\n\nRead the value.\n\n  >>> widget.getInputValue()\n  datetime.date(1963, 6, 1)\n\nLet's render the widget.\n\n  >>> print widget()\n  <div class=\"dropDownDateWidget\"><select class=\"dayField\" id=\"field.foo.day\" name=\"field.foo.day\">...</select>\n  <select class=\"monthField\" id=\"field.foo.month\" name=\"field.foo.month\">...</select>\n  <select class=\"yearField\" id=\"field.foo.year\" name=\"field.foo.year\">...</select>\n  </div>\n\nAnd if we set a value.\n\n  >>> from datetime import date\n  >>> widget.setRenderedValue(date(1977, 4, 3))\n  >>> print widget()\n  <div class=\"dropDownDateWidget\"><select ...<option selected=\"selected\" value=\"03\">...\n  <select ...<option selected=\"selected\" value=\"04\">...\n  <select ...<option selected=\"selected\" value=\"1977\">...\n  ...\n\n\n\n===================\nFLASH UPLOAD WIDGET\n===================\n\nthe flashupload vars page configures the flash frontend\n\n    >>> from z3c.widget.flashupload import upload\n    >>> from zope.publisher.browser import TestRequest\n    >>> from zope.app.pagetemplate import ViewPageTemplateFile\n    >>> from zope.app.pagetemplate.simpleviewclass import SimpleViewClass\n    >>> request = TestRequest()\n    >>> context = object()\n    >>> viewClass = SimpleViewClass(\n    ...     'flashuploadvars.pt', bases=(upload.FlashUploadVars,))\n    >>> view = viewClass(context, request)\n    >>> print view()\n    <?xml version=\"1.0\" ?>\n    <var>\n        <var name=\"file_progress\">File Progress</var>\n        <var name=\"overall_progress\">Overall Progress</var>\n        <var name=\"error\">Error on uploading files</var>\n        <var name=\"uploadcomplete\">all files uploaded</var>\n        <var name=\"uploadpartial\">files uploaded</var>\n        <var name=\"notuploaded\">files were not uploaded because\n           they're too big</var>\n        <var name=\"maxfilesize\">maximum file size is</var>\n    </var>\n\n    >>> view.allowedFileTypes = ('.jpg', '.gif')\n    >>> print view()\n    <?xml version=\"1.0\" ?>\n    <var>\n    ...\n        <var name=\"allowedFileType\">.jpg</var>\n        <var name=\"allowedFileType\">.gif</var>\n     </var>\n\n\n\n================\nThe Image Widget\n================\n\nthis image widget should be used as a custom_widget for image fields.\ncomparing to the default widget in zope3 it does not delete the\ndata in the field if the \"delete\" checkbox is not explicitly selected.\n\n\nAdding an Image\n===============\n\n  >>> import zope.schema\n  >>> from zope.publisher.browser import TestRequest\n  >>> from zope import interface\n  >>> from zope.schema.fieldproperty import FieldProperty\n  >>> from zope.app.file.interfaces import IImage\n  >>> from z3c.widget.image.widget import ImageWidget\n  >>> from zope.app.file.image import Image\n\n\ncreate a content type with an image field.\n\n  >>> class ITestObject(interface.Interface):\n  ...     image = zope.schema.Object(\n  ...     title=u'Image',\n  ...     schema=IImage)\n  >>> class TestObject(object):\n  ...     interface.implements(ITestObject)\n  ...     image = FieldProperty(ITestObject['image'])\n\n  >>> obj = TestObject()\n\n  >>> field = ITestObject['image'].bind(obj)\n\n\nSend the request without any image information. the empty field\nshould not be changed...\n\n  >>> request = TestRequest(form={'field.image' : u''})\n  >>> widget = ImageWidget(field, request)\n  >>> widget._getFormInput() is None\n  True\n\nSend some Image information to the field. the image information\nshould be stored in the field as a Image Object\n\n  >>> request = TestRequest(form={'field.image' : u'PNG123Test'})\n  >>> widget = ImageWidget(field, request)\n  >>> widget._getFormInput()\n  <zope.app.file.image.Image object at ...>\n\n\nNow we save the field again, but without any new image data.\nthe old image information should not be lost\n\n  >>> obj.image = Image(u'PNG123Test')\n  >>> request = TestRequest(form={'field.image' : u''})\n  >>> widget = ImageWidget(field, request)\n  >>> widget._getFormInput() is obj.image\n  True\n\nNow we want to delete the image. the forminput should be None now.\n\n  >>> request = TestRequest(form={'field.image' : u'',\n  ...     'field.image.delete': u'true'})\n  >>> widget = ImageWidget(field, request)\n  >>> widget._getFormInput() is None\n  True\n\n  >>> print widget()\n  <div class=\"z3cImageWidget\">\n    <input type=\"file\" name=\"field.image\" id=\"field.image\" /><br/>\n    <input type=\"checkbox\" name=\"field.image.delete\" value=\"true\" />delete image\n  </div>\n\n\n\n\n\n\n====================\nThe Widget Namespace\n====================\n\nThe widget namespace provides a way to traverse to the widgets of a\nformlib form.\n\n  >>> from z3c.widget.namespace.namespace import WidgetHandler\n\nLet us define a form to test this behaviour.\n\n  >>> from zope.formlib import form\n  >>> from zope import interface, schema\n  >>> class IMyContent(interface.Interface):\n  ...     title = schema.TextLine(title=u'Title')\n  >>> class MyContent(object):\n  ...     interface.implements(IMyContent)\n  ...     title=None\n  >>> content = MyContent()\n  >>> from zope.publisher.browser import TestRequest\n  >>> request = TestRequest()\n  >>> class MyForm(form.EditForm):\n  ...     form_fields = form.Fields(IMyContent)\n  >>> view = MyForm(content,request)\n  >>> handler = WidgetHandler(view,request)\n  >>> handler.traverse('title',None)\n  <zope.formlib.textwidgets.TextWidget object at ...>\n\n\n\n=========================\nOptional Dropdown Widgets\n=========================\n\nThe Optional Dropdown Widget simulates the common desktop widget of a combo\nbox, which can also receive a custom entry.\n\nBefore we can start, we have to do a little bit of setup:\n\n  >>> import zope.component\n  >>> import zope.schema\n  >>> import zope.app.form.browser\n  >>> from zope.publisher.interfaces.browser import IBrowserRequest\n\n  >>> zope.component.provideAdapter(\n  ...     zope.app.form.browser.TextWidget,\n  ...     (zope.schema.interfaces.ITextLine, IBrowserRequest),\n  ...     zope.app.form.interfaces.IInputWidget)\n\n\nFirst we have to create a field and a request:\n\n  >>> from z3c.schema.optchoice import OptionalChoice\n\n  >>> optchoice = OptionalChoice(\n  ...     __name__='occupation',\n  ...     title=u'Occupation',\n  ...     description=u'The Occupation',\n  ...     values=(u'Programmer', u'Designer', u'Project Manager'),\n  ...     value_type=zope.schema.TextLine())\n\n  >>> from zope.publisher.browser import TestRequest\n  >>> request = TestRequest()\n\nNow we can initialize widget.\n\n  >>> class Content(object):\n  ...     occupation = None\n  >>> content = Content()\n  >>> boundOptChoice = optchoice.bind(content)\n\n  >>> from z3c.widget.optdropdown import OptionalDropdownWidget\n  >>> widget = OptionalDropdownWidget(boundOptChoice, request)\n\nLet's make sure that all fields have the correct value:\n\n  >>> widget.name\n  'field.occupation'\n\n  >>> widget.label\n  u'Occupation'\n\n  >>> widget.hint\n  u'The Occupation'\n\n  >>> widget.visible\n  True\n\n  >>> widget.required\n  True\n\nThe constructor should have also created 2 widgets:\n\n  >>> widget.customWidget\n  <zope.formlib.textwidgets.TextWidget object at ...>\n  >>> widget.dropdownWidget\n  <zope.formlib.itemswidgets.DropdownWidget object at ...>\n\n\n``setRenderedValue(value)`` Method\n==================================\n\nThe first method is ``setRenderedValue()``. The widget has two use cases,\nbased on the type of value. If the value is a custom value, it will\nsend the information to the custom widget:\n\n  >>> print widget.customWidget()\n  <... value=\"\" />\n  >>> 'selected=\"\"' in widget.dropdownWidget()\n  False\n\n  >>> widget.setRenderedValue(u'Scientist')\n\n  >>> print widget.customWidget()\n  <... value=\"Scientist\" />\n  >>> 'selected=\"\"' in widget.dropdownWidget()\n  False\n\nAfter resetting the widget passing in one of the choices in the\nvocabulary, the value should be displayed in the dropdown:\n\n  >>> widget.setRenderedValue(u'Designer')\n\n  >>> print widget.customWidget()\n  <... value=\"\" />\n  >>> print widget.dropdownWidget()\n  <div>\n  ...\n  <option selected=\"selected\" value=\"Designer\">Designer</option>\n  ...\n  </div>\n\n\n``setPrefix(prefix)`` Method\n============================\n\nThe prefix determines the name of the widget and the sub-widgets.\n\n  >>> widget.name\n  'field.occupation'\n  >>> widget.dropdownWidget.name\n  'field.occupation.occupation'\n  >>> widget.customWidget.name\n  'field.occupation.custom'\n\n  >>> widget.setPrefix('test.')\n\n  >>> widget.name\n  'test.occupation'\n  >>> widget.dropdownWidget.name\n  'test.occupation.occupation'\n  >>> widget.customWidget.name\n  'test.occupation.custom'\n\n\n``getInputValue()`` Method\n==========================\n\nThis method returns a value based on the input; the data is assumed to\nbe valid. In our case that means, if we entered a custom value, it is\nreturned:\n\n  >>> request = TestRequest(form={\n  ...     'field.occupation.custom': u'Teacher'})\n\n  >>> widget = OptionalDropdownWidget(boundOptChoice, request)\n\n  >>> widget.getInputValue()\n  u'Teacher'\n\nOn the other hand, if we selected a choice from the vocabulary, it should be\nreturned:\n\n  >>> request = TestRequest(form={\n  ...     'field.occupation.occupation': u'Designer'})\n\n  >>> widget = OptionalDropdownWidget(boundOptChoice, request)\n\n  >>> widget.getInputValue()\n  u'Designer'\n\n\n``applyChanges(content)`` Method\n================================\n\nThis method applies the new value to the passed content. However, it\nmust be smart enough to detect whether the values really changed.\n\n  >>> request = TestRequest(form={\n  ...     'field.occupation.custom': u'Teacher'})\n\n  >>> widget = OptionalDropdownWidget(boundOptChoice, request)\n  >>> widget.applyChanges(content)\n  True\n  >>> content.occupation\n  u'Teacher'\n\n  >>> widget.applyChanges(content)\n  False\n\n  >>> request = TestRequest(form={\n  ...     'field.occupation.occupation': u'Designer'})\n\n  >>> widget = OptionalDropdownWidget(boundOptChoice, request)\n\n  >>> widget.applyChanges(content)\n  True\n  >>> content.occupation\n  u'Designer'\n\n  >>> widget.applyChanges(content)\n  False\n\n\n``hasInput()`` Method\n=====================\n\nThis mehtod checks for any input, but does not validate it. In our case this\nmeans that either a choice has been selected or the the custom value has been\nentered.\n\n  >>> request = TestRequest()\n  >>> widget = OptionalDropdownWidget(boundOptChoice, request)\n  >>> widget.hasInput()\n  False\n\n  >>> request = TestRequest(form={\n  ...     'field.occupation.custom': u'Teacher\\nBad Stuff'})\n  >>> widget = OptionalDropdownWidget(boundOptChoice, request)\n  >>> widget.hasInput()\n  True\n\n  >>> request = TestRequest(form={\n  ...     'field.occupation.occupation': u'Waitress'})\n  >>> widget = OptionalDropdownWidget(boundOptChoice, request)\n  >>> widget.hasInput()\n  True\n\n\n``hasValidInput()`` Method\n==========================\n\nAdditionally to checking for any input, this method also checks whether the\ninput is valid:\n\n  >>> request = TestRequest()\n  >>> widget = OptionalDropdownWidget(boundOptChoice, request)\n  >>> widget.hasValidInput()\n  False\n\n  >>> request = TestRequest(form={\n  ...     'field.occupation.occupation': u'Waitress'})\n  >>> widget = OptionalDropdownWidget(boundOptChoice, request)\n  >>> widget.hasValidInput()\n  False\n\n  >>> request = TestRequest(form={\n  ...     'field.occupation.occupation': u'Designer'})\n  >>> widget = OptionalDropdownWidget(boundOptChoice, request)\n  >>> widget.hasValidInput()\n  True\n\n  >>> request = TestRequest(form={\n  ...     'field.occupation.custom': u'Teacher\\nBad Stuff'})\n  >>> widget = OptionalDropdownWidget(boundOptChoice, request)\n  >>> widget.hasValidInput()\n  False\n\n  >>> request = TestRequest(form={\n  ...     'field.occupation.custom': u'Teacher'})\n  >>> widget = OptionalDropdownWidget(boundOptChoice, request)\n  >>> widget.hasValidInput()\n  True\n\n\nhidden() Method\n===============\n\nThis method is implemented by simply concatenating the two widget's hidden\noutput:\n\n  >>> request = TestRequest()\n  >>> widget = OptionalDropdownWidget(boundOptChoice, request)\n  >>> widget.setRenderedValue(u'Designer')\n  >>> print widget.hidden()\n  <input class=\"hiddenType\" id=\"field.occupation.occupation\"\n         name=\"field.occupation.occupation\" type=\"hidden\" value=\"Designer\"  />\n  <input class=\"hiddenType\" id=\"field.occupation.custom\"\n         name=\"field.occupation.custom\" type=\"hidden\" value=\"\"  />\n\n  >>> widget.setRenderedValue(u'Teacher')\n  >>> print widget.hidden()\n  <input class=\"hiddenType\" id=\"field.occupation.occupation\"\n         name=\"field.occupation.occupation\" type=\"hidden\" value=\"\"  />\n  <input class=\"hiddenType\" id=\"field.occupation.custom\"\n         name=\"field.occupation.custom\" type=\"hidden\" value=\"Teacher\"  />\n\n\nerror() Method\n==============\n\nAgain, we have our two cases. If an error occured in the dropdown, it is\nreported:\n\n  >>> from zope.app.form.interfaces import IWidgetInputError\n  >>> from zope.app.form.browser.exception import WidgetInputErrorView\n  >>> from zope.app.form.browser.interfaces import IWidgetInputErrorView\n\n  >>> zope.component.provideAdapter(\n  ...     WidgetInputErrorView,\n  ...     (IWidgetInputError, IBrowserRequest), IWidgetInputErrorView)\n\n  >>> request = TestRequest(form={\n  ...     'field.occupation.occupation': u'Designer'})\n  >>> widget = OptionalDropdownWidget(boundOptChoice, request)\n  >>> widget.getInputValue()\n  u'Designer'\n  >>> widget.error()\n  ''\n\n  >>> request = TestRequest(form={\n  ...     'field.occupation.occupation': u'Waitress'})\n  >>> widget = OptionalDropdownWidget(boundOptChoice, request)\n\n  >>> widget.getInputValue()\n  Traceback (most recent call last):\n  ...\n  ConversionError: (u'Invalid value', InvalidValue(\"token u'Waitress' not found in vocabulary\"))\n  >>> widget.error()\n  u'<span class=\"error\">Invalid value</span>'\n\nOtherwise the custom widget's errors are reported:\n\n  >>> request = TestRequest(form={\n  ...     'field.occupation.custom': u'Teacher'})\n  >>> widget = OptionalDropdownWidget(boundOptChoice, request)\n  >>> widget.getInputValue()\n  u'Teacher'\n  >>> widget.error()\n  ''\n\n  >>> request = TestRequest(form={\n  ...     'field.occupation.custom': u'Teacher\\nBad Stuff'})\n  >>> widget = OptionalDropdownWidget(boundOptChoice, request)\n\n  >>> widget.getInputValue()\n  Traceback (most recent call last):\n  ...\n  WidgetInputError: ('custom', u'', ConstraintNotSatisfied(u'Teacher\\nBad Stuff'))\n  >>> widget.error()\n  u'<span class=\"error\">Constraint not satisfied</span>'\n\n\n__call__() Method\n=================\n\nThis method renders the widget using the sub-widgets. It simply adds the two\nwidgets' output placing the ``connector`` between them:\n\n  >>> request = TestRequest(form={\n  ...     'field.occupation.custom': u'Teacher'})\n\n  >>> widget = OptionalDropdownWidget(boundOptChoice, request)\n  >>> widget.connector\n  u'<br />\\n'\n\n  >>> print widget()\n  <div>\n  <div class=\"value\">\n  <select id=\"field.occupation.occupation\"\n          name=\"field.occupation.occupation\" size=\"1\" >\n  <option selected=\"selected\" value=\"\">(nothing selected)</option>\n  <option value=\"Programmer\">Programmer</option>\n  <option value=\"Designer\">Designer</option>\n  <option value=\"Project Manager\">Project Manager</option>\n  </select>\n  </div>\n  <input name=\"field.occupation.occupation-empty-marker\" type=\"hidden\"\n         value=\"1\" />\n  </div><br />\n  <input class=\"textType\" id=\"field.occupation.custom\"\n         name=\"field.occupation.custom\" size=\"20\" type=\"text\" value=\"Teacher\" />\n\n\n====================\nSequenceTable Widget\n====================\n\nThis package provides a Sequence Widget just as\nzope.app.form.browser.sequencewidget.\nThe main difference is that it places the subobject's fields horizontally in\na table. That means a kind of voucher-item forms are piece of cake to do.\n\nThere is also a widget (SequenceTableJSWidget) which does the add/remove item\nin the browser with javascript.\nThe trick is to embed an invisible template of an empty row in the HTML,\nadd that each time a new row is required.\n\nDrawbacks of JS:\n * Validation is done ONLY when the complete form is submitted to the server.\n * Submitting the form and using the Back button of the browser does not work.\n\nWARNING!\n========\nThe subobject MUST have subwidgets. That is usually the case if the subobject\nis based on zope.schema.Object.\n\nTODO\n====\nTests.\nSome are there, some are copied from z.a.form.browser and need fix.\n\n==========\nSSN Widget\n==========\n\nThe social security number widget can be used as a custom widget for text line\nfields, enforcing a particular layout.\n\nFirst we have to create a field and a request:\n\n  >>> import datetime\n  >>> import zope.schema\n\n  >>> field = zope.schema.TextLine(\n  ...     title=u'SSN',\n  ...     description=u'Social Security Number',\n  ...     required=True)\n  >>> field.__name__ = 'field'\n\n  >>> from zope.publisher.browser import TestRequest\n  >>> request = TestRequest()\n\nNow we can initialize widget.\n\n  >>> from z3c.widget.ssn.browser import SSNWidget\n  >>> widget = SSNWidget(field, request)\n\nLet's make sure that all fields have the correct value:\n\n  >>> widget.name\n  'field.field'\n\n  >>> widget.label\n  u'SSN'\n\n  >>> widget.hint\n  u'Social Security Number'\n\n  >>> widget.visible\n  True\n\n  >>> widget.required\n  True\n\nThe constructor should have also created 3 sub-widgets:\n\n  >>> widget.widgets['first']\n  <zope.formlib.textwidgets.TextWidget object at ...>\n  >>> widget.widgets['second']\n  <zope.formlib.textwidgets.TextWidget object at ...>\n  >>> widget.widgets['third']\n  <zope.formlib.textwidgets.TextWidget object at ...>\n\n\n``setRenderedValue(value)`` Method\n==================================\n\nThe first method is ``setRenderedValue()``. The widget has two use cases,\nbased on the type of value:\n\n  >>> widget = SSNWidget(field, request)\n  >>> widget.setRenderedValue(u'123-45-6789')\n  >>> print widget()\n  <input class=\"textType\" id=\"field.field.first\" name=\"field.field.first\"\n         size=\"3\" type=\"text\" value=\"123\"  />&nbsp;&mdash;&nbsp;\n  <input class=\"textType\" id=\"field.field.second\" name=\"field.field.second\"\n         size=\"2\" type=\"text\" value=\"45\"  />&nbsp;&mdash;&nbsp;\n  <input class=\"textType\" id=\"field.field.third\" name=\"field.field.third\"\n         size=\"4\" type=\"text\" value=\"6789\"  />\n\n\n``setPrefix(prefix)`` Method\n============================\n\nThe prefix determines the name of the widget and all its sub-widgets.\n\n  >>> widget.name\n  'field.field'\n  >>> widget.widgets['first'].name\n  'field.field.first'\n  >>> widget.widgets['second'].name\n  'field.field.second'\n  >>> widget.widgets['third'].name\n  'field.field.third'\n\n  >>> widget.setPrefix('test.')\n\n  >>> widget.name\n  'test.field'\n  >>> widget.widgets['first'].name\n  'test.field.first'\n  >>> widget.widgets['second'].name\n  'test.field.second'\n  >>> widget.widgets['third'].name\n  'test.field.third'\n\nIf the prefix does not end in a dot, one is added:\n\n  >>> widget.setPrefix('test')\n\n  >>> widget.name\n  'test.field'\n  >>> widget.widgets['first'].name\n  'test.field.first'\n  >>> widget.widgets['second'].name\n  'test.field.second'\n  >>> widget.widgets['third'].name\n  'test.field.third'\n\n\n``getInputValue()`` Method\n==========================\n\nThis method returns the full SSN string:\n\n  >>> request = TestRequest(form={\n  ...     'field.field.first': '123',\n  ...     'field.field.second': '45',\n  ...     'field.field.third': '6789'})\n\n  >>> widget = SSNWidget(field, request)\n\n  >>> value = widget.getInputValue()\n  >>> value\n  u'123-45-6789'\n\nIf a set of values does not produce a valid string, a value error is\nraised:\n\n  >>> request = TestRequest(form={\n  ...     'field.field.first': '1234',\n  ...     'field.field.second': '56',\n  ...     'field.field.third': '7890'})\n\n  >>> widget = SSNWidget(field, request)\n  >>> widget.getInputValue()\n  Traceback (most recent call last):\n  ...\n  WidgetInputError: ('first', u'Frst three digits', ConstraintNotSatisfied(u'1234'))\n\n  >>> widget._error.__class__\n  <class 'zope.formlib.interfaces.WidgetInputError'>\n\n\n``applyChanges(content)`` Method\n================================\n\nThis method applies the new SSN to the passed content. However, it\nmust be smart enough to detect whether the values really changed.\n\n  >>> class Content(object):\n  ...     field = None\n  >>> content = Content()\n\n  >>> request = TestRequest(form={\n  ...     'field.field.first': '123',\n  ...     'field.field.second': '45',\n  ...     'field.field.third': '6789'})\n\n  >>> widget = SSNWidget(field, request)\n  >>> widget.applyChanges(content)\n  True\n  >>> content.field\n  u'123-45-6789'\n\n  >>> widget.applyChanges(content)\n  False\n\n\n``hasInput()`` Method\n=====================\n\nThis method checks for any input, but does not validate it.\n\n  >>> request = TestRequest()\n  >>> widget = SSNWidget(field, request)\n  >>> widget.hasInput()\n  False\n\n  >>> request = TestRequest(form={\n  ...     'field.field.first': '123'})\n  >>> widget = SSNWidget(field, request)\n  >>> widget.hasInput()\n  False\n\n  >>> request = TestRequest(form={\n  ...     'field.field.second': '45'})\n  >>> widget = SSNWidget(field, request)\n  >>> widget.hasInput()\n  False\n\n  >>> request = TestRequest(form={\n  ...     'field.field.third': '6789'})\n  >>> widget = SSNWidget(field, request)\n  >>> widget.hasInput()\n  False\n\n  >>> request = TestRequest(form={\n  ...     'field.field.first': '123',\n  ...     'field.field.second': '45',\n  ...     'field.field.third': '6789'})\n  >>> widget = SSNWidget(field, request)\n  >>> widget.hasInput()\n  True\n\n\n``hasValidInput()`` Method\n==========================\n\nAdditionally to checking for any input, this method also checks whether the\ninput is valid:\n\n  >>> request = TestRequest()\n  >>> widget = SSNWidget(field, request)\n  >>> widget.hasValidInput()\n  False\n\n  >>> request = TestRequest(form={\n  ...     'field.field.first': '123'})\n  >>> widget = SSNWidget(field, request)\n  >>> widget.hasValidInput()\n  False\n\n  >>> request = TestRequest(form={\n  ...     'field.field.second': '45'})\n  >>> widget = SSNWidget(field, request)\n  >>> widget.hasValidInput()\n  False\n\n  >>> request = TestRequest(form={\n  ...     'field.field.third': '6789'})\n  >>> widget = SSNWidget(field, request)\n  >>> widget.hasValidInput()\n  False\n\n  >>> request = TestRequest(form={\n  ...     'field.field.first': '123',\n  ...     'field.field.second': '45',\n  ...     'field.field.third': '6789'})\n  >>> widget = SSNWidget(field, request)\n  >>> widget.hasValidInput()\n  True\n\n\n``hidden()`` Method\n===================\n\nThis method is renders the output as hidden fields:\n\n  >>> request = TestRequest(form={\n  ...     'field.field.first': '123',\n  ...     'field.field.second': '45',\n  ...     'field.field.third': '6789'})\n  >>> widget = SSNWidget(field, request)\n  >>> print widget.hidden()\n  <input class=\"hiddenType\" id=\"field.field.first\" name=\"field.field.first\"\n         type=\"hidden\" value=\"123\" />\n  <input class=\"hiddenType\" id=\"field.field.second\" name=\"field.field.second\"\n         type=\"hidden\" value=\"45\"  />\n  <input class=\"hiddenType\" id=\"field.field.third\" name=\"field.field.third\"\n         type=\"hidden\" value=\"6789\"  />\n\n\n``error()`` Method\n==================\n\nLet's test some bad data and check the error handling.\n\nThe third field contains an invalid value:\n\n  >>> request = TestRequest(form={\n  ...     'field.field.first': '123',\n  ...     'field.field.second': '45',\n  ...     'field.field.third': '678'})\n  >>> widget = SSNWidget(field, request)\n  >>> widget.getInputValue()\n  Traceback (most recent call last):\n  ...\n  WidgetInputError: ('third', u'Third four digits', ConstraintNotSatisfied(u'678'))\n  >>> print widget.error()\n  <span class=\"error\">Constraint not satisfied</span>\n\nThe second field contains an invalid value:\n\n  >>> request = TestRequest(form={\n  ...     'field.field.first': '123',\n  ...     'field.field.second': '4-',\n  ...     'field.field.third': '6789'})\n  >>> widget = SSNWidget(field, request)\n  >>> widget.getInputValue()\n  Traceback (most recent call last):\n  ...\n  WidgetInputError: ('second', u'Second two digits', ConstraintNotSatisfied(u'4-'))\n  >>> print widget.error()\n  <span class=\"error\">Constraint not satisfied</span>\n\nThe first field contains an invalid value:\n\n  >>> request = TestRequest(form={\n  ...     'field.field.first': 'xxx',\n  ...     'field.field.second': '45',\n  ...     'field.field.third': '6789'})\n  >>> widget = SSNWidget(field, request)\n  >>> widget.getInputValue()\n  Traceback (most recent call last):\n  ...\n  WidgetInputError: ('first', u'Frst three digits', ConstraintNotSatisfied(u'xxx'))\n  >>> print widget.error()\n  <span class=\"error\">Constraint not satisfied</span>\n\nNo error occurred:\n\n  >>> request = TestRequest(form={\n  ...     'field.field.first': '123',\n  ...     'field.field.second': '45',\n  ...     'field.field.third': '6789'})\n  >>> widget = SSNWidget(field, request)\n  >>> widget.getInputValue()\n  u'123-45-6789'\n  >>> widget.error()\n  ''\n\n\n``__call__()`` Method\n=====================\n\nThis method renders the widget using the sub-widgets. Let's see the output:\n\n  >>> request = TestRequest(form={\n  ...     'field.field.first': '123',\n  ...     'field.field.second': '45',\n  ...     'field.field.third': '6789'})\n  >>> widget = SSNWidget(field, request)\n  >>> print widget()\n  <input class=\"textType\" id=\"field.field.first\" name=\"field.field.first\"\n         size=\"3\" type=\"text\" value=\"123\"  />&nbsp;&mdash;&nbsp;\n  <input class=\"textType\" id=\"field.field.second\" name=\"field.field.second\"\n         size=\"2\" type=\"text\" value=\"45\"  />&nbsp;&mdash;&nbsp;\n  <input class=\"textType\" id=\"field.field.third\" name=\"field.field.third\"\n         size=\"4\" type=\"text\" value=\"6789\"  />\n\n\n==========================\nHTML-Editor Widget TinyMCE\n==========================\n\nThis package provides a WYSIWYG-Editor-Widget for HTML-Content, by\nusing the greate TinyMCE editor (see: http://tinymce.moxiecode.com/).\n\n\n\n\n===============\nUS Phone Widget\n===============\n\nThe US phone number widget can be used as a custom widget for text line\nfields, enforcing a particular layout.\n\nFirst we have to create a field and a request:\n\n  >>> import datetime\n  >>> import zope.schema\n\n  >>> field = zope.schema.TextLine(\n  ...     title=u'Phone',\n  ...     description=u'Phone Number',\n  ...     required=True)\n  >>> field.__name__ = 'field'\n\n  >>> from zope.publisher.browser import TestRequest\n  >>> request = TestRequest()\n\nNow we can initialize widget.\n\n  >>> from z3c.widget.usphone.browser import PhoneWidget\n  >>> widget = PhoneWidget(field, request)\n\nLet's make sure that all fields have the correct value:\n\n  >>> widget.name\n  'field.field'\n\n  >>> widget.label\n  u'Phone'\n\n  >>> widget.hint\n  u'Phone Number'\n\n  >>> widget.visible\n  True\n\n  >>> widget.required\n  True\n\nThe constructor should have also created 3 sub-widgets:\n\n  >>> widget.widgets['first']\n  <zope.formlib.textwidgets.TextWidget object at ...>\n  >>> widget.widgets['second']\n  <zope.formlib.textwidgets.TextWidget object at ...>\n  >>> widget.widgets['third']\n  <zope.formlib.textwidgets.TextWidget object at ...>\n\n\n``setRenderedValue(value)`` Method\n==================================\n\nThe first method is ``setRenderedValue()``. The widget has two use cases,\nbased on the type of value:\n\n  >>> widget = PhoneWidget(field, request)\n  >>> widget.setRenderedValue(u'123-456-7890')\n  >>> print widget()\n  (<input class=\"textType\" id=\"field.field.first\" name=\"field.field.first\"\n          size=\"3\" type=\"text\" value=\"123\"  />)&nbsp;\n  <input class=\"textType\" id=\"field.field.second\" name=\"field.field.second\"\n         size=\"3\" type=\"text\" value=\"456\"  />&nbsp;&mdash;&nbsp;\n  <input class=\"textType\" id=\"field.field.third\" name=\"field.field.third\"\n         size=\"4\" type=\"text\" value=\"7890\"  />\n\n\n``setPrefix(prefix)`` Method\n============================\n\nThe prefix determines the name of the widget and all its sub-widgets.\n\n  >>> widget.name\n  'field.field'\n  >>> widget.widgets['first'].name\n  'field.field.first'\n  >>> widget.widgets['second'].name\n  'field.field.second'\n  >>> widget.widgets['third'].name\n  'field.field.third'\n\n  >>> widget.setPrefix('test.')\n\n  >>> widget.name\n  'test.field'\n  >>> widget.widgets['first'].name\n  'test.field.first'\n  >>> widget.widgets['second'].name\n  'test.field.second'\n  >>> widget.widgets['third'].name\n  'test.field.third'\n\nIf the prefix does not end in a dot, one is added:\n\n  >>> widget.setPrefix('test')\n\n  >>> widget.name\n  'test.field'\n  >>> widget.widgets['first'].name\n  'test.field.first'\n  >>> widget.widgets['second'].name\n  'test.field.second'\n  >>> widget.widgets['third'].name\n  'test.field.third'\n\n\n``getInputValue()`` Method\n==========================\n\nThis method returns the full phone string:\n\n  >>> request = TestRequest(form={\n  ...     'field.field.first': '123',\n  ...     'field.field.second': '456',\n  ...     'field.field.third': '7890'})\n\n  >>> widget = PhoneWidget(field, request)\n\n  >>> value = widget.getInputValue()\n  >>> value\n  u'123-456-7890'\n\nIf a set of values does not produce a valid string, a value error is\nraised:\n\n  >>> request = TestRequest(form={\n  ...     'field.field.first': '1234',\n  ...     'field.field.second': '56',\n  ...     'field.field.third': '7890'})\n\n  >>> widget = PhoneWidget(field, request)\n  >>> widget.getInputValue()\n  Traceback (most recent call last):\n  ...\n  WidgetInputError: ('first', u'Area Code', ConstraintNotSatisfied(u'1234'))\n\n  >>> widget._error.__class__\n  <class 'zope.formlib.interfaces.WidgetInputError'>\n\n\n``applyChanges(content)`` Method\n================================\n\nThis method applies the new phone number to the passed content. However, it\nmust be smart enough to detect whether the values really changed.\n\n  >>> class Content(object):\n  ...     field = None\n  >>> content = Content()\n\n  >>> request = TestRequest(form={\n  ...     'field.field.first': '123',\n  ...     'field.field.second': '456',\n  ...     'field.field.third': '7890'})\n\n  >>> widget = PhoneWidget(field, request)\n  >>> widget.applyChanges(content)\n  True\n  >>> content.field\n  u'123-456-7890'\n\n  >>> widget.applyChanges(content)\n  False\n\n\n``hasInput()`` Method\n=====================\n\nThis method checks for any input, but does not validate it.\n\n  >>> request = TestRequest()\n  >>> widget = PhoneWidget(field, request)\n  >>> widget.hasInput()\n  False\n\n  >>> request = TestRequest(form={\n  ...     'field.field.first': '123'})\n  >>> widget = PhoneWidget(field, request)\n  >>> widget.hasInput()\n  False\n\n  >>> request = TestRequest(form={\n  ...     'field.field.second': '456'})\n  >>> widget = PhoneWidget(field, request)\n  >>> widget.hasInput()\n  False\n\n  >>> request = TestRequest(form={\n  ...     'field.field.third': '7890'})\n  >>> widget = PhoneWidget(field, request)\n  >>> widget.hasInput()\n  False\n\n  >>> request = TestRequest(form={\n  ...     'field.field.first': '123',\n  ...     'field.field.second': '456',\n  ...     'field.field.third': '7890'})\n  >>> widget = PhoneWidget(field, request)\n  >>> widget.hasInput()\n  True\n\n\n``hasValidInput()`` Method\n==========================\n\nAdditionally to checking for any input, this method also checks whether the\ninput is valid:\n\n  >>> request = TestRequest()\n  >>> widget = PhoneWidget(field, request)\n  >>> widget.hasValidInput()\n  False\n\n  >>> request = TestRequest(form={\n  ...     'field.field.first': '123'})\n  >>> widget = PhoneWidget(field, request)\n  >>> widget.hasValidInput()\n  False\n\n  >>> request = TestRequest(form={\n  ...     'field.field.second': '456'})\n  >>> widget = PhoneWidget(field, request)\n  >>> widget.hasValidInput()\n  False\n\n  >>> request = TestRequest(form={\n  ...     'field.field.third': '7890'})\n  >>> widget = PhoneWidget(field, request)\n  >>> widget.hasValidInput()\n  False\n\n  >>> request = TestRequest(form={\n  ...     'field.field.first': '123',\n  ...     'field.field.second': '456',\n  ...     'field.field.third': '7890'})\n  >>> widget = PhoneWidget(field, request)\n  >>> widget.hasValidInput()\n  True\n\n\n``hidden()`` Method\n===================\n\nThis method is renders the output as hidden fields:\n\n  >>> request = TestRequest(form={\n  ...     'field.field.first': '123',\n  ...     'field.field.second': '456',\n  ...     'field.field.third': '7890'})\n  >>> widget = PhoneWidget(field, request)\n  >>> print widget.hidden()\n  <input class=\"hiddenType\" id=\"field.field.first\" name=\"field.field.first\"\n         type=\"hidden\" value=\"123\" />\n  <input class=\"hiddenType\" id=\"field.field.second\" name=\"field.field.second\"\n         type=\"hidden\" value=\"456\"  />\n  <input class=\"hiddenType\" id=\"field.field.third\" name=\"field.field.third\"\n         type=\"hidden\" value=\"7890\"  />\n\n\n``error()`` Method\n==================\n\nLet's test some bad data and check the error handling.\n\nThe third field contains an invalid value:\n\n  >>> request = TestRequest(form={\n  ...     'field.field.first': '123',\n  ...     'field.field.second': '456',\n  ...     'field.field.third': '78901'})\n  >>> widget = PhoneWidget(field, request)\n  >>> widget.getInputValue()\n  Traceback (most recent call last):\n  ...\n  WidgetInputError: ('third', u'Four Digits', ConstraintNotSatisfied(u'78901'))\n\n  >>> print widget.error()\n  <span class=\"error\">Constraint not satisfied</span>\n\nThe second field contains an invalid value:\n\n  >>> request = TestRequest(form={\n  ...     'field.field.first': '123',\n  ...     'field.field.second': '45-',\n  ...     'field.field.third': '7890'})\n  >>> widget = PhoneWidget(field, request)\n  >>> widget.getInputValue()\n  Traceback (most recent call last):\n  ...\n  WidgetInputError: ('second', u'Three Digits', ConstraintNotSatisfied(u'45-'))\n\n  >>> print widget.error()\n  <span class=\"error\">Constraint not satisfied</span>\n\nThe first field contains an invalid value:\n\n  >>> request = TestRequest(form={\n  ...     'field.field.first': 'xxx',\n  ...     'field.field.second': '456',\n  ...     'field.field.third': '7890'})\n  >>> widget = PhoneWidget(field, request)\n  >>> widget.getInputValue()\n  Traceback (most recent call last):\n  ...\n  WidgetInputError: ('first', u'Area Code', ConstraintNotSatisfied(u'xxx'))\n\n  >>> print widget.error()\n  <span class=\"error\">Constraint not satisfied</span>\n\nNo error occurred:\n\n  >>> request = TestRequest(form={\n  ...     'field.field.first': '123',\n  ...     'field.field.second': '456',\n  ...     'field.field.third': '7890'})\n  >>> widget = PhoneWidget(field, request)\n  >>> widget.getInputValue()\n  u'123-456-7890'\n  >>> widget.error()\n  ''\n\n\n``__call__()`` Method\n=====================\n\nThis method renders the widget using the sub-widgets. Let's see the output:\n\n  >>> request = TestRequest(form={\n  ...     'field.field.first': '123',\n  ...     'field.field.second': '456',\n  ...     'field.field.third': '7890'})\n  >>> widget = PhoneWidget(field, request)\n  >>> print widget()\n  (<input class=\"textType\" id=\"field.field.first\" name=\"field.field.first\"\n          size=\"3\" type=\"text\" value=\"123\"  />)&nbsp;\n  <input class=\"textType\" id=\"field.field.second\" name=\"field.field.second\"\n         size=\"3\" type=\"text\" value=\"456\"  />&nbsp;&mdash;&nbsp;\n  <input class=\"textType\" id=\"field.field.third\" name=\"field.field.third\"\n         size=\"4\" type=\"text\" value=\"7890\"  />", "description_content_type": null, "docs_url": null, "download_url": "UNKNOWN", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "http://svn.zope.org/z3c.widget", "keywords": "zope zope3 form formlib", "license": "ZPL 2.1", "maintainer": null, "maintainer_email": null, "name": "z3c.widget", "package_url": "https://pypi.org/project/z3c.widget/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/z3c.widget/", "project_urls": {"Download": "UNKNOWN", "Homepage": "http://svn.zope.org/z3c.widget"}, "release_url": "https://pypi.org/project/z3c.widget/0.3.0/", "requires_dist": null, "requires_python": null, "summary": "Additional zope.formlib Widgets", "version": "0.3.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            <div id=\"contents\">\n<p>Contents</p>\n<ul>\n<li><a href=\"#changes-for-z3c-widget\" id=\"id39\" rel=\"nofollow\">Changes for z3c.widget</a><ul>\n<li><a href=\"#id1\" id=\"id40\" rel=\"nofollow\">0.3.0 (2010-11-16)</a></li>\n<li><a href=\"#id2\" id=\"id41\" rel=\"nofollow\">2008/01/29 0.2.1</a></li>\n<li><a href=\"#id3\" id=\"id42\" rel=\"nofollow\">2007/09/21 0.2.0</a></li>\n<li><a href=\"#id4\" id=\"id43\" rel=\"nofollow\">2007/09/19 0.1.7</a></li>\n<li><a href=\"#id5\" id=\"id44\" rel=\"nofollow\">2007/09/19 0.1.6</a></li>\n<li><a href=\"#id6\" id=\"id45\" rel=\"nofollow\">2007/09/05 0.1.5</a></li>\n<li><a href=\"#id7\" id=\"id46\" rel=\"nofollow\">2007/09/05 0.1.4</a></li>\n<li><a href=\"#id8\" id=\"id47\" rel=\"nofollow\">2007/09/03 0.1.3</a></li>\n<li><a href=\"#id9\" id=\"id48\" rel=\"nofollow\">2007/09/03 0.1.2</a></li>\n<li><a href=\"#id10\" id=\"id49\" rel=\"nofollow\">2007/08/06 0.1.1</a></li>\n<li><a href=\"#id11\" id=\"id50\" rel=\"nofollow\">2007/06/14 0.1.0:</a></li>\n</ul>\n</li>\n<li><a href=\"#autocomplete-widgets\" id=\"id51\" rel=\"nofollow\">Autocomplete Widgets</a></li>\n<li><a href=\"#autocompletewidget-demo\" id=\"id52\" rel=\"nofollow\">AutoCompleteWidget Demo</a></li>\n<li><a href=\"#country-selection-widgets\" id=\"id53\" rel=\"nofollow\">Country selection Widgets</a></li>\n<li><a href=\"#date-selection-widget\" id=\"id54\" rel=\"nofollow\">Date Selection Widget</a><ul>\n<li><a href=\"#setrenderedvalue-value-method\" id=\"id55\" rel=\"nofollow\"><tt>setRenderedValue(value)</tt> Method</a></li>\n<li><a href=\"#setprefix-prefix-method\" id=\"id56\" rel=\"nofollow\"><tt>setPrefix(prefix)</tt> Method</a></li>\n<li><a href=\"#getinputvalue-method\" id=\"id57\" rel=\"nofollow\"><tt>getInputValue()</tt> Method</a></li>\n<li><a href=\"#applychanges-content-method\" id=\"id58\" rel=\"nofollow\"><tt>applyChanges(content)</tt> Method</a></li>\n<li><a href=\"#hasinput-method\" id=\"id59\" rel=\"nofollow\"><tt>hasInput()</tt> Method</a></li>\n<li><a href=\"#hasvalidinput-method\" id=\"id60\" rel=\"nofollow\"><tt>hasValidInput()</tt> Method</a></li>\n<li><a href=\"#hidden-method\" id=\"id61\" rel=\"nofollow\"><tt>hidden()</tt> Method</a></li>\n<li><a href=\"#error-method\" id=\"id62\" rel=\"nofollow\"><tt>error()</tt> Method</a></li>\n<li><a href=\"#call-method\" id=\"id63\" rel=\"nofollow\"><tt>__call__()</tt> Method</a></li>\n<li><a href=\"#dropdowndatewidget\" id=\"id64\" rel=\"nofollow\">DropDownDateWidget</a></li>\n</ul>\n</li>\n<li><a href=\"#flash-upload-widget\" id=\"id65\" rel=\"nofollow\">FLASH UPLOAD WIDGET</a></li>\n<li><a href=\"#the-image-widget\" id=\"id66\" rel=\"nofollow\">The Image Widget</a><ul>\n<li><a href=\"#adding-an-image\" id=\"id67\" rel=\"nofollow\">Adding an Image</a></li>\n</ul>\n</li>\n<li><a href=\"#the-widget-namespace\" id=\"id68\" rel=\"nofollow\">The Widget Namespace</a></li>\n<li><a href=\"#optional-dropdown-widgets\" id=\"id69\" rel=\"nofollow\">Optional Dropdown Widgets</a><ul>\n<li><a href=\"#id12\" id=\"id70\" rel=\"nofollow\"><tt>setRenderedValue(value)</tt> Method</a></li>\n<li><a href=\"#id13\" id=\"id71\" rel=\"nofollow\"><tt>setPrefix(prefix)</tt> Method</a></li>\n<li><a href=\"#id14\" id=\"id72\" rel=\"nofollow\"><tt>getInputValue()</tt> Method</a></li>\n<li><a href=\"#id15\" id=\"id73\" rel=\"nofollow\"><tt>applyChanges(content)</tt> Method</a></li>\n<li><a href=\"#id16\" id=\"id74\" rel=\"nofollow\"><tt>hasInput()</tt> Method</a></li>\n<li><a href=\"#id17\" id=\"id75\" rel=\"nofollow\"><tt>hasValidInput()</tt> Method</a></li>\n<li><a href=\"#id18\" id=\"id76\" rel=\"nofollow\">hidden() Method</a></li>\n<li><a href=\"#id19\" id=\"id77\" rel=\"nofollow\">error() Method</a></li>\n<li><a href=\"#id20\" id=\"id78\" rel=\"nofollow\">__call__() Method</a></li>\n</ul>\n</li>\n<li><a href=\"#sequencetable-widget\" id=\"id79\" rel=\"nofollow\">SequenceTable Widget</a><ul>\n<li><a href=\"#warning\" id=\"id80\" rel=\"nofollow\">WARNING!</a></li>\n<li><a href=\"#todo\" id=\"id81\" rel=\"nofollow\">TODO</a></li>\n</ul>\n</li>\n<li><a href=\"#ssn-widget\" id=\"id82\" rel=\"nofollow\">SSN Widget</a><ul>\n<li><a href=\"#id21\" id=\"id83\" rel=\"nofollow\"><tt>setRenderedValue(value)</tt> Method</a></li>\n<li><a href=\"#id22\" id=\"id84\" rel=\"nofollow\"><tt>setPrefix(prefix)</tt> Method</a></li>\n<li><a href=\"#id23\" id=\"id85\" rel=\"nofollow\"><tt>getInputValue()</tt> Method</a></li>\n<li><a href=\"#id24\" id=\"id86\" rel=\"nofollow\"><tt>applyChanges(content)</tt> Method</a></li>\n<li><a href=\"#id25\" id=\"id87\" rel=\"nofollow\"><tt>hasInput()</tt> Method</a></li>\n<li><a href=\"#id26\" id=\"id88\" rel=\"nofollow\"><tt>hasValidInput()</tt> Method</a></li>\n<li><a href=\"#id27\" id=\"id89\" rel=\"nofollow\"><tt>hidden()</tt> Method</a></li>\n<li><a href=\"#id28\" id=\"id90\" rel=\"nofollow\"><tt>error()</tt> Method</a></li>\n<li><a href=\"#id29\" id=\"id91\" rel=\"nofollow\"><tt>__call__()</tt> Method</a></li>\n</ul>\n</li>\n<li><a href=\"#html-editor-widget-tinymce\" id=\"id92\" rel=\"nofollow\">HTML-Editor Widget TinyMCE</a></li>\n<li><a href=\"#us-phone-widget\" id=\"id93\" rel=\"nofollow\">US Phone Widget</a><ul>\n<li><a href=\"#id30\" id=\"id94\" rel=\"nofollow\"><tt>setRenderedValue(value)</tt> Method</a></li>\n<li><a href=\"#id31\" id=\"id95\" rel=\"nofollow\"><tt>setPrefix(prefix)</tt> Method</a></li>\n<li><a href=\"#id32\" id=\"id96\" rel=\"nofollow\"><tt>getInputValue()</tt> Method</a></li>\n<li><a href=\"#id33\" id=\"id97\" rel=\"nofollow\"><tt>applyChanges(content)</tt> Method</a></li>\n<li><a href=\"#id34\" id=\"id98\" rel=\"nofollow\"><tt>hasInput()</tt> Method</a></li>\n<li><a href=\"#id35\" id=\"id99\" rel=\"nofollow\"><tt>hasValidInput()</tt> Method</a></li>\n<li><a href=\"#id36\" id=\"id100\" rel=\"nofollow\"><tt>hidden()</tt> Method</a></li>\n<li><a href=\"#id37\" id=\"id101\" rel=\"nofollow\"><tt>error()</tt> Method</a></li>\n<li><a href=\"#id38\" id=\"id102\" rel=\"nofollow\"><tt>__call__()</tt> Method</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<div id=\"changes-for-z3c-widget\">\n<h2><a href=\"#id39\" rel=\"nofollow\">Changes for z3c.widget</a></h2>\n<div id=\"id1\">\n<h3><a href=\"#id40\" rel=\"nofollow\">0.3.0 (2010-11-16)</a></h3>\n<blockquote>\n<ul>\n<li>Added translation for french.</li>\n<li>Updated tests to run with <cite>zope.formlib</cite> 4.0 and <cite>zope.schema</cite> 3.6.</li>\n<li>Using Python\u2019s <tt>doctest</tt> module instead of depreacted\n<tt>zope.testing.doctest[unit]</tt>.</li>\n<li>Added doctests to <tt>long_description</tt> to be visible on PyPI.</li>\n</ul>\n</blockquote>\n</div>\n<div id=\"id2\">\n<h3><a href=\"#id41\" rel=\"nofollow\">2008/01/29 0.2.1</a></h3>\n<blockquote>\n<ul>\n<li>add translation for hungarian and romanian languages</li>\n</ul>\n</blockquote>\n</div>\n<div id=\"id3\">\n<h3><a href=\"#id42\" rel=\"nofollow\">2007/09/21 0.2.0</a></h3>\n<blockquote>\n<ul>\n<li>feature: Added a date-selection widget.</li>\n<li>feature: Added a social security number widget.</li>\n<li>feature: Added a US phone number widget.</li>\n</ul>\n</blockquote>\n</div>\n<div id=\"id4\">\n<h3><a href=\"#id43\" rel=\"nofollow\">2007/09/19 0.1.7</a></h3>\n<blockquote>\n<ul>\n<li>added translation for english to get i18n working in some browsers</li>\n</ul>\n</blockquote>\n</div>\n<div id=\"id5\">\n<h3><a href=\"#id44\" rel=\"nofollow\">2007/09/19 0.1.6</a></h3>\n<blockquote>\n<ul>\n<li>added cheesehop classification, registered there</li>\n<li>fixed typos</li>\n</ul>\n</blockquote>\n</div>\n<div id=\"id6\">\n<h3><a href=\"#id45\" rel=\"nofollow\">2007/09/05 0.1.5</a></h3>\n<blockquote>\n<ul>\n<li>bugfix: browse butten will now be enabled after cancel was clicked in\nthe open file dialog</li>\n<li>do not set the progessbar to 100% before the upload was started</li>\n<li>bugfix: files will not be uploaded if no limit was set</li>\n</ul>\n</blockquote>\n</div>\n<div id=\"id7\">\n<h3><a href=\"#id46\" rel=\"nofollow\">2007/09/05 0.1.4</a></h3>\n<blockquote>\n<ul>\n<li>dealing file size during upload. If one or more files are bigger than\nthe passed size each one of them will be ignored during upload but listed\nbelow the progress bar after the upload of the working files is done.</li>\n<li>displaying the maximal allowed file size (if it\u2019s contained in the config\nfile)</li>\n</ul>\n</blockquote>\n</div>\n<div id=\"id8\">\n<h3><a href=\"#id47\" rel=\"nofollow\">2007/09/03 0.1.3</a></h3>\n<blockquote>\n<ul>\n<li>bugfix: too much quoting.</li>\n</ul>\n</blockquote>\n</div>\n<div id=\"id9\">\n<h3><a href=\"#id48\" rel=\"nofollow\">2007/09/03 0.1.2</a></h3>\n<blockquote>\n<ul>\n<li>using passed config url instead of hard coded flashuploadvars.xml</li>\n</ul>\n</blockquote>\n</div>\n<div id=\"id10\">\n<h3><a href=\"#id49\" rel=\"nofollow\">2007/08/06 0.1.1</a></h3>\n<blockquote>\n<ul>\n<li>flashupload: better skinnability for upload.swf. cleanup folder\nstructure for flash stuff.</li>\n</ul>\n</blockquote>\n</div>\n<div id=\"id11\">\n<h3><a href=\"#id50\" rel=\"nofollow\">2007/06/14 0.1.0:</a></h3>\n<blockquote>\n<ul>\n<li>z3c.widget.image: added translations for es</li>\n<li>update to newest bootstrap.py version</li>\n</ul>\n</blockquote>\n</div>\n</div>\n<div id=\"autocomplete-widgets\">\n<h2><a href=\"#id51\" rel=\"nofollow\">Autocomplete Widgets</a></h2>\n<p>Autocomplete widgets are an alternative to normal select widgets.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from z3c.widget.autocomplete.widget import AutoCompleteWidget\n</pre>\n</blockquote>\n<p>Let us create a vocabulary.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from zope.schema.vocabulary import SimpleVocabulary\n&gt;&gt;&gt; from zope.publisher.browser import TestRequest\n&gt;&gt;&gt; from zope import schema, component, interface\n&gt;&gt;&gt; items = ((u'value1',1,u'Title1'),\n...          (u'value2',2,u'Title2'),\n...          (u'value3',3,u'Title3'))\n&gt;&gt;&gt; terms = map(lambda i: SimpleVocabulary.createTerm(*i),items)\n&gt;&gt;&gt; voc = SimpleVocabulary(terms)\n&gt;&gt;&gt; [term.title for term in voc]\n[u'Title1', u'Title2', u'Title3']\n&gt;&gt;&gt; field = schema.Choice(__name__='foo',\n...     missing_value=None,\n...     vocabulary=voc)\n&gt;&gt;&gt; request = TestRequest()\n &gt;&gt;&gt; widget =  AutoCompleteWidget(field, request)\n&gt;&gt;&gt; widget\n&lt;z3c.widget.autocomplete.widget.AutoCompleteWidget object at ...&gt;\n&gt;&gt;&gt; print widget()\n&lt;input class=\"textType\" id=\"field.foo\" name=\"field.foo\" type=\"text\" value=\"\"  /&gt;\n&lt;div id=\"field.foo.target\" class=\"autoComplete\"&gt;&lt;/div&gt;\n&lt;script type=\"text/javascript\"&gt;\nnew Ajax.Autocompleter('field.foo','field.foo.target',\n'http://127.0.0.1/++widget++field.foo/suggestions'\n,options={\nparamName: 'value'\n});\n&lt;/script&gt;\n</pre>\n</blockquote>\n<p>Let\u2019s add some input. Note that the input must match the title of the\nvocabulary term.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; request.form['field.foo']=u'Title1'\n&gt;&gt;&gt; widget.getInputValue()\nu'value1'\n</pre>\n</blockquote>\n<p>If we have no matching title a ConversionError is raised.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; request.form['field.foo']=u'Unknown'\n&gt;&gt;&gt; widget.getInputValue()\nTraceback (most recent call last):\n...\nConversionError: ('Invalid value', u'Unknown')\n</pre>\n</blockquote>\n<p>Also the form value is the title of the term with the given value.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; widget._toFormValue('value1')\nu'Title1'\n</pre>\n<pre>&gt;&gt;&gt; suggestions = widget.getSuggestions('Title')\n&gt;&gt;&gt; [title for title in suggestions]\n[u'Title1', u'Title2', u'Title3']\n&gt;&gt;&gt; suggestions = widget.getSuggestions('Title1')\n&gt;&gt;&gt; [title for title in suggestions]\n[u'Title1']\n&gt;&gt;&gt; suggestions = widget.getSuggestions('ABC')\n&gt;&gt;&gt; [title for title in suggestions]\n[]\n&gt;&gt;&gt; suggestions = widget.getSuggestions('title')\n&gt;&gt;&gt; [title for title in suggestions]\n[u'Title1', u'Title2', u'Title3']\n</pre>\n</blockquote>\n</div>\n<div id=\"autocompletewidget-demo\">\n<h2><a href=\"#id52\" rel=\"nofollow\">AutoCompleteWidget Demo</a></h2>\n<p>This demo packe provides a simple content class which uses the\nz3c autocomplete widget.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from zope.testbrowser.testing import Browser\n&gt;&gt;&gt; browser = Browser()\n&gt;&gt;&gt; browser.handleErrors = False\n&gt;&gt;&gt; browser.addHeader('Authorization', 'Basic mgr:mgrpw')\n&gt;&gt;&gt; browser.open('http://localhost/@@contents.html')\n</pre>\n</blockquote>\n<p>It can be added by clicking on the \u201cAutocomplete Widget Demo\u201d link in the\nadd menu. And giving it a name.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; link = browser.getLink('Autocomplete Widget Demo')\n&gt;&gt;&gt; link.click()\n&gt;&gt;&gt; nameCtrl = browser.getControl(name='new_value')\n&gt;&gt;&gt; nameCtrl.value = 'mydemo'\n&gt;&gt;&gt; applyCtrl = browser.getControl('Apply')\n&gt;&gt;&gt; applyCtrl.click()\n&gt;&gt;&gt; link = browser.getLink('mydemo')\n&gt;&gt;&gt; link.click()\n&gt;&gt;&gt; browser.url\n'http://localhost/mydemo/@@edit.html'\n</pre>\n</blockquote>\n<p>Let us test the widget rendering by direct access.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; browser.open('http://localhost/mydemo/@@edit.html/++widget++country')\n&gt;&gt;&gt; print browser.contents\n&lt;input class=\"textType\" ...\n&lt;/script&gt;\n</pre>\n</blockquote>\n<p>The suggestions are proveded by its own view.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; browser.open('http://localhost/mydemo/@@edit.html/++widget++country/suggestions')\n&gt;&gt;&gt; print browser.contents\n</pre>\n<pre>&gt;&gt;&gt; browser.open('http://localhost/++lang++en/mydemo/@@edit.html/++widget++country/suggestions?value=a')\n&gt;&gt;&gt; print browser.contents\n&lt;BLANKLINE&gt;\n &lt;ul&gt;\n  &lt;li&gt;Algeria&lt;/li&gt;\n  &lt;li&gt;Andorra&lt;/li&gt;\n  &lt;li&gt;Antigua and Barbuda&lt;/li&gt;\n  &lt;li&gt;Afghanistan&lt;/li&gt;\n  &lt;li&gt;Anguilla&lt;/li&gt;\n  &lt;li&gt;Armenia&lt;/li&gt;\n  &lt;li&gt;Albania&lt;/li&gt;\n  &lt;li&gt;Angola&lt;/li&gt;\n  &lt;li&gt;Antarctica&lt;/li&gt;\n  &lt;li&gt;American Samoa&lt;/li&gt;\n  &lt;li&gt;Argentina&lt;/li&gt;\n  &lt;li&gt;Australia&lt;/li&gt;\n  &lt;li&gt;Austria&lt;/li&gt;\n  &lt;li&gt;Aruba&lt;/li&gt;\n  &lt;li&gt;Azerbaijan&lt;/li&gt;\n &lt;/ul&gt;\n&lt;BLANKLINE&gt;\n&lt;BLANKLINE&gt;\n</pre>\n</blockquote>\n<p>Suggestions are translated.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; browser.open('http://localhost/++lang++de/mydemo/@@edit.html/++widget++country/suggestions?value=a')\n&gt;&gt;&gt; print browser.contents\n&lt;BLANKLINE&gt;\n &lt;ul&gt;\n  &lt;li&gt;Amerikanische Jungferninseln&lt;/li&gt;\n  &lt;li&gt;Amerikanisch-Ozeanien&lt;/li&gt;\n  &lt;li&gt;Algerien&lt;/li&gt;\n  &lt;li&gt;Andorra&lt;/li&gt;\n  &lt;li&gt;Antigua und Barbuda&lt;/li&gt;\n  &lt;li&gt;Afghanistan&lt;/li&gt;\n  &lt;li&gt;Anguilla&lt;/li&gt;\n  &lt;li&gt;Armenien&lt;/li&gt;\n  &lt;li&gt;Albanien&lt;/li&gt;\n  &lt;li&gt;Angola&lt;/li&gt;\n  &lt;li&gt;Antarktis&lt;/li&gt;\n  &lt;li&gt;Amerikanisch-Samoa&lt;/li&gt;\n  &lt;li&gt;Argentinien&lt;/li&gt;\n  &lt;li&gt;Australien&lt;/li&gt;\n  &lt;li&gt;Aruba&lt;/li&gt;\n  &lt;li&gt;Aserbaidschan&lt;/li&gt;\n &lt;/ul&gt;\n&lt;BLANKLINE&gt;\n&lt;BLANKLINE&gt;\n</pre>\n</blockquote>\n</div>\n<div id=\"country-selection-widgets\">\n<h2><a href=\"#id53\" rel=\"nofollow\">Country selection Widgets</a></h2>\n<p>This package provides widgets to select a country.\nThe dropdown type is registered as a default for the Country schema.</p>\n<p>The pain was to sort the options after the translation.</p>\n<p>Before we can start, we have to do a little bit of setup:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; import zope.component\n&gt;&gt;&gt; import zope.schema\n&gt;&gt;&gt; import zope.app.form.browser\n&gt;&gt;&gt; from z3c.widget.country.widget import CountryInputDropdown\n&gt;&gt;&gt; from z3c.widget.country import ICountry\n&gt;&gt;&gt; from z3c.i18n.iso import territoryVocabularyFactory\n&gt;&gt;&gt; from zope.publisher.interfaces.browser import IBrowserRequest\n</pre>\n</blockquote>\n<p>First we have to create a field and a request:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from z3c.widget.country import Country\n</pre>\n<pre>&gt;&gt;&gt; countryFld = Country(\n...     __name__='country',\n...     title=u'Country',\n...     description=u'Select a Country')\n</pre>\n<pre>&gt;&gt;&gt; from zope.publisher.browser import TestRequest\n&gt;&gt;&gt; request = TestRequest()\n</pre>\n</blockquote>\n<p>Now we can initialize the widget.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; class Content(object):\n...     country = None\n&gt;&gt;&gt; content = Content()\n&gt;&gt;&gt; boundCountry = countryFld.bind(content)\n</pre>\n<pre>&gt;&gt;&gt; widget = CountryInputDropdown(boundCountry,\n...   territoryVocabularyFactory(None), request)\n</pre>\n</blockquote>\n<p>Let\u2019s make sure that all fields have the correct value:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; widget.name\n'field.country'\n</pre>\n<pre>&gt;&gt;&gt; widget.label\nu'Country'\n</pre>\n<pre>&gt;&gt;&gt; widget.hint\nu'Select a Country'\n</pre>\n<pre>&gt;&gt;&gt; widget.visible\nTrue\n</pre>\n</blockquote>\n<p>Let\u2019s see how the widget is rendered:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; print widget()\n&lt;div&gt;\n&lt;div class=\"value\"&gt;\n&lt;select id=\"field.country\" name=\"field.country\" size=\"1\" &gt;\n&lt;option value=\"AF\"&gt;Afghanistan&lt;/option&gt;\n&lt;option value=\"AL\"&gt;Albania&lt;/option&gt;\n&lt;option value=\"DZ\"&gt;Algeria&lt;/option&gt;\n...\n&lt;option value=\"HU\"&gt;Hungary&lt;/option&gt;\n&lt;option value=\"IS\"&gt;Iceland&lt;/option&gt;\n&lt;option value=\"IN\"&gt;India&lt;/option&gt;\n...\n&lt;option value=\"ZM\"&gt;Zambia&lt;/option&gt;\n&lt;option value=\"ZW\"&gt;Zimbabwe&lt;/option&gt;\n&lt;/select&gt;\n...\n</pre>\n</blockquote>\n<p>#Let\u2019s see the german translation:\n#z3c.i18n registrations required!!!\n#\n#  &gt;&gt;&gt; request = TestRequest(HTTP_ACCEPT_LANGUAGE=\u2019de\u2019)\n#\n#  &gt;&gt;&gt; widget = CountryInputDropdown(boundCountry,\n#  \u2026   territoryVocabularyFactory(None), request)\n#\n#  &gt;&gt;&gt; print widget()\n#  &lt;div&gt;\n#  &lt;div class=\u201dvalue\u201d&gt;\n#  &lt;select id=\u201dfield.country\u201d name=\u201dfield.country\u201d size=\u201d1\u201d &gt;\n#  &lt;option value=\u201dAF\u201d&gt;Afghanistan&lt;/option&gt;\n#  &lt;option value=\u201dAL\u201d&gt;Albania&lt;/option&gt;\n#  &lt;option value=\u201dDZ\u201d&gt;Algeria&lt;/option&gt;\n#  \u2026\n#  &lt;option value=\u201dHU\u201d&gt;Hungary&lt;/option&gt;\n#  &lt;option value=\u201dIS\u201d&gt;Iceland&lt;/option&gt;\n#  &lt;option value=\u201dIN\u201d&gt;India&lt;/option&gt;\n#  \u2026\n#  &lt;option value=\u201dZM\u201d&gt;Zambia&lt;/option&gt;\n#  &lt;option value=\u201dZW\u201d&gt;Zimbabwe&lt;/option&gt;\n#  &lt;/select&gt;\n#  \u2026</p>\n</div>\n<div id=\"date-selection-widget\">\n<h2><a href=\"#id54\" rel=\"nofollow\">Date Selection Widget</a></h2>\n<p>The <tt>DateSelectWidget</tt> widget provides three select boxes presenting the\nday, month and year.</p>\n<p>First we have to create a field and a request. Note that we can set the\nyear range in this widget:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; import datetime\n&gt;&gt;&gt; from z3c.schema.dateselect import DateSelect\n&gt;&gt;&gt; from z3c.widget.dateselect.browser import DateSelectWidget\n</pre>\n<pre>&gt;&gt;&gt; field = DateSelect(\n...     title=u'Birthday',\n...     description=u'Somebodys birthday',\n...     yearRange=range(1930, 2007),\n...     required=True)\n&gt;&gt;&gt; field.__name__ = 'field'\n</pre>\n<pre>&gt;&gt;&gt; from zope.publisher.browser import TestRequest\n&gt;&gt;&gt; request = TestRequest()\n</pre>\n</blockquote>\n<p>Now we can initialize widget.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; widget = DateSelectWidget(field, request)\n</pre>\n</blockquote>\n<p>Let\u2019s make sure that all fields have the correct value:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; widget.name\n'field.field'\n</pre>\n<pre>&gt;&gt;&gt; widget.label\nu'Birthday'\n</pre>\n<pre>&gt;&gt;&gt; widget.hint\nu'Somebodys birthday'\n</pre>\n<pre>&gt;&gt;&gt; widget.visible\nTrue\n</pre>\n<pre>&gt;&gt;&gt; widget.required\nTrue\n</pre>\n</blockquote>\n<p>The constructor should have also created 3 widgets:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; widget.widgets['year']\n&lt;z3c.widget.dateselect.browser.DropdownWidget object at ...&gt;\n&gt;&gt;&gt; widget.widgets['month']\n&lt;z3c.widget.dateselect.browser.DropdownWidget object at ...&gt;\n&gt;&gt;&gt; widget.widgets['day']\n&lt;z3c.widget.dateselect.browser.DropdownWidget object at ...&gt;\n</pre>\n</blockquote>\n<p>let\u2019s also test the year range:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; '1929' in widget.widgets['year'].vocabulary.by_token.keys()\nFalse\n&gt;&gt;&gt; '1930' in widget.widgets['year'].vocabulary.by_token.keys()\nTrue\n&gt;&gt;&gt; '2006' in widget.widgets['year'].vocabulary.by_token.keys()\nTrue\n&gt;&gt;&gt; '2007' in widget.widgets['year'].vocabulary.by_token.keys()\nFalse\n</pre>\n</blockquote>\n<p>Test another year range:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; field2 = DateSelect(\n...     title=u'Another Birthday',\n...     yearRange=range(2000, 2010))\n&gt;&gt;&gt; field2.__name__ = 'field'\n&gt;&gt;&gt; widget2 = DateSelectWidget(field2, request)\n</pre>\n<pre>&gt;&gt;&gt; '1930' in widget2.widgets['year'].vocabulary.by_token.keys()\nFalse\n&gt;&gt;&gt; '2000' in widget2.widgets['year'].vocabulary.by_token.keys()\nTrue\n&gt;&gt;&gt; '2009' in widget2.widgets['year'].vocabulary.by_token.keys()\nTrue\n&gt;&gt;&gt; '2010' in widget2.widgets['year'].vocabulary.by_token.keys()\nFalse\n</pre>\n</blockquote>\n<div id=\"setrenderedvalue-value-method\">\n<h3><a href=\"#id55\" rel=\"nofollow\"><tt>setRenderedValue(value)</tt> Method</a></h3>\n<p>The first method is <tt>setRenderedValue()</tt>. The widget has two use cases,\nbased on the type of value. If the value is a custom score system, it will\nsend the information to the custom, min and max widget:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; widget = DateSelectWidget(field, request)\n&gt;&gt;&gt; year = 2000\n&gt;&gt;&gt; month = 12\n&gt;&gt;&gt; day = 31\n&gt;&gt;&gt; data = datetime.date(year, month, day)\n&gt;&gt;&gt; widget.setRenderedValue(data)\n</pre>\n<pre>&gt;&gt;&gt; 'value=\"2000\"' in widget()\nTrue\n&gt;&gt;&gt; 'value=\"12\"' in widget()\nTrue\n&gt;&gt;&gt; 'value=\"31\"' in widget()\nTrue\n</pre>\n</blockquote>\n</div>\n<div id=\"setprefix-prefix-method\">\n<h3><a href=\"#id56\" rel=\"nofollow\"><tt>setPrefix(prefix)</tt> Method</a></h3>\n<p>The prefix determines the name of the widget and all its sub-widgets.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; widget.name\n'field.field'\n&gt;&gt;&gt; widget.widgets['year'].name\n'field.field.year'\n&gt;&gt;&gt; widget.widgets['month'].name\n'field.field.month'\n&gt;&gt;&gt; widget.widgets['day'].name\n'field.field.day'\n</pre>\n<pre>&gt;&gt;&gt; widget.setPrefix('test.')\n</pre>\n<pre>&gt;&gt;&gt; widget.name\n'test.field'\n&gt;&gt;&gt; widget.widgets['year'].name\n'test.field.year'\n&gt;&gt;&gt; widget.widgets['month'].name\n'test.field.month'\n&gt;&gt;&gt; widget.widgets['day'].name\n'test.field.day'\n</pre>\n</blockquote>\n<p>If the prefix does not end in a dot, one is added:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; widget.setPrefix('test')\n</pre>\n<pre>&gt;&gt;&gt; widget.name\n'test.field'\n&gt;&gt;&gt; widget.widgets['year'].name\n'test.field.year'\n&gt;&gt;&gt; widget.widgets['month'].name\n'test.field.month'\n&gt;&gt;&gt; widget.widgets['day'].name\n'test.field.day'\n</pre>\n</blockquote>\n</div>\n<div id=\"getinputvalue-method\">\n<h3><a href=\"#id57\" rel=\"nofollow\"><tt>getInputValue()</tt> Method</a></h3>\n<p>This method returns a date object:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; request = TestRequest(form={\n...     'field.field.year': '2006',\n...     'field.field.month': '2',\n...     'field.field.day': '24'})\n</pre>\n<pre>&gt;&gt;&gt; widget = DateSelectWidget(field, request)\n</pre>\n<pre>&gt;&gt;&gt; value = widget.getInputValue()\n&gt;&gt;&gt; value.year\n2006\n&gt;&gt;&gt; value.month\n2\n&gt;&gt;&gt; value.day\n24\n</pre>\n</blockquote>\n<p>If a set of values does not produce a valid date object, a value error is\nraised:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; request = TestRequest(form={\n...     'field.field.year': '2006',\n...     'field.field.month': '2',\n...     'field.field.day': '29'})\n</pre>\n<pre>&gt;&gt;&gt; widget = DateSelectWidget(field, request)\n&gt;&gt;&gt; widget.getInputValue()\nTraceback (most recent call last):\n...\nWidgetInputError: ('field', u'Birthday', u'day is out of range for month')\n</pre>\n<pre>&gt;&gt;&gt; widget._error.__class__\n&lt;class 'zope.formlib.interfaces.WidgetInputError'&gt;\n</pre>\n</blockquote>\n</div>\n<div id=\"applychanges-content-method\">\n<h3><a href=\"#id58\" rel=\"nofollow\"><tt>applyChanges(content)</tt> Method</a></h3>\n<p>This method applies the new date to the passed content. However, it\nmust be smart enough to detect whether the values really changed.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; class Content(object):\n...     field = None\n&gt;&gt;&gt; content = Content()\n</pre>\n<pre>&gt;&gt;&gt; request = TestRequest(form={\n...     'field.field.year': '2006',\n...     'field.field.month': '2',\n...     'field.field.day': '24'})\n</pre>\n<pre>&gt;&gt;&gt; widget = DateSelectWidget(field, request)\n&gt;&gt;&gt; widget.applyChanges(content)\nTrue\n&gt;&gt;&gt; content.field\ndatetime.date(2006, 2, 24)\n</pre>\n<pre>&gt;&gt;&gt; widget.applyChanges(content)\nFalse\n</pre>\n</blockquote>\n</div>\n<div id=\"hasinput-method\">\n<h3><a href=\"#id59\" rel=\"nofollow\"><tt>hasInput()</tt> Method</a></h3>\n<p>This method checks for any input, but does not validate it.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; request = TestRequest()\n&gt;&gt;&gt; widget = DateSelectWidget(field, request)\n&gt;&gt;&gt; widget.hasInput()\nFalse\n</pre>\n<pre>&gt;&gt;&gt; request = TestRequest(form={\n...     'field.field.year': '2006'})\n&gt;&gt;&gt; widget = DateSelectWidget(field, request)\n&gt;&gt;&gt; widget.hasInput()\nFalse\n</pre>\n<pre>&gt;&gt;&gt; request = TestRequest(form={\n...     'field.field.month': '2'})\n&gt;&gt;&gt; widget = DateSelectWidget(field, request)\n&gt;&gt;&gt; widget.hasInput()\nFalse\n</pre>\n<pre>&gt;&gt;&gt; request = TestRequest(form={\n...     'field.field.day': '24'})\n&gt;&gt;&gt; widget = DateSelectWidget(field, request)\n&gt;&gt;&gt; widget.hasInput()\nFalse\n</pre>\n<pre>&gt;&gt;&gt; request = TestRequest(form={\n...     'field.field.year': '2006',\n...     'field.field.month': '2',\n...     'field.field.day': '24'})\n&gt;&gt;&gt; widget = DateSelectWidget(field, request)\n&gt;&gt;&gt; widget.hasInput()\nTrue\n</pre>\n</blockquote>\n</div>\n<div id=\"hasvalidinput-method\">\n<h3><a href=\"#id60\" rel=\"nofollow\"><tt>hasValidInput()</tt> Method</a></h3>\n<p>Additionally to checking for any input, this method also checks whether the\ninput is valid:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; request = TestRequest()\n&gt;&gt;&gt; widget = DateSelectWidget(field, request)\n&gt;&gt;&gt; widget.hasValidInput()\nFalse\n</pre>\n<pre>&gt;&gt;&gt; request = TestRequest(form={\n...     'field.field.year': '2006'})\n&gt;&gt;&gt; widget = DateSelectWidget(field, request)\n&gt;&gt;&gt; widget.hasValidInput()\nFalse\n</pre>\n<pre>&gt;&gt;&gt; request = TestRequest(form={\n...     'field.field.month': '2'})\n&gt;&gt;&gt; widget = DateSelectWidget(field, request)\n&gt;&gt;&gt; widget.hasValidInput()\nFalse\n</pre>\n<pre>&gt;&gt;&gt; request = TestRequest(form={\n...     'field.field.day': '24'})\n&gt;&gt;&gt; widget = DateSelectWidget(field, request)\n&gt;&gt;&gt; widget.hasValidInput()\nFalse\n</pre>\n<pre>&gt;&gt;&gt; request = TestRequest(form={\n...     'field.field.year': '2006',\n...     'field.field.month': '2',\n...     'field.field.day': '24'})\n&gt;&gt;&gt; widget = DateSelectWidget(field, request)\n&gt;&gt;&gt; widget.hasValidInput()\nTrue\n</pre>\n</blockquote>\n</div>\n<div id=\"hidden-method\">\n<h3><a href=\"#id61\" rel=\"nofollow\"><tt>hidden()</tt> Method</a></h3>\n<p>This method is renders the output as hidden fields:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; request = TestRequest(form={\n...     'field.field.year': '2006',\n...     'field.field.month': '2',\n...     'field.field.day': '24'})\n&gt;&gt;&gt; widget = DateSelectWidget(field, request)\n&gt;&gt;&gt; print widget.hidden()\n&lt;input class=\"hiddenType\" id=\"field.field.year\" name=\"field.field.year\"\n       type=\"hidden\" value=\"2006\" /&gt;\n&lt;input class=\"hiddenType\" id=\"field.field.month\" name=\"field.field.month\"\n       type=\"hidden\" value=\"2\"  /&gt;\n&lt;input class=\"hiddenType\" id=\"field.field.day\" name=\"field.field.day\"\n       type=\"hidden\" value=\"24\"  /&gt;\n</pre>\n</blockquote>\n</div>\n<div id=\"error-method\">\n<h3><a href=\"#id62\" rel=\"nofollow\"><tt>error()</tt> Method</a></h3>\n<p>Let\u2019s test some bad data and check the error handling.</p>\n<p>The day field contains an invalid value:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; request = TestRequest(form={\n...     'field.field.year': '2006',\n...     'field.field.month': '2',\n...     'field.field.day': '99'})\n&gt;&gt;&gt; widget = DateSelectWidget(field, request)\n&gt;&gt;&gt; widget.getInputValue()\nTraceback (most recent call last):\n...\nConversionError: (u'Invalid value', InvalidValue(\"token '99' not found in vocabulary\"))\n&gt;&gt;&gt; print widget.error()\n&lt;span class=\"error\"&gt;Invalid value&lt;/span&gt;\n</pre>\n</blockquote>\n<p>The month field contains an invalid value:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; request = TestRequest(form={\n...     'field.field.year': '2006',\n...     'field.field.month': '0',\n...     'field.field.day': '31'})\n&gt;&gt;&gt; widget = DateSelectWidget(field, request)\n&gt;&gt;&gt; widget.getInputValue()\nTraceback (most recent call last):\n...\nConversionError: (u'Invalid value', InvalidValue(\"token '0' not found in vocabulary\"))\n&gt;&gt;&gt; print widget.error()\n&lt;span class=\"error\"&gt;Invalid value&lt;/span&gt;\n</pre>\n</blockquote>\n<p>The year field contains an invalid value:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; request = TestRequest(form={\n...     'field.field.year': '1900',\n...     'field.field.month': '1',\n...     'field.field.day': '31'})\n&gt;&gt;&gt; widget = DateSelectWidget(field, request)\n&gt;&gt;&gt; widget.getInputValue()\nTraceback (most recent call last):\n...\nConversionError: (u'Invalid value', InvalidValue(\"token '1900' not found in vocabulary\"))\n&gt;&gt;&gt; print widget.error()\n&lt;span class=\"error\"&gt;Invalid value&lt;/span&gt;\n</pre>\n</blockquote>\n<p>The single inputs were correct, but did not create a valid date.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; request = TestRequest(form={\n...     'field.field.year': '1980',\n...     'field.field.month': '2',\n...     'field.field.day': '31'})\n&gt;&gt;&gt; widget = DateSelectWidget(field, request)\n&gt;&gt;&gt; widget.getInputValue()\nTraceback (most recent call last):\n...\nWidgetInputError: ('field', u'Birthday', u'day is out of range for month')\n</pre>\n<pre>&gt;&gt;&gt; print widget.error()\n&lt;span class=\"error\"&gt;day is out of range for month&lt;/span&gt;\n</pre>\n</blockquote>\n<p>No error occurred:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; request = TestRequest(form={\n...     'field.field.year': '1980',\n...     'field.field.month': '1',\n...     'field.field.day': '31'})\n&gt;&gt;&gt; widget = DateSelectWidget(field, request)\n&gt;&gt;&gt; widget.getInputValue()\ndatetime.date(1980, 1, 31)\n&gt;&gt;&gt; widget.error()\n''\n</pre>\n</blockquote>\n</div>\n<div id=\"call-method\">\n<h3><a href=\"#id63\" rel=\"nofollow\"><tt>__call__()</tt> Method</a></h3>\n<p>This method renders the widget using the sub-widgets. Let\u2019s see the output:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; request = TestRequest(form={\n...     'field.field.year': '2006',\n...     'field.field.month': '2',\n...     'field.field.day': '24'})\n&gt;&gt;&gt; widget = DateSelectWidget(field, request)\n&gt;&gt;&gt; print widget()\n&lt;select id=\"field.field.day\" name=\"field.field.day\" size=\"1\" &gt;\n&lt;option value=\"1\"&gt;1&lt;/option&gt;\n...\n&lt;option value=\"23\"&gt;23&lt;/option&gt;\n&lt;option selected=\"selected\" value=\"24\"&gt;24&lt;/option&gt;\n&lt;option value=\"25\"&gt;25&lt;/option&gt;\n...\n&lt;option value=\"31\"&gt;31&lt;/option&gt;\n&lt;/select&gt;&lt;input name=\"field.field.day-empty-marker\" type=\"hidden\"\n                value=\"1\" /&gt;&amp;nbsp;\n&lt;select id=\"field.field.month\" name=\"field.field.month\" size=\"1\" &gt;\n&lt;option value=\"1\"&gt;1&lt;/option&gt;\n&lt;option selected=\"selected\" value=\"2\"&gt;2&lt;/option&gt;\n&lt;option value=\"3\"&gt;3&lt;/option&gt;\n...\n&lt;option value=\"12\"&gt;12&lt;/option&gt;\n&lt;/select&gt;&lt;input name=\"field.field.month-empty-marker\" type=\"hidden\"\n                value=\"1\" /&gt;&amp;nbsp;\n&lt;select id=\"field.field.year\" name=\"field.field.year\" size=\"1\" &gt;\n&lt;option value=\"1930\"&gt;1930&lt;/option&gt;\n...\n&lt;option value=\"2005\"&gt;2005&lt;/option&gt;\n&lt;option selected=\"selected\" value=\"2006\"&gt;2006&lt;/option&gt;\n&lt;/select&gt;&lt;input\n    name=\"field.field.year-empty-marker\" type=\"hidden\" value=\"1\" /&gt;\n&lt;BLANKLINE&gt;\n</pre>\n</blockquote>\n</div>\n<div id=\"dropdowndatewidget\">\n<h3><a href=\"#id64\" rel=\"nofollow\">DropDownDateWidget</a></h3>\n<blockquote>\n<pre>&gt;&gt;&gt; from z3c.widget.dropdowndatewidget.widget import DropDownDateWidget\n</pre>\n<pre>&gt;&gt;&gt; from zope.publisher.browser import TestRequest\n&gt;&gt;&gt; request = TestRequest()\n</pre>\n</blockquote>\n<p>Widgets are use for fields.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from zope.schema import Date\n&gt;&gt;&gt; dateField = Date(__name__='foo', title=u'Foo')\n</pre>\n<pre>&gt;&gt;&gt; widget = DropDownDateWidget(dateField, request)\n</pre>\n<pre>&gt;&gt;&gt; widget.name\n'field.foo'\n&gt;&gt;&gt; widget.label\nu'Foo'\n&gt;&gt;&gt; widget.hasInput()\nFalse\n</pre>\n</blockquote>\n<p>We need to provide some input.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; request.form['field.foo.day'] = '1'\n&gt;&gt;&gt; widget.hasInput()\nFalse\n&gt;&gt;&gt; request.form['field.foo.month'] = '6'\n&gt;&gt;&gt; widget.hasInput()\nFalse\n&gt;&gt;&gt; request.form['field.foo.year'] = '1963'\n&gt;&gt;&gt; widget.hasInput()\nTrue\n</pre>\n</blockquote>\n<p>Read the value.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; widget.getInputValue()\ndatetime.date(1963, 6, 1)\n</pre>\n</blockquote>\n<p>Let\u2019s render the widget.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; print widget()\n&lt;div class=\"dropDownDateWidget\"&gt;&lt;select class=\"dayField\" id=\"field.foo.day\" name=\"field.foo.day\"&gt;...&lt;/select&gt;\n&lt;select class=\"monthField\" id=\"field.foo.month\" name=\"field.foo.month\"&gt;...&lt;/select&gt;\n&lt;select class=\"yearField\" id=\"field.foo.year\" name=\"field.foo.year\"&gt;...&lt;/select&gt;\n&lt;/div&gt;\n</pre>\n</blockquote>\n<p>And if we set a value.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from datetime import date\n&gt;&gt;&gt; widget.setRenderedValue(date(1977, 4, 3))\n&gt;&gt;&gt; print widget()\n&lt;div class=\"dropDownDateWidget\"&gt;&lt;select ...&lt;option selected=\"selected\" value=\"03\"&gt;...\n&lt;select ...&lt;option selected=\"selected\" value=\"04\"&gt;...\n&lt;select ...&lt;option selected=\"selected\" value=\"1977\"&gt;...\n...\n</pre>\n</blockquote>\n</div>\n</div>\n<div id=\"flash-upload-widget\">\n<h2><a href=\"#id65\" rel=\"nofollow\">FLASH UPLOAD WIDGET</a></h2>\n<p>the flashupload vars page configures the flash frontend</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from z3c.widget.flashupload import upload\n&gt;&gt;&gt; from zope.publisher.browser import TestRequest\n&gt;&gt;&gt; from zope.app.pagetemplate import ViewPageTemplateFile\n&gt;&gt;&gt; from zope.app.pagetemplate.simpleviewclass import SimpleViewClass\n&gt;&gt;&gt; request = TestRequest()\n&gt;&gt;&gt; context = object()\n&gt;&gt;&gt; viewClass = SimpleViewClass(\n...     'flashuploadvars.pt', bases=(upload.FlashUploadVars,))\n&gt;&gt;&gt; view = viewClass(context, request)\n&gt;&gt;&gt; print view()\n&lt;?xml version=\"1.0\" ?&gt;\n&lt;var&gt;\n    &lt;var name=\"file_progress\"&gt;File Progress&lt;/var&gt;\n    &lt;var name=\"overall_progress\"&gt;Overall Progress&lt;/var&gt;\n    &lt;var name=\"error\"&gt;Error on uploading files&lt;/var&gt;\n    &lt;var name=\"uploadcomplete\"&gt;all files uploaded&lt;/var&gt;\n    &lt;var name=\"uploadpartial\"&gt;files uploaded&lt;/var&gt;\n    &lt;var name=\"notuploaded\"&gt;files were not uploaded because\n       they're too big&lt;/var&gt;\n    &lt;var name=\"maxfilesize\"&gt;maximum file size is&lt;/var&gt;\n&lt;/var&gt;\n</pre>\n<pre>&gt;&gt;&gt; view.allowedFileTypes = ('.jpg', '.gif')\n&gt;&gt;&gt; print view()\n&lt;?xml version=\"1.0\" ?&gt;\n&lt;var&gt;\n...\n    &lt;var name=\"allowedFileType\"&gt;.jpg&lt;/var&gt;\n    &lt;var name=\"allowedFileType\"&gt;.gif&lt;/var&gt;\n &lt;/var&gt;\n</pre>\n</blockquote>\n</div>\n<div id=\"the-image-widget\">\n<h2><a href=\"#id66\" rel=\"nofollow\">The Image Widget</a></h2>\n<p>this image widget should be used as a custom_widget for image fields.\ncomparing to the default widget in zope3 it does not delete the\ndata in the field if the \u201cdelete\u201d checkbox is not explicitly selected.</p>\n<div id=\"adding-an-image\">\n<h3><a href=\"#id67\" rel=\"nofollow\">Adding an Image</a></h3>\n<blockquote>\n<pre>&gt;&gt;&gt; import zope.schema\n&gt;&gt;&gt; from zope.publisher.browser import TestRequest\n&gt;&gt;&gt; from zope import interface\n&gt;&gt;&gt; from zope.schema.fieldproperty import FieldProperty\n&gt;&gt;&gt; from zope.app.file.interfaces import IImage\n&gt;&gt;&gt; from z3c.widget.image.widget import ImageWidget\n&gt;&gt;&gt; from zope.app.file.image import Image\n</pre>\n</blockquote>\n<p>create a content type with an image field.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; class ITestObject(interface.Interface):\n...     image = zope.schema.Object(\n...     title=u'Image',\n...     schema=IImage)\n&gt;&gt;&gt; class TestObject(object):\n...     interface.implements(ITestObject)\n...     image = FieldProperty(ITestObject['image'])\n</pre>\n<pre>&gt;&gt;&gt; obj = TestObject()\n</pre>\n<pre>&gt;&gt;&gt; field = ITestObject['image'].bind(obj)\n</pre>\n</blockquote>\n<p>Send the request without any image information. the empty field\nshould not be changed\u2026</p>\n<blockquote>\n<pre>&gt;&gt;&gt; request = TestRequest(form={'field.image' : u''})\n&gt;&gt;&gt; widget = ImageWidget(field, request)\n&gt;&gt;&gt; widget._getFormInput() is None\nTrue\n</pre>\n</blockquote>\n<p>Send some Image information to the field. the image information\nshould be stored in the field as a Image Object</p>\n<blockquote>\n<pre>&gt;&gt;&gt; request = TestRequest(form={'field.image' : u'PNG123Test'})\n&gt;&gt;&gt; widget = ImageWidget(field, request)\n&gt;&gt;&gt; widget._getFormInput()\n&lt;zope.app.file.image.Image object at ...&gt;\n</pre>\n</blockquote>\n<p>Now we save the field again, but without any new image data.\nthe old image information should not be lost</p>\n<blockquote>\n<pre>&gt;&gt;&gt; obj.image = Image(u'PNG123Test')\n&gt;&gt;&gt; request = TestRequest(form={'field.image' : u''})\n&gt;&gt;&gt; widget = ImageWidget(field, request)\n&gt;&gt;&gt; widget._getFormInput() is obj.image\nTrue\n</pre>\n</blockquote>\n<p>Now we want to delete the image. the forminput should be None now.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; request = TestRequest(form={'field.image' : u'',\n...     'field.image.delete': u'true'})\n&gt;&gt;&gt; widget = ImageWidget(field, request)\n&gt;&gt;&gt; widget._getFormInput() is None\nTrue\n</pre>\n<pre>&gt;&gt;&gt; print widget()\n&lt;div class=\"z3cImageWidget\"&gt;\n  &lt;input type=\"file\" name=\"field.image\" id=\"field.image\" /&gt;&lt;br/&gt;\n  &lt;input type=\"checkbox\" name=\"field.image.delete\" value=\"true\" /&gt;delete image\n&lt;/div&gt;\n</pre>\n</blockquote>\n</div>\n</div>\n<div id=\"the-widget-namespace\">\n<h2><a href=\"#id68\" rel=\"nofollow\">The Widget Namespace</a></h2>\n<p>The widget namespace provides a way to traverse to the widgets of a\nformlib form.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from z3c.widget.namespace.namespace import WidgetHandler\n</pre>\n</blockquote>\n<p>Let us define a form to test this behaviour.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from zope.formlib import form\n&gt;&gt;&gt; from zope import interface, schema\n&gt;&gt;&gt; class IMyContent(interface.Interface):\n...     title = schema.TextLine(title=u'Title')\n&gt;&gt;&gt; class MyContent(object):\n...     interface.implements(IMyContent)\n...     title=None\n&gt;&gt;&gt; content = MyContent()\n&gt;&gt;&gt; from zope.publisher.browser import TestRequest\n&gt;&gt;&gt; request = TestRequest()\n&gt;&gt;&gt; class MyForm(form.EditForm):\n...     form_fields = form.Fields(IMyContent)\n&gt;&gt;&gt; view = MyForm(content,request)\n&gt;&gt;&gt; handler = WidgetHandler(view,request)\n&gt;&gt;&gt; handler.traverse('title',None)\n&lt;zope.formlib.textwidgets.TextWidget object at ...&gt;\n</pre>\n</blockquote>\n</div>\n<div id=\"optional-dropdown-widgets\">\n<h2><a href=\"#id69\" rel=\"nofollow\">Optional Dropdown Widgets</a></h2>\n<p>The Optional Dropdown Widget simulates the common desktop widget of a combo\nbox, which can also receive a custom entry.</p>\n<p>Before we can start, we have to do a little bit of setup:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; import zope.component\n&gt;&gt;&gt; import zope.schema\n&gt;&gt;&gt; import zope.app.form.browser\n&gt;&gt;&gt; from zope.publisher.interfaces.browser import IBrowserRequest\n</pre>\n<pre>&gt;&gt;&gt; zope.component.provideAdapter(\n...     zope.app.form.browser.TextWidget,\n...     (zope.schema.interfaces.ITextLine, IBrowserRequest),\n...     zope.app.form.interfaces.IInputWidget)\n</pre>\n</blockquote>\n<p>First we have to create a field and a request:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from z3c.schema.optchoice import OptionalChoice\n</pre>\n<pre>&gt;&gt;&gt; optchoice = OptionalChoice(\n...     __name__='occupation',\n...     title=u'Occupation',\n...     description=u'The Occupation',\n...     values=(u'Programmer', u'Designer', u'Project Manager'),\n...     value_type=zope.schema.TextLine())\n</pre>\n<pre>&gt;&gt;&gt; from zope.publisher.browser import TestRequest\n&gt;&gt;&gt; request = TestRequest()\n</pre>\n</blockquote>\n<p>Now we can initialize widget.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; class Content(object):\n...     occupation = None\n&gt;&gt;&gt; content = Content()\n&gt;&gt;&gt; boundOptChoice = optchoice.bind(content)\n</pre>\n<pre>&gt;&gt;&gt; from z3c.widget.optdropdown import OptionalDropdownWidget\n&gt;&gt;&gt; widget = OptionalDropdownWidget(boundOptChoice, request)\n</pre>\n</blockquote>\n<p>Let\u2019s make sure that all fields have the correct value:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; widget.name\n'field.occupation'\n</pre>\n<pre>&gt;&gt;&gt; widget.label\nu'Occupation'\n</pre>\n<pre>&gt;&gt;&gt; widget.hint\nu'The Occupation'\n</pre>\n<pre>&gt;&gt;&gt; widget.visible\nTrue\n</pre>\n<pre>&gt;&gt;&gt; widget.required\nTrue\n</pre>\n</blockquote>\n<p>The constructor should have also created 2 widgets:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; widget.customWidget\n&lt;zope.formlib.textwidgets.TextWidget object at ...&gt;\n&gt;&gt;&gt; widget.dropdownWidget\n&lt;zope.formlib.itemswidgets.DropdownWidget object at ...&gt;\n</pre>\n</blockquote>\n<div id=\"id12\">\n<h3><a href=\"#id70\" rel=\"nofollow\"><tt>setRenderedValue(value)</tt> Method</a></h3>\n<p>The first method is <tt>setRenderedValue()</tt>. The widget has two use cases,\nbased on the type of value. If the value is a custom value, it will\nsend the information to the custom widget:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; print widget.customWidget()\n&lt;... value=\"\" /&gt;\n&gt;&gt;&gt; 'selected=\"\"' in widget.dropdownWidget()\nFalse\n</pre>\n<pre>&gt;&gt;&gt; widget.setRenderedValue(u'Scientist')\n</pre>\n<pre>&gt;&gt;&gt; print widget.customWidget()\n&lt;... value=\"Scientist\" /&gt;\n&gt;&gt;&gt; 'selected=\"\"' in widget.dropdownWidget()\nFalse\n</pre>\n</blockquote>\n<p>After resetting the widget passing in one of the choices in the\nvocabulary, the value should be displayed in the dropdown:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; widget.setRenderedValue(u'Designer')\n</pre>\n<pre>&gt;&gt;&gt; print widget.customWidget()\n&lt;... value=\"\" /&gt;\n&gt;&gt;&gt; print widget.dropdownWidget()\n&lt;div&gt;\n...\n&lt;option selected=\"selected\" value=\"Designer\"&gt;Designer&lt;/option&gt;\n...\n&lt;/div&gt;\n</pre>\n</blockquote>\n</div>\n<div id=\"id13\">\n<h3><a href=\"#id71\" rel=\"nofollow\"><tt>setPrefix(prefix)</tt> Method</a></h3>\n<p>The prefix determines the name of the widget and the sub-widgets.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; widget.name\n'field.occupation'\n&gt;&gt;&gt; widget.dropdownWidget.name\n'field.occupation.occupation'\n&gt;&gt;&gt; widget.customWidget.name\n'field.occupation.custom'\n</pre>\n<pre>&gt;&gt;&gt; widget.setPrefix('test.')\n</pre>\n<pre>&gt;&gt;&gt; widget.name\n'test.occupation'\n&gt;&gt;&gt; widget.dropdownWidget.name\n'test.occupation.occupation'\n&gt;&gt;&gt; widget.customWidget.name\n'test.occupation.custom'\n</pre>\n</blockquote>\n</div>\n<div id=\"id14\">\n<h3><a href=\"#id72\" rel=\"nofollow\"><tt>getInputValue()</tt> Method</a></h3>\n<p>This method returns a value based on the input; the data is assumed to\nbe valid. In our case that means, if we entered a custom value, it is\nreturned:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; request = TestRequest(form={\n...     'field.occupation.custom': u'Teacher'})\n</pre>\n<pre>&gt;&gt;&gt; widget = OptionalDropdownWidget(boundOptChoice, request)\n</pre>\n<pre>&gt;&gt;&gt; widget.getInputValue()\nu'Teacher'\n</pre>\n</blockquote>\n<p>On the other hand, if we selected a choice from the vocabulary, it should be\nreturned:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; request = TestRequest(form={\n...     'field.occupation.occupation': u'Designer'})\n</pre>\n<pre>&gt;&gt;&gt; widget = OptionalDropdownWidget(boundOptChoice, request)\n</pre>\n<pre>&gt;&gt;&gt; widget.getInputValue()\nu'Designer'\n</pre>\n</blockquote>\n</div>\n<div id=\"id15\">\n<h3><a href=\"#id73\" rel=\"nofollow\"><tt>applyChanges(content)</tt> Method</a></h3>\n<p>This method applies the new value to the passed content. However, it\nmust be smart enough to detect whether the values really changed.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; request = TestRequest(form={\n...     'field.occupation.custom': u'Teacher'})\n</pre>\n<pre>&gt;&gt;&gt; widget = OptionalDropdownWidget(boundOptChoice, request)\n&gt;&gt;&gt; widget.applyChanges(content)\nTrue\n&gt;&gt;&gt; content.occupation\nu'Teacher'\n</pre>\n<pre>&gt;&gt;&gt; widget.applyChanges(content)\nFalse\n</pre>\n<pre>&gt;&gt;&gt; request = TestRequest(form={\n...     'field.occupation.occupation': u'Designer'})\n</pre>\n<pre>&gt;&gt;&gt; widget = OptionalDropdownWidget(boundOptChoice, request)\n</pre>\n<pre>&gt;&gt;&gt; widget.applyChanges(content)\nTrue\n&gt;&gt;&gt; content.occupation\nu'Designer'\n</pre>\n<pre>&gt;&gt;&gt; widget.applyChanges(content)\nFalse\n</pre>\n</blockquote>\n</div>\n<div id=\"id16\">\n<h3><a href=\"#id74\" rel=\"nofollow\"><tt>hasInput()</tt> Method</a></h3>\n<p>This mehtod checks for any input, but does not validate it. In our case this\nmeans that either a choice has been selected or the the custom value has been\nentered.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; request = TestRequest()\n&gt;&gt;&gt; widget = OptionalDropdownWidget(boundOptChoice, request)\n&gt;&gt;&gt; widget.hasInput()\nFalse\n</pre>\n<pre>&gt;&gt;&gt; request = TestRequest(form={\n...     'field.occupation.custom': u'Teacher\\nBad Stuff'})\n&gt;&gt;&gt; widget = OptionalDropdownWidget(boundOptChoice, request)\n&gt;&gt;&gt; widget.hasInput()\nTrue\n</pre>\n<pre>&gt;&gt;&gt; request = TestRequest(form={\n...     'field.occupation.occupation': u'Waitress'})\n&gt;&gt;&gt; widget = OptionalDropdownWidget(boundOptChoice, request)\n&gt;&gt;&gt; widget.hasInput()\nTrue\n</pre>\n</blockquote>\n</div>\n<div id=\"id17\">\n<h3><a href=\"#id75\" rel=\"nofollow\"><tt>hasValidInput()</tt> Method</a></h3>\n<p>Additionally to checking for any input, this method also checks whether the\ninput is valid:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; request = TestRequest()\n&gt;&gt;&gt; widget = OptionalDropdownWidget(boundOptChoice, request)\n&gt;&gt;&gt; widget.hasValidInput()\nFalse\n</pre>\n<pre>&gt;&gt;&gt; request = TestRequest(form={\n...     'field.occupation.occupation': u'Waitress'})\n&gt;&gt;&gt; widget = OptionalDropdownWidget(boundOptChoice, request)\n&gt;&gt;&gt; widget.hasValidInput()\nFalse\n</pre>\n<pre>&gt;&gt;&gt; request = TestRequest(form={\n...     'field.occupation.occupation': u'Designer'})\n&gt;&gt;&gt; widget = OptionalDropdownWidget(boundOptChoice, request)\n&gt;&gt;&gt; widget.hasValidInput()\nTrue\n</pre>\n<pre>&gt;&gt;&gt; request = TestRequest(form={\n...     'field.occupation.custom': u'Teacher\\nBad Stuff'})\n&gt;&gt;&gt; widget = OptionalDropdownWidget(boundOptChoice, request)\n&gt;&gt;&gt; widget.hasValidInput()\nFalse\n</pre>\n<pre>&gt;&gt;&gt; request = TestRequest(form={\n...     'field.occupation.custom': u'Teacher'})\n&gt;&gt;&gt; widget = OptionalDropdownWidget(boundOptChoice, request)\n&gt;&gt;&gt; widget.hasValidInput()\nTrue\n</pre>\n</blockquote>\n</div>\n<div id=\"id18\">\n<h3><a href=\"#id76\" rel=\"nofollow\">hidden() Method</a></h3>\n<p>This method is implemented by simply concatenating the two widget\u2019s hidden\noutput:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; request = TestRequest()\n&gt;&gt;&gt; widget = OptionalDropdownWidget(boundOptChoice, request)\n&gt;&gt;&gt; widget.setRenderedValue(u'Designer')\n&gt;&gt;&gt; print widget.hidden()\n&lt;input class=\"hiddenType\" id=\"field.occupation.occupation\"\n       name=\"field.occupation.occupation\" type=\"hidden\" value=\"Designer\"  /&gt;\n&lt;input class=\"hiddenType\" id=\"field.occupation.custom\"\n       name=\"field.occupation.custom\" type=\"hidden\" value=\"\"  /&gt;\n</pre>\n<pre>&gt;&gt;&gt; widget.setRenderedValue(u'Teacher')\n&gt;&gt;&gt; print widget.hidden()\n&lt;input class=\"hiddenType\" id=\"field.occupation.occupation\"\n       name=\"field.occupation.occupation\" type=\"hidden\" value=\"\"  /&gt;\n&lt;input class=\"hiddenType\" id=\"field.occupation.custom\"\n       name=\"field.occupation.custom\" type=\"hidden\" value=\"Teacher\"  /&gt;\n</pre>\n</blockquote>\n</div>\n<div id=\"id19\">\n<h3><a href=\"#id77\" rel=\"nofollow\">error() Method</a></h3>\n<p>Again, we have our two cases. If an error occured in the dropdown, it is\nreported:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from zope.app.form.interfaces import IWidgetInputError\n&gt;&gt;&gt; from zope.app.form.browser.exception import WidgetInputErrorView\n&gt;&gt;&gt; from zope.app.form.browser.interfaces import IWidgetInputErrorView\n</pre>\n<pre>&gt;&gt;&gt; zope.component.provideAdapter(\n...     WidgetInputErrorView,\n...     (IWidgetInputError, IBrowserRequest), IWidgetInputErrorView)\n</pre>\n<pre>&gt;&gt;&gt; request = TestRequest(form={\n...     'field.occupation.occupation': u'Designer'})\n&gt;&gt;&gt; widget = OptionalDropdownWidget(boundOptChoice, request)\n&gt;&gt;&gt; widget.getInputValue()\nu'Designer'\n&gt;&gt;&gt; widget.error()\n''\n</pre>\n<pre>&gt;&gt;&gt; request = TestRequest(form={\n...     'field.occupation.occupation': u'Waitress'})\n&gt;&gt;&gt; widget = OptionalDropdownWidget(boundOptChoice, request)\n</pre>\n<pre>&gt;&gt;&gt; widget.getInputValue()\nTraceback (most recent call last):\n...\nConversionError: (u'Invalid value', InvalidValue(\"token u'Waitress' not found in vocabulary\"))\n&gt;&gt;&gt; widget.error()\nu'&lt;span class=\"error\"&gt;Invalid value&lt;/span&gt;'\n</pre>\n</blockquote>\n<p>Otherwise the custom widget\u2019s errors are reported:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; request = TestRequest(form={\n...     'field.occupation.custom': u'Teacher'})\n&gt;&gt;&gt; widget = OptionalDropdownWidget(boundOptChoice, request)\n&gt;&gt;&gt; widget.getInputValue()\nu'Teacher'\n&gt;&gt;&gt; widget.error()\n''\n</pre>\n<pre>&gt;&gt;&gt; request = TestRequest(form={\n...     'field.occupation.custom': u'Teacher\\nBad Stuff'})\n&gt;&gt;&gt; widget = OptionalDropdownWidget(boundOptChoice, request)\n</pre>\n<pre>&gt;&gt;&gt; widget.getInputValue()\nTraceback (most recent call last):\n...\nWidgetInputError: ('custom', u'', ConstraintNotSatisfied(u'Teacher\\nBad Stuff'))\n&gt;&gt;&gt; widget.error()\nu'&lt;span class=\"error\"&gt;Constraint not satisfied&lt;/span&gt;'\n</pre>\n</blockquote>\n</div>\n<div id=\"id20\">\n<h3><a href=\"#id78\" rel=\"nofollow\">__call__() Method</a></h3>\n<p>This method renders the widget using the sub-widgets. It simply adds the two\nwidgets\u2019 output placing the <tt>connector</tt> between them:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; request = TestRequest(form={\n...     'field.occupation.custom': u'Teacher'})\n</pre>\n<pre>&gt;&gt;&gt; widget = OptionalDropdownWidget(boundOptChoice, request)\n&gt;&gt;&gt; widget.connector\nu'&lt;br /&gt;\\n'\n</pre>\n<pre>&gt;&gt;&gt; print widget()\n&lt;div&gt;\n&lt;div class=\"value\"&gt;\n&lt;select id=\"field.occupation.occupation\"\n        name=\"field.occupation.occupation\" size=\"1\" &gt;\n&lt;option selected=\"selected\" value=\"\"&gt;(nothing selected)&lt;/option&gt;\n&lt;option value=\"Programmer\"&gt;Programmer&lt;/option&gt;\n&lt;option value=\"Designer\"&gt;Designer&lt;/option&gt;\n&lt;option value=\"Project Manager\"&gt;Project Manager&lt;/option&gt;\n&lt;/select&gt;\n&lt;/div&gt;\n&lt;input name=\"field.occupation.occupation-empty-marker\" type=\"hidden\"\n       value=\"1\" /&gt;\n&lt;/div&gt;&lt;br /&gt;\n&lt;input class=\"textType\" id=\"field.occupation.custom\"\n       name=\"field.occupation.custom\" size=\"20\" type=\"text\" value=\"Teacher\" /&gt;\n</pre>\n</blockquote>\n</div>\n</div>\n<div id=\"sequencetable-widget\">\n<h2><a href=\"#id79\" rel=\"nofollow\">SequenceTable Widget</a></h2>\n<p>This package provides a Sequence Widget just as\nzope.app.form.browser.sequencewidget.\nThe main difference is that it places the subobject\u2019s fields horizontally in\na table. That means a kind of voucher-item forms are piece of cake to do.</p>\n<p>There is also a widget (SequenceTableJSWidget) which does the add/remove item\nin the browser with javascript.\nThe trick is to embed an invisible template of an empty row in the HTML,\nadd that each time a new row is required.</p>\n<dl>\n<dt>Drawbacks of JS:</dt>\n<dd><ul>\n<li>Validation is done ONLY when the complete form is submitted to the server.</li>\n<li>Submitting the form and using the Back button of the browser does not work.</li>\n</ul>\n</dd>\n</dl>\n<div id=\"warning\">\n<h3><a href=\"#id80\" rel=\"nofollow\">WARNING!</a></h3>\n<p>The subobject MUST have subwidgets. That is usually the case if the subobject\nis based on zope.schema.Object.</p>\n</div>\n<div id=\"todo\">\n<h3><a href=\"#id81\" rel=\"nofollow\">TODO</a></h3>\n<p>Tests.\nSome are there, some are copied from z.a.form.browser and need fix.</p>\n</div>\n</div>\n<div id=\"ssn-widget\">\n<h2><a href=\"#id82\" rel=\"nofollow\">SSN Widget</a></h2>\n<p>The social security number widget can be used as a custom widget for text line\nfields, enforcing a particular layout.</p>\n<p>First we have to create a field and a request:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; import datetime\n&gt;&gt;&gt; import zope.schema\n</pre>\n<pre>&gt;&gt;&gt; field = zope.schema.TextLine(\n...     title=u'SSN',\n...     description=u'Social Security Number',\n...     required=True)\n&gt;&gt;&gt; field.__name__ = 'field'\n</pre>\n<pre>&gt;&gt;&gt; from zope.publisher.browser import TestRequest\n&gt;&gt;&gt; request = TestRequest()\n</pre>\n</blockquote>\n<p>Now we can initialize widget.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from z3c.widget.ssn.browser import SSNWidget\n&gt;&gt;&gt; widget = SSNWidget(field, request)\n</pre>\n</blockquote>\n<p>Let\u2019s make sure that all fields have the correct value:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; widget.name\n'field.field'\n</pre>\n<pre>&gt;&gt;&gt; widget.label\nu'SSN'\n</pre>\n<pre>&gt;&gt;&gt; widget.hint\nu'Social Security Number'\n</pre>\n<pre>&gt;&gt;&gt; widget.visible\nTrue\n</pre>\n<pre>&gt;&gt;&gt; widget.required\nTrue\n</pre>\n</blockquote>\n<p>The constructor should have also created 3 sub-widgets:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; widget.widgets['first']\n&lt;zope.formlib.textwidgets.TextWidget object at ...&gt;\n&gt;&gt;&gt; widget.widgets['second']\n&lt;zope.formlib.textwidgets.TextWidget object at ...&gt;\n&gt;&gt;&gt; widget.widgets['third']\n&lt;zope.formlib.textwidgets.TextWidget object at ...&gt;\n</pre>\n</blockquote>\n<div id=\"id21\">\n<h3><a href=\"#id83\" rel=\"nofollow\"><tt>setRenderedValue(value)</tt> Method</a></h3>\n<p>The first method is <tt>setRenderedValue()</tt>. The widget has two use cases,\nbased on the type of value:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; widget = SSNWidget(field, request)\n&gt;&gt;&gt; widget.setRenderedValue(u'123-45-6789')\n&gt;&gt;&gt; print widget()\n&lt;input class=\"textType\" id=\"field.field.first\" name=\"field.field.first\"\n       size=\"3\" type=\"text\" value=\"123\"  /&gt;&amp;nbsp;&amp;mdash;&amp;nbsp;\n&lt;input class=\"textType\" id=\"field.field.second\" name=\"field.field.second\"\n       size=\"2\" type=\"text\" value=\"45\"  /&gt;&amp;nbsp;&amp;mdash;&amp;nbsp;\n&lt;input class=\"textType\" id=\"field.field.third\" name=\"field.field.third\"\n       size=\"4\" type=\"text\" value=\"6789\"  /&gt;\n</pre>\n</blockquote>\n</div>\n<div id=\"id22\">\n<h3><a href=\"#id84\" rel=\"nofollow\"><tt>setPrefix(prefix)</tt> Method</a></h3>\n<p>The prefix determines the name of the widget and all its sub-widgets.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; widget.name\n'field.field'\n&gt;&gt;&gt; widget.widgets['first'].name\n'field.field.first'\n&gt;&gt;&gt; widget.widgets['second'].name\n'field.field.second'\n&gt;&gt;&gt; widget.widgets['third'].name\n'field.field.third'\n</pre>\n<pre>&gt;&gt;&gt; widget.setPrefix('test.')\n</pre>\n<pre>&gt;&gt;&gt; widget.name\n'test.field'\n&gt;&gt;&gt; widget.widgets['first'].name\n'test.field.first'\n&gt;&gt;&gt; widget.widgets['second'].name\n'test.field.second'\n&gt;&gt;&gt; widget.widgets['third'].name\n'test.field.third'\n</pre>\n</blockquote>\n<p>If the prefix does not end in a dot, one is added:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; widget.setPrefix('test')\n</pre>\n<pre>&gt;&gt;&gt; widget.name\n'test.field'\n&gt;&gt;&gt; widget.widgets['first'].name\n'test.field.first'\n&gt;&gt;&gt; widget.widgets['second'].name\n'test.field.second'\n&gt;&gt;&gt; widget.widgets['third'].name\n'test.field.third'\n</pre>\n</blockquote>\n</div>\n<div id=\"id23\">\n<h3><a href=\"#id85\" rel=\"nofollow\"><tt>getInputValue()</tt> Method</a></h3>\n<p>This method returns the full SSN string:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; request = TestRequest(form={\n...     'field.field.first': '123',\n...     'field.field.second': '45',\n...     'field.field.third': '6789'})\n</pre>\n<pre>&gt;&gt;&gt; widget = SSNWidget(field, request)\n</pre>\n<pre>&gt;&gt;&gt; value = widget.getInputValue()\n&gt;&gt;&gt; value\nu'123-45-6789'\n</pre>\n</blockquote>\n<p>If a set of values does not produce a valid string, a value error is\nraised:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; request = TestRequest(form={\n...     'field.field.first': '1234',\n...     'field.field.second': '56',\n...     'field.field.third': '7890'})\n</pre>\n<pre>&gt;&gt;&gt; widget = SSNWidget(field, request)\n&gt;&gt;&gt; widget.getInputValue()\nTraceback (most recent call last):\n...\nWidgetInputError: ('first', u'Frst three digits', ConstraintNotSatisfied(u'1234'))\n</pre>\n<pre>&gt;&gt;&gt; widget._error.__class__\n&lt;class 'zope.formlib.interfaces.WidgetInputError'&gt;\n</pre>\n</blockquote>\n</div>\n<div id=\"id24\">\n<h3><a href=\"#id86\" rel=\"nofollow\"><tt>applyChanges(content)</tt> Method</a></h3>\n<p>This method applies the new SSN to the passed content. However, it\nmust be smart enough to detect whether the values really changed.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; class Content(object):\n...     field = None\n&gt;&gt;&gt; content = Content()\n</pre>\n<pre>&gt;&gt;&gt; request = TestRequest(form={\n...     'field.field.first': '123',\n...     'field.field.second': '45',\n...     'field.field.third': '6789'})\n</pre>\n<pre>&gt;&gt;&gt; widget = SSNWidget(field, request)\n&gt;&gt;&gt; widget.applyChanges(content)\nTrue\n&gt;&gt;&gt; content.field\nu'123-45-6789'\n</pre>\n<pre>&gt;&gt;&gt; widget.applyChanges(content)\nFalse\n</pre>\n</blockquote>\n</div>\n<div id=\"id25\">\n<h3><a href=\"#id87\" rel=\"nofollow\"><tt>hasInput()</tt> Method</a></h3>\n<p>This method checks for any input, but does not validate it.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; request = TestRequest()\n&gt;&gt;&gt; widget = SSNWidget(field, request)\n&gt;&gt;&gt; widget.hasInput()\nFalse\n</pre>\n<pre>&gt;&gt;&gt; request = TestRequest(form={\n...     'field.field.first': '123'})\n&gt;&gt;&gt; widget = SSNWidget(field, request)\n&gt;&gt;&gt; widget.hasInput()\nFalse\n</pre>\n<pre>&gt;&gt;&gt; request = TestRequest(form={\n...     'field.field.second': '45'})\n&gt;&gt;&gt; widget = SSNWidget(field, request)\n&gt;&gt;&gt; widget.hasInput()\nFalse\n</pre>\n<pre>&gt;&gt;&gt; request = TestRequest(form={\n...     'field.field.third': '6789'})\n&gt;&gt;&gt; widget = SSNWidget(field, request)\n&gt;&gt;&gt; widget.hasInput()\nFalse\n</pre>\n<pre>&gt;&gt;&gt; request = TestRequest(form={\n...     'field.field.first': '123',\n...     'field.field.second': '45',\n...     'field.field.third': '6789'})\n&gt;&gt;&gt; widget = SSNWidget(field, request)\n&gt;&gt;&gt; widget.hasInput()\nTrue\n</pre>\n</blockquote>\n</div>\n<div id=\"id26\">\n<h3><a href=\"#id88\" rel=\"nofollow\"><tt>hasValidInput()</tt> Method</a></h3>\n<p>Additionally to checking for any input, this method also checks whether the\ninput is valid:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; request = TestRequest()\n&gt;&gt;&gt; widget = SSNWidget(field, request)\n&gt;&gt;&gt; widget.hasValidInput()\nFalse\n</pre>\n<pre>&gt;&gt;&gt; request = TestRequest(form={\n...     'field.field.first': '123'})\n&gt;&gt;&gt; widget = SSNWidget(field, request)\n&gt;&gt;&gt; widget.hasValidInput()\nFalse\n</pre>\n<pre>&gt;&gt;&gt; request = TestRequest(form={\n...     'field.field.second': '45'})\n&gt;&gt;&gt; widget = SSNWidget(field, request)\n&gt;&gt;&gt; widget.hasValidInput()\nFalse\n</pre>\n<pre>&gt;&gt;&gt; request = TestRequest(form={\n...     'field.field.third': '6789'})\n&gt;&gt;&gt; widget = SSNWidget(field, request)\n&gt;&gt;&gt; widget.hasValidInput()\nFalse\n</pre>\n<pre>&gt;&gt;&gt; request = TestRequest(form={\n...     'field.field.first': '123',\n...     'field.field.second': '45',\n...     'field.field.third': '6789'})\n&gt;&gt;&gt; widget = SSNWidget(field, request)\n&gt;&gt;&gt; widget.hasValidInput()\nTrue\n</pre>\n</blockquote>\n</div>\n<div id=\"id27\">\n<h3><a href=\"#id89\" rel=\"nofollow\"><tt>hidden()</tt> Method</a></h3>\n<p>This method is renders the output as hidden fields:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; request = TestRequest(form={\n...     'field.field.first': '123',\n...     'field.field.second': '45',\n...     'field.field.third': '6789'})\n&gt;&gt;&gt; widget = SSNWidget(field, request)\n&gt;&gt;&gt; print widget.hidden()\n&lt;input class=\"hiddenType\" id=\"field.field.first\" name=\"field.field.first\"\n       type=\"hidden\" value=\"123\" /&gt;\n&lt;input class=\"hiddenType\" id=\"field.field.second\" name=\"field.field.second\"\n       type=\"hidden\" value=\"45\"  /&gt;\n&lt;input class=\"hiddenType\" id=\"field.field.third\" name=\"field.field.third\"\n       type=\"hidden\" value=\"6789\"  /&gt;\n</pre>\n</blockquote>\n</div>\n<div id=\"id28\">\n<h3><a href=\"#id90\" rel=\"nofollow\"><tt>error()</tt> Method</a></h3>\n<p>Let\u2019s test some bad data and check the error handling.</p>\n<p>The third field contains an invalid value:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; request = TestRequest(form={\n...     'field.field.first': '123',\n...     'field.field.second': '45',\n...     'field.field.third': '678'})\n&gt;&gt;&gt; widget = SSNWidget(field, request)\n&gt;&gt;&gt; widget.getInputValue()\nTraceback (most recent call last):\n...\nWidgetInputError: ('third', u'Third four digits', ConstraintNotSatisfied(u'678'))\n&gt;&gt;&gt; print widget.error()\n&lt;span class=\"error\"&gt;Constraint not satisfied&lt;/span&gt;\n</pre>\n</blockquote>\n<p>The second field contains an invalid value:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; request = TestRequest(form={\n...     'field.field.first': '123',\n...     'field.field.second': '4-',\n...     'field.field.third': '6789'})\n&gt;&gt;&gt; widget = SSNWidget(field, request)\n&gt;&gt;&gt; widget.getInputValue()\nTraceback (most recent call last):\n...\nWidgetInputError: ('second', u'Second two digits', ConstraintNotSatisfied(u'4-'))\n&gt;&gt;&gt; print widget.error()\n&lt;span class=\"error\"&gt;Constraint not satisfied&lt;/span&gt;\n</pre>\n</blockquote>\n<p>The first field contains an invalid value:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; request = TestRequest(form={\n...     'field.field.first': 'xxx',\n...     'field.field.second': '45',\n...     'field.field.third': '6789'})\n&gt;&gt;&gt; widget = SSNWidget(field, request)\n&gt;&gt;&gt; widget.getInputValue()\nTraceback (most recent call last):\n...\nWidgetInputError: ('first', u'Frst three digits', ConstraintNotSatisfied(u'xxx'))\n&gt;&gt;&gt; print widget.error()\n&lt;span class=\"error\"&gt;Constraint not satisfied&lt;/span&gt;\n</pre>\n</blockquote>\n<p>No error occurred:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; request = TestRequest(form={\n...     'field.field.first': '123',\n...     'field.field.second': '45',\n...     'field.field.third': '6789'})\n&gt;&gt;&gt; widget = SSNWidget(field, request)\n&gt;&gt;&gt; widget.getInputValue()\nu'123-45-6789'\n&gt;&gt;&gt; widget.error()\n''\n</pre>\n</blockquote>\n</div>\n<div id=\"id29\">\n<h3><a href=\"#id91\" rel=\"nofollow\"><tt>__call__()</tt> Method</a></h3>\n<p>This method renders the widget using the sub-widgets. Let\u2019s see the output:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; request = TestRequest(form={\n...     'field.field.first': '123',\n...     'field.field.second': '45',\n...     'field.field.third': '6789'})\n&gt;&gt;&gt; widget = SSNWidget(field, request)\n&gt;&gt;&gt; print widget()\n&lt;input class=\"textType\" id=\"field.field.first\" name=\"field.field.first\"\n       size=\"3\" type=\"text\" value=\"123\"  /&gt;&amp;nbsp;&amp;mdash;&amp;nbsp;\n&lt;input class=\"textType\" id=\"field.field.second\" name=\"field.field.second\"\n       size=\"2\" type=\"text\" value=\"45\"  /&gt;&amp;nbsp;&amp;mdash;&amp;nbsp;\n&lt;input class=\"textType\" id=\"field.field.third\" name=\"field.field.third\"\n       size=\"4\" type=\"text\" value=\"6789\"  /&gt;\n</pre>\n</blockquote>\n</div>\n</div>\n<div id=\"html-editor-widget-tinymce\">\n<h2><a href=\"#id92\" rel=\"nofollow\">HTML-Editor Widget TinyMCE</a></h2>\n<p>This package provides a WYSIWYG-Editor-Widget for HTML-Content, by\nusing the greate TinyMCE editor (see: <a href=\"http://tinymce.moxiecode.com/\" rel=\"nofollow\">http://tinymce.moxiecode.com/</a>).</p>\n</div>\n<div id=\"us-phone-widget\">\n<h2><a href=\"#id93\" rel=\"nofollow\">US Phone Widget</a></h2>\n<p>The US phone number widget can be used as a custom widget for text line\nfields, enforcing a particular layout.</p>\n<p>First we have to create a field and a request:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; import datetime\n&gt;&gt;&gt; import zope.schema\n</pre>\n<pre>&gt;&gt;&gt; field = zope.schema.TextLine(\n...     title=u'Phone',\n...     description=u'Phone Number',\n...     required=True)\n&gt;&gt;&gt; field.__name__ = 'field'\n</pre>\n<pre>&gt;&gt;&gt; from zope.publisher.browser import TestRequest\n&gt;&gt;&gt; request = TestRequest()\n</pre>\n</blockquote>\n<p>Now we can initialize widget.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from z3c.widget.usphone.browser import PhoneWidget\n&gt;&gt;&gt; widget = PhoneWidget(field, request)\n</pre>\n</blockquote>\n<p>Let\u2019s make sure that all fields have the correct value:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; widget.name\n'field.field'\n</pre>\n<pre>&gt;&gt;&gt; widget.label\nu'Phone'\n</pre>\n<pre>&gt;&gt;&gt; widget.hint\nu'Phone Number'\n</pre>\n<pre>&gt;&gt;&gt; widget.visible\nTrue\n</pre>\n<pre>&gt;&gt;&gt; widget.required\nTrue\n</pre>\n</blockquote>\n<p>The constructor should have also created 3 sub-widgets:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; widget.widgets['first']\n&lt;zope.formlib.textwidgets.TextWidget object at ...&gt;\n&gt;&gt;&gt; widget.widgets['second']\n&lt;zope.formlib.textwidgets.TextWidget object at ...&gt;\n&gt;&gt;&gt; widget.widgets['third']\n&lt;zope.formlib.textwidgets.TextWidget object at ...&gt;\n</pre>\n</blockquote>\n<div id=\"id30\">\n<h3><a href=\"#id94\" rel=\"nofollow\"><tt>setRenderedValue(value)</tt> Method</a></h3>\n<p>The first method is <tt>setRenderedValue()</tt>. The widget has two use cases,\nbased on the type of value:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; widget = PhoneWidget(field, request)\n&gt;&gt;&gt; widget.setRenderedValue(u'123-456-7890')\n&gt;&gt;&gt; print widget()\n(&lt;input class=\"textType\" id=\"field.field.first\" name=\"field.field.first\"\n        size=\"3\" type=\"text\" value=\"123\"  /&gt;)&amp;nbsp;\n&lt;input class=\"textType\" id=\"field.field.second\" name=\"field.field.second\"\n       size=\"3\" type=\"text\" value=\"456\"  /&gt;&amp;nbsp;&amp;mdash;&amp;nbsp;\n&lt;input class=\"textType\" id=\"field.field.third\" name=\"field.field.third\"\n       size=\"4\" type=\"text\" value=\"7890\"  /&gt;\n</pre>\n</blockquote>\n</div>\n<div id=\"id31\">\n<h3><a href=\"#id95\" rel=\"nofollow\"><tt>setPrefix(prefix)</tt> Method</a></h3>\n<p>The prefix determines the name of the widget and all its sub-widgets.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; widget.name\n'field.field'\n&gt;&gt;&gt; widget.widgets['first'].name\n'field.field.first'\n&gt;&gt;&gt; widget.widgets['second'].name\n'field.field.second'\n&gt;&gt;&gt; widget.widgets['third'].name\n'field.field.third'\n</pre>\n<pre>&gt;&gt;&gt; widget.setPrefix('test.')\n</pre>\n<pre>&gt;&gt;&gt; widget.name\n'test.field'\n&gt;&gt;&gt; widget.widgets['first'].name\n'test.field.first'\n&gt;&gt;&gt; widget.widgets['second'].name\n'test.field.second'\n&gt;&gt;&gt; widget.widgets['third'].name\n'test.field.third'\n</pre>\n</blockquote>\n<p>If the prefix does not end in a dot, one is added:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; widget.setPrefix('test')\n</pre>\n<pre>&gt;&gt;&gt; widget.name\n'test.field'\n&gt;&gt;&gt; widget.widgets['first'].name\n'test.field.first'\n&gt;&gt;&gt; widget.widgets['second'].name\n'test.field.second'\n&gt;&gt;&gt; widget.widgets['third'].name\n'test.field.third'\n</pre>\n</blockquote>\n</div>\n<div id=\"id32\">\n<h3><a href=\"#id96\" rel=\"nofollow\"><tt>getInputValue()</tt> Method</a></h3>\n<p>This method returns the full phone string:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; request = TestRequest(form={\n...     'field.field.first': '123',\n...     'field.field.second': '456',\n...     'field.field.third': '7890'})\n</pre>\n<pre>&gt;&gt;&gt; widget = PhoneWidget(field, request)\n</pre>\n<pre>&gt;&gt;&gt; value = widget.getInputValue()\n&gt;&gt;&gt; value\nu'123-456-7890'\n</pre>\n</blockquote>\n<p>If a set of values does not produce a valid string, a value error is\nraised:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; request = TestRequest(form={\n...     'field.field.first': '1234',\n...     'field.field.second': '56',\n...     'field.field.third': '7890'})\n</pre>\n<pre>&gt;&gt;&gt; widget = PhoneWidget(field, request)\n&gt;&gt;&gt; widget.getInputValue()\nTraceback (most recent call last):\n...\nWidgetInputError: ('first', u'Area Code', ConstraintNotSatisfied(u'1234'))\n</pre>\n<pre>&gt;&gt;&gt; widget._error.__class__\n&lt;class 'zope.formlib.interfaces.WidgetInputError'&gt;\n</pre>\n</blockquote>\n</div>\n<div id=\"id33\">\n<h3><a href=\"#id97\" rel=\"nofollow\"><tt>applyChanges(content)</tt> Method</a></h3>\n<p>This method applies the new phone number to the passed content. However, it\nmust be smart enough to detect whether the values really changed.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; class Content(object):\n...     field = None\n&gt;&gt;&gt; content = Content()\n</pre>\n<pre>&gt;&gt;&gt; request = TestRequest(form={\n...     'field.field.first': '123',\n...     'field.field.second': '456',\n...     'field.field.third': '7890'})\n</pre>\n<pre>&gt;&gt;&gt; widget = PhoneWidget(field, request)\n&gt;&gt;&gt; widget.applyChanges(content)\nTrue\n&gt;&gt;&gt; content.field\nu'123-456-7890'\n</pre>\n<pre>&gt;&gt;&gt; widget.applyChanges(content)\nFalse\n</pre>\n</blockquote>\n</div>\n<div id=\"id34\">\n<h3><a href=\"#id98\" rel=\"nofollow\"><tt>hasInput()</tt> Method</a></h3>\n<p>This method checks for any input, but does not validate it.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; request = TestRequest()\n&gt;&gt;&gt; widget = PhoneWidget(field, request)\n&gt;&gt;&gt; widget.hasInput()\nFalse\n</pre>\n<pre>&gt;&gt;&gt; request = TestRequest(form={\n...     'field.field.first': '123'})\n&gt;&gt;&gt; widget = PhoneWidget(field, request)\n&gt;&gt;&gt; widget.hasInput()\nFalse\n</pre>\n<pre>&gt;&gt;&gt; request = TestRequest(form={\n...     'field.field.second': '456'})\n&gt;&gt;&gt; widget = PhoneWidget(field, request)\n&gt;&gt;&gt; widget.hasInput()\nFalse\n</pre>\n<pre>&gt;&gt;&gt; request = TestRequest(form={\n...     'field.field.third': '7890'})\n&gt;&gt;&gt; widget = PhoneWidget(field, request)\n&gt;&gt;&gt; widget.hasInput()\nFalse\n</pre>\n<pre>&gt;&gt;&gt; request = TestRequest(form={\n...     'field.field.first': '123',\n...     'field.field.second': '456',\n...     'field.field.third': '7890'})\n&gt;&gt;&gt; widget = PhoneWidget(field, request)\n&gt;&gt;&gt; widget.hasInput()\nTrue\n</pre>\n</blockquote>\n</div>\n<div id=\"id35\">\n<h3><a href=\"#id99\" rel=\"nofollow\"><tt>hasValidInput()</tt> Method</a></h3>\n<p>Additionally to checking for any input, this method also checks whether the\ninput is valid:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; request = TestRequest()\n&gt;&gt;&gt; widget = PhoneWidget(field, request)\n&gt;&gt;&gt; widget.hasValidInput()\nFalse\n</pre>\n<pre>&gt;&gt;&gt; request = TestRequest(form={\n...     'field.field.first': '123'})\n&gt;&gt;&gt; widget = PhoneWidget(field, request)\n&gt;&gt;&gt; widget.hasValidInput()\nFalse\n</pre>\n<pre>&gt;&gt;&gt; request = TestRequest(form={\n...     'field.field.second': '456'})\n&gt;&gt;&gt; widget = PhoneWidget(field, request)\n&gt;&gt;&gt; widget.hasValidInput()\nFalse\n</pre>\n<pre>&gt;&gt;&gt; request = TestRequest(form={\n...     'field.field.third': '7890'})\n&gt;&gt;&gt; widget = PhoneWidget(field, request)\n&gt;&gt;&gt; widget.hasValidInput()\nFalse\n</pre>\n<pre>&gt;&gt;&gt; request = TestRequest(form={\n...     'field.field.first': '123',\n...     'field.field.second': '456',\n...     'field.field.third': '7890'})\n&gt;&gt;&gt; widget = PhoneWidget(field, request)\n&gt;&gt;&gt; widget.hasValidInput()\nTrue\n</pre>\n</blockquote>\n</div>\n<div id=\"id36\">\n<h3><a href=\"#id100\" rel=\"nofollow\"><tt>hidden()</tt> Method</a></h3>\n<p>This method is renders the output as hidden fields:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; request = TestRequest(form={\n...     'field.field.first': '123',\n...     'field.field.second': '456',\n...     'field.field.third': '7890'})\n&gt;&gt;&gt; widget = PhoneWidget(field, request)\n&gt;&gt;&gt; print widget.hidden()\n&lt;input class=\"hiddenType\" id=\"field.field.first\" name=\"field.field.first\"\n       type=\"hidden\" value=\"123\" /&gt;\n&lt;input class=\"hiddenType\" id=\"field.field.second\" name=\"field.field.second\"\n       type=\"hidden\" value=\"456\"  /&gt;\n&lt;input class=\"hiddenType\" id=\"field.field.third\" name=\"field.field.third\"\n       type=\"hidden\" value=\"7890\"  /&gt;\n</pre>\n</blockquote>\n</div>\n<div id=\"id37\">\n<h3><a href=\"#id101\" rel=\"nofollow\"><tt>error()</tt> Method</a></h3>\n<p>Let\u2019s test some bad data and check the error handling.</p>\n<p>The third field contains an invalid value:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; request = TestRequest(form={\n...     'field.field.first': '123',\n...     'field.field.second': '456',\n...     'field.field.third': '78901'})\n&gt;&gt;&gt; widget = PhoneWidget(field, request)\n&gt;&gt;&gt; widget.getInputValue()\nTraceback (most recent call last):\n...\nWidgetInputError: ('third', u'Four Digits', ConstraintNotSatisfied(u'78901'))\n</pre>\n<pre>&gt;&gt;&gt; print widget.error()\n&lt;span class=\"error\"&gt;Constraint not satisfied&lt;/span&gt;\n</pre>\n</blockquote>\n<p>The second field contains an invalid value:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; request = TestRequest(form={\n...     'field.field.first': '123',\n...     'field.field.second': '45-',\n...     'field.field.third': '7890'})\n&gt;&gt;&gt; widget = PhoneWidget(field, request)\n&gt;&gt;&gt; widget.getInputValue()\nTraceback (most recent call last):\n...\nWidgetInputError: ('second', u'Three Digits', ConstraintNotSatisfied(u'45-'))\n</pre>\n<pre>&gt;&gt;&gt; print widget.error()\n&lt;span class=\"error\"&gt;Constraint not satisfied&lt;/span&gt;\n</pre>\n</blockquote>\n<p>The first field contains an invalid value:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; request = TestRequest(form={\n...     'field.field.first': 'xxx',\n...     'field.field.second': '456',\n...     'field.field.third': '7890'})\n&gt;&gt;&gt; widget = PhoneWidget(field, request)\n&gt;&gt;&gt; widget.getInputValue()\nTraceback (most recent call last):\n...\nWidgetInputError: ('first', u'Area Code', ConstraintNotSatisfied(u'xxx'))\n</pre>\n<pre>&gt;&gt;&gt; print widget.error()\n&lt;span class=\"error\"&gt;Constraint not satisfied&lt;/span&gt;\n</pre>\n</blockquote>\n<p>No error occurred:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; request = TestRequest(form={\n...     'field.field.first': '123',\n...     'field.field.second': '456',\n...     'field.field.third': '7890'})\n&gt;&gt;&gt; widget = PhoneWidget(field, request)\n&gt;&gt;&gt; widget.getInputValue()\nu'123-456-7890'\n&gt;&gt;&gt; widget.error()\n''\n</pre>\n</blockquote>\n</div>\n<div id=\"id38\">\n<h3><a href=\"#id102\" rel=\"nofollow\"><tt>__call__()</tt> Method</a></h3>\n<p>This method renders the widget using the sub-widgets. Let\u2019s see the output:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; request = TestRequest(form={\n...     'field.field.first': '123',\n...     'field.field.second': '456',\n...     'field.field.third': '7890'})\n&gt;&gt;&gt; widget = PhoneWidget(field, request)\n&gt;&gt;&gt; print widget()\n(&lt;input class=\"textType\" id=\"field.field.first\" name=\"field.field.first\"\n        size=\"3\" type=\"text\" value=\"123\"  /&gt;)&amp;nbsp;\n&lt;input class=\"textType\" id=\"field.field.second\" name=\"field.field.second\"\n       size=\"3\" type=\"text\" value=\"456\"  /&gt;&amp;nbsp;&amp;mdash;&amp;nbsp;\n&lt;input class=\"textType\" id=\"field.field.third\" name=\"field.field.third\"\n       size=\"4\" type=\"text\" value=\"7890\"  /&gt;\n</pre>\n</blockquote>\n</div>\n</div>\n\n          </div>"}, "last_serial": 802126, "releases": {"0.1.6": [{"comment_text": "", "digests": {"md5": "4d99a2fe65774b2c1fe1bcdc671de181", "sha256": "acad0b89c80c6e55eab191ef4761bf363e2918b9c3fe1982d240e152b0f8bf37"}, "downloads": -1, "filename": "z3c.widget-0.1.6-py2.4.egg", "has_sig": false, "md5_digest": "4d99a2fe65774b2c1fe1bcdc671de181", "packagetype": "bdist_egg", "python_version": "2.4", "requires_python": null, "size": 1602934, "upload_time": "2007-09-18T22:29:15", "upload_time_iso_8601": "2007-09-18T22:29:15Z", "url": "https://files.pythonhosted.org/packages/f6/71/df78e63ba3e1ccbe80217e5683df08da785ad7337d1231a934aaa1c633cb/z3c.widget-0.1.6-py2.4.egg", "yanked": false}, {"comment_text": "", "digests": {"md5": "906a825302e40aaa515c64ba5c3f8431", "sha256": "35b1e9328471d833f3ef7618408cd8899f467a9da11e238008a7798d9658bef0"}, "downloads": -1, "filename": "z3c.widget-0.1.6.tar.gz", "has_sig": false, "md5_digest": "906a825302e40aaa515c64ba5c3f8431", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 1259191, "upload_time": "2007-09-18T22:28:45", "upload_time_iso_8601": "2007-09-18T22:28:45Z", "url": "https://files.pythonhosted.org/packages/6a/58/2438b51fe2dcfd3464049159289f0980184a0a09b5da1b1ebae2b60aee20/z3c.widget-0.1.6.tar.gz", "yanked": false}], "0.3.0": [{"comment_text": "", "digests": {"md5": "e5936e943a9fb4f75ed45c51111a5790", "sha256": "f5432f07ee9f28586eeea573a48a4af10a950efad8651de815bc043407f03f0d"}, "downloads": -1, "filename": "z3c.widget-0.3.0.tar.gz", "has_sig": false, "md5_digest": "e5936e943a9fb4f75ed45c51111a5790", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 1287836, "upload_time": "2010-11-16T08:43:54", "upload_time_iso_8601": "2010-11-16T08:43:54.607157Z", "url": "https://files.pythonhosted.org/packages/ff/81/fc884bb8c411579254401e626e517f1b456257cc58b8b27ebff8a58d2574/z3c.widget-0.3.0.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "e5936e943a9fb4f75ed45c51111a5790", "sha256": "f5432f07ee9f28586eeea573a48a4af10a950efad8651de815bc043407f03f0d"}, "downloads": -1, "filename": "z3c.widget-0.3.0.tar.gz", "has_sig": false, "md5_digest": "e5936e943a9fb4f75ed45c51111a5790", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 1287836, "upload_time": "2010-11-16T08:43:54", "upload_time_iso_8601": "2010-11-16T08:43:54.607157Z", "url": "https://files.pythonhosted.org/packages/ff/81/fc884bb8c411579254401e626e517f1b456257cc58b8b27ebff8a58d2574/z3c.widget-0.3.0.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:20:15 2020"}