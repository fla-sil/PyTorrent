{"info": {"author": "KubeMQ", "author_email": "info@kubemq.io", "bugtrack_url": null, "classifiers": [], "description": "# KubeMQ SDK for Python\n\nThe **KubeMQ SDK for Python** enables Python developers to easily work with [KubeMQ](https://kubemq.io/). \n\n## Getting Started\n\n### Prerequisites\n\nKubeMQ-SDK-Python works with **Python 3.2** or newer.\n\n### Installing\n\nThe recommended way to use the SDK for Python in your project is to consume it from pip.\n\n```\npip install kubemq\n```\n\n## Generating Documentation\n\nSphinx is used for documentation. Use the Makefile to build the docs, like so:\n\n```\n$ pip install -r requirements-docs.txt\n$ cd docs\n$ make html\n```\n(`make latex` or `make linkcheck` supported)\n\n## Building from source\n\nOnce you check out the code from GitHub, you can install the package locally with:\n\n```\n$ pip install .\n```\n\nYou can also install the package with a symlink, \nso that changes to the source files will be immediately available:\n\n```\n$ pip install -e .\n```\n\nInstallation:\n$ pip install kubemq\n\n### Core Basics\nKubeMQ messaging broker has five messaging patterns:\n\n- **Queues**  - FIFO based, exactly one durable queue pattern\n- **Events** - real-time pub/sub pattern\n- **Events Store** - pub/sub with persistence pattern\n- **Commands** - the Command part of CQRS pattern, which sends commands with the response for executed or not (with proper error messaging)\n- **Queries** - the Query part of CQRS pattern, which sends a query and gets a response with the relevant query result back\nFor each one of the patterns, we can distinguish between the senders and the receivers.\n\nFor events and events store, the KubeMQ supports both RPC and upstream calls.\n\nthe data model is almost identical between all the pattern with some data added related to the specific patter.\n\n### The common part of all the patterns are:\n\n- **ID** - the sender can set the ID for each type of message, or the Id is automatically generated a UUID Id for him.\n- **Metadata** - a string field that can hold any metadata related to the message\n- **Body** - a Bytes array which contains the actual payload to be sent from the sender to the receiver\n- **Tags** - a Map of string, string for user define data\n- The KubeMQ core transport is based on gRPC, and the library is a wrapper around the client-side of gRPC complied protobuf hence -   leveraging the gRPC benefits and advantages.\n\nBefore any transactions to be performed with KubeMQ server, the Client should connect and dial KubeMQ server and obtain Client connection.\n\nWith the Client connection object, the user can perform all transactions to and from KubeMQ server.\n\nA Client connection object is thread-safe and can be shared between all process needed to communicate with KubeMQ.\n\nIMPORTANT - it's the user responsibility to close the Client connection when no further communication with KubeMQ is needed.\n\nConnection\nConnecting to KubeMQ server can be by creating the type needed:\n```\n    pub/sub:\n        sender:\n        sender = Sender(\"localhost:50000\")\n        Subscriber:\n        subscriber = Subscriber(\"localhost:50000)\n\n    command/query:\n        Initiator:\n        initiator = Initiator(\"localhost:50000\")\n        Responder:\n        responder = Responder(\"localhost:50000\")\n\n    then to check connection call ping as such:\n        #\n        def create_check_connection():\n        sender= Sender(\"localhost:50000\")\n        try:\n            result=sender.ping()\n        except Exception as identifier:\n            print('error {}'.format(identifier))\n            exit()\n        print(result)\n\n```\nExamples\nPlease visit our extensive examples folder Please find usage examples on the examples folders.\n\n### Queues\nCore features\n- KubeMQ supports distributed durable FIFO based queues with the following core features:\n\n- **Exactly One Delivery** - Only one message guarantee will deliver to the subscriber\n\n- **Single and Batch Messages Send and Receive** - Single and multiple messages in one call\n\n- **RPC and Stream Flows** - RPC flow allows an insert and pulls messages in one call. Stream flow allows single message consuming in a transactional way\n\n- **Message Policy** - Each message can be configured with expiration and delay timers. Also, each message can specify a dead-letter queue for un-processed messages attempts\n\n- **Long Polling** - Consumers can wait until a message available in the queue to consume\n\n- **Peek Messages**- Consumers can peek into a queue without removing them from the queue\n\n- **Ack All Queue Messages** - Any client can mark all the messages in a queue as discarded and will not be available anymore to consume\n\n- **Visibility timers** - Consumers can pull a message from the queue and set a timer which will cause the message not be visible to other consumers. This timer can be extended as needed.\n\n- **Resend Messages** - Consumers can send back a message they pulled to a new queue or send a modified message to the same queue for further processing.\n\n\nSend Message to a Queue:\n```\n    queue = MessageQueue(queue_name, client_id, kube_add)\n    message = create_queue_message(\"someMeta\", \"some-simple_queue-queue-message\".encode('UTF-8'))\n    queue_send_response = queue.send_queue_message(message)\n    print(\"finished sending to queue answer. message_id: %s, body: %s\" % (queue_send_response.message_id, message.body))\n```\ncreate_queue_message:\n```\n    def create_queue_message(meta_data, body, policy=None):\n        message = Message()\n        message.metadata = meta_data\n        message.body = body\n        message.tags = [\n            ('key', 'value'),\n            ('key2', 'value2')\n        ]\n        message.attributes = None\n        message.policy = policy\n        return message\n```\nSend Message to a Queue with Expiration:\n```\n    queue = MessageQueue(queue_name, client_id, kube_add, max_number_messages, max_timeout)\n    policy = QueueMessagePolicy()\n    policy.ExpirationSeconds = 5\n    message = create_queue_message(\"someMeta\", \"some-simple_queue-queue-message\".encode('UTF-8'), policy)\n    queue_send_message_to_queue_with_expiration_response = queue.send_queue_message(message)\n    print(\"finished sending message to queue with expiration answer: {} \".format(\n        queue_send_message_to_queue_with_expiration_response))\n```\n\nSend Message to a Queue with Delay:\n```\n    queue = MessageQueue(queue_name, client_id, kube_add, max_number_messages, max_timeout)\n    policy = QueueMessagePolicy()\n    policy.DelaySeconds = 5\n    message = create_queue_message(\"someMeta\", \"some-simple_queue-queue-message\".encode('UTF-8'), policy)\n    queue_send_message_to_queue_with_delay_response = queue.send_queue_message(message)\n    print(\"finished sending message to queue with delay answer: {} \".format(\n        queue_send_message_to_queue_with_delay_response))\n```\n\nSend Message to a Queue with Dead-letter Queue:\n```\n    queue = MessageQueue(queue_name, client_id, kube_add, max_number_messages, max_timeout)\n    policy = QueueMessagePolicy()\n    policy.MaxReceiveCount = 3\n    policy.MaxReceiveQueue = \"DeadLetterQueue\"\n    message = create_queue_message(\"someMeta\", \"some-simple_queue-queue-message\".encode('UTF-8'), policy)\n    queue_send_message_to_queue_with_deadletter_response = queue.send_queue_message(message)\n    print(\"finished sending message to queue with deadletter answer: {} \".format(\n        queue_send_message_to_queue_with_deadletter_response))\n```\n\nSend Batch Messages:\n```\n    queue = MessageQueue(queue_name, client_id, kube_add, max_number_messages, max_timeout)\n    mm = []\n    for i in range(2):\n        message = create_queue_message(\"queueName {}\".format(i), \"some-simple_queue-queue-message\".encode('UTF-8'))\n        mm.append(message)\n    queue_send_batch_response = queue.send_queue_messages_batch(mm)\n    print(\"finished sending message to queue with batch answer: {} \".format(queue_send_batch_response))\n```\n\nReceive Messages from a Queue:\n```\n    queue = MessageQueue(queue_name, client_id, kube_add, max_number_messages, max_timeout)\n    queue_receive_response = queue.receive_queue_messages()\n    print(\"finished sending message to receive_queue answer: {} \".format(queue_receive_response))\n```\n\nPeak Messages from a Queue:\n```\n    queue = MessageQueue(queue_name, client_id, kube_add, max_number_messages, max_timeout)\n    queue_receive_response = queue.peek_queue_message(5)\n    print(\"finished sending message to peek answer: {} \".format(queue_receive_response))\n```\n\nAck All Messages In a Queue:\n```\n    queue = MessageQueue(queue_name, client_id, kube_add, max_number_messages, max_timeout)\n    queue_ack_response = queue.ack_all_queue_messages()\n    print(\"finished sending message to ack answer: {} \".format(queue_ack_response))\n```\nTransactional Queue - Ack:\n```\n    queue = MessageQueue(queue_name, client_id, kube_add)\n    transaction = queue.create_transaction()\n    res_rec = transaction.receive(10, 10)\n\n    if res_rec.is_error:\n        raise \"Message dequeue error, error: %s\" % res_rec.is_error\n\n    print(\"Received message id: %s, body: %s\" % (res_rec.message.MessageID, res_rec.message.Body))\n    print(\"tags: %s\" % res_rec.message.Tags)\n\n    res_ack = transaction.ack_message(res_rec.message.Attributes.Sequence)\n    if res_ack.is_error:\n        raise Exception(\"Ack message error: %s\" % res_ack.error)\n\n    print(\"Received message of type: %s\" % StreamRequestType(res_ack.stream_request_type).name)\n```\nTransactional Queue - Reject:\n```\n    queue = MessageQueue(queue_name, client_id, kube_add)\n    transaction = queue.create_transaction()\n    res_rec = transaction.receive(10, 10)\n\n    if res_rec.is_error:\n        raise \"Message dequeue error, error: %s\" % res_rec.is_error\n\n    print(\"Received message id: {}, body: {} tags:{}\".format(res_rec.message.MessageID, res_rec.message.Body,res_rec.message.Tags))\n\n    res_rej = transaction.rejected_message(res_rec.message.Attributes.Sequence)\n    if res_rej.is_error:\n        raise Exception(\"Ack message error: %s\" % res_rej.error)\n\n    print(\"rejected message message of type: %s\" % StreamRequestType(res_rej.stream_request_type).name)\n```\n\nTransactional Queue - Extend Visibility:\n```\n    queue_rej = MessageQueue(\"reject_test\", client_id, kube_add)\n\n    message = create_queue_message(\"queueName {}\".format(0), \"my reject\".encode('UTF-8'))\n    queue_rej.send_queue_message(message)\n\n    queue= MessageQueue(\"reject_test\", client_id, kube_add)\n    tran=queue.create_transaction()\n\n    res_rec=tran.receive(5,10)\n\n    if res_rec.is_error:\n        raise \"Message dequeue error, error: %s\" % res_rec.is_error\n\n    print(\"Received message id: {}, body: {} tags: {}\".format(res_rec.message.MessageID, res_rec.message.Body,res_rec.message.Tags))\n\n    print(\"work for 1 second\")\n\n    time.sleep(1)\n\n    print(\"Need more time to process, extend visibility for more 3 seconds\")\n\n    res_ext=tran.extend_visibility(3)\n\n    if res_ext.is_error:\n        raise Exception(\"Ack message error: %s\" % res_ext.error)\n\n    print(\"Approved. work for 2.5 seconds\")\n\n    time.sleep(2.5)\n\n    print(\"Work done... ack the message\")\n\n\n    res_ack=tran.ack_message(res_rec.message.Attributes.Sequence)\n\n    if res_ack.is_error:\n        raise Exception(\"Ack message error: %s\" % res_ack.error)\n\n    print(\"ack done\")\n```\n\nTransactional Queue - Resend to New Queue:\n```\n    queue_rej = MessageQueue(\"resend_to_new_queue\", client_id, kube_add)\n\n    message = create_queue_message(\"resend to new queue {}\".format(0), \"my resend\".encode('UTF-8'))\n    queue_rej.send_queue_message(message)\n\n    queue= MessageQueue(\"resend_to_new_queue\", client_id, kube_add)\n    tran=queue.create_transaction()\n\n    res_rec=tran.receive(5,10)\n\n    if res_rec.is_error:\n        raise \"Message dequeue error, error: %s\" % res_rec.is_error\n\n    print(\"Received message id: {}, body: {} tags:{}\".format(res_rec.message.MessageID, res_rec.message.Body, res_rec.message.Tags))\n\n    print(\"resend to new queue\")\n\n    res_resend=tran.resend(\"new-queue\")\n\n    if res_resend.is_error:\n        raise \"Message resend error, error: %s\" % res_resend.is_error\n\n    print(\"Done\")\n```\nTransactional Queue - Resend Modified Message:\n```\n    queue_res = MessageQueue(\"resend_modify_message\", client_id, kube_add)\n\n    message = create_queue_message(\"resend to new queue {}\".format(0), \"my resend modify\".encode('UTF-8'))\n    queue_res.send_queue_message(message)\n\n    queue= MessageQueue(\"resend_modify_message\", client_id, kube_add)\n    tran=queue.create_transaction()\n\n    res_rec=tran.receive(3,5)\n\n    if res_rec.is_error:\n        raise \"Message dequeue error, error: %s\" % res_rec.is_error\n\n    print(\"Received message id: {}, body: {} tags:{}\".format(res_rec.message.MessageID, res_rec.message.Body,res_rec.message.Tags))\n\n    mod_msg=res_rec.message\n    mod_msg.Channel=\"receiverB\"\n\n    mod_msg.Metadata=\"new Metadata\"\n\n    res_mod=tran.modify(mod_msg)\n\n    if res_mod.is_error:\n        raise \"Message modify error, error: %s\" % res_mod.is_error\n\n    print(\"Done\")\n```\nEvents\nSending Events\nSingle Event:\n```\n    def send_single_event():\n        sender = Sender(kube_add)\n        event = Event(\n            metadata=\"EventMetaData\",\n            body=(\"Event Created on time %s\" % datetime.datetime.utcnow()).encode('UTF-8'),\n            store=False,\n            channel=\"MyTestChannelName\",\n            client_id=\"EventSender\"\n        )\n        event.tags=[\n                ('key', 'value'),\n                ('key2', 'value2'),\n            ]\n        sender.send_event(event)\n```\nStream Events:\n```\n    sender = Sender(kube_add)\n\n\n    def async_streamer():\n        for counter in range(3):\n            yield Event(\n                metadata=\"EventMetaData\",\n                body=(\"Event %s Created on time %s\" % (counter, datetime.datetime.utcnow())).encode('UTF-8'),\n                store=False,\n                channel=\"MyTestChannelName\",\n                client_id=\"EventSenderStream\",\n            )\n\n\n    def result_handler(result):\n        print(result)\n\n\n    sender.stream_event(async_streamer(), result_handler)\n```\n\nReceiving Events\nFirst you should subscribe to Events:\n```\n        def event_subscriber():\n            subscriber = Subscriber(kube_add)\n            cancel_token=ListenerCancellationToken()\n            sub_req= SubscribeRequest(\n                channel=\"MyTestChannelName\",\n                client_id=str(randint(9, 19999)),\n                events_store_type=EventsStoreType.Undefined,\n                events_store_type_value=0,\n                group=\"\",\n                subscribe_type=SubscribeType.Events\n            )\n            subscriber.subscribe_to_events(sub_req, handle_incoming_events,handle_incoming_error,cancel_token)\n            print(\"sub for 2 seconds\")\n            time.sleep(2.0)\n            print(\"Canceled token\")\n            cancel_token.cancel()\n\n        def handle_incoming_events(event):\n            if event:\n                print(\"Subscriber Received Event: Metadata:'%s', Channel:'%s', Body:'%s tags:%s'\" % (\n                    event.metadata,\n                    event.channel,\n                    event.body,\n                    event.tags\n                ))\n\n        def handle_incoming_error(error_msg):\n                print(\"received error:%s'\" % (\n                    error_msg\n                ))\n```\nEvents Store\nSending Events Store\nSingle Event to Store:\n```\n        sender = Sender(kube_add)\n        event = Event(\n            metadata=\"EventMetaData\",\n            body=(\"Event Created on time %s\" % datetime.datetime.utcnow()).encode('UTF-8'),\n            store=True,\n            channel=\"MyTestChannelNameStore\",\n            client_id=\"EventSenderStore\"\n        )\n        event.tags=[\n                ('key', 'value'),\n                ('key2', 'value2'),\n            ]\n        sender.send_event(event)\n```\nStream Events Store:\n```\n        sender = Sender(kube_add)\n\n\n        def async_streamer():\n            for counter in range(3):\n                yield Event(\n                    metadata=\"EventMetaData\",\n                    body=(\"Event %s Created on time %s\" % (counter, datetime.datetime.utcnow())).encode('UTF-8'),\n                    store=True,\n                    channel=\"MyTestChannelNameStore\",\n                    client_id=\"EventSenderStore\",\n                )\n\n\n        def result_handler(result):\n            print(result)\n\n\n        sender.stream_event(async_streamer(), result_handler)\n\n```\nReceiving Events Store\nFirst you should subscribe to Events Store and get a channel:\n```\n    subscriber = Subscriber(kube_add)\n    cancel_token=ListenerCancellationToken()\n    sub_req= SubscribeRequest(\n        channel=\"MyTestChannelNameStore\",\n        client_id=str(randint(9, 19999)),\n        events_store_type=EventsStoreType.StartFromFirst,\n        events_store_type_value=0,\n        group=\"\",\n        subscribe_type=SubscribeType.EventsStore\n    )\n    subscriber.subscribe_to_events(sub_req, handle_incoming_events,handle_incoming_error,cancel_token)\n    print(\"sub for 2 seconds\")\n    time.sleep(2.0)\n    print(\"Canceled token\")\n    cancel_token.cancel()\n```\n### Subscription Options\nKubeMQ supports six types of subscriptions:\n\n- **StartFromNewEvents** - start event store subscription with only new events\n\n- **StartFromFirstEvent** - replay all the stored events from the first available sequence and continue stream new events from this point\n\n- **StartFromLastEvent** - replay the last event and continue stream new events from this point\n\n- **StartFromSequence** - replay events from specific event sequence number and continue stream new events from this point\n\n- **StartFromTime** - replay events from specific time continue stream new events from this point\n\n- **StartFromTimeDelta** - replay events from specific current time - delta duration in seconds, continue stream new events from this point\n\n## Commands\nConcept\nCommands implement synchronous messaging pattern which the sender send a request and wait for a specific amount of time to get a response.\n\nThe response can be successful or not. This is the responsibility of the responder to return with the result of the command within the time the sender set in the request.\n\nSending Command Requests:\nIn this example, the responder should send his response withing one second. Otherwise, an error will be return as a timeout:\n```\n    request = Request(\n        body=\"Request\".encode('UTF-8'),\n        metadata=\"MyMetadata\",\n        cache_key=\"\",\n        cache_ttl=0,\n        channel=\"MyTestChannelName\",\n        client_id=\"CommandQueryInitiator\",\n        timeout=1000,\n        request_type=RequestType.Command,\n        tags=[\n            ('key', 'value'),\n            ('key2', 'value2'),\n        ]\n    )\n    initiator = Initiator(kube_add)\n    response = initiator.send_request(request)\n\n```\n### Queries\nConcept\nQueries implement synchronous messaging pattern which the sender send a request and wait for a specific amount of time to get a response.\n\nThe response must include metadata or body together with an indication of successful or not operation. This is the responsibility of the responder to return with the result of the query within the time the sender set in the request.\n\nSending Query Requests:\n```\n    request = Request(\n        body=\"Request\".encode('UTF-8'),\n        metadata=\"MyMetadata\",\n        cache_key=\"\",\n        cache_ttl=0,\n        channel=\"MyTestChannelName\",\n        client_id=\"QueryInitiator\",\n        timeout=1000,\n        request_type=RequestType.Query,\n        tags=[\n            ('key', 'value'),\n            ('key2', 'value2'),\n        ]\n    )\n    initiator = Initiator(kube_add)\n    response = initiator.send_request(request)\n```\nReceiving Query Requests and sending response\nFirst get a channel of queries:\n```\n    responder = Responder(kube_add)\n    cancel_token=ListenerCancellationToken()\n    sub_req= SubscribeRequest(\n        channel=\"MyTestRequestChannelName\",\n        client_id=str(randint(9, 19999)),\n        events_store_type=EventsStoreType.Undefined,\n        events_store_type_value=0,\n        group=\"\",\n        subscribe_type=SubscribeType.Queries\n    )\n    responder.subscribe_to_requests(sub_req, handle_incoming_events,handle_incoming_error,cancel_token)\n    print(\"sub for 10 seconds\")\n    time.sleep(10.0)\n    print(\"Canceled token\")\n    cancel_token.cancel()\n\ndef handle_incoming_request(request):\n    if request:\n        print(\"Subscriber Received request: Metadata:'%s', Channel:'%s', Body:'%s' tags:%s\" % (\n            request.metadata,\n            request.channel,\n            request.body,\n            request.tags\n        ))\n\n        response = Response(request)\n        response.body = \"OK\".encode('UTF-8')\n        response.cache_hit = False\n        response.error = \"None\"\n        response.client_id = client_id\n        response.executed = True\n        response.metadata = \"OK\"\n        response.timestamp = datetime.datetime.now()\n        response.tags=request.tags\n        #Return response\n        return response\n\ndef handle_request_incoming_error(error_msg):\n        print(\"received error:%s'\" % (\n            error_msg\n        ))\n```\n\nLicense\nThis project is licensed under the MIT License - see the LICENSE file for details\n\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/kubemq-io/kubemq-Python", "keywords": "", "license": "MIT", "maintainer": "", "maintainer_email": "", "name": "kubemq", "package_url": "https://pypi.org/project/kubemq/", "platform": "", "project_url": "https://pypi.org/project/kubemq/", "project_urls": {"Homepage": "https://github.com/kubemq-io/kubemq-Python"}, "release_url": "https://pypi.org/project/kubemq/1.1.0/", "requires_dist": ["future (==0.17.1)", "grpcio (==1.27.1)", "protobuf (==3.6.1)"], "requires_python": "", "summary": "KubeMQ SDK for Python", "version": "1.1.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>KubeMQ SDK for Python</h1>\n<p>The <strong>KubeMQ SDK for Python</strong> enables Python developers to easily work with <a href=\"https://kubemq.io/\" rel=\"nofollow\">KubeMQ</a>.</p>\n<h2>Getting Started</h2>\n<h3>Prerequisites</h3>\n<p>KubeMQ-SDK-Python works with <strong>Python 3.2</strong> or newer.</p>\n<h3>Installing</h3>\n<p>The recommended way to use the SDK for Python in your project is to consume it from pip.</p>\n<pre><code>pip install kubemq\n</code></pre>\n<h2>Generating Documentation</h2>\n<p>Sphinx is used for documentation. Use the Makefile to build the docs, like so:</p>\n<pre><code>$ pip install -r requirements-docs.txt\n$ cd docs\n$ make html\n</code></pre>\n<p>(<code>make latex</code> or <code>make linkcheck</code> supported)</p>\n<h2>Building from source</h2>\n<p>Once you check out the code from GitHub, you can install the package locally with:</p>\n<pre><code>$ pip install .\n</code></pre>\n<p>You can also install the package with a symlink,\nso that changes to the source files will be immediately available:</p>\n<pre><code>$ pip install -e .\n</code></pre>\n<p>Installation:\n$ pip install kubemq</p>\n<h3>Core Basics</h3>\n<p>KubeMQ messaging broker has five messaging patterns:</p>\n<ul>\n<li><strong>Queues</strong>  - FIFO based, exactly one durable queue pattern</li>\n<li><strong>Events</strong> - real-time pub/sub pattern</li>\n<li><strong>Events Store</strong> - pub/sub with persistence pattern</li>\n<li><strong>Commands</strong> - the Command part of CQRS pattern, which sends commands with the response for executed or not (with proper error messaging)</li>\n<li><strong>Queries</strong> - the Query part of CQRS pattern, which sends a query and gets a response with the relevant query result back\nFor each one of the patterns, we can distinguish between the senders and the receivers.</li>\n</ul>\n<p>For events and events store, the KubeMQ supports both RPC and upstream calls.</p>\n<p>the data model is almost identical between all the pattern with some data added related to the specific patter.</p>\n<h3>The common part of all the patterns are:</h3>\n<ul>\n<li><strong>ID</strong> - the sender can set the ID for each type of message, or the Id is automatically generated a UUID Id for him.</li>\n<li><strong>Metadata</strong> - a string field that can hold any metadata related to the message</li>\n<li><strong>Body</strong> - a Bytes array which contains the actual payload to be sent from the sender to the receiver</li>\n<li><strong>Tags</strong> - a Map of string, string for user define data</li>\n<li>The KubeMQ core transport is based on gRPC, and the library is a wrapper around the client-side of gRPC complied protobuf hence -   leveraging the gRPC benefits and advantages.</li>\n</ul>\n<p>Before any transactions to be performed with KubeMQ server, the Client should connect and dial KubeMQ server and obtain Client connection.</p>\n<p>With the Client connection object, the user can perform all transactions to and from KubeMQ server.</p>\n<p>A Client connection object is thread-safe and can be shared between all process needed to communicate with KubeMQ.</p>\n<p>IMPORTANT - it's the user responsibility to close the Client connection when no further communication with KubeMQ is needed.</p>\n<p>Connection\nConnecting to KubeMQ server can be by creating the type needed:</p>\n<pre><code>    pub/sub:\n        sender:\n        sender = Sender(\"localhost:50000\")\n        Subscriber:\n        subscriber = Subscriber(\"localhost:50000)\n\n    command/query:\n        Initiator:\n        initiator = Initiator(\"localhost:50000\")\n        Responder:\n        responder = Responder(\"localhost:50000\")\n\n    then to check connection call ping as such:\n        #\n        def create_check_connection():\n        sender= Sender(\"localhost:50000\")\n        try:\n            result=sender.ping()\n        except Exception as identifier:\n            print('error {}'.format(identifier))\n            exit()\n        print(result)\n\n</code></pre>\n<p>Examples\nPlease visit our extensive examples folder Please find usage examples on the examples folders.</p>\n<h3>Queues</h3>\n<p>Core features</p>\n<ul>\n<li>\n<p>KubeMQ supports distributed durable FIFO based queues with the following core features:</p>\n</li>\n<li>\n<p><strong>Exactly One Delivery</strong> - Only one message guarantee will deliver to the subscriber</p>\n</li>\n<li>\n<p><strong>Single and Batch Messages Send and Receive</strong> - Single and multiple messages in one call</p>\n</li>\n<li>\n<p><strong>RPC and Stream Flows</strong> - RPC flow allows an insert and pulls messages in one call. Stream flow allows single message consuming in a transactional way</p>\n</li>\n<li>\n<p><strong>Message Policy</strong> - Each message can be configured with expiration and delay timers. Also, each message can specify a dead-letter queue for un-processed messages attempts</p>\n</li>\n<li>\n<p><strong>Long Polling</strong> - Consumers can wait until a message available in the queue to consume</p>\n</li>\n<li>\n<p><strong>Peek Messages</strong>- Consumers can peek into a queue without removing them from the queue</p>\n</li>\n<li>\n<p><strong>Ack All Queue Messages</strong> - Any client can mark all the messages in a queue as discarded and will not be available anymore to consume</p>\n</li>\n<li>\n<p><strong>Visibility timers</strong> - Consumers can pull a message from the queue and set a timer which will cause the message not be visible to other consumers. This timer can be extended as needed.</p>\n</li>\n<li>\n<p><strong>Resend Messages</strong> - Consumers can send back a message they pulled to a new queue or send a modified message to the same queue for further processing.</p>\n</li>\n</ul>\n<p>Send Message to a Queue:</p>\n<pre><code>    queue = MessageQueue(queue_name, client_id, kube_add)\n    message = create_queue_message(\"someMeta\", \"some-simple_queue-queue-message\".encode('UTF-8'))\n    queue_send_response = queue.send_queue_message(message)\n    print(\"finished sending to queue answer. message_id: %s, body: %s\" % (queue_send_response.message_id, message.body))\n</code></pre>\n<p>create_queue_message:</p>\n<pre><code>    def create_queue_message(meta_data, body, policy=None):\n        message = Message()\n        message.metadata = meta_data\n        message.body = body\n        message.tags = [\n            ('key', 'value'),\n            ('key2', 'value2')\n        ]\n        message.attributes = None\n        message.policy = policy\n        return message\n</code></pre>\n<p>Send Message to a Queue with Expiration:</p>\n<pre><code>    queue = MessageQueue(queue_name, client_id, kube_add, max_number_messages, max_timeout)\n    policy = QueueMessagePolicy()\n    policy.ExpirationSeconds = 5\n    message = create_queue_message(\"someMeta\", \"some-simple_queue-queue-message\".encode('UTF-8'), policy)\n    queue_send_message_to_queue_with_expiration_response = queue.send_queue_message(message)\n    print(\"finished sending message to queue with expiration answer: {} \".format(\n        queue_send_message_to_queue_with_expiration_response))\n</code></pre>\n<p>Send Message to a Queue with Delay:</p>\n<pre><code>    queue = MessageQueue(queue_name, client_id, kube_add, max_number_messages, max_timeout)\n    policy = QueueMessagePolicy()\n    policy.DelaySeconds = 5\n    message = create_queue_message(\"someMeta\", \"some-simple_queue-queue-message\".encode('UTF-8'), policy)\n    queue_send_message_to_queue_with_delay_response = queue.send_queue_message(message)\n    print(\"finished sending message to queue with delay answer: {} \".format(\n        queue_send_message_to_queue_with_delay_response))\n</code></pre>\n<p>Send Message to a Queue with Dead-letter Queue:</p>\n<pre><code>    queue = MessageQueue(queue_name, client_id, kube_add, max_number_messages, max_timeout)\n    policy = QueueMessagePolicy()\n    policy.MaxReceiveCount = 3\n    policy.MaxReceiveQueue = \"DeadLetterQueue\"\n    message = create_queue_message(\"someMeta\", \"some-simple_queue-queue-message\".encode('UTF-8'), policy)\n    queue_send_message_to_queue_with_deadletter_response = queue.send_queue_message(message)\n    print(\"finished sending message to queue with deadletter answer: {} \".format(\n        queue_send_message_to_queue_with_deadletter_response))\n</code></pre>\n<p>Send Batch Messages:</p>\n<pre><code>    queue = MessageQueue(queue_name, client_id, kube_add, max_number_messages, max_timeout)\n    mm = []\n    for i in range(2):\n        message = create_queue_message(\"queueName {}\".format(i), \"some-simple_queue-queue-message\".encode('UTF-8'))\n        mm.append(message)\n    queue_send_batch_response = queue.send_queue_messages_batch(mm)\n    print(\"finished sending message to queue with batch answer: {} \".format(queue_send_batch_response))\n</code></pre>\n<p>Receive Messages from a Queue:</p>\n<pre><code>    queue = MessageQueue(queue_name, client_id, kube_add, max_number_messages, max_timeout)\n    queue_receive_response = queue.receive_queue_messages()\n    print(\"finished sending message to receive_queue answer: {} \".format(queue_receive_response))\n</code></pre>\n<p>Peak Messages from a Queue:</p>\n<pre><code>    queue = MessageQueue(queue_name, client_id, kube_add, max_number_messages, max_timeout)\n    queue_receive_response = queue.peek_queue_message(5)\n    print(\"finished sending message to peek answer: {} \".format(queue_receive_response))\n</code></pre>\n<p>Ack All Messages In a Queue:</p>\n<pre><code>    queue = MessageQueue(queue_name, client_id, kube_add, max_number_messages, max_timeout)\n    queue_ack_response = queue.ack_all_queue_messages()\n    print(\"finished sending message to ack answer: {} \".format(queue_ack_response))\n</code></pre>\n<p>Transactional Queue - Ack:</p>\n<pre><code>    queue = MessageQueue(queue_name, client_id, kube_add)\n    transaction = queue.create_transaction()\n    res_rec = transaction.receive(10, 10)\n\n    if res_rec.is_error:\n        raise \"Message dequeue error, error: %s\" % res_rec.is_error\n\n    print(\"Received message id: %s, body: %s\" % (res_rec.message.MessageID, res_rec.message.Body))\n    print(\"tags: %s\" % res_rec.message.Tags)\n\n    res_ack = transaction.ack_message(res_rec.message.Attributes.Sequence)\n    if res_ack.is_error:\n        raise Exception(\"Ack message error: %s\" % res_ack.error)\n\n    print(\"Received message of type: %s\" % StreamRequestType(res_ack.stream_request_type).name)\n</code></pre>\n<p>Transactional Queue - Reject:</p>\n<pre><code>    queue = MessageQueue(queue_name, client_id, kube_add)\n    transaction = queue.create_transaction()\n    res_rec = transaction.receive(10, 10)\n\n    if res_rec.is_error:\n        raise \"Message dequeue error, error: %s\" % res_rec.is_error\n\n    print(\"Received message id: {}, body: {} tags:{}\".format(res_rec.message.MessageID, res_rec.message.Body,res_rec.message.Tags))\n\n    res_rej = transaction.rejected_message(res_rec.message.Attributes.Sequence)\n    if res_rej.is_error:\n        raise Exception(\"Ack message error: %s\" % res_rej.error)\n\n    print(\"rejected message message of type: %s\" % StreamRequestType(res_rej.stream_request_type).name)\n</code></pre>\n<p>Transactional Queue - Extend Visibility:</p>\n<pre><code>    queue_rej = MessageQueue(\"reject_test\", client_id, kube_add)\n\n    message = create_queue_message(\"queueName {}\".format(0), \"my reject\".encode('UTF-8'))\n    queue_rej.send_queue_message(message)\n\n    queue= MessageQueue(\"reject_test\", client_id, kube_add)\n    tran=queue.create_transaction()\n\n    res_rec=tran.receive(5,10)\n\n    if res_rec.is_error:\n        raise \"Message dequeue error, error: %s\" % res_rec.is_error\n\n    print(\"Received message id: {}, body: {} tags: {}\".format(res_rec.message.MessageID, res_rec.message.Body,res_rec.message.Tags))\n\n    print(\"work for 1 second\")\n\n    time.sleep(1)\n\n    print(\"Need more time to process, extend visibility for more 3 seconds\")\n\n    res_ext=tran.extend_visibility(3)\n\n    if res_ext.is_error:\n        raise Exception(\"Ack message error: %s\" % res_ext.error)\n\n    print(\"Approved. work for 2.5 seconds\")\n\n    time.sleep(2.5)\n\n    print(\"Work done... ack the message\")\n\n\n    res_ack=tran.ack_message(res_rec.message.Attributes.Sequence)\n\n    if res_ack.is_error:\n        raise Exception(\"Ack message error: %s\" % res_ack.error)\n\n    print(\"ack done\")\n</code></pre>\n<p>Transactional Queue - Resend to New Queue:</p>\n<pre><code>    queue_rej = MessageQueue(\"resend_to_new_queue\", client_id, kube_add)\n\n    message = create_queue_message(\"resend to new queue {}\".format(0), \"my resend\".encode('UTF-8'))\n    queue_rej.send_queue_message(message)\n\n    queue= MessageQueue(\"resend_to_new_queue\", client_id, kube_add)\n    tran=queue.create_transaction()\n\n    res_rec=tran.receive(5,10)\n\n    if res_rec.is_error:\n        raise \"Message dequeue error, error: %s\" % res_rec.is_error\n\n    print(\"Received message id: {}, body: {} tags:{}\".format(res_rec.message.MessageID, res_rec.message.Body, res_rec.message.Tags))\n\n    print(\"resend to new queue\")\n\n    res_resend=tran.resend(\"new-queue\")\n\n    if res_resend.is_error:\n        raise \"Message resend error, error: %s\" % res_resend.is_error\n\n    print(\"Done\")\n</code></pre>\n<p>Transactional Queue - Resend Modified Message:</p>\n<pre><code>    queue_res = MessageQueue(\"resend_modify_message\", client_id, kube_add)\n\n    message = create_queue_message(\"resend to new queue {}\".format(0), \"my resend modify\".encode('UTF-8'))\n    queue_res.send_queue_message(message)\n\n    queue= MessageQueue(\"resend_modify_message\", client_id, kube_add)\n    tran=queue.create_transaction()\n\n    res_rec=tran.receive(3,5)\n\n    if res_rec.is_error:\n        raise \"Message dequeue error, error: %s\" % res_rec.is_error\n\n    print(\"Received message id: {}, body: {} tags:{}\".format(res_rec.message.MessageID, res_rec.message.Body,res_rec.message.Tags))\n\n    mod_msg=res_rec.message\n    mod_msg.Channel=\"receiverB\"\n\n    mod_msg.Metadata=\"new Metadata\"\n\n    res_mod=tran.modify(mod_msg)\n\n    if res_mod.is_error:\n        raise \"Message modify error, error: %s\" % res_mod.is_error\n\n    print(\"Done\")\n</code></pre>\n<p>Events\nSending Events\nSingle Event:</p>\n<pre><code>    def send_single_event():\n        sender = Sender(kube_add)\n        event = Event(\n            metadata=\"EventMetaData\",\n            body=(\"Event Created on time %s\" % datetime.datetime.utcnow()).encode('UTF-8'),\n            store=False,\n            channel=\"MyTestChannelName\",\n            client_id=\"EventSender\"\n        )\n        event.tags=[\n                ('key', 'value'),\n                ('key2', 'value2'),\n            ]\n        sender.send_event(event)\n</code></pre>\n<p>Stream Events:</p>\n<pre><code>    sender = Sender(kube_add)\n\n\n    def async_streamer():\n        for counter in range(3):\n            yield Event(\n                metadata=\"EventMetaData\",\n                body=(\"Event %s Created on time %s\" % (counter, datetime.datetime.utcnow())).encode('UTF-8'),\n                store=False,\n                channel=\"MyTestChannelName\",\n                client_id=\"EventSenderStream\",\n            )\n\n\n    def result_handler(result):\n        print(result)\n\n\n    sender.stream_event(async_streamer(), result_handler)\n</code></pre>\n<p>Receiving Events\nFirst you should subscribe to Events:</p>\n<pre><code>        def event_subscriber():\n            subscriber = Subscriber(kube_add)\n            cancel_token=ListenerCancellationToken()\n            sub_req= SubscribeRequest(\n                channel=\"MyTestChannelName\",\n                client_id=str(randint(9, 19999)),\n                events_store_type=EventsStoreType.Undefined,\n                events_store_type_value=0,\n                group=\"\",\n                subscribe_type=SubscribeType.Events\n            )\n            subscriber.subscribe_to_events(sub_req, handle_incoming_events,handle_incoming_error,cancel_token)\n            print(\"sub for 2 seconds\")\n            time.sleep(2.0)\n            print(\"Canceled token\")\n            cancel_token.cancel()\n\n        def handle_incoming_events(event):\n            if event:\n                print(\"Subscriber Received Event: Metadata:'%s', Channel:'%s', Body:'%s tags:%s'\" % (\n                    event.metadata,\n                    event.channel,\n                    event.body,\n                    event.tags\n                ))\n\n        def handle_incoming_error(error_msg):\n                print(\"received error:%s'\" % (\n                    error_msg\n                ))\n</code></pre>\n<p>Events Store\nSending Events Store\nSingle Event to Store:</p>\n<pre><code>        sender = Sender(kube_add)\n        event = Event(\n            metadata=\"EventMetaData\",\n            body=(\"Event Created on time %s\" % datetime.datetime.utcnow()).encode('UTF-8'),\n            store=True,\n            channel=\"MyTestChannelNameStore\",\n            client_id=\"EventSenderStore\"\n        )\n        event.tags=[\n                ('key', 'value'),\n                ('key2', 'value2'),\n            ]\n        sender.send_event(event)\n</code></pre>\n<p>Stream Events Store:</p>\n<pre><code>        sender = Sender(kube_add)\n\n\n        def async_streamer():\n            for counter in range(3):\n                yield Event(\n                    metadata=\"EventMetaData\",\n                    body=(\"Event %s Created on time %s\" % (counter, datetime.datetime.utcnow())).encode('UTF-8'),\n                    store=True,\n                    channel=\"MyTestChannelNameStore\",\n                    client_id=\"EventSenderStore\",\n                )\n\n\n        def result_handler(result):\n            print(result)\n\n\n        sender.stream_event(async_streamer(), result_handler)\n\n</code></pre>\n<p>Receiving Events Store\nFirst you should subscribe to Events Store and get a channel:</p>\n<pre><code>    subscriber = Subscriber(kube_add)\n    cancel_token=ListenerCancellationToken()\n    sub_req= SubscribeRequest(\n        channel=\"MyTestChannelNameStore\",\n        client_id=str(randint(9, 19999)),\n        events_store_type=EventsStoreType.StartFromFirst,\n        events_store_type_value=0,\n        group=\"\",\n        subscribe_type=SubscribeType.EventsStore\n    )\n    subscriber.subscribe_to_events(sub_req, handle_incoming_events,handle_incoming_error,cancel_token)\n    print(\"sub for 2 seconds\")\n    time.sleep(2.0)\n    print(\"Canceled token\")\n    cancel_token.cancel()\n</code></pre>\n<h3>Subscription Options</h3>\n<p>KubeMQ supports six types of subscriptions:</p>\n<ul>\n<li>\n<p><strong>StartFromNewEvents</strong> - start event store subscription with only new events</p>\n</li>\n<li>\n<p><strong>StartFromFirstEvent</strong> - replay all the stored events from the first available sequence and continue stream new events from this point</p>\n</li>\n<li>\n<p><strong>StartFromLastEvent</strong> - replay the last event and continue stream new events from this point</p>\n</li>\n<li>\n<p><strong>StartFromSequence</strong> - replay events from specific event sequence number and continue stream new events from this point</p>\n</li>\n<li>\n<p><strong>StartFromTime</strong> - replay events from specific time continue stream new events from this point</p>\n</li>\n<li>\n<p><strong>StartFromTimeDelta</strong> - replay events from specific current time - delta duration in seconds, continue stream new events from this point</p>\n</li>\n</ul>\n<h2>Commands</h2>\n<p>Concept\nCommands implement synchronous messaging pattern which the sender send a request and wait for a specific amount of time to get a response.</p>\n<p>The response can be successful or not. This is the responsibility of the responder to return with the result of the command within the time the sender set in the request.</p>\n<p>Sending Command Requests:\nIn this example, the responder should send his response withing one second. Otherwise, an error will be return as a timeout:</p>\n<pre><code>    request = Request(\n        body=\"Request\".encode('UTF-8'),\n        metadata=\"MyMetadata\",\n        cache_key=\"\",\n        cache_ttl=0,\n        channel=\"MyTestChannelName\",\n        client_id=\"CommandQueryInitiator\",\n        timeout=1000,\n        request_type=RequestType.Command,\n        tags=[\n            ('key', 'value'),\n            ('key2', 'value2'),\n        ]\n    )\n    initiator = Initiator(kube_add)\n    response = initiator.send_request(request)\n\n</code></pre>\n<h3>Queries</h3>\n<p>Concept\nQueries implement synchronous messaging pattern which the sender send a request and wait for a specific amount of time to get a response.</p>\n<p>The response must include metadata or body together with an indication of successful or not operation. This is the responsibility of the responder to return with the result of the query within the time the sender set in the request.</p>\n<p>Sending Query Requests:</p>\n<pre><code>    request = Request(\n        body=\"Request\".encode('UTF-8'),\n        metadata=\"MyMetadata\",\n        cache_key=\"\",\n        cache_ttl=0,\n        channel=\"MyTestChannelName\",\n        client_id=\"QueryInitiator\",\n        timeout=1000,\n        request_type=RequestType.Query,\n        tags=[\n            ('key', 'value'),\n            ('key2', 'value2'),\n        ]\n    )\n    initiator = Initiator(kube_add)\n    response = initiator.send_request(request)\n</code></pre>\n<p>Receiving Query Requests and sending response\nFirst get a channel of queries:</p>\n<pre><code>    responder = Responder(kube_add)\n    cancel_token=ListenerCancellationToken()\n    sub_req= SubscribeRequest(\n        channel=\"MyTestRequestChannelName\",\n        client_id=str(randint(9, 19999)),\n        events_store_type=EventsStoreType.Undefined,\n        events_store_type_value=0,\n        group=\"\",\n        subscribe_type=SubscribeType.Queries\n    )\n    responder.subscribe_to_requests(sub_req, handle_incoming_events,handle_incoming_error,cancel_token)\n    print(\"sub for 10 seconds\")\n    time.sleep(10.0)\n    print(\"Canceled token\")\n    cancel_token.cancel()\n\ndef handle_incoming_request(request):\n    if request:\n        print(\"Subscriber Received request: Metadata:'%s', Channel:'%s', Body:'%s' tags:%s\" % (\n            request.metadata,\n            request.channel,\n            request.body,\n            request.tags\n        ))\n\n        response = Response(request)\n        response.body = \"OK\".encode('UTF-8')\n        response.cache_hit = False\n        response.error = \"None\"\n        response.client_id = client_id\n        response.executed = True\n        response.metadata = \"OK\"\n        response.timestamp = datetime.datetime.now()\n        response.tags=request.tags\n        #Return response\n        return response\n\ndef handle_request_incoming_error(error_msg):\n        print(\"received error:%s'\" % (\n            error_msg\n        ))\n</code></pre>\n<p>License\nThis project is licensed under the MIT License - see the LICENSE file for details</p>\n\n          </div>"}, "last_serial": 6660468, "releases": {"1.0.2": [{"comment_text": "", "digests": {"md5": "7adb8c6527e2deb54ee9d8090e09a988", "sha256": "d867c311c0a69977b5a2fc89a7628df45fc23a123857fcfd4d8805977595dd32"}, "downloads": -1, "filename": "Kubemq-1.0.2-py3-none-any.whl", "has_sig": false, "md5_digest": "7adb8c6527e2deb54ee9d8090e09a988", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 45405, "upload_time": "2019-10-10T06:56:56", "upload_time_iso_8601": "2019-10-10T06:56:56.418780Z", "url": "https://files.pythonhosted.org/packages/65/05/e6f4ff4a0cdde69310ec552e01d22c124e5328f9ba50c2790e50bb3d7972/Kubemq-1.0.2-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "40bdc207c8b3a5c0bf2878ee480b458e", "sha256": "045e5353c086dfefdc0822a4af84705460dc64adf6759f6051d87b88769a0aa2"}, "downloads": -1, "filename": "Kubemq-1.0.2.tar.gz", "has_sig": false, "md5_digest": "40bdc207c8b3a5c0bf2878ee480b458e", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 20162, "upload_time": "2019-10-10T06:56:58", "upload_time_iso_8601": "2019-10-10T06:56:58.309367Z", "url": "https://files.pythonhosted.org/packages/bb/b7/e6e626583d5ac7fc8510562467b9f037b36c6dc0180364ca6b33bac0dbb2/Kubemq-1.0.2.tar.gz", "yanked": false}], "1.0.4": [{"comment_text": "", "digests": {"md5": "418cf806ac7a22c299341e8f9e34a7cf", "sha256": "873b5feaa9d200bb937e9e94cc695e8b857e24bd3bd7c0c8fd6b42299f4e6cfc"}, "downloads": -1, "filename": "kubemq-1.0.4-py3-none-any.whl", "has_sig": false, "md5_digest": "418cf806ac7a22c299341e8f9e34a7cf", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 68211, "upload_time": "2019-10-07T13:01:02", "upload_time_iso_8601": "2019-10-07T13:01:02.446987Z", "url": "https://files.pythonhosted.org/packages/67/97/cc86acf278382e1bb5a425532798a79087fa66ef71bb15c9a1a26d3f49f6/kubemq-1.0.4-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "3f29078a86174c2d9551b52092902693", "sha256": "a01b390a1481d61a1b649fefcb4c0943125dca1f131a8b0879683b98a4c00620"}, "downloads": -1, "filename": "kubemq-1.0.4.tar.gz", "has_sig": false, "md5_digest": "3f29078a86174c2d9551b52092902693", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 36242, "upload_time": "2019-10-07T13:01:04", "upload_time_iso_8601": "2019-10-07T13:01:04.022787Z", "url": "https://files.pythonhosted.org/packages/c8/b6/be5b53da22902bf08ac3d342e69efb07057c447a88e72601358beb258159/kubemq-1.0.4.tar.gz", "yanked": false}], "1.0.7": [{"comment_text": "", "digests": {"md5": "98b1957973d55a0b090919ac92699aae", "sha256": "7f6365becc7719aeb08b0118162329d70715e9d6b74a4fa41f079db50bbef8ee"}, "downloads": -1, "filename": "kubemq-1.0.7-py3-none-any.whl", "has_sig": false, "md5_digest": "98b1957973d55a0b090919ac92699aae", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 68379, "upload_time": "2019-12-30T09:25:02", "upload_time_iso_8601": "2019-12-30T09:25:02.001519Z", "url": "https://files.pythonhosted.org/packages/6c/a6/169f2dd1dcf905548f8826a58293537b0c81f8a3c53393afa1738562b575/kubemq-1.0.7-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "49100ff2411a661f35c23588170019ee", "sha256": "2cc61958478fa0a721d4207aa8145428ed00de0830b8058f3d27aa2edb5bf486"}, "downloads": -1, "filename": "kubemq-1.0.7.tar.gz", "has_sig": false, "md5_digest": "49100ff2411a661f35c23588170019ee", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 36062, "upload_time": "2019-12-30T09:25:03", "upload_time_iso_8601": "2019-12-30T09:25:03.837842Z", "url": "https://files.pythonhosted.org/packages/de/e0/b3b236c656f5c584134e0018ac812ead80200f6900106c85d5971acbe5a5/kubemq-1.0.7.tar.gz", "yanked": false}], "1.0.8": [{"comment_text": "", "digests": {"md5": "33c9a266c127637d6e31a37dd3d5a96e", "sha256": "0d5f6dec556478fb3031e08b2ab98fd88d964bc74508199d948a288b3b141058"}, "downloads": -1, "filename": "kubemq-1.0.8-py3-none-any.whl", "has_sig": false, "md5_digest": "33c9a266c127637d6e31a37dd3d5a96e", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 68438, "upload_time": "2020-02-18T12:37:14", "upload_time_iso_8601": "2020-02-18T12:37:14.080230Z", "url": "https://files.pythonhosted.org/packages/91/1c/ba0f20b861f3e7e9f8b9b6a346b59300466f7d8ea776ac6ce8adb1857eb7/kubemq-1.0.8-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "6c53322d264d440445c6713b7576ca96", "sha256": "ffa1b14692a9dfb978100ad21bb6a7913d676a8a253316027141d39722e34fdc"}, "downloads": -1, "filename": "kubemq-1.0.8.tar.gz", "has_sig": false, "md5_digest": "6c53322d264d440445c6713b7576ca96", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 36172, "upload_time": "2020-02-18T12:37:15", "upload_time_iso_8601": "2020-02-18T12:37:15.540386Z", "url": "https://files.pythonhosted.org/packages/6f/d5/5f758f4497fe3e4bdbb549162fe1fd78b67b39f823c2224ca69826135de1/kubemq-1.0.8.tar.gz", "yanked": false}], "1.0.9": [{"comment_text": "", "digests": {"md5": "46ce4b6f140d0be6f71d18ec86d8c888", "sha256": "a09fb9151acf343c4eabffe379cf59aa406ba0437d005c7c057c1a05e2d202b0"}, "downloads": -1, "filename": "kubemq-1.0.9-py3-none-any.whl", "has_sig": false, "md5_digest": "46ce4b6f140d0be6f71d18ec86d8c888", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 68434, "upload_time": "2020-02-19T11:25:38", "upload_time_iso_8601": "2020-02-19T11:25:38.358839Z", "url": "https://files.pythonhosted.org/packages/dc/a7/61b55db4ff1ad35c845e7580c4861cc984783e0fc8ad09d1930df75e2db1/kubemq-1.0.9-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "c7069f736863c22bed99e6ebef5b1084", "sha256": "e225ce03a5da631d43133277044b1a689c0ee720f7dfe0ef9b05ae212f42aea9"}, "downloads": -1, "filename": "kubemq-1.0.9.tar.gz", "has_sig": false, "md5_digest": "c7069f736863c22bed99e6ebef5b1084", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 36216, "upload_time": "2020-02-19T11:25:40", "upload_time_iso_8601": "2020-02-19T11:25:40.959485Z", "url": "https://files.pythonhosted.org/packages/fb/84/edaded0edc4a8a0930b94e170104b11bad09f829b4ac3aaf1ae838bd7a40/kubemq-1.0.9.tar.gz", "yanked": false}], "1.1.0": [{"comment_text": "", "digests": {"md5": "0a3d1b4521a337f791adebb41dd781ea", "sha256": "95b3ee5c55ef634a7783713a37ce525bc9d6cad9264cfc98668a0dee63f79cbe"}, "downloads": -1, "filename": "kubemq-1.1.0-py3-none-any.whl", "has_sig": false, "md5_digest": "0a3d1b4521a337f791adebb41dd781ea", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 68437, "upload_time": "2020-02-19T11:28:12", "upload_time_iso_8601": "2020-02-19T11:28:12.682781Z", "url": "https://files.pythonhosted.org/packages/88/d8/a7a33165c128b4f3e91323d2d57e2330d5c42ccd9ace098ceb1c7e87ecda/kubemq-1.1.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "7b7d0249d20666949757af4b026fbfeb", "sha256": "9c41ce0e480fe6098420caf5c3f4947ffe70665450195bed149dcac1b65d1d3e"}, "downloads": -1, "filename": "kubemq-1.1.0.tar.gz", "has_sig": false, "md5_digest": "7b7d0249d20666949757af4b026fbfeb", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 36217, "upload_time": "2020-02-19T11:28:14", "upload_time_iso_8601": "2020-02-19T11:28:14.297685Z", "url": "https://files.pythonhosted.org/packages/9c/b1/b6df92381b8ff2460ab08cde3b45ff14cb69b88142a57b59484a5bcbbfb6/kubemq-1.1.0.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "0a3d1b4521a337f791adebb41dd781ea", "sha256": "95b3ee5c55ef634a7783713a37ce525bc9d6cad9264cfc98668a0dee63f79cbe"}, "downloads": -1, "filename": "kubemq-1.1.0-py3-none-any.whl", "has_sig": false, "md5_digest": "0a3d1b4521a337f791adebb41dd781ea", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 68437, "upload_time": "2020-02-19T11:28:12", "upload_time_iso_8601": "2020-02-19T11:28:12.682781Z", "url": "https://files.pythonhosted.org/packages/88/d8/a7a33165c128b4f3e91323d2d57e2330d5c42ccd9ace098ceb1c7e87ecda/kubemq-1.1.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "7b7d0249d20666949757af4b026fbfeb", "sha256": "9c41ce0e480fe6098420caf5c3f4947ffe70665450195bed149dcac1b65d1d3e"}, "downloads": -1, "filename": "kubemq-1.1.0.tar.gz", "has_sig": false, "md5_digest": "7b7d0249d20666949757af4b026fbfeb", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 36217, "upload_time": "2020-02-19T11:28:14", "upload_time_iso_8601": "2020-02-19T11:28:14.297685Z", "url": "https://files.pythonhosted.org/packages/9c/b1/b6df92381b8ff2460ab08cde3b45ff14cb69b88142a57b59484a5bcbbfb6/kubemq-1.1.0.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:48:37 2020"}