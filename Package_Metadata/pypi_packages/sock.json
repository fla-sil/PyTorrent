{"info": {"author": "hellman", "author_email": "hellman1908@gmail.com", "bugtrack_url": null, "classifiers": ["Development Status :: 4 - Beta", "Intended Audience :: Developers", "License :: OSI Approved :: MIT License", "Natural Language :: English", "Operating System :: Unix", "Programming Language :: Python :: 2", "Topic :: System :: Networking"], "description": "sock\n====================\n\nSmall script to simplify network communication.\nSomething like telnetlib http://docs.python.org/library/telnetlib.html, but for clean TCP/UDP (no command sequences, \\r\\n newlines, etc.)\n\n\nUsage\n---------------------\n\n###TCP Client\n\n```python\nfrom sock import *\n\nf = Sock(\"some.cool.servi.ce:3123\", timeout=10)\n# or IPv6\nf = Sock6(\"::1 3123\", timeout=3)\n# or already existing socket\nf = Sock.from_socket(some_socket)  # or toSock(some_socket)\n# or UDP/IPv6\nf = SockU6(\"::1 3123\", timeout=3)\n\n# wait for prompt (skip banner for example)\n# the prompt itself will be skipped (and returned) too\nf.read_until(\"> \", timeout=3)  # read_until_re also exists\n\nf.send(\"flip coin\\n\")\n\n# skip until regexp\nresult1 = f.skip_until_re(r\"You've got (heads|tails)\")  # skip_until(str) also exists\n\n# read until also consumes matched part\nf.read_until_re(r\"You've g[oe]t \")  # read_until(str) also exists\n\n# read specific number of bytes\nresult2 = f.read_nbytes(5)\n\nassert result1 == result2\n\n# alias for f.send(s + \"\\n\")\nf.send_line(\"random please\")\n\n# read one packet and flush buffers\nprint f.read_one()\n\n# non-blocking read (flush buffers)\nprint f.read_one(0)\n\n# read until disconnect\nprint f.read_all()\n```\n\nAbout\n---------------------\n\nThis software uses Semantic Versioning ( http://semver.org/ )\n\nAuthor: hellman ( hellman1908@gmail.com )\n\nLicense: MIT License (http://opensource.org/licenses/MIT)", "description_content_type": null, "docs_url": null, "download_url": "UNKNOWN", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/hellman/sock", "keywords": "socket telnet network sock", "license": "MIT", "maintainer": null, "maintainer_email": null, "name": "sock", "package_url": "https://pypi.org/project/sock/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/sock/", "project_urls": {"Download": "UNKNOWN", "Homepage": "https://github.com/hellman/sock"}, "release_url": "https://pypi.org/project/sock/0.4.0/", "requires_dist": null, "requires_python": null, "summary": "Small script to simplify network communication", "version": "0.4.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            sock<br>====================<br><br>Small script to simplify network communication.<br>Something like telnetlib http://docs.python.org/library/telnetlib.html, but for clean TCP/UDP (no command sequences, \\r\\n newlines, etc.)<br><br><br>Usage<br>---------------------<br><br>###TCP Client<br><br>```python<br>from sock import *<br><br>f = Sock(\"some.cool.servi.ce:3123\", timeout=10)<br># or IPv6<br>f = Sock6(\"::1 3123\", timeout=3)<br># or already existing socket<br>f = Sock.from_socket(some_socket)  # or toSock(some_socket)<br># or UDP/IPv6<br>f = SockU6(\"::1 3123\", timeout=3)<br><br># wait for prompt (skip banner for example)<br># the prompt itself will be skipped (and returned) too<br>f.read_until(\"&gt; \", timeout=3)  # read_until_re also exists<br><br>f.send(\"flip coin\\n\")<br><br># skip until regexp<br>result1 = f.skip_until_re(r\"You've got (heads|tails)\")  # skip_until(str) also exists<br><br># read until also consumes matched part<br>f.read_until_re(r\"You've g[oe]t \")  # read_until(str) also exists<br><br># read specific number of bytes<br>result2 = f.read_nbytes(5)<br><br>assert result1 == result2<br><br># alias for f.send(s + \"\\n\")<br>f.send_line(\"random please\")<br><br># read one packet and flush buffers<br>print f.read_one()<br><br># non-blocking read (flush buffers)<br>print f.read_one(0)<br><br># read until disconnect<br>print f.read_all()<br>```<br><br>About<br>---------------------<br><br>This software uses Semantic Versioning ( http://semver.org/ )<br><br>Author: hellman ( hellman1908@gmail.com )<br><br>License: MIT License (http://opensource.org/licenses/MIT)\n          </div>"}, "last_serial": 1464376, "releases": {"0.4.0": []}, "urls": [], "timestamp": "Fri May  8 03:07:03 2020"}