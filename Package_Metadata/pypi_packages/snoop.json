{"info": {"author": "Alex Hall", "author_email": "alex.mojaki@gmail.com", "bugtrack_url": null, "classifiers": ["Environment :: Console", "Intended Audience :: Developers", "License :: OSI Approved :: MIT License", "Operating System :: OS Independent", "Programming Language :: Python :: 2.7", "Programming Language :: Python :: 3.4", "Programming Language :: Python :: 3.5", "Programming Language :: Python :: 3.6", "Programming Language :: Python :: 3.7", "Programming Language :: Python :: Implementation :: CPython", "Programming Language :: Python :: Implementation :: PyPy", "Topic :: Software Development :: Debuggers"], "description": "# snoop\n\n[![Build Status](https://travis-ci.org/alexmojaki/snoop.svg?branch=master)](https://travis-ci.org/alexmojaki/snoop) [![Supports Python versions 2.7 and 3.4+, including PyPy](https://img.shields.io/pypi/pyversions/snoop.svg)](https://pypi.python.org/pypi/snoop)\n\nsnoop is a powerful set of Python debugging tools. It's primarily meant to be a [more featureful and refined](https://github.com/alexmojaki/snoop/wiki/Comparison-to-PySnooper) version of [PySnooper](https://github.com/cool-RR/pysnooper). It also includes a more accurate version of [icecream](https://github.com/gruns/icecream) and some other nifty stuff.\n\nYou're trying to figure out why your Python code isn't doing what you think it should be doing. You'd love to use a full-fledged debugger with breakpoints and watches, but you can't be bothered to set one up right now.\n\nYou want to know which lines are running and which aren't, and what the values of the local variables are.\n\nMost people would use `print` lines, in strategic locations, some of them showing the values of variables.\n\n**snoop** lets you do the same, except instead of carefully crafting the right `print` lines, you just add one decorator line to the function you're interested in. You'll get a play-by-play log of your function, including which lines ran and when, and exactly when local variables were changed.\n\nInstallation is as simple as `pip install snoop`.\n\n  * [Basic snoop usage](#basic-snoop-usage)\n     * [Common arguments](#common-arguments)\n  * [pp - awesome print debugging](#pp---awesome-print-debugging)\n     * [pp.deep for tracing subexpressions](#ppdeep-for-tracing-subexpressions)\n  * [@spy](#spy)\n  * [install()](#install)\n     * [Disabling](#disabling)\n     * [Output configuration](#output-configuration)\n  * [API differences from PySnooper](#api-differences-from-pysnooper)\n  * [IPython/Jupyter integration](#ipythonjupyter-integration)\n  * [Advanced usage](#advanced-usage)\n     * [watch_extras](#watch_extras)\n     * [Controlling watch_explode](#controlling-watch_explode)\n     * [Customising the display of variables](#customising-the-display-of-variables)\n     * [Multiple separate configurations](#multiple-separate-configurations)\n  * [Contribute](#contribute)\n     * [Feedback and discussions](#feedback-and-discussions)\n     * [Developing](#developing)\n\n\n## Basic snoop usage\n\nWe're writing a function that converts a number to binary, by returning a list of bits. Let's snoop on it by adding the `@snoop` decorator:\n\n```python\nimport snoop\n\n@snoop\ndef number_to_bits(number):\n    if number:\n        bits = []\n        while number:\n            number, remainder = divmod(number, 2)\n            bits.insert(0, remainder)\n        return bits\n    else:\n        return [0]\n\nnumber_to_bits(6)\n```\n\nNote how easy it is: Just `import snoop` and `@snoop`. If you don't like the magical import, `snoop.snoop` and `from snoop import snoop` still work too. Or if you don't want to import in your project at all, just call [`install()`](#install) somewhere once.\n\nThe output to stderr looks like this:\n\n![number_to_bits output](https://i.imgur.com/3ozqWam.png)\n\nLet's try a more complex example. We're writing a memoizing decorator: it stores function arguments and return values in a cache to avoid recomputation:\n\n```python\nimport snoop\n\ndef cache(func):\n    d = {}\n\n    def wrapper(*args):\n        try:\n            return d[args]\n        except KeyError:\n            result = d[args] = func(*args)\n            return result\n\n    return wrapper\n\n@snoop(depth=2)\n@cache\ndef add(x, y):\n    return x + y\n\nadd(1, 2)\nadd(1, 2)\n```\n\nHere we specify `depth=2` to mean we should also step one level down into inner function calls. We then call the function twice to see the caching in action. Here's the output:\n\n![cache output](https://i.imgur.com/Enu7k0h.png)\n\nAt a glance we can see that in the first call the cache lookup failed with a `KeyError` so the original `add` function was called, while in the second call the previously cached result was returned immediately. \n\nIf you don't want to trace an entire function, you can wrap the relevant part in a `with` block:\n\n```python\nimport snoop\nimport random\n\ndef foo():\n    lst = []\n    for i in range(10):\n        lst.append(random.randrange(1, 1000))\n\n    with snoop:\n        lower = min(lst)\n        upper = max(lst)\n        mid = (lower + upper) / 2\n\n    return lower, mid, upper\n\nfoo()\n```\n\nwhich outputs something like:\n\n![foo output](https://i.imgur.com/aBVXFSQ.png)\n\n### Common arguments\n\n- `depth`: as seen above, snoops deeper calls made by the function/block you trace. The default is 1, meaning no inner calls, so pass something bigger.\n- `watch`: show values of arbitrary expressions by specifying them as a string, e.g:\n \n```python\n@snoop(watch=('foo.bar', 'self.x[\"whatever\"]'))\n```\n\n- `watch_explode`: Expand variables or expressions to see all their attributes or items of lists/dictionaries:\n\n```python\n@snoop(watch_explode=['foo', 'self'])\n```\n\nThis will output lines like:\n\n```\n........ foo[2] = 'whatever'\n........ self.baz = 8\n```\n\nSee [Controlling `watch_explode`](#controlling-watch_explode) for more advanced usage of this argument.\n\nSee [`watch_extras`](#watch_extras) to show additional information about any value (local variable, watched expression, or exploded item) automatically.\n\n## `pp` - awesome print debugging\n\nWhile `snoop` is meant to save you from writing `print` calls, sometimes that's still exactly the kind of thing you need. `pp` aims to be the best possible version of this. It can be used alone or in combination with `snoop`.\n\n`pp(x)` will output `x = <pretty printed value of x>`, i.e. it will show the source code of its argument(s) so you know what's being printed, and format the value with `pprint.pformat` so that you can easily see the layout of complicated data structures.\n\n`pp` will return its argument directly so you can easily insert it in code without rearranging. If given multiple arguments, it will return them as a tuple, so you can replace `foo(x, y)` with `foo(*pp(x, y))` to leave the behaviour of the code intact. \n\nHere's an example:\n\n```python\nfrom snoop import pp\nx = 1\ny = 2\npp(pp(x + 1) + max(*pp(y + 2, y + 3)))\n```\n\nOutput:\n\n```\n12:34:56.78 LOG:\n12:34:56.78 .... x + 1 = 2\n12:34:56.78 LOG:\n12:34:56.78 .... y + 2 = 4\n12:34:56.78 .... y + 3 = 5\n12:34:56.78 LOG:\n12:34:56.78 .... pp(x + 1) + max(*pp(y + 2, y + 3)) = 7\n```\n\nIf you've already got `import snoop` you can also use `snoop.pp`. But ideally, you would use [`install()`](#install) to avoid importing at all.\n\nThere are a few situations where `pp` can't find the source code of its arguments, in which case it will show a placeholder instead:\n\n - When the source file cannot be found, usually because it doesn't exist, e.g. if you're in a Python shell. The source is fetched from `linecache`.\n - In Python 3.4 and PyPy.\n - In the presence of magic which transforms source code under the hood, such as `pytest` or `birdseye` (and thus the [`@spy`](#spy) decorator).\n - When the source file has been modified before the first call to `pp` or `snoop`.\n \nUnder the hood, `pp` uses the library [`executing`](https://github.com/alexmojaki/executing) to locate the AST node of the function call - check it out if you'd like to write some cool utilities of your own.\n\n`pp` is inspired by [icecream](https://github.com/gruns/icecream) and offers the same basic API for printing, but [icecream's algorithm is less accurate than `executing`](https://github.com/gruns/icecream/pull/33), and `pp` integrates seamlessly with `snoop`. It also offers `pp.deep`, which is unique.\n\n'`pp`' stands for 'pretty-print' and *totally definitely absolutely has no other meaning*. It's also very easy and quick to type.\n\n### `pp.deep` for tracing subexpressions\n\nIf you have `pp(<complicated expression>)` and you want to see what happens inside that expression and not just the final value, replace it wth `pp.deep(lambda: <complicated expression>)`. This will log every intermediate subexpression, in the correct order, with no additional side effects, and return the final value. Repeating the previous example:\n\n```python\npp.deep(lambda: x + 1 + max(y + 2, y + 3))\n```\n\nOutput:\n\n```\n12:34:56.78 LOG:\n12:34:56.78 ............ x = 1\n12:34:56.78 ........ x + 1 = 2\n12:34:56.78 ................ y = 2\n12:34:56.78 ............ y + 2 = 4\n12:34:56.78 ................ y = 2\n12:34:56.78 ............ y + 3 = 5\n12:34:56.78 ........ max(y + 2, y + 3) = 5\n12:34:56.78 .... x + 1 + max(y + 2, y + 3) = 7\n```\n\n(the values of literals and builtins are left out because they're trivial)\n\nIf an exception is raised, it'll show which subexpression is responsible, which looks something like this:\n\n```\n12:34:56.78 ................ y = 2\n12:34:56.78 ............ y + 3 = 5\n12:34:56.78 ........ (y + 3) / 0 = !!! ZeroDivisionError!\n12:34:56.78 !!! ZeroDivisionError: division by zero\n```\n\nIf you like this, you'll probably love `@spy`.\n\n## `@spy`\n\nThe `@spy` decorator lets you combine `@snoop` with the powerful debugger [`birdseye`](https://github.com/alexmojaki/birdseye). The code:\n\n```python\nfrom snoop import spy  # not required if you use install()\n\n@spy\ndef foo():\n```\n\nis roughly equivalent to:\n\n```python\nimport snoop\nfrom birdseye import eye\n\n@snoop\n@eye\ndef foo():\n```\n\nTo reduce the dependencies of `snoop`, you'll need to install `birdseye` separately: `pip install birdseye`.\n\nThe only big disadvantage of `@spy` is that it significantly reduces performance, so avoid it for functions with many loop iterations. Otherwise you can basically always use it instead of `@snoop`. Then if the logs don't have the information you need you can open up the birdseye UI to see more detail, without needing to edit or rerun your code. Great for when you're feeling lazy and unsure which tool is best.\n\n`spy` passes its arguments to `snoop`, so e.g. `@spy(depth=2, watch='x.y')` works.\n\n[Read more about `birdseye` in the documentation here.](https://birdseye.readthedocs.io/en/latest/)\n\n('`spy`' is so named because it's a combination of the decorator names '`snoop`' and '`eye`')  \n\n## `install()`\n\nTo make regularly debugging your project more convenient, run this code early on:\n\n```python\nimport snoop\n\nsnoop.install()\n```\n\nThen `snoop`, `pp`, and `spy` will be available in every file without needing to import them.\n\nYou can choose different names by passing keyword arguments `<original name>=<new name>`, e.g:\n\n```python\nsnoop.install(snoop=\"ss\")\n```\n\nwill let you decorate functions with `@ss`.\n\nIf you dislike this feature and would prefer to just import normally, but you want to use `install()` for other configuration, pass `builtins=False`.\n\nAs an alternative, in Python 3.7+ you can use the new `breakpoint` function in place of `snoop` if you set the environment variable `PYTHONBREAKPOINT=snoop.snoop`. \n\n### Disabling\n\nIf you would like to leave `snoop` and other functions in your codebase but disable their effects, pass `enabled=False`. For example, if you're using Django, put `snoop.install(enabled=DEBUG)` in `settings.py` to automatically disable it in production. When disabled, performance impact is minimised and there is no output anywhere.\n\nYou can also dynamically re-enable the functions at any point by calling `snoop.install(enabled=True)` again, e.g. in a special view or signal handler.\n\n### Output configuration\n\n`install` has several keyword arguments for controlling the output of `snoop` and `pp`:\n\n - `out`: determines the output destination. By default this is stderr. You can also pass:\n    - A string or a `Path` object to write to a file at that location. By default this always will append to the file. Pass `overwrite=True` to clear the file initially.\n    - Anything with a `write` method, e.g. `sys.stdout` or a file object.\n    - Any callable with a single string argument, e.g. `logger.info`.\n - `color`: determines whether the output includes escape characters to display colored text in the console. If you see weird characters in your output, your console doesn't support colors, so pass `color=False`.\n    - Code is syntax highlighted using [Pygments](http://pygments.org/), and this argument is passed as the style. You can choose a different color scheme by passing a string naming a style (see [this gallery](https://help.farbox.com/pygments.html)) or a style class. The default style is monokai.   \n    - By default this parameter is set to `out.isatty()`, which is usually true for stdout and stderr but will be false if they are redirected or piped. Pass `True` or a style if you want to force coloring.\n    - To see colors in the PyCharm Run window, edit the Run Configuration and tick \"Emulate terminal in output console\".\n - `prefix`: Pass a string to start all snoop lines with that string so you can grep for them easily.\n - `columns`: This specifies the columns at the start of each output line. You can pass a string with the names of built in columns separated by spaces or commas. These are the available columns:\n    - `time`: The current time. This is the only column by default.\n    - `thread`: The name of the current thread.  \n    - `thread_ident`: The [identifier](https://docs.python.org/3/library/threading.html#threading.Thread.ident) of the current thread, in case thread names are not unique.\n    - `file`: The filename (not the full path) of the current function.\n    - `full_file`: The full path to the file (also shown anyway when the function is called).\n    - `function`: The name of the current function.\n    - `function_qualname`: The qualified name of the current function.\n - `watch_extras` and `replace_watch_extras`: read about these under [Advanced usage](#watch_extras)\n    \n    If you want a custom column, please open an issue to tell me what you're interested in! In the meantime, you can pass a list, where the elements are either strings or callables. The callables should take one argument, which will be an `Event` object. It has attributes `frame`, `event`, and `arg`, as specified in [`sys.settrace()`](https://docs.python.org/3/library/sys.html#sys.settrace), and other attributes which may change.\n\n## API differences from `PySnooper`\n\nIf you're familiar with `PySnooper` and want to use `snoop`, there are a few things you should be aware of that you have to do differently: \n\n- Pass `prefix` and `overwrite` to `install()`, not `snoop()`.\n- The first argument to `pysnooper.snoop`, called `output`, should be passed to `install` with the keyword `out`.\n- Instead of `snoop(thread_info=True)`, write `install(columns='time thread thread_ident')`.\n- Instead of the environment variable `PYSNOOPER_DISABLED`, use `install(enabled=False)`. \n- Instead of using `custom_repr`, see [`watch_extras`](#watch_extras) and [Customising the display of variables](#customising-the-display-of-variables).\n\nIf you're not sure if it's worth using `snoop` instead of `PySnooper`, [read the comparison here](https://github.com/alexmojaki/snoop/wiki/Comparison-to-PySnooper).\n\n## IPython/Jupyter integration\n\nsnoop comes with an IPython extension that you can use in shells or notebooks.\n\nFirst you need to [load the extension](https://ipython.readthedocs.io/en/stable/config/extensions/#using-extensions), using either `%load_ext snoop` in a notebook cell or by adding `'snoop'` to the list `c.InteractiveShellApp.extensions` in your IPython configuration file, e.g. `~/.ipython/profile_default/ipython_config.py`.\n\nThen use the cell magic `%%snoop` at the top of a notebook cell to trace that cell:\n\n![%%snoop example](https://i.imgur.com/d6L7NnH.png)\n\n## Advanced usage\n\n### `watch_extras`\n\n`install` has another parameter called `watch_extras`. You can pass it a list of functions to automatically show extra information about any value: local variables, watched expressions, and exploded items. For example, suppose you wanted to see the type of every variable. You could define a function like this:\n\n```python\ndef type_watch(source, value):\n    return 'type({})'.format(source), type(value)\n```\n\nYou would then write `install(watch_extras=[type_watch])`. The result is output like this:\n\n```\n12:34:56.78    9 |     x = 1\n12:34:56.78 .......... type(x) = <class 'int'>\n12:34:56.78   10 |     y = [x]\n12:34:56.78 .......... y = [1]\n12:34:56.78 .......... type(y) = <class 'list'>\n```\n\nThe functions you write should accept two arguments `source` and `value` - typically these will be the name of a variable and its actual value. They should return a pair representing the 'source' of the returned information (used only for display, it doesn't have to be valid Python) and the actual information. If you don't want to display anything for this particular value, return `None`. Any exceptions raised are caught and silenced.\n\nTwo such functions are already enabled by default: one which shows either the `len()` or the `.shape` property (used by numpy, pandas, tensorflow, etc) of values, and one which shows the `.dtype` property.\n\n`watch_extras` is added to these two default functions so you don't have to specify them again. If you don't want to include them, use `replace_watch_extras` instead to specify the exact list. The original functions can be found here:\n\n```python\nfrom snoop.configuration import len_shape_watch, dtype_watch\n```\n\n### Controlling `watch_explode`\n\n`watch_explode` will automatically guess how to expand the expression passed to it based on its class. You can be more specific by using one of the following classes:\n\n```python\n@snoop(watch=(\n    snoop.Attrs('x'),    # Attributes (specifically from __dict__ or __slots__)\n    snoop.Keys('y'),     # Mapping (e.g. dict) items, based on .keys()\n    snoop.Indices('z'),  # Sequence (e.g. list/tuple) items, based on len()\n))\n```\n\nExclude specific keys/attributes/indices with the `exclude` parameter, e.g. `Attrs('x', exclude=('_foo', '_bar'))`.\n\nAdd a slice after `Indices` to only see the values within that slice, e.g. `Indices('z')[-3:]`.\n\n### Customising the display of variables\n\n(See also [`watch_extras`](#watch_extras))\n\nValues are rendered using the [`cheap_repr`](https://github.com/alexmojaki/cheap_repr) library to improve performance and avoid flooding the console. It has a specially defined repr function for most common classes, including from third party libraries. If a class is missing, please open an issue there. You can also register your own repr for the class. Here's an example:\n\n```python\nfrom cheap_repr import register_repr, cheap_repr\n\n@register_repr(MyClass)\ndef repr_my_class(x, helper):\n    return '{}(items={})'.format(\n        x.__class__.__name__, \n        cheap_repr(x.items, helper.level - 1),\n    )\n```\n\nRead more [here](https://github.com/alexmojaki/cheap_repr#registering-your-own-repr-function).\n\nYou can also increase the verbosity of individual classes (see the documentation), e.g:\n\n```python\nfrom cheap_repr import find_repr_function\n\nfind_repr_function(list).maxparts = 100\n```\n\n### Multiple separate configurations\n\nIf you need more control than the global `install` function, e.g. if you want to write to several different files in one process, you can create a `Config` object, e.g: `config = snoop.Config(out=filename)`. Then `config.snoop`, `config.pp` and `config.spy` will use that configuration rather than the global one.\n\nThe arguments are the same as the arguments of `install()` relating to output configuration and `enabled`.\n\n## Contribute\n\n### Feedback and discussions\n\nI'd love to hear from users! Obviously [open an issue](https://github.com/alexmojaki/snoop/issues/new) if you have one, but also check out [the issues with the 'discussion' label](https://github.com/alexmojaki/snoop/issues?q=is%3Aissue+is%3Aopen+label%3Adiscussion). There's still a lot more work that can be done and I really want people's opinions so that I can do it right.\n\nYou can also [email me](mailto:alex.mojaki@gmail.com) what you like or hate about `snoop`. Just knowing it's being used is helpful.\n\n### Developing\n\n[Pull requests](https://github.com/alexmojaki/snoop/pulls) are always welcome!\n\nPlease, write tests and run them with [Tox](https://tox.readthedocs.io/).\n\nTox installs all dependencies automatically. You only need to install Tox itself:\n\n```console\n$ pip install tox\n```\n\nIf you want to run tests against all target Python versions use [pyenv](\nhttps://github.com/pyenv/pyenv) to install them. Otherwise, you can run\nonly the ones you have already installed on your machine:\n\n```console\n# run only some interpreters\n$ tox -e py27,py36\n```\n\nOr just install project in developer mode with test dependencies:\n\n``` bash\n$ pip install -e path/to/snoop[tests]\n```\n\nAnd run tests:\n\n``` bash\n$ pytest\n```", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "http://github.com/alexmojaki/snoop", "keywords": "", "license": "MIT", "maintainer": "", "maintainer_email": "", "name": "snoop", "package_url": "https://pypi.org/project/snoop/", "platform": "", "project_url": "https://pypi.org/project/snoop/", "project_urls": {"Homepage": "http://github.com/alexmojaki/snoop"}, "release_url": "https://pypi.org/project/snoop/0.2.4/", "requires_dist": null, "requires_python": "", "summary": "Powerful debugging tools for Python", "version": "0.2.4", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>snoop</h1>\n<p><a href=\"https://travis-ci.org/alexmojaki/snoop\" rel=\"nofollow\"><img alt=\"Build Status\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/608caf29734b0f5bd0097750e98ae9388ae8eae2/68747470733a2f2f7472617669732d63692e6f72672f616c65786d6f6a616b692f736e6f6f702e7376673f6272616e63683d6d6173746572\"></a> <a href=\"https://pypi.python.org/pypi/snoop\" rel=\"nofollow\"><img alt=\"Supports Python versions 2.7 and 3.4+, including PyPy\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/08cb1073d9f3bab9c0f6de097e55c12a23b4ead6/68747470733a2f2f696d672e736869656c64732e696f2f707970692f707976657273696f6e732f736e6f6f702e737667\"></a></p>\n<p>snoop is a powerful set of Python debugging tools. It's primarily meant to be a <a href=\"https://github.com/alexmojaki/snoop/wiki/Comparison-to-PySnooper\" rel=\"nofollow\">more featureful and refined</a> version of <a href=\"https://github.com/cool-RR/pysnooper\" rel=\"nofollow\">PySnooper</a>. It also includes a more accurate version of <a href=\"https://github.com/gruns/icecream\" rel=\"nofollow\">icecream</a> and some other nifty stuff.</p>\n<p>You're trying to figure out why your Python code isn't doing what you think it should be doing. You'd love to use a full-fledged debugger with breakpoints and watches, but you can't be bothered to set one up right now.</p>\n<p>You want to know which lines are running and which aren't, and what the values of the local variables are.</p>\n<p>Most people would use <code>print</code> lines, in strategic locations, some of them showing the values of variables.</p>\n<p><strong>snoop</strong> lets you do the same, except instead of carefully crafting the right <code>print</code> lines, you just add one decorator line to the function you're interested in. You'll get a play-by-play log of your function, including which lines ran and when, and exactly when local variables were changed.</p>\n<p>Installation is as simple as <code>pip install snoop</code>.</p>\n<ul>\n<li><a href=\"#basic-snoop-usage\" rel=\"nofollow\">Basic snoop usage</a>\n<ul>\n<li><a href=\"#common-arguments\" rel=\"nofollow\">Common arguments</a></li>\n</ul>\n</li>\n<li><a href=\"#pp---awesome-print-debugging\" rel=\"nofollow\">pp - awesome print debugging</a>\n<ul>\n<li><a href=\"#ppdeep-for-tracing-subexpressions\" rel=\"nofollow\">pp.deep for tracing subexpressions</a></li>\n</ul>\n</li>\n<li><a href=\"#spy\" rel=\"nofollow\">@spy</a></li>\n<li><a href=\"#install\" rel=\"nofollow\">install()</a>\n<ul>\n<li><a href=\"#disabling\" rel=\"nofollow\">Disabling</a></li>\n<li><a href=\"#output-configuration\" rel=\"nofollow\">Output configuration</a></li>\n</ul>\n</li>\n<li><a href=\"#api-differences-from-pysnooper\" rel=\"nofollow\">API differences from PySnooper</a></li>\n<li><a href=\"#ipythonjupyter-integration\" rel=\"nofollow\">IPython/Jupyter integration</a></li>\n<li><a href=\"#advanced-usage\" rel=\"nofollow\">Advanced usage</a>\n<ul>\n<li><a href=\"#watch_extras\" rel=\"nofollow\">watch_extras</a></li>\n<li><a href=\"#controlling-watch_explode\" rel=\"nofollow\">Controlling watch_explode</a></li>\n<li><a href=\"#customising-the-display-of-variables\" rel=\"nofollow\">Customising the display of variables</a></li>\n<li><a href=\"#multiple-separate-configurations\" rel=\"nofollow\">Multiple separate configurations</a></li>\n</ul>\n</li>\n<li><a href=\"#contribute\" rel=\"nofollow\">Contribute</a>\n<ul>\n<li><a href=\"#feedback-and-discussions\" rel=\"nofollow\">Feedback and discussions</a></li>\n<li><a href=\"#developing\" rel=\"nofollow\">Developing</a></li>\n</ul>\n</li>\n</ul>\n<h2>Basic snoop usage</h2>\n<p>We're writing a function that converts a number to binary, by returning a list of bits. Let's snoop on it by adding the <code>@snoop</code> decorator:</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">snoop</span>\n\n<span class=\"nd\">@snoop</span>\n<span class=\"k\">def</span> <span class=\"nf\">number_to_bits</span><span class=\"p\">(</span><span class=\"n\">number</span><span class=\"p\">):</span>\n    <span class=\"k\">if</span> <span class=\"n\">number</span><span class=\"p\">:</span>\n        <span class=\"n\">bits</span> <span class=\"o\">=</span> <span class=\"p\">[]</span>\n        <span class=\"k\">while</span> <span class=\"n\">number</span><span class=\"p\">:</span>\n            <span class=\"n\">number</span><span class=\"p\">,</span> <span class=\"n\">remainder</span> <span class=\"o\">=</span> <span class=\"nb\">divmod</span><span class=\"p\">(</span><span class=\"n\">number</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">)</span>\n            <span class=\"n\">bits</span><span class=\"o\">.</span><span class=\"n\">insert</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">remainder</span><span class=\"p\">)</span>\n        <span class=\"k\">return</span> <span class=\"n\">bits</span>\n    <span class=\"k\">else</span><span class=\"p\">:</span>\n        <span class=\"k\">return</span> <span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span>\n\n<span class=\"n\">number_to_bits</span><span class=\"p\">(</span><span class=\"mi\">6</span><span class=\"p\">)</span>\n</pre>\n<p>Note how easy it is: Just <code>import snoop</code> and <code>@snoop</code>. If you don't like the magical import, <code>snoop.snoop</code> and <code>from snoop import snoop</code> still work too. Or if you don't want to import in your project at all, just call <a href=\"#install\" rel=\"nofollow\"><code>install()</code></a> somewhere once.</p>\n<p>The output to stderr looks like this:</p>\n<p><img alt=\"number_to_bits output\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/54439b34304d99efacbf3c676069c0ad6de9e947/68747470733a2f2f692e696d6775722e636f6d2f336f7a7157616d2e706e67\"></p>\n<p>Let's try a more complex example. We're writing a memoizing decorator: it stores function arguments and return values in a cache to avoid recomputation:</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">snoop</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">cache</span><span class=\"p\">(</span><span class=\"n\">func</span><span class=\"p\">):</span>\n    <span class=\"n\">d</span> <span class=\"o\">=</span> <span class=\"p\">{}</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">wrapper</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">args</span><span class=\"p\">):</span>\n        <span class=\"k\">try</span><span class=\"p\">:</span>\n            <span class=\"k\">return</span> <span class=\"n\">d</span><span class=\"p\">[</span><span class=\"n\">args</span><span class=\"p\">]</span>\n        <span class=\"k\">except</span> <span class=\"ne\">KeyError</span><span class=\"p\">:</span>\n            <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">d</span><span class=\"p\">[</span><span class=\"n\">args</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">func</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">args</span><span class=\"p\">)</span>\n            <span class=\"k\">return</span> <span class=\"n\">result</span>\n\n    <span class=\"k\">return</span> <span class=\"n\">wrapper</span>\n\n<span class=\"nd\">@snoop</span><span class=\"p\">(</span><span class=\"n\">depth</span><span class=\"o\">=</span><span class=\"mi\">2</span><span class=\"p\">)</span>\n<span class=\"nd\">@cache</span>\n<span class=\"k\">def</span> <span class=\"nf\">add</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">y</span><span class=\"p\">):</span>\n    <span class=\"k\">return</span> <span class=\"n\">x</span> <span class=\"o\">+</span> <span class=\"n\">y</span>\n\n<span class=\"n\">add</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">)</span>\n<span class=\"n\">add</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">)</span>\n</pre>\n<p>Here we specify <code>depth=2</code> to mean we should also step one level down into inner function calls. We then call the function twice to see the caching in action. Here's the output:</p>\n<p><img alt=\"cache output\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/fd2b2f7b7b9d39416e244d462b742db0c033e0e0/68747470733a2f2f692e696d6775722e636f6d2f456e75376b30682e706e67\"></p>\n<p>At a glance we can see that in the first call the cache lookup failed with a <code>KeyError</code> so the original <code>add</code> function was called, while in the second call the previously cached result was returned immediately.</p>\n<p>If you don't want to trace an entire function, you can wrap the relevant part in a <code>with</code> block:</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">snoop</span>\n<span class=\"kn\">import</span> <span class=\"nn\">random</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">foo</span><span class=\"p\">():</span>\n    <span class=\"n\">lst</span> <span class=\"o\">=</span> <span class=\"p\">[]</span>\n    <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"mi\">10</span><span class=\"p\">):</span>\n        <span class=\"n\">lst</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"n\">random</span><span class=\"o\">.</span><span class=\"n\">randrange</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1000</span><span class=\"p\">))</span>\n\n    <span class=\"k\">with</span> <span class=\"n\">snoop</span><span class=\"p\">:</span>\n        <span class=\"n\">lower</span> <span class=\"o\">=</span> <span class=\"nb\">min</span><span class=\"p\">(</span><span class=\"n\">lst</span><span class=\"p\">)</span>\n        <span class=\"n\">upper</span> <span class=\"o\">=</span> <span class=\"nb\">max</span><span class=\"p\">(</span><span class=\"n\">lst</span><span class=\"p\">)</span>\n        <span class=\"n\">mid</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">lower</span> <span class=\"o\">+</span> <span class=\"n\">upper</span><span class=\"p\">)</span> <span class=\"o\">/</span> <span class=\"mi\">2</span>\n\n    <span class=\"k\">return</span> <span class=\"n\">lower</span><span class=\"p\">,</span> <span class=\"n\">mid</span><span class=\"p\">,</span> <span class=\"n\">upper</span>\n\n<span class=\"n\">foo</span><span class=\"p\">()</span>\n</pre>\n<p>which outputs something like:</p>\n<p><img alt=\"foo output\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/bce1fe3b8144a727f58e299362e03c8d1c8d87ff/68747470733a2f2f692e696d6775722e636f6d2f614256584653512e706e67\"></p>\n<h3>Common arguments</h3>\n<ul>\n<li><code>depth</code>: as seen above, snoops deeper calls made by the function/block you trace. The default is 1, meaning no inner calls, so pass something bigger.</li>\n<li><code>watch</code>: show values of arbitrary expressions by specifying them as a string, e.g:</li>\n</ul>\n<pre><span class=\"nd\">@snoop</span><span class=\"p\">(</span><span class=\"n\">watch</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"s1\">'foo.bar'</span><span class=\"p\">,</span> <span class=\"s1\">'self.x[\"whatever\"]'</span><span class=\"p\">))</span>\n</pre>\n<ul>\n<li><code>watch_explode</code>: Expand variables or expressions to see all their attributes or items of lists/dictionaries:</li>\n</ul>\n<pre><span class=\"nd\">@snoop</span><span class=\"p\">(</span><span class=\"n\">watch_explode</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"s1\">'foo'</span><span class=\"p\">,</span> <span class=\"s1\">'self'</span><span class=\"p\">])</span>\n</pre>\n<p>This will output lines like:</p>\n<pre><code>........ foo[2] = 'whatever'\n........ self.baz = 8\n</code></pre>\n<p>See <a href=\"#controlling-watch_explode\" rel=\"nofollow\">Controlling <code>watch_explode</code></a> for more advanced usage of this argument.</p>\n<p>See <a href=\"#watch_extras\" rel=\"nofollow\"><code>watch_extras</code></a> to show additional information about any value (local variable, watched expression, or exploded item) automatically.</p>\n<h2><code>pp</code> - awesome print debugging</h2>\n<p>While <code>snoop</code> is meant to save you from writing <code>print</code> calls, sometimes that's still exactly the kind of thing you need. <code>pp</code> aims to be the best possible version of this. It can be used alone or in combination with <code>snoop</code>.</p>\n<p><code>pp(x)</code> will output <code>x = &lt;pretty printed value of x&gt;</code>, i.e. it will show the source code of its argument(s) so you know what's being printed, and format the value with <code>pprint.pformat</code> so that you can easily see the layout of complicated data structures.</p>\n<p><code>pp</code> will return its argument directly so you can easily insert it in code without rearranging. If given multiple arguments, it will return them as a tuple, so you can replace <code>foo(x, y)</code> with <code>foo(*pp(x, y))</code> to leave the behaviour of the code intact.</p>\n<p>Here's an example:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">snoop</span> <span class=\"kn\">import</span> <span class=\"n\">pp</span>\n<span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>\n<span class=\"n\">y</span> <span class=\"o\">=</span> <span class=\"mi\">2</span>\n<span class=\"n\">pp</span><span class=\"p\">(</span><span class=\"n\">pp</span><span class=\"p\">(</span><span class=\"n\">x</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"o\">+</span> <span class=\"nb\">max</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">pp</span><span class=\"p\">(</span><span class=\"n\">y</span> <span class=\"o\">+</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"n\">y</span> <span class=\"o\">+</span> <span class=\"mi\">3</span><span class=\"p\">)))</span>\n</pre>\n<p>Output:</p>\n<pre><code>12:34:56.78 LOG:\n12:34:56.78 .... x + 1 = 2\n12:34:56.78 LOG:\n12:34:56.78 .... y + 2 = 4\n12:34:56.78 .... y + 3 = 5\n12:34:56.78 LOG:\n12:34:56.78 .... pp(x + 1) + max(*pp(y + 2, y + 3)) = 7\n</code></pre>\n<p>If you've already got <code>import snoop</code> you can also use <code>snoop.pp</code>. But ideally, you would use <a href=\"#install\" rel=\"nofollow\"><code>install()</code></a> to avoid importing at all.</p>\n<p>There are a few situations where <code>pp</code> can't find the source code of its arguments, in which case it will show a placeholder instead:</p>\n<ul>\n<li>When the source file cannot be found, usually because it doesn't exist, e.g. if you're in a Python shell. The source is fetched from <code>linecache</code>.</li>\n<li>In Python 3.4 and PyPy.</li>\n<li>In the presence of magic which transforms source code under the hood, such as <code>pytest</code> or <code>birdseye</code> (and thus the <a href=\"#spy\" rel=\"nofollow\"><code>@spy</code></a> decorator).</li>\n<li>When the source file has been modified before the first call to <code>pp</code> or <code>snoop</code>.</li>\n</ul>\n<p>Under the hood, <code>pp</code> uses the library <a href=\"https://github.com/alexmojaki/executing\" rel=\"nofollow\"><code>executing</code></a> to locate the AST node of the function call - check it out if you'd like to write some cool utilities of your own.</p>\n<p><code>pp</code> is inspired by <a href=\"https://github.com/gruns/icecream\" rel=\"nofollow\">icecream</a> and offers the same basic API for printing, but <a href=\"https://github.com/gruns/icecream/pull/33\" rel=\"nofollow\">icecream's algorithm is less accurate than <code>executing</code></a>, and <code>pp</code> integrates seamlessly with <code>snoop</code>. It also offers <code>pp.deep</code>, which is unique.</p>\n<p>'<code>pp</code>' stands for 'pretty-print' and <em>totally definitely absolutely has no other meaning</em>. It's also very easy and quick to type.</p>\n<h3><code>pp.deep</code> for tracing subexpressions</h3>\n<p>If you have <code>pp(&lt;complicated expression&gt;)</code> and you want to see what happens inside that expression and not just the final value, replace it wth <code>pp.deep(lambda: &lt;complicated expression&gt;)</code>. This will log every intermediate subexpression, in the correct order, with no additional side effects, and return the final value. Repeating the previous example:</p>\n<pre><span class=\"n\">pp</span><span class=\"o\">.</span><span class=\"n\">deep</span><span class=\"p\">(</span><span class=\"k\">lambda</span><span class=\"p\">:</span> <span class=\"n\">x</span> <span class=\"o\">+</span> <span class=\"mi\">1</span> <span class=\"o\">+</span> <span class=\"nb\">max</span><span class=\"p\">(</span><span class=\"n\">y</span> <span class=\"o\">+</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"n\">y</span> <span class=\"o\">+</span> <span class=\"mi\">3</span><span class=\"p\">))</span>\n</pre>\n<p>Output:</p>\n<pre><code>12:34:56.78 LOG:\n12:34:56.78 ............ x = 1\n12:34:56.78 ........ x + 1 = 2\n12:34:56.78 ................ y = 2\n12:34:56.78 ............ y + 2 = 4\n12:34:56.78 ................ y = 2\n12:34:56.78 ............ y + 3 = 5\n12:34:56.78 ........ max(y + 2, y + 3) = 5\n12:34:56.78 .... x + 1 + max(y + 2, y + 3) = 7\n</code></pre>\n<p>(the values of literals and builtins are left out because they're trivial)</p>\n<p>If an exception is raised, it'll show which subexpression is responsible, which looks something like this:</p>\n<pre><code>12:34:56.78 ................ y = 2\n12:34:56.78 ............ y + 3 = 5\n12:34:56.78 ........ (y + 3) / 0 = !!! ZeroDivisionError!\n12:34:56.78 !!! ZeroDivisionError: division by zero\n</code></pre>\n<p>If you like this, you'll probably love <code>@spy</code>.</p>\n<h2><code>@spy</code></h2>\n<p>The <code>@spy</code> decorator lets you combine <code>@snoop</code> with the powerful debugger <a href=\"https://github.com/alexmojaki/birdseye\" rel=\"nofollow\"><code>birdseye</code></a>. The code:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">snoop</span> <span class=\"kn\">import</span> <span class=\"n\">spy</span>  <span class=\"c1\"># not required if you use install()</span>\n\n<span class=\"nd\">@spy</span>\n<span class=\"k\">def</span> <span class=\"nf\">foo</span><span class=\"p\">():</span>\n</pre>\n<p>is roughly equivalent to:</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">snoop</span>\n<span class=\"kn\">from</span> <span class=\"nn\">birdseye</span> <span class=\"kn\">import</span> <span class=\"n\">eye</span>\n\n<span class=\"nd\">@snoop</span>\n<span class=\"nd\">@eye</span>\n<span class=\"k\">def</span> <span class=\"nf\">foo</span><span class=\"p\">():</span>\n</pre>\n<p>To reduce the dependencies of <code>snoop</code>, you'll need to install <code>birdseye</code> separately: <code>pip install birdseye</code>.</p>\n<p>The only big disadvantage of <code>@spy</code> is that it significantly reduces performance, so avoid it for functions with many loop iterations. Otherwise you can basically always use it instead of <code>@snoop</code>. Then if the logs don't have the information you need you can open up the birdseye UI to see more detail, without needing to edit or rerun your code. Great for when you're feeling lazy and unsure which tool is best.</p>\n<p><code>spy</code> passes its arguments to <code>snoop</code>, so e.g. <code>@spy(depth=2, watch='x.y')</code> works.</p>\n<p><a href=\"https://birdseye.readthedocs.io/en/latest/\" rel=\"nofollow\">Read more about <code>birdseye</code> in the documentation here.</a></p>\n<p>('<code>spy</code>' is so named because it's a combination of the decorator names '<code>snoop</code>' and '<code>eye</code>')</p>\n<h2><code>install()</code></h2>\n<p>To make regularly debugging your project more convenient, run this code early on:</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">snoop</span>\n\n<span class=\"n\">snoop</span><span class=\"o\">.</span><span class=\"n\">install</span><span class=\"p\">()</span>\n</pre>\n<p>Then <code>snoop</code>, <code>pp</code>, and <code>spy</code> will be available in every file without needing to import them.</p>\n<p>You can choose different names by passing keyword arguments <code>&lt;original name&gt;=&lt;new name&gt;</code>, e.g:</p>\n<pre><span class=\"n\">snoop</span><span class=\"o\">.</span><span class=\"n\">install</span><span class=\"p\">(</span><span class=\"n\">snoop</span><span class=\"o\">=</span><span class=\"s2\">\"ss\"</span><span class=\"p\">)</span>\n</pre>\n<p>will let you decorate functions with <code>@ss</code>.</p>\n<p>If you dislike this feature and would prefer to just import normally, but you want to use <code>install()</code> for other configuration, pass <code>builtins=False</code>.</p>\n<p>As an alternative, in Python 3.7+ you can use the new <code>breakpoint</code> function in place of <code>snoop</code> if you set the environment variable <code>PYTHONBREAKPOINT=snoop.snoop</code>.</p>\n<h3>Disabling</h3>\n<p>If you would like to leave <code>snoop</code> and other functions in your codebase but disable their effects, pass <code>enabled=False</code>. For example, if you're using Django, put <code>snoop.install(enabled=DEBUG)</code> in <code>settings.py</code> to automatically disable it in production. When disabled, performance impact is minimised and there is no output anywhere.</p>\n<p>You can also dynamically re-enable the functions at any point by calling <code>snoop.install(enabled=True)</code> again, e.g. in a special view or signal handler.</p>\n<h3>Output configuration</h3>\n<p><code>install</code> has several keyword arguments for controlling the output of <code>snoop</code> and <code>pp</code>:</p>\n<ul>\n<li>\n<p><code>out</code>: determines the output destination. By default this is stderr. You can also pass:</p>\n<ul>\n<li>A string or a <code>Path</code> object to write to a file at that location. By default this always will append to the file. Pass <code>overwrite=True</code> to clear the file initially.</li>\n<li>Anything with a <code>write</code> method, e.g. <code>sys.stdout</code> or a file object.</li>\n<li>Any callable with a single string argument, e.g. <code>logger.info</code>.</li>\n</ul>\n</li>\n<li>\n<p><code>color</code>: determines whether the output includes escape characters to display colored text in the console. If you see weird characters in your output, your console doesn't support colors, so pass <code>color=False</code>.</p>\n<ul>\n<li>Code is syntax highlighted using <a href=\"http://pygments.org/\" rel=\"nofollow\">Pygments</a>, and this argument is passed as the style. You can choose a different color scheme by passing a string naming a style (see <a href=\"https://help.farbox.com/pygments.html\" rel=\"nofollow\">this gallery</a>) or a style class. The default style is monokai.</li>\n<li>By default this parameter is set to <code>out.isatty()</code>, which is usually true for stdout and stderr but will be false if they are redirected or piped. Pass <code>True</code> or a style if you want to force coloring.</li>\n<li>To see colors in the PyCharm Run window, edit the Run Configuration and tick \"Emulate terminal in output console\".</li>\n</ul>\n</li>\n<li>\n<p><code>prefix</code>: Pass a string to start all snoop lines with that string so you can grep for them easily.</p>\n</li>\n<li>\n<p><code>columns</code>: This specifies the columns at the start of each output line. You can pass a string with the names of built in columns separated by spaces or commas. These are the available columns:</p>\n<ul>\n<li><code>time</code>: The current time. This is the only column by default.</li>\n<li><code>thread</code>: The name of the current thread.</li>\n<li><code>thread_ident</code>: The <a href=\"https://docs.python.org/3/library/threading.html#threading.Thread.ident\" rel=\"nofollow\">identifier</a> of the current thread, in case thread names are not unique.</li>\n<li><code>file</code>: The filename (not the full path) of the current function.</li>\n<li><code>full_file</code>: The full path to the file (also shown anyway when the function is called).</li>\n<li><code>function</code>: The name of the current function.</li>\n<li><code>function_qualname</code>: The qualified name of the current function.</li>\n</ul>\n</li>\n<li>\n<p><code>watch_extras</code> and <code>replace_watch_extras</code>: read about these under <a href=\"#watch_extras\" rel=\"nofollow\">Advanced usage</a></p>\n<p>If you want a custom column, please open an issue to tell me what you're interested in! In the meantime, you can pass a list, where the elements are either strings or callables. The callables should take one argument, which will be an <code>Event</code> object. It has attributes <code>frame</code>, <code>event</code>, and <code>arg</code>, as specified in <a href=\"https://docs.python.org/3/library/sys.html#sys.settrace\" rel=\"nofollow\"><code>sys.settrace()</code></a>, and other attributes which may change.</p>\n</li>\n</ul>\n<h2>API differences from <code>PySnooper</code></h2>\n<p>If you're familiar with <code>PySnooper</code> and want to use <code>snoop</code>, there are a few things you should be aware of that you have to do differently:</p>\n<ul>\n<li>Pass <code>prefix</code> and <code>overwrite</code> to <code>install()</code>, not <code>snoop()</code>.</li>\n<li>The first argument to <code>pysnooper.snoop</code>, called <code>output</code>, should be passed to <code>install</code> with the keyword <code>out</code>.</li>\n<li>Instead of <code>snoop(thread_info=True)</code>, write <code>install(columns='time thread thread_ident')</code>.</li>\n<li>Instead of the environment variable <code>PYSNOOPER_DISABLED</code>, use <code>install(enabled=False)</code>.</li>\n<li>Instead of using <code>custom_repr</code>, see <a href=\"#watch_extras\" rel=\"nofollow\"><code>watch_extras</code></a> and <a href=\"#customising-the-display-of-variables\" rel=\"nofollow\">Customising the display of variables</a>.</li>\n</ul>\n<p>If you're not sure if it's worth using <code>snoop</code> instead of <code>PySnooper</code>, <a href=\"https://github.com/alexmojaki/snoop/wiki/Comparison-to-PySnooper\" rel=\"nofollow\">read the comparison here</a>.</p>\n<h2>IPython/Jupyter integration</h2>\n<p>snoop comes with an IPython extension that you can use in shells or notebooks.</p>\n<p>First you need to <a href=\"https://ipython.readthedocs.io/en/stable/config/extensions/#using-extensions\" rel=\"nofollow\">load the extension</a>, using either <code>%load_ext snoop</code> in a notebook cell or by adding <code>'snoop'</code> to the list <code>c.InteractiveShellApp.extensions</code> in your IPython configuration file, e.g. <code>~/.ipython/profile_default/ipython_config.py</code>.</p>\n<p>Then use the cell magic <code>%%snoop</code> at the top of a notebook cell to trace that cell:</p>\n<p><img alt=\"%%snoop example\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/98ed48e9755f88c30764835c793ab83acb475baf/68747470733a2f2f692e696d6775722e636f6d2f64364c374e6e482e706e67\"></p>\n<h2>Advanced usage</h2>\n<h3><code>watch_extras</code></h3>\n<p><code>install</code> has another parameter called <code>watch_extras</code>. You can pass it a list of functions to automatically show extra information about any value: local variables, watched expressions, and exploded items. For example, suppose you wanted to see the type of every variable. You could define a function like this:</p>\n<pre><span class=\"k\">def</span> <span class=\"nf\">type_watch</span><span class=\"p\">(</span><span class=\"n\">source</span><span class=\"p\">,</span> <span class=\"n\">value</span><span class=\"p\">):</span>\n    <span class=\"k\">return</span> <span class=\"s1\">'type(</span><span class=\"si\">{}</span><span class=\"s1\">)'</span><span class=\"o\">.</span><span class=\"n\">format</span><span class=\"p\">(</span><span class=\"n\">source</span><span class=\"p\">),</span> <span class=\"nb\">type</span><span class=\"p\">(</span><span class=\"n\">value</span><span class=\"p\">)</span>\n</pre>\n<p>You would then write <code>install(watch_extras=[type_watch])</code>. The result is output like this:</p>\n<pre><code>12:34:56.78    9 |     x = 1\n12:34:56.78 .......... type(x) = &lt;class 'int'&gt;\n12:34:56.78   10 |     y = [x]\n12:34:56.78 .......... y = [1]\n12:34:56.78 .......... type(y) = &lt;class 'list'&gt;\n</code></pre>\n<p>The functions you write should accept two arguments <code>source</code> and <code>value</code> - typically these will be the name of a variable and its actual value. They should return a pair representing the 'source' of the returned information (used only for display, it doesn't have to be valid Python) and the actual information. If you don't want to display anything for this particular value, return <code>None</code>. Any exceptions raised are caught and silenced.</p>\n<p>Two such functions are already enabled by default: one which shows either the <code>len()</code> or the <code>.shape</code> property (used by numpy, pandas, tensorflow, etc) of values, and one which shows the <code>.dtype</code> property.</p>\n<p><code>watch_extras</code> is added to these two default functions so you don't have to specify them again. If you don't want to include them, use <code>replace_watch_extras</code> instead to specify the exact list. The original functions can be found here:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">snoop.configuration</span> <span class=\"kn\">import</span> <span class=\"n\">len_shape_watch</span><span class=\"p\">,</span> <span class=\"n\">dtype_watch</span>\n</pre>\n<h3>Controlling <code>watch_explode</code></h3>\n<p><code>watch_explode</code> will automatically guess how to expand the expression passed to it based on its class. You can be more specific by using one of the following classes:</p>\n<pre><span class=\"nd\">@snoop</span><span class=\"p\">(</span><span class=\"n\">watch</span><span class=\"o\">=</span><span class=\"p\">(</span>\n    <span class=\"n\">snoop</span><span class=\"o\">.</span><span class=\"n\">Attrs</span><span class=\"p\">(</span><span class=\"s1\">'x'</span><span class=\"p\">),</span>    <span class=\"c1\"># Attributes (specifically from __dict__ or __slots__)</span>\n    <span class=\"n\">snoop</span><span class=\"o\">.</span><span class=\"n\">Keys</span><span class=\"p\">(</span><span class=\"s1\">'y'</span><span class=\"p\">),</span>     <span class=\"c1\"># Mapping (e.g. dict) items, based on .keys()</span>\n    <span class=\"n\">snoop</span><span class=\"o\">.</span><span class=\"n\">Indices</span><span class=\"p\">(</span><span class=\"s1\">'z'</span><span class=\"p\">),</span>  <span class=\"c1\"># Sequence (e.g. list/tuple) items, based on len()</span>\n<span class=\"p\">))</span>\n</pre>\n<p>Exclude specific keys/attributes/indices with the <code>exclude</code> parameter, e.g. <code>Attrs('x', exclude=('_foo', '_bar'))</code>.</p>\n<p>Add a slice after <code>Indices</code> to only see the values within that slice, e.g. <code>Indices('z')[-3:]</code>.</p>\n<h3>Customising the display of variables</h3>\n<p>(See also <a href=\"#watch_extras\" rel=\"nofollow\"><code>watch_extras</code></a>)</p>\n<p>Values are rendered using the <a href=\"https://github.com/alexmojaki/cheap_repr\" rel=\"nofollow\"><code>cheap_repr</code></a> library to improve performance and avoid flooding the console. It has a specially defined repr function for most common classes, including from third party libraries. If a class is missing, please open an issue there. You can also register your own repr for the class. Here's an example:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">cheap_repr</span> <span class=\"kn\">import</span> <span class=\"n\">register_repr</span><span class=\"p\">,</span> <span class=\"n\">cheap_repr</span>\n\n<span class=\"nd\">@register_repr</span><span class=\"p\">(</span><span class=\"n\">MyClass</span><span class=\"p\">)</span>\n<span class=\"k\">def</span> <span class=\"nf\">repr_my_class</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">helper</span><span class=\"p\">):</span>\n    <span class=\"k\">return</span> <span class=\"s1\">'</span><span class=\"si\">{}</span><span class=\"s1\">(items=</span><span class=\"si\">{}</span><span class=\"s1\">)'</span><span class=\"o\">.</span><span class=\"n\">format</span><span class=\"p\">(</span>\n        <span class=\"n\">x</span><span class=\"o\">.</span><span class=\"vm\">__class__</span><span class=\"o\">.</span><span class=\"vm\">__name__</span><span class=\"p\">,</span> \n        <span class=\"n\">cheap_repr</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"o\">.</span><span class=\"n\">items</span><span class=\"p\">,</span> <span class=\"n\">helper</span><span class=\"o\">.</span><span class=\"n\">level</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">),</span>\n    <span class=\"p\">)</span>\n</pre>\n<p>Read more <a href=\"https://github.com/alexmojaki/cheap_repr#registering-your-own-repr-function\" rel=\"nofollow\">here</a>.</p>\n<p>You can also increase the verbosity of individual classes (see the documentation), e.g:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">cheap_repr</span> <span class=\"kn\">import</span> <span class=\"n\">find_repr_function</span>\n\n<span class=\"n\">find_repr_function</span><span class=\"p\">(</span><span class=\"nb\">list</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">maxparts</span> <span class=\"o\">=</span> <span class=\"mi\">100</span>\n</pre>\n<h3>Multiple separate configurations</h3>\n<p>If you need more control than the global <code>install</code> function, e.g. if you want to write to several different files in one process, you can create a <code>Config</code> object, e.g: <code>config = snoop.Config(out=filename)</code>. Then <code>config.snoop</code>, <code>config.pp</code> and <code>config.spy</code> will use that configuration rather than the global one.</p>\n<p>The arguments are the same as the arguments of <code>install()</code> relating to output configuration and <code>enabled</code>.</p>\n<h2>Contribute</h2>\n<h3>Feedback and discussions</h3>\n<p>I'd love to hear from users! Obviously <a href=\"https://github.com/alexmojaki/snoop/issues/new\" rel=\"nofollow\">open an issue</a> if you have one, but also check out <a href=\"https://github.com/alexmojaki/snoop/issues?q=is%3Aissue+is%3Aopen+label%3Adiscussion\" rel=\"nofollow\">the issues with the 'discussion' label</a>. There's still a lot more work that can be done and I really want people's opinions so that I can do it right.</p>\n<p>You can also <a href=\"mailto:alex.mojaki@gmail.com\">email me</a> what you like or hate about <code>snoop</code>. Just knowing it's being used is helpful.</p>\n<h3>Developing</h3>\n<p><a href=\"https://github.com/alexmojaki/snoop/pulls\" rel=\"nofollow\">Pull requests</a> are always welcome!</p>\n<p>Please, write tests and run them with <a href=\"https://tox.readthedocs.io/\" rel=\"nofollow\">Tox</a>.</p>\n<p>Tox installs all dependencies automatically. You only need to install Tox itself:</p>\n<pre><span class=\"gp\">$</span> pip install tox\n</pre>\n<p>If you want to run tests against all target Python versions use <a href=\"https://github.com/pyenv/pyenv\" rel=\"nofollow\">pyenv</a> to install them. Otherwise, you can run\nonly the ones you have already installed on your machine:</p>\n<pre><span class=\"gp\">#</span> run only some interpreters\n<span class=\"gp\">$</span> tox -e py27,py36\n</pre>\n<p>Or just install project in developer mode with test dependencies:</p>\n<pre>$ pip install -e path/to/snoop<span class=\"o\">[</span>tests<span class=\"o\">]</span>\n</pre>\n<p>And run tests:</p>\n<pre>$ pytest\n</pre>\n\n          </div>"}, "last_serial": 6473481, "releases": {"0.1.0": [{"comment_text": "", "digests": {"md5": "c5630cab16af8641f0002967eb29e0c0", "sha256": "7ef033920637a73debb93c85c39b0e1353fcbd694d387712b7f26ffe6760da1d"}, "downloads": -1, "filename": "snoop-0.1.0.tar.gz", "has_sig": false, "md5_digest": "c5630cab16af8641f0002967eb29e0c0", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 17569, "upload_time": "2019-05-29T17:42:31", "upload_time_iso_8601": "2019-05-29T17:42:31.281654Z", "url": "https://files.pythonhosted.org/packages/cd/9a/298ccb6d5bc5dbe531875e039518e4f525251d4535dfeb6f2112f7eb8eff/snoop-0.1.0.tar.gz", "yanked": false}], "0.1.1": [{"comment_text": "", "digests": {"md5": "2f028a0328324377a9792f90e4e59ecf", "sha256": "1a1a6863b698832c530d8ec5db5f960547b8128162675bcfd3d20839342a0d17"}, "downloads": -1, "filename": "snoop-0.1.1.tar.gz", "has_sig": false, "md5_digest": "2f028a0328324377a9792f90e4e59ecf", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 19687, "upload_time": "2019-06-19T20:22:01", "upload_time_iso_8601": "2019-06-19T20:22:01.950790Z", "url": "https://files.pythonhosted.org/packages/39/e3/334dbdfca260e2a304bbe744f94367748c4f562b5df07fdf76abce3ed5ee/snoop-0.1.1.tar.gz", "yanked": false}], "0.1.2": [{"comment_text": "", "digests": {"md5": "62e9af697686b93a54aa636b2348eb50", "sha256": "95c58f9a6c1f8bc9e26f373d96ffce119f270b1040237e8b5f55e8c7b0f10ba8"}, "downloads": -1, "filename": "snoop-0.1.2.tar.gz", "has_sig": false, "md5_digest": "62e9af697686b93a54aa636b2348eb50", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 30133, "upload_time": "2019-07-03T12:59:59", "upload_time_iso_8601": "2019-07-03T12:59:59.529476Z", "url": "https://files.pythonhosted.org/packages/51/b3/709930d3a3f2d2cbc6670b7967bd1beca049e579eb4c6960d3b6c15e0428/snoop-0.1.2.tar.gz", "yanked": false}], "0.2.0": [{"comment_text": "", "digests": {"md5": "80bca9a902a98552bffb47069a925fd1", "sha256": "96bedb37bbc71695ffa6cc8a5cb3978d3f57c64b7f5e78d7d60027a6b979a394"}, "downloads": -1, "filename": "snoop-0.2.0.tar.gz", "has_sig": false, "md5_digest": "80bca9a902a98552bffb47069a925fd1", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 31475, "upload_time": "2019-07-10T19:15:22", "upload_time_iso_8601": "2019-07-10T19:15:22.217967Z", "url": "https://files.pythonhosted.org/packages/56/dd/afc17ddcbca02ce1afc573d2f837ab01c02c335d82e90515776b90d409a3/snoop-0.2.0.tar.gz", "yanked": false}], "0.2.1": [{"comment_text": "", "digests": {"md5": "9dfdc25a8f9ced7d9a9c1c237fad5ad1", "sha256": "2a55c9b65dfcab471b3dea56efe634ed2d25df80a8109e86587afa9fb56aab9f"}, "downloads": -1, "filename": "snoop-0.2.1.tar.gz", "has_sig": false, "md5_digest": "9dfdc25a8f9ced7d9a9c1c237fad5ad1", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 32071, "upload_time": "2019-07-13T10:16:59", "upload_time_iso_8601": "2019-07-13T10:16:59.390607Z", "url": "https://files.pythonhosted.org/packages/63/b0/194282bd64929aba28a5b4e7b959d3d9d3c7dfb893d2932ee6bbc560002f/snoop-0.2.1.tar.gz", "yanked": false}], "0.2.2": [{"comment_text": "", "digests": {"md5": "2a9cb8e88a01c1ebfb1f02b2339ab87e", "sha256": "562e81d6f03dc418779d758738e599d9a0950ae347c11b98b8c4467e422fd3ae"}, "downloads": -1, "filename": "snoop-0.2.2.tar.gz", "has_sig": false, "md5_digest": "2a9cb8e88a01c1ebfb1f02b2339ab87e", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 32142, "upload_time": "2019-09-06T08:19:00", "upload_time_iso_8601": "2019-09-06T08:19:00.015886Z", "url": "https://files.pythonhosted.org/packages/f9/cf/314b84fff07c6ed0830938f011b0f1712cf5d6e0f393923d3f7fd4f80744/snoop-0.2.2.tar.gz", "yanked": false}], "0.2.3": [{"comment_text": "", "digests": {"md5": "357fa9308b3f6564635c9583023dfec6", "sha256": "395f89226e4c3d26d02be8453c10adc745dc621cd7babeaa71040ff94745fd7b"}, "downloads": -1, "filename": "snoop-0.2.3.tar.gz", "has_sig": false, "md5_digest": "357fa9308b3f6564635c9583023dfec6", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 32144, "upload_time": "2019-12-25T19:24:56", "upload_time_iso_8601": "2019-12-25T19:24:56.150207Z", "url": "https://files.pythonhosted.org/packages/bd/a6/6a549e009545cc914aa81d417fb8324c332f349957385fc05873b62fa159/snoop-0.2.3.tar.gz", "yanked": false}], "0.2.4": [{"comment_text": "", "digests": {"md5": "1ac6606affbbebd320bc906d9791bd8e", "sha256": "89a60f95fac717cd7e4af7674478c6c31d33e40a159452a6db7c609993e535c9"}, "downloads": -1, "filename": "snoop-0.2.4.tar.gz", "has_sig": false, "md5_digest": "1ac6606affbbebd320bc906d9791bd8e", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 32164, "upload_time": "2020-01-17T14:43:34", "upload_time_iso_8601": "2020-01-17T14:43:34.833418Z", "url": "https://files.pythonhosted.org/packages/ce/bf/b08c02a51fd5c1731a0bf63e7edaaa7e5a96f9c416cb511ded595bc33419/snoop-0.2.4.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "1ac6606affbbebd320bc906d9791bd8e", "sha256": "89a60f95fac717cd7e4af7674478c6c31d33e40a159452a6db7c609993e535c9"}, "downloads": -1, "filename": "snoop-0.2.4.tar.gz", "has_sig": false, "md5_digest": "1ac6606affbbebd320bc906d9791bd8e", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 32164, "upload_time": "2020-01-17T14:43:34", "upload_time_iso_8601": "2020-01-17T14:43:34.833418Z", "url": "https://files.pythonhosted.org/packages/ce/bf/b08c02a51fd5c1731a0bf63e7edaaa7e5a96f9c416cb511ded595bc33419/snoop-0.2.4.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:07:18 2020"}