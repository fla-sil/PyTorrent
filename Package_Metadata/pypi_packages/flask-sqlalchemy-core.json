{"info": {"author": "Samuele Santi", "author_email": "samuele@samuelesanti.com", "bugtrack_url": null, "classifiers": ["License :: OSI Approved :: BSD License", "Programming Language :: Python :: 3.6", "Programming Language :: Python :: 3.7", "Programming Language :: Python :: 3 :: Only"], "description": "Flask / SQLAlchemy Core\n#######################\n\nSQLAlchemy Core integration for Flask application.\n\nProvides an easy way for setting up and using SQLAlchemy Core in Flask\n(or Werkzeug-based, really) applications.\n\nThe main benefit of using this package over plain SQLAlchemy is the\nability of sharing the current connection in a context-local \"global\"\nobject.\n\nThis allows creating nested transactions without having to explicitly\npass the connection object across functions.\n\nThis in turn enables running test functions inside a transaction,\nwhich will be rolled back on test teardown, greatly reducing test run\ntime, by removing the need of continuously dropping and re-creating\nthe whole database schema for each test function run.\n\n\nUsage\n=====\n\nSet up\n------\n\n.. code-block:: python\n\n    import os\n    from flask_sqlalchemy_core import FlaskSQLAlchemy\n\n    DATABASE_URL = os.environ['DATABASE_URL']\n\n    db = FlaskSQLAlchemy(DATABASE_URL)\n\n\nRunning queries\n---------------\n\n.. code-block:: python\n\n    from sqlalchemy import select\n\n    # Create your query here\n    query = select(...)\n\n    with db.connect() as conn:\n        result = conn.execute(query)\n        # Do something with the result...\n\n\nTransactions\n------------\n\n.. code-block:: python\n\n    with db.transaction() as conn:\n        result = conn.execute(query)\n\n\nThe transaction will automatically committed upon a successful exit\nfrom the \"with\" block, or rolled back if an exception was raised.\n\n\nNested transactions\n-------------------\n\nSimply nest ``with db.transaction():`` blocks.\n\nThis allows for more reusable code, for example:\n\n.. code-block:: python\n\n    def create_user(...):\n        with db.transaction() as conn:\n            # Create record in the users table\n            conn.execute(...)\n            # Other data for the user in some other table\n            conn.execute(...)\n\n    def create_client(...):\n        with db.transaction() as conn:\n            # Create record in the clients table\n            conn.execute(...)\n            # ...other data for this client...\n            conn.execute(...)\n\n    def setup_new_client(client_name, user_name):\n        with db.transaction():\n            create_user(user_name)\n            create_client(client_name)\n\n\nDefine tables\n-------------\n\nJust do as you normally would (create a Metadata instance, use it to\ndefine your schema).\n\n\nCreating schema\n---------------\n\n.. code-block:: python\n\n    metadata.create_all(db.get_engine())\n\n\nTest fixtures\n-------------\n\nFor use with pytest, place those in a ``conftest.py`` file in your\ntests directory.\n\n**Note:** you might want to change your ``DATABASE_URL`` environment\nvariable during testing, to avoid overriding your current development\ndatabase.\n\n.. code-block:: python\n\n    import pytest\n\n    @pytest.fixture\n    def db(db_schema):\n        with db.transaction(autocommit=False, rollback=True):\n            # By wrapping execution in a transaction that automatically\n            # gets rolled back, we can avoid having to recreate the whole\n            # schema for every test function run.\n            yield\n\n    @pytest.fixture(scope='session')\n    def db_schema():\n        engine = db.get_engine()\n\n        # Clean up, in case tables were left around from a previous run.\n        # This can happen if the test process was abruptly killed.\n        metadata.drop_all(engine)\n\n        metadata.create_all(engine)\n\n        yield\n\n        metadata.drop_all(engine)\n\n\nDatabase migrations\n-------------------\n\nUse Alembic_ for creating database migrations.\n\n\n.. _Alembic: https://alembic.zzzcomputing.com/en/latest/\n\n\nDatabase support\n================\n\nThe library is currently tested with PostgreSQL (10).\n\nEverything should work with other backends too (except nested\ntransactions, on backends that don't support checkpoints).\n\n\nTesting\n=======\n\nBefore running the test suite, you'll need to start a SQL database and\nset the DATABASE_URL environment variable.\n\nFor convenience, you can use the ``bin/run-test-database`` script,\nwhich will automatically run a PostgreSQL instance via Docker.\n\nThe script will print a suitable value for ``DATABASE_URL`` as well.\n\nOncer you're done, simply kill it via Ctrl-C.\n\n\nTo install test dependencies::\n\n    pip install -r test_requirements.txt\n\nTo run the test suite::\n\n    pytest -vvv ./tests\n\n\nTo run tests using SQLite backend::\n\n    DATABASE_URL=\"sqlite:///:memory:\" pytest -vvv ./tests\n\n**Warning:** some tests will be skipped, as SQLite doesn't support\nnested transactions.\n\n\n\n\n", "description_content_type": "", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/rshk/flask-sqlalchemy-core", "keywords": "", "license": "BSD License", "maintainer": "", "maintainer_email": "", "name": "flask-sqlalchemy-core", "package_url": "https://pypi.org/project/flask-sqlalchemy-core/", "platform": "", "project_url": "https://pypi.org/project/flask-sqlalchemy-core/", "project_urls": {"Homepage": "https://github.com/rshk/flask-sqlalchemy-core"}, "release_url": "https://pypi.org/project/flask-sqlalchemy-core/0.1.1/", "requires_dist": ["werkzeug", "sqlalchemy"], "requires_python": "", "summary": "SQLAlchemy Core integration for Flask", "version": "0.1.1", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p>SQLAlchemy Core integration for Flask application.</p>\n<p>Provides an easy way for setting up and using SQLAlchemy Core in Flask\n(or Werkzeug-based, really) applications.</p>\n<p>The main benefit of using this package over plain SQLAlchemy is the\nability of sharing the current connection in a context-local \u201cglobal\u201d\nobject.</p>\n<p>This allows creating nested transactions without having to explicitly\npass the connection object across functions.</p>\n<p>This in turn enables running test functions inside a transaction,\nwhich will be rolled back on test teardown, greatly reducing test run\ntime, by removing the need of continuously dropping and re-creating\nthe whole database schema for each test function run.</p>\n<div id=\"usage\">\n<h2>Usage</h2>\n<div id=\"set-up\">\n<h3>Set up</h3>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">os</span>\n<span class=\"kn\">from</span> <span class=\"nn\">flask_sqlalchemy_core</span> <span class=\"kn\">import</span> <span class=\"n\">FlaskSQLAlchemy</span>\n\n<span class=\"n\">DATABASE_URL</span> <span class=\"o\">=</span> <span class=\"n\">os</span><span class=\"o\">.</span><span class=\"n\">environ</span><span class=\"p\">[</span><span class=\"s1\">'DATABASE_URL'</span><span class=\"p\">]</span>\n\n<span class=\"n\">db</span> <span class=\"o\">=</span> <span class=\"n\">FlaskSQLAlchemy</span><span class=\"p\">(</span><span class=\"n\">DATABASE_URL</span><span class=\"p\">)</span>\n</pre>\n</div>\n<div id=\"running-queries\">\n<h3>Running queries</h3>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">sqlalchemy</span> <span class=\"kn\">import</span> <span class=\"n\">select</span>\n\n<span class=\"c1\"># Create your query here</span>\n<span class=\"n\">query</span> <span class=\"o\">=</span> <span class=\"n\">select</span><span class=\"p\">(</span><span class=\"o\">...</span><span class=\"p\">)</span>\n\n<span class=\"k\">with</span> <span class=\"n\">db</span><span class=\"o\">.</span><span class=\"n\">connect</span><span class=\"p\">()</span> <span class=\"k\">as</span> <span class=\"n\">conn</span><span class=\"p\">:</span>\n    <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">conn</span><span class=\"o\">.</span><span class=\"n\">execute</span><span class=\"p\">(</span><span class=\"n\">query</span><span class=\"p\">)</span>\n    <span class=\"c1\"># Do something with the result...</span>\n</pre>\n</div>\n<div id=\"transactions\">\n<h3>Transactions</h3>\n<pre><span class=\"k\">with</span> <span class=\"n\">db</span><span class=\"o\">.</span><span class=\"n\">transaction</span><span class=\"p\">()</span> <span class=\"k\">as</span> <span class=\"n\">conn</span><span class=\"p\">:</span>\n    <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">conn</span><span class=\"o\">.</span><span class=\"n\">execute</span><span class=\"p\">(</span><span class=\"n\">query</span><span class=\"p\">)</span>\n</pre>\n<p>The transaction will automatically committed upon a successful exit\nfrom the \u201cwith\u201d block, or rolled back if an exception was raised.</p>\n</div>\n<div id=\"nested-transactions\">\n<h3>Nested transactions</h3>\n<p>Simply nest <tt>with <span class=\"pre\">db.transaction():</span></tt> blocks.</p>\n<p>This allows for more reusable code, for example:</p>\n<pre><span class=\"k\">def</span> <span class=\"nf\">create_user</span><span class=\"p\">(</span><span class=\"o\">...</span><span class=\"p\">):</span>\n    <span class=\"k\">with</span> <span class=\"n\">db</span><span class=\"o\">.</span><span class=\"n\">transaction</span><span class=\"p\">()</span> <span class=\"k\">as</span> <span class=\"n\">conn</span><span class=\"p\">:</span>\n        <span class=\"c1\"># Create record in the users table</span>\n        <span class=\"n\">conn</span><span class=\"o\">.</span><span class=\"n\">execute</span><span class=\"p\">(</span><span class=\"o\">...</span><span class=\"p\">)</span>\n        <span class=\"c1\"># Other data for the user in some other table</span>\n        <span class=\"n\">conn</span><span class=\"o\">.</span><span class=\"n\">execute</span><span class=\"p\">(</span><span class=\"o\">...</span><span class=\"p\">)</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">create_client</span><span class=\"p\">(</span><span class=\"o\">...</span><span class=\"p\">):</span>\n    <span class=\"k\">with</span> <span class=\"n\">db</span><span class=\"o\">.</span><span class=\"n\">transaction</span><span class=\"p\">()</span> <span class=\"k\">as</span> <span class=\"n\">conn</span><span class=\"p\">:</span>\n        <span class=\"c1\"># Create record in the clients table</span>\n        <span class=\"n\">conn</span><span class=\"o\">.</span><span class=\"n\">execute</span><span class=\"p\">(</span><span class=\"o\">...</span><span class=\"p\">)</span>\n        <span class=\"c1\"># ...other data for this client...</span>\n        <span class=\"n\">conn</span><span class=\"o\">.</span><span class=\"n\">execute</span><span class=\"p\">(</span><span class=\"o\">...</span><span class=\"p\">)</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">setup_new_client</span><span class=\"p\">(</span><span class=\"n\">client_name</span><span class=\"p\">,</span> <span class=\"n\">user_name</span><span class=\"p\">):</span>\n    <span class=\"k\">with</span> <span class=\"n\">db</span><span class=\"o\">.</span><span class=\"n\">transaction</span><span class=\"p\">():</span>\n        <span class=\"n\">create_user</span><span class=\"p\">(</span><span class=\"n\">user_name</span><span class=\"p\">)</span>\n        <span class=\"n\">create_client</span><span class=\"p\">(</span><span class=\"n\">client_name</span><span class=\"p\">)</span>\n</pre>\n</div>\n<div id=\"define-tables\">\n<h3>Define tables</h3>\n<p>Just do as you normally would (create a Metadata instance, use it to\ndefine your schema).</p>\n</div>\n<div id=\"creating-schema\">\n<h3>Creating schema</h3>\n<pre><span class=\"n\">metadata</span><span class=\"o\">.</span><span class=\"n\">create_all</span><span class=\"p\">(</span><span class=\"n\">db</span><span class=\"o\">.</span><span class=\"n\">get_engine</span><span class=\"p\">())</span>\n</pre>\n</div>\n<div id=\"test-fixtures\">\n<h3>Test fixtures</h3>\n<p>For use with pytest, place those in a <tt>conftest.py</tt> file in your\ntests directory.</p>\n<p><strong>Note:</strong> you might want to change your <tt>DATABASE_URL</tt> environment\nvariable during testing, to avoid overriding your current development\ndatabase.</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">pytest</span>\n\n<span class=\"nd\">@pytest</span><span class=\"o\">.</span><span class=\"n\">fixture</span>\n<span class=\"k\">def</span> <span class=\"nf\">db</span><span class=\"p\">(</span><span class=\"n\">db_schema</span><span class=\"p\">):</span>\n    <span class=\"k\">with</span> <span class=\"n\">db</span><span class=\"o\">.</span><span class=\"n\">transaction</span><span class=\"p\">(</span><span class=\"n\">autocommit</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">,</span> <span class=\"n\">rollback</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">):</span>\n        <span class=\"c1\"># By wrapping execution in a transaction that automatically</span>\n        <span class=\"c1\"># gets rolled back, we can avoid having to recreate the whole</span>\n        <span class=\"c1\"># schema for every test function run.</span>\n        <span class=\"k\">yield</span>\n\n<span class=\"nd\">@pytest</span><span class=\"o\">.</span><span class=\"n\">fixture</span><span class=\"p\">(</span><span class=\"n\">scope</span><span class=\"o\">=</span><span class=\"s1\">'session'</span><span class=\"p\">)</span>\n<span class=\"k\">def</span> <span class=\"nf\">db_schema</span><span class=\"p\">():</span>\n    <span class=\"n\">engine</span> <span class=\"o\">=</span> <span class=\"n\">db</span><span class=\"o\">.</span><span class=\"n\">get_engine</span><span class=\"p\">()</span>\n\n    <span class=\"c1\"># Clean up, in case tables were left around from a previous run.</span>\n    <span class=\"c1\"># This can happen if the test process was abruptly killed.</span>\n    <span class=\"n\">metadata</span><span class=\"o\">.</span><span class=\"n\">drop_all</span><span class=\"p\">(</span><span class=\"n\">engine</span><span class=\"p\">)</span>\n\n    <span class=\"n\">metadata</span><span class=\"o\">.</span><span class=\"n\">create_all</span><span class=\"p\">(</span><span class=\"n\">engine</span><span class=\"p\">)</span>\n\n    <span class=\"k\">yield</span>\n\n    <span class=\"n\">metadata</span><span class=\"o\">.</span><span class=\"n\">drop_all</span><span class=\"p\">(</span><span class=\"n\">engine</span><span class=\"p\">)</span>\n</pre>\n</div>\n<div id=\"database-migrations\">\n<h3>Database migrations</h3>\n<p>Use <a href=\"https://alembic.zzzcomputing.com/en/latest/\" rel=\"nofollow\">Alembic</a> for creating database migrations.</p>\n</div>\n</div>\n<div id=\"database-support\">\n<h2>Database support</h2>\n<p>The library is currently tested with PostgreSQL (10).</p>\n<p>Everything should work with other backends too (except nested\ntransactions, on backends that don\u2019t support checkpoints).</p>\n</div>\n<div id=\"testing\">\n<h2>Testing</h2>\n<p>Before running the test suite, you\u2019ll need to start a SQL database and\nset the DATABASE_URL environment variable.</p>\n<p>For convenience, you can use the <tt><span class=\"pre\">bin/run-test-database</span></tt> script,\nwhich will automatically run a PostgreSQL instance via Docker.</p>\n<p>The script will print a suitable value for <tt>DATABASE_URL</tt> as well.</p>\n<p>Oncer you\u2019re done, simply kill it via Ctrl-C.</p>\n<p>To install test dependencies:</p>\n<pre>pip install -r test_requirements.txt\n</pre>\n<p>To run the test suite:</p>\n<pre>pytest -vvv ./tests\n</pre>\n<p>To run tests using SQLite backend:</p>\n<pre>DATABASE_URL=\"sqlite:///:memory:\" pytest -vvv ./tests\n</pre>\n<p><strong>Warning:</strong> some tests will be skipped, as SQLite doesn\u2019t support\nnested transactions.</p>\n</div>\n\n          </div>"}, "last_serial": 4983936, "releases": {"0.1": [{"comment_text": "", "digests": {"md5": "b6877e825545ffc1db0e05a5d525f4da", "sha256": "007df2da8b0dac24af95589c8fff841fb07bdbb1a77febfad23c1ac9b0071ed0"}, "downloads": -1, "filename": "flask_sqlalchemy_core-0.1-py3-none-any.whl", "has_sig": false, "md5_digest": "b6877e825545ffc1db0e05a5d525f4da", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 6181, "upload_time": "2018-10-04T15:24:13", "upload_time_iso_8601": "2018-10-04T15:24:13.238833Z", "url": "https://files.pythonhosted.org/packages/d5/6d/304870191339b63f28455bd493a1e0de771666e3dec14671d9d04c6d325c/flask_sqlalchemy_core-0.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "c4b7b3bd9610da32c6dd8b3739c8e74a", "sha256": "b6868aee88e674f25c44c84662f76d58c786ffa06062a0b37cf91892229c5b95"}, "downloads": -1, "filename": "flask_sqlalchemy_core-0.1.tar.gz", "has_sig": false, "md5_digest": "c4b7b3bd9610da32c6dd8b3739c8e74a", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 5546, "upload_time": "2018-10-04T15:24:14", "upload_time_iso_8601": "2018-10-04T15:24:14.975429Z", "url": "https://files.pythonhosted.org/packages/46/75/2f8a1d171e023ce1ba76467eddfde808116e761b33fb16a38764a6a87dd0/flask_sqlalchemy_core-0.1.tar.gz", "yanked": false}], "0.1.1": [{"comment_text": "", "digests": {"md5": "4a671ff8c1b8f611c3dddb4c3c673070", "sha256": "b26f7f887b0edb99518b6ec0cd098a9dc2b76aca93eae5818d542af8c1921378"}, "downloads": -1, "filename": "flask_sqlalchemy_core-0.1.1-py3-none-any.whl", "has_sig": false, "md5_digest": "4a671ff8c1b8f611c3dddb4c3c673070", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 6233, "upload_time": "2019-03-25T18:12:58", "upload_time_iso_8601": "2019-03-25T18:12:58.057368Z", "url": "https://files.pythonhosted.org/packages/0d/82/ae3bb748ebcf16aa8e0d939bc751ef011daa479b5e24123695eb63d94c95/flask_sqlalchemy_core-0.1.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "6da8600b35c3f2c6ee49d8d1703a70a8", "sha256": "ee3984392f80f91278bd0adb1386f747ddd03e1de3e8741f3277cf21af1ca52c"}, "downloads": -1, "filename": "flask_sqlalchemy_core-0.1.1.tar.gz", "has_sig": false, "md5_digest": "6da8600b35c3f2c6ee49d8d1703a70a8", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 5593, "upload_time": "2019-03-25T18:12:59", "upload_time_iso_8601": "2019-03-25T18:12:59.490122Z", "url": "https://files.pythonhosted.org/packages/91/1a/0aa7854ff459d118abd6f28eeadd15394f727118849849b219f87218ae6d/flask_sqlalchemy_core-0.1.1.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "4a671ff8c1b8f611c3dddb4c3c673070", "sha256": "b26f7f887b0edb99518b6ec0cd098a9dc2b76aca93eae5818d542af8c1921378"}, "downloads": -1, "filename": "flask_sqlalchemy_core-0.1.1-py3-none-any.whl", "has_sig": false, "md5_digest": "4a671ff8c1b8f611c3dddb4c3c673070", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 6233, "upload_time": "2019-03-25T18:12:58", "upload_time_iso_8601": "2019-03-25T18:12:58.057368Z", "url": "https://files.pythonhosted.org/packages/0d/82/ae3bb748ebcf16aa8e0d939bc751ef011daa479b5e24123695eb63d94c95/flask_sqlalchemy_core-0.1.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "6da8600b35c3f2c6ee49d8d1703a70a8", "sha256": "ee3984392f80f91278bd0adb1386f747ddd03e1de3e8741f3277cf21af1ca52c"}, "downloads": -1, "filename": "flask_sqlalchemy_core-0.1.1.tar.gz", "has_sig": false, "md5_digest": "6da8600b35c3f2c6ee49d8d1703a70a8", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 5593, "upload_time": "2019-03-25T18:12:59", "upload_time_iso_8601": "2019-03-25T18:12:59.490122Z", "url": "https://files.pythonhosted.org/packages/91/1a/0aa7854ff459d118abd6f28eeadd15394f727118849849b219f87218ae6d/flask_sqlalchemy_core-0.1.1.tar.gz", "yanked": false}], "timestamp": "Fri May  8 01:02:15 2020"}