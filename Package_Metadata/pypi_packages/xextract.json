{"info": {"author": "Michal \"Mimino\" Danilak", "author_email": "michal.danilak@gmail.com", "bugtrack_url": null, "classifiers": ["Development Status :: 4 - Beta", "Intended Audience :: Developers", "License :: OSI Approved :: MIT License", "Natural Language :: English", "Programming Language :: Python", "Programming Language :: Python :: 2.6", "Programming Language :: Python :: 2.7", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.3", "Programming Language :: Python :: 3.5", "Programming Language :: Python :: 3.6", "Programming Language :: Python :: 3.7", "Programming Language :: Python :: 3.8", "Programming Language :: Python :: Implementation :: CPython"], "description": "********\nxextract\n********\n\nExtract structured data from HTML and XML documents like a boss.\n\n**xextract** is simple enough for writing a one-line parser, yet powerful enough to be used in a big project.\n\n\n**Features**\n\n- Parsing of HTML and XML documents\n- Supports **xpath** and **css** selectors\n- Simple declarative style of parsers\n- Built-in self-validation to let you know when the structure of the website has changed\n- Speed - under the hood the library uses `lxml library <http://lxml.de/>`_ with compiled xpath selectors\n\n\n**Table of Contents**\n\n.. contents::\n    :local:\n    :depth: 2\n    :backlinks: none\n\n\n====================\nA little taste of it\n====================\n\nLet's parse `The Shawshank Redemption <http://www.imdb.com/title/tt0111161/>`_'s IMDB page:\n\n.. code-block:: python\n\n  # fetch the website\n  >>> import requests\n  >>> response = requests.get('http://www.imdb.com/title/tt0111161/')\n\n  # parse like a boss\n  >>> from xextract import String, Group\n\n  # extract title with css selector\n  >>> String(css='h1[itemprop=\"name\"]', quant=1).parse(response.text)\n  u'The Shawshank Redemption'\n\n  # extract release year with xpath selector\n  >>> String(xpath='//*[@id=\"titleYear\"]/a', quant=1, callback=int).parse(response.text)\n  1994\n\n  # extract structured data\n  >>> Group(css='.cast_list tr:not(:first-child)', children=[\n  ...   String(name='name', css='[itemprop=\"actor\"]', attr='_all_text', quant=1),\n  ...   String(name='character', css='.character', attr='_all_text', quant=1)\n  ... ]).parse(response.text)\n  [\n   {'name': u'Tim Robbins', 'character': u'Andy Dufresne'},\n   {'name': u'Morgan Freeman', 'character': u\"Ellis Boyd 'Red' Redding\"},\n   ...\n  ]\n\n\n============\nInstallation\n============\n\nTo install **xextract**, simply run:\n\n.. code-block:: bash\n\n    $ pip install xextract\n\nRequirements: six, lxml, cssselect\n\nSupported Python versions are 2.6, 2.7, 3.x.\n\nWindows users can download lxml binary `here <http://www.lfd.uci.edu/~gohlke/pythonlibs/#lxml>`_.\n\n\n=======\nParsers\n=======\n\n------\nString\n------\n\n**Parameters**: `name`_ (optional), `css / xpath`_ (optional, default ``\"self::*\"``), `quant`_ (optional, default ``\"*\"``), `attr`_ (optional, default ``\"_text\"``), `callback`_ (optional), `namespaces`_ (optional)\n\nExtract string data from the matched element(s).\nExtracted value is always unicode.\n\nBy default, ``String`` extracts the text content of only the matched element, but not its descendants.\nTo extract and concatenate the text out of every descendant element, use ``attr`` parameter with the special value ``\"_all_text\"``:\n\nUse ``attr`` parameter to extract the data from an HTML/XML attribute.\n\nUse ``callback`` parameter to post-process extracted values.\n\nExample:\n\n.. code-block:: python\n\n    >>> from xextract import String\n    >>> String(css='span', quant=1).parse('<span>Hello <b>world</b>!</span>')\n    u'Hello !'\n\n    >>> String(css='span', quant=1, attr='class').parse('<span class=\"text-success\"></span>')\n    u'text-success'\n\n    # use special `attr` value `_all_text` to extract and concantenate text out of all descendants\n    >>> String(css='span', quant=1, attr='_all_text').parse('<span>Hello <b>world</b>!</span>')\n    u'Hello world!'\n\n    # use special `attr` value `_name` to extract tag name of the matched element\n    >>> String(css='span', quant=1, attr='_name').parse('<span>hello</span>')\n    u'span'\n\n    >>> String(css='span', callback=int).parse('<span>1</span><span>2</span>')\n    [1, 2]\n\n---\nUrl\n---\n\n**Parameters**: `name`_ (optional), `css / xpath`_ (optional, default ``\"self::*\"``), `quant`_ (optional, default ``\"*\"``), `attr`_ (optional, default ``\"href\"``), `callback`_ (optional), `namespaces`_ (optional)\n\nBehaves like ``String`` parser, but with two exceptions:\n\n* default value for ``attr`` parameter is ``\"href\"``\n* if you pass ``url`` parameter to ``parse()`` method, the absolute url will be constructed and returned\n\nIf ``callback`` is specified, it is called *after* the absolute urls are constructed.\n\nExample:\n\n.. code-block:: python\n\n    >>> from xextract import Url, Prefix\n    >>> content = '<div id=\"main\"> <a href=\"/test\">Link</a> </div>'\n\n    >>> Url(css='a', quant=1).parse(content)\n    u'/test'\n\n    >>> Url(css='a', quant=1).parse(content, url='http://github.com/Mimino666')\n    u'http://github.com/test'  # absolute url address. Told ya!\n\n    >>> Prefix(css='#main', children=[\n    ...   Url(css='a', quant=1)\n    ... ]).parse(content, url='http://github.com/Mimino666')  # you can pass url also to ancestor's parse(). It will propagate down.\n    u'http://github.com/test'\n\n\n--------\nDateTime\n--------\n\n**Parameters**: `name`_ (optional), `css / xpath`_ (optional, default ``\"self::*\"``), ``format`` (**required**), `quant`_ (optional, default ``\"*\"``), `attr`_ (optional, default ``\"_text\"``), `callback`_ (optional) `namespaces`_ (optional)\n\nReturns the ``datetime.datetime`` object constructed out of the extracted data: ``datetime.strptime(extracted_data, format)``.\n\n``format`` syntax is described in the `Python documentation <https://docs.python.org/2/library/datetime.html#strftime-strptime-behavior>`_.\n\nIf ``callback`` is specified, it is called *after* the datetime objects are constructed.\n\nExample:\n\n.. code-block:: python\n\n    >>> from xextract import DateTime\n    >>> DateTime(css='span', quant=1, format='%d.%m.%Y %H:%M').parse('<span>24.12.2015 5:30</span>')\n    datetime.datetime(2015, 12, 24, 50, 30)\n\n\n----\nDate\n----\n\n**Parameters**: `name`_ (optional), `css / xpath`_ (optional, default ``\"self::*\"``), ``format`` (**required**), `quant`_ (optional, default ``\"*\"``), `attr`_ (optional, default ``\"_text\"``), `callback`_ (optional) `namespaces`_ (optional)\n\nReturns the ``datetime.date`` object constructed out of the extracted data: ``datetime.strptime(extracted_data, format).date()``.\n\n``format`` syntax is described in the `Python documentation <https://docs.python.org/2/library/datetime.html#strftime-strptime-behavior>`_.\n\nIf ``callback`` is specified, it is called *after* the datetime objects are constructed.\n\nExample:\n\n.. code-block:: python\n\n    >>> from xextract import Date\n    >>> Date(css='span', quant=1, format='%d.%m.%Y').parse('<span>24.12.2015</span>')\n    datetime.date(2015, 12, 24)\n\n\n-------\nElement\n-------\n\n**Parameters**: `name`_ (optional), `css / xpath`_ (optional, default ``\"self::*\"``), `quant`_ (optional, default ``\"*\"``), `callback`_ (optional), `namespaces`_ (optional)\n\nReturns lxml instance (``lxml.etree._Element``) of the matched element(s).\nIf you use xpath expression and match the text content of the element (e.g. ``text()`` or ``@attr``), unicode is returned.\n\nIf ``callback`` is specified, it is called with ``lxml.etree._Element`` instance.\n\nExample:\n\n.. code-block:: python\n\n    >>> from xextract import Element\n    >>> Element(css='span', quant=1).parse('<span>Hello</span>')\n    <Element span at 0x2ac2990>\n\n    >>> Element(css='span', quant=1, callback=lambda el: el.text).parse('<span>Hello</span>')\n    u'Hello'\n\n    # same as above\n    >>> Element(xpath='//span/text()', quant=1).parse('<span>Hello</span>')\n    u'Hello'\n\n\n-----\nGroup\n-----\n\n**Parameters**: `name`_ (optional), `css / xpath`_ (optional, default ``\"self::*\"``), `children`_ (**required**), `quant`_ (optional, default ``\"*\"``), `callback`_ (optional), `namespaces`_ (optional)\n\nFor each element matched by css/xpath selector returns the dictionary containing the data extracted by the parsers listed in ``children`` parameter.\nAll parsers listed in ``children`` parameter **must** have ``name`` specified - this is then used as the key in dictionary.\n\nTypical use case for this parser is when you want to parse structured data, e.g. list of user profiles, where each profile contains fields like name, address, etc. Use ``Group`` parser to group the fields of each user profile together.\n\nIf ``callback`` is specified, it is called with the dictionary of parsed children values.\n\nExample:\n\n.. code-block:: python\n\n    >>> from xextract import Group\n    >>> content = '<ul><li id=\"id1\">michal</li> <li id=\"id2\">peter</li></ul>'\n\n    >>> Group(css='li', quant=2, children=[\n    ...     String(name='id', xpath='self::*', quant=1, attr='id'),\n    ...     String(name='name', xpath='self::*', quant=1)\n    ... ]).parse(content)\n    [{'name': u'michal', 'id': u'id1'},\n     {'name': u'peter', 'id': u'id2'}]\n\n\n------\nPrefix\n------\n\n**Parameters**: `css / xpath`_ (optional, default ``\"self::*\"``), `children`_ (**required**), `namespaces`_ (optional)\n\nThis parser doesn't actually parse any data on its own. Instead you can use it, when many of your parsers share the same css/xpath selector prefix.\n\n``Prefix`` parser always returns a single dictionary containing the data extracted by the parsers listed in ``children`` parameter.\nAll parsers listed in ``children`` parameter **must** have ``name`` specified - this is then used as the key in dictionary.\n\nExample:\n\n.. code-block:: python\n\n    # instead of...\n    >>> String(css='#main .name').parse(...)\n    >>> String(css='#main .date').parse(...)\n\n    # ...you can use\n    >>> from xextract import Prefix\n    >>> Prefix(css='#main', children=[\n    ...   String(name=\"name\", css='.name'),\n    ...   String(name=\"date\", css='.date')\n    ... ]).parse(...)\n\n\n=================\nParser parameters\n=================\n\n----\nname\n----\n\n**Parsers**: `String`_, `Url`_, `DateTime`_, `Date`_, `Element`_, `Group`_\n\n**Default value**: ``None``\n\nIf specified, then the extracted data will be returned in a dictionary, with the ``name`` as the key and the data as the value.\n\nAll parsers listed in ``children`` parameter of ``Group`` or ``Prefix`` parser **must** have ``name`` specified.\nIf multiple children parsers have the same ``name``, the behavior is undefined.\n\nExample:\n\n.. code-block:: python\n\n  # when `name` is not specified, raw value is returned\n  >>> String(css='span', quant=1).parse('<span>Hello!</span>')\n  u'Hello!'\n\n  # when `name` is specified, dictionary is returned with `name` as the key\n  >>> String(name='message', css='span', quant=1).parse('<span>Hello!</span>')\n  {'message': u'Hello!'}\n\n\n-----------\ncss / xpath\n-----------\n\n**Parsers**: `String`_, `Url`_, `DateTime`_, `Date`_, `Element`_, `Group`_, `Prefix`_\n\n**Default value (xpath)**: ``\"self::*\"``\n\nUse either ``css`` or ``xpath`` parameter (but not both) to select the elements from which to extract the data.\n\nUnder the hood css selectors are translated into equivalent xpath selectors.\n\nFor the children of ``Prefix`` or ``Group`` parsers, the elements are selected relative to the elements matched by the parent parser.\n\nExample:\n\n.. code-block:: python\n\n    Prefix(xpath='//*[@id=\"profile\"]', children=[\n        # equivalent to: //*[@id=\"profile\"]/descendant-or-self::*[@class=\"name\"]\n        String(name='name', css='.name', quant=1),\n\n        # equivalent to: //*[@id=\"profile\"]/*[@class=\"title\"]\n        String(name='title', xpath='*[@class=\"title\"]', quant=1),\n\n        # equivalent to: //*[@class=\"subtitle\"]\n        String(name='subtitle', xpath='//*[@class=\"subtitle\"]', quant=1)\n    ])\n\n\n-----\nquant\n-----\n\n**Parsers**: `String`_, `Url`_, `DateTime`_, `Date`_, `Element`_, `Group`_\n\n**Default value**: ``\"*\"``\n\n``quant`` specifies the expected number of elements to be matched with css/xpath selector. It serves two purposes:\n\n1. Number of matched elements is checked against the ``quant`` parameter. If the number of elements doesn't match the expected quantity, ``xextract.parsers.ParsingError`` exception is raised. This way you will be notified, when the website has changed its structure.\n2. It tells the parser whether to return a single extracted value or a list of values. See the table below.\n\nSyntax for ``quant`` mimics the regular expressions.\nYou can either pass the value as a string, single integer or tuple of two integers.\n\nDepending on the value of ``quant``, the parser returns either a single extracted value or a list of values.\n\n+-------------------+-----------------------------------------------+-----------------------------+\n| Value of ``quant``| Meaning                                       | Extracted data              |\n+===================+===============================================+=============================+\n| ``\"*\"`` (default) | Zero or more elements.                        | List of values              |\n+-------------------+-----------------------------------------------+-----------------------------+\n| ``\"+\"``           | One or more elements.                         | List of values              |\n+-------------------+-----------------------------------------------+-----------------------------+\n| ``\"?\"``           | Zero or one element.                          | Single value or ``None``    |\n+-------------------+-----------------------------------------------+-----------------------------+\n| ``num``           | Exactly ``num`` elements.                     | ``num`` == 0: ``None``      |\n|                   |                                               |                             |\n|                   | You can pass either string or integer.        | ``num`` == 1: Single value  |\n|                   |                                               |                             |\n|                   |                                               | ``num`` > 1: List of values |\n+-------------------+-----------------------------------------------+-----------------------------+\n| ``(num1, num2)``  | Number of elements has to be between          | List of values              |\n|                   | ``num1`` and ``num2``, inclusive.             |                             |\n|                   |                                               |                             |\n|                   | You can pass either a string or 2-tuple.      |                             |\n+-------------------+-----------------------------------------------+-----------------------------+\n\nExample:\n\n.. code-block:: python\n\n    >>> String(css='.full-name', quant=1).parse(content)  # return single value\n    u'John Rambo'\n\n    >>> String(css='.full-name', quant='1').parse(content)  # same as above\n    u'John Rambo'\n\n    >>> String(css='.full-name', quant=(1,2)).parse(content)  # return list of values\n    [u'John Rambo']\n\n    >>> String(css='.full-name', quant='1,2').parse(content)  # same as above\n    [u'John Rambo']\n\n    >>> String(css='.middle-name', quant='?').parse(content)  # return single value or None\n    None\n\n    >>> String(css='.job-titles', quant='+').parse(content)  # return list of values\n    [u'President', u'US Senator', u'State Senator', u'Senior Lecturer in Law']\n\n    >>> String(css='.friends', quant='*').parse(content)  # return possibly empty list of values\n    []\n\n    >>> String(css='.friends', quant='+').parse(content)  # raise exception, when no elements are matched\n    xextract.parsers.ParsingError: Parser String matched 0 elements (\"+\" expected).\n\n\n----\nattr\n----\n\n**Parsers**: `String`_, `Url`_, `DateTime`_, `Date`_\n\n**Default value**: ``\"href\"`` for ``Url`` parser. ``\"_text\"`` otherwise.\n\nUse ``attr`` parameter to specify what data to extract from the matched element.\n\n+-------------------+-----------------------------------------------------+\n| Value of ``attr`` | Meaning                                             |\n+===================+=====================================================+\n| ``\"_text\"``       | Extract the text content of the matched element.    |\n+-------------------+-----------------------------------------------------+\n| ``\"_all_text\"``   | Extract and concatenate the text content of         |\n|                   | the matched element and all its descendants.        |\n+-------------------+-----------------------------------------------------+\n| ``\"_name\"``       | Extract tag name of the matched element.            |\n+-------------------+-----------------------------------------------------+\n| ``att_name``      | Extract the value out of ``att_name`` attribute of  |\n|                   | the matched element.                                |\n|                   |                                                     |\n|                   | If such attribute doesn't exist, empty string is    |\n|                   | returned.                                           |\n+-------------------+-----------------------------------------------------+\n\nExample:\n\n.. code-block:: python\n\n    >>> from xextract import String, Url\n    >>> content = '<span class=\"name\">Barack <strong>Obama</strong> III.</span> <a href=\"/test\">Link</a>'\n\n    >>> String(css='.name', quant=1).parse(content)  # default attr is \"_text\"\n    u'Barack  III.'\n\n    >>> String(css='.name', quant=1, attr='_text').parse(content)  # same as above\n    u'Barack  III.'\n\n    >>> String(css='.name', quant=1, attr='_all_text').parse(content)  # all text\n    u'Barack Obama III.'\n\n    >>> String(css='.name', quant=1, attr='_name').parse(content)  # tag name\n    u'span'\n\n    >>> Url(css='a', quant='1').parse(content)  # Url extracts href by default\n    u'/test'\n\n    >>> String(css='a', quant='1', attr='id').parse(content)  # non-existent attributes return empty string\n    u''\n\n\n--------\ncallback\n--------\n\n**Parsers**: `String`_, `Url`_, `DateTime`_, `Date`_, `Element`_, `Group`_\n\nProvides an easy way to post-process extracted values.\nIt should be a function that takes a single argument, the extracted value, and returns the postprocessed value.\n\nExample:\n\n.. code-block:: python\n\n    >>> String(css='span', callback=int).parse('<span>1</span><span>2</span>')\n    [1, 2]\n\n    >>> Element(css='span', quant=1, callback=lambda el: el.text).parse('<span>Hello</span>')\n    u'Hello'\n\n--------\nchildren\n--------\n\n**Parsers**: `Group`_, `Prefix`_\n\nSpecifies the children parsers for the ``Group`` and ``Prefix`` parsers.\nAll parsers listed in ``children`` parameter **must** have ``name`` specified\n\nCss/xpath selectors in the children parsers are relative to the selectors specified in the parent parser.\n\nExample:\n\n.. code-block:: python\n\n    Prefix(xpath='//*[@id=\"profile\"]', children=[\n        # equivalent to: //*[@id=\"profile\"]/descendant-or-self::*[@class=\"name\"]\n        String(name='name', css='.name', quant=1),\n\n        # equivalent to: //*[@id=\"profile\"]/*[@class=\"title\"]\n        String(name='title', xpath='*[@class=\"title\"]', quant=1),\n\n        # equivalent to: //*[@class=\"subtitle\"]\n        String(name='subtitle', xpath='//*[@class=\"subtitle\"]', quant=1)\n    ])\n\n----------\nnamespaces\n----------\n\n**Parsers**: `String`_, `Url`_, `DateTime`_, `Date`_, `Element`_, `Group`_, `Prefix`_\n\nWhen parsing XML documents containing namespace prefixes, pass the dictionary mapping namespace prefixes to namespace URIs.\nUse then full name for elements in xpath selector in the form ``\"prefix:element\"``\n\nAs for the moment, you **cannot use default namespace** for parsing (see `lxml docs <http://lxml.de/FAQ.html#how-can-i-specify-a-default-namespace-for-xpath-expressions>`_ for more information).  Just use an arbitrary prefix.\n\nExample:\n\n.. code-block:: python\n\n    >>> content = '''<?xml version='1.0' encoding='UTF-8'?>\n    ... <movie xmlns=\"http://imdb.com/ns/\">\n    ...   <title>The Shawshank Redemption</title>\n    ...   <year>1994</year>\n    ... </movie>'''\n    >>> nsmap = {'imdb': 'http://imdb.com/ns/'}  # use arbitrary prefix for default namespace\n\n    >>> Prefix(xpath='//imdb:movie', namespaces=nsmap, children=[  # pass namespaces to the outermost parser\n    ...   String(name='title', xpath='imdb:title', quant=1),\n    ...   String(name='year', xpath='imdb:year', quant=1)\n    ... ]).parse(content)\n    {'title': u'The Shawshank Redemption', 'year': u'1994'}\n\n\n====================\nHTML vs. XML parsing\n====================\n\nTo extract data from HTML or XML document, simply call ``parse()`` method of the parser:\n\n.. code-block:: python\n\n    >>> from xextract import *\n    >>> parser = Prefix(..., children=[...])\n    >>> extracted_data = parser.parse(content)\n\n\n``content`` can be either string or unicode, containing the content of the document.\n\nUnder the hood **xextact** uses either ``lxml.etree.XMLParser`` or ``lxml.etree.HTMLParser`` to parse the document.\nTo select the parser, **xextract** looks for ``\"<?xml\"`` string in the first 128 bytes of the document. If it is found, then ``XMLParser`` is used.\n\nTo force either of the parsers, you can call ``parse_html()`` or ``parse_xml()`` method:\n\n.. code-block:: python\n\n    >>> parser.parse_html(content)  # force lxml.etree.HTMLParser\n    >>> parser.parse_xml(content)   # force lxml.etree.XMLParser\n\n\n", "description_content_type": "text/x-rst", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/Mimino666/python-xextract", "keywords": "HTML parse parsing extraction extract crawl", "license": "MIT", "maintainer": "", "maintainer_email": "", "name": "xextract", "package_url": "https://pypi.org/project/xextract/", "platform": "", "project_url": "https://pypi.org/project/xextract/", "project_urls": {"Homepage": "https://github.com/Mimino666/python-xextract"}, "release_url": "https://pypi.org/project/xextract/0.1.8/", "requires_dist": ["lxml", "cssselect", "six"], "requires_python": "", "summary": "Extract structured data from HTML and XML documents like a boss.", "version": "0.1.8", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p>Extract structured data from HTML and XML documents like a boss.</p>\n<p><strong>xextract</strong> is simple enough for writing a one-line parser, yet powerful enough to be used in a big project.</p>\n<p><strong>Features</strong></p>\n<ul>\n<li>Parsing of HTML and XML documents</li>\n<li>Supports <strong>xpath</strong> and <strong>css</strong> selectors</li>\n<li>Simple declarative style of parsers</li>\n<li>Built-in self-validation to let you know when the structure of the website has changed</li>\n<li>Speed - under the hood the library uses <a href=\"http://lxml.de/\" rel=\"nofollow\">lxml library</a> with compiled xpath selectors</li>\n</ul>\n<p><strong>Table of Contents</strong></p>\n<div id=\"contents\">\n<ul>\n<li><a href=\"#a-little-taste-of-it\" id=\"id2\" rel=\"nofollow\">A little taste of it</a></li>\n<li><a href=\"#installation\" id=\"id3\" rel=\"nofollow\">Installation</a></li>\n<li><a href=\"#parsers\" id=\"id4\" rel=\"nofollow\">Parsers</a><ul>\n<li><a href=\"#string\" id=\"id5\" rel=\"nofollow\">String</a></li>\n<li><a href=\"#url\" id=\"id6\" rel=\"nofollow\">Url</a></li>\n<li><a href=\"#datetime\" id=\"id7\" rel=\"nofollow\">DateTime</a></li>\n<li><a href=\"#date\" id=\"id8\" rel=\"nofollow\">Date</a></li>\n<li><a href=\"#element\" id=\"id9\" rel=\"nofollow\">Element</a></li>\n<li><a href=\"#group\" id=\"id10\" rel=\"nofollow\">Group</a></li>\n<li><a href=\"#prefix\" id=\"id11\" rel=\"nofollow\">Prefix</a></li>\n</ul>\n</li>\n<li><a href=\"#parser-parameters\" id=\"id12\" rel=\"nofollow\">Parser parameters</a><ul>\n<li><a href=\"#name\" id=\"id13\" rel=\"nofollow\">name</a></li>\n<li><a href=\"#css-xpath\" id=\"id14\" rel=\"nofollow\">css / xpath</a></li>\n<li><a href=\"#quant\" id=\"id15\" rel=\"nofollow\">quant</a></li>\n<li><a href=\"#attr\" id=\"id16\" rel=\"nofollow\">attr</a></li>\n<li><a href=\"#callback\" id=\"id17\" rel=\"nofollow\">callback</a></li>\n<li><a href=\"#children\" id=\"id18\" rel=\"nofollow\">children</a></li>\n<li><a href=\"#namespaces\" id=\"id19\" rel=\"nofollow\">namespaces</a></li>\n</ul>\n</li>\n<li><a href=\"#html-vs-xml-parsing\" id=\"id20\" rel=\"nofollow\">HTML vs. XML parsing</a></li>\n</ul>\n</div>\n<div id=\"a-little-taste-of-it\">\n<h2>A little taste of it</h2>\n<p>Let\u2019s parse <a href=\"http://www.imdb.com/title/tt0111161/\" rel=\"nofollow\">The Shawshank Redemption</a>\u2019s IMDB page:</p>\n<pre><span class=\"c1\"># fetch the website</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">import</span> <span class=\"nn\">requests</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">response</span> <span class=\"o\">=</span> <span class=\"n\">requests</span><span class=\"o\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"s1\">'http://www.imdb.com/title/tt0111161/'</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># parse like a boss</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">from</span> <span class=\"nn\">xextract</span> <span class=\"kn\">import</span> <span class=\"n\">String</span><span class=\"p\">,</span> <span class=\"n\">Group</span>\n\n<span class=\"c1\"># extract title with css selector</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">String</span><span class=\"p\">(</span><span class=\"n\">css</span><span class=\"o\">=</span><span class=\"s1\">'h1[itemprop=\"name\"]'</span><span class=\"p\">,</span> <span class=\"n\">quant</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"n\">response</span><span class=\"o\">.</span><span class=\"n\">text</span><span class=\"p\">)</span>\n<span class=\"sa\">u</span><span class=\"s1\">'The Shawshank Redemption'</span>\n\n<span class=\"c1\"># extract release year with xpath selector</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">String</span><span class=\"p\">(</span><span class=\"n\">xpath</span><span class=\"o\">=</span><span class=\"s1\">'//*[@id=\"titleYear\"]/a'</span><span class=\"p\">,</span> <span class=\"n\">quant</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">callback</span><span class=\"o\">=</span><span class=\"nb\">int</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"n\">response</span><span class=\"o\">.</span><span class=\"n\">text</span><span class=\"p\">)</span>\n<span class=\"mi\">1994</span>\n\n<span class=\"c1\"># extract structured data</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">Group</span><span class=\"p\">(</span><span class=\"n\">css</span><span class=\"o\">=</span><span class=\"s1\">'.cast_list tr:not(:first-child)'</span><span class=\"p\">,</span> <span class=\"n\">children</span><span class=\"o\">=</span><span class=\"p\">[</span>\n<span class=\"o\">...</span>   <span class=\"n\">String</span><span class=\"p\">(</span><span class=\"n\">name</span><span class=\"o\">=</span><span class=\"s1\">'name'</span><span class=\"p\">,</span> <span class=\"n\">css</span><span class=\"o\">=</span><span class=\"s1\">'[itemprop=\"actor\"]'</span><span class=\"p\">,</span> <span class=\"n\">attr</span><span class=\"o\">=</span><span class=\"s1\">'_all_text'</span><span class=\"p\">,</span> <span class=\"n\">quant</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">),</span>\n<span class=\"o\">...</span>   <span class=\"n\">String</span><span class=\"p\">(</span><span class=\"n\">name</span><span class=\"o\">=</span><span class=\"s1\">'character'</span><span class=\"p\">,</span> <span class=\"n\">css</span><span class=\"o\">=</span><span class=\"s1\">'.character'</span><span class=\"p\">,</span> <span class=\"n\">attr</span><span class=\"o\">=</span><span class=\"s1\">'_all_text'</span><span class=\"p\">,</span> <span class=\"n\">quant</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n<span class=\"o\">...</span> <span class=\"p\">])</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"n\">response</span><span class=\"o\">.</span><span class=\"n\">text</span><span class=\"p\">)</span>\n<span class=\"p\">[</span>\n <span class=\"p\">{</span><span class=\"s1\">'name'</span><span class=\"p\">:</span> <span class=\"sa\">u</span><span class=\"s1\">'Tim Robbins'</span><span class=\"p\">,</span> <span class=\"s1\">'character'</span><span class=\"p\">:</span> <span class=\"sa\">u</span><span class=\"s1\">'Andy Dufresne'</span><span class=\"p\">},</span>\n <span class=\"p\">{</span><span class=\"s1\">'name'</span><span class=\"p\">:</span> <span class=\"sa\">u</span><span class=\"s1\">'Morgan Freeman'</span><span class=\"p\">,</span> <span class=\"s1\">'character'</span><span class=\"p\">:</span> <span class=\"sa\">u</span><span class=\"s2\">\"Ellis Boyd 'Red' Redding\"</span><span class=\"p\">},</span>\n <span class=\"o\">...</span>\n<span class=\"p\">]</span>\n</pre>\n</div>\n<div id=\"installation\">\n<h2>Installation</h2>\n<p>To install <strong>xextract</strong>, simply run:</p>\n<pre>$ pip install xextract\n</pre>\n<p>Requirements: six, lxml, cssselect</p>\n<p>Supported Python versions are 2.6, 2.7, 3.x.</p>\n<p>Windows users can download lxml binary <a href=\"http://www.lfd.uci.edu/~gohlke/pythonlibs/#lxml\" rel=\"nofollow\">here</a>.</p>\n</div>\n<div id=\"parsers\">\n<h2>Parsers</h2>\n<div id=\"string\">\n<h3>String</h3>\n<p><strong>Parameters</strong>: <a href=\"#name\" rel=\"nofollow\">name</a> (optional), <a href=\"#css-xpath\" rel=\"nofollow\">css / xpath</a> (optional, default <tt><span class=\"pre\">\"self::*\"</span></tt>), <a href=\"#quant\" rel=\"nofollow\">quant</a> (optional, default <tt>\"*\"</tt>), <a href=\"#attr\" rel=\"nofollow\">attr</a> (optional, default <tt>\"_text\"</tt>), <a href=\"#callback\" rel=\"nofollow\">callback</a> (optional), <a href=\"#namespaces\" rel=\"nofollow\">namespaces</a> (optional)</p>\n<p>Extract string data from the matched element(s).\nExtracted value is always unicode.</p>\n<p>By default, <tt>String</tt> extracts the text content of only the matched element, but not its descendants.\nTo extract and concatenate the text out of every descendant element, use <tt>attr</tt> parameter with the special value <tt>\"_all_text\"</tt>:</p>\n<p>Use <tt>attr</tt> parameter to extract the data from an HTML/XML attribute.</p>\n<p>Use <tt>callback</tt> parameter to post-process extracted values.</p>\n<p>Example:</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">from</span> <span class=\"nn\">xextract</span> <span class=\"kn\">import</span> <span class=\"n\">String</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">String</span><span class=\"p\">(</span><span class=\"n\">css</span><span class=\"o\">=</span><span class=\"s1\">'span'</span><span class=\"p\">,</span> <span class=\"n\">quant</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"s1\">'&lt;span&gt;Hello &lt;b&gt;world&lt;/b&gt;!&lt;/span&gt;'</span><span class=\"p\">)</span>\n<span class=\"sa\">u</span><span class=\"s1\">'Hello !'</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">String</span><span class=\"p\">(</span><span class=\"n\">css</span><span class=\"o\">=</span><span class=\"s1\">'span'</span><span class=\"p\">,</span> <span class=\"n\">quant</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">attr</span><span class=\"o\">=</span><span class=\"s1\">'class'</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"s1\">'&lt;span class=\"text-success\"&gt;&lt;/span&gt;'</span><span class=\"p\">)</span>\n<span class=\"sa\">u</span><span class=\"s1\">'text-success'</span>\n\n<span class=\"c1\"># use special `attr` value `_all_text` to extract and concantenate text out of all descendants</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">String</span><span class=\"p\">(</span><span class=\"n\">css</span><span class=\"o\">=</span><span class=\"s1\">'span'</span><span class=\"p\">,</span> <span class=\"n\">quant</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">attr</span><span class=\"o\">=</span><span class=\"s1\">'_all_text'</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"s1\">'&lt;span&gt;Hello &lt;b&gt;world&lt;/b&gt;!&lt;/span&gt;'</span><span class=\"p\">)</span>\n<span class=\"sa\">u</span><span class=\"s1\">'Hello world!'</span>\n\n<span class=\"c1\"># use special `attr` value `_name` to extract tag name of the matched element</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">String</span><span class=\"p\">(</span><span class=\"n\">css</span><span class=\"o\">=</span><span class=\"s1\">'span'</span><span class=\"p\">,</span> <span class=\"n\">quant</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">attr</span><span class=\"o\">=</span><span class=\"s1\">'_name'</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"s1\">'&lt;span&gt;hello&lt;/span&gt;'</span><span class=\"p\">)</span>\n<span class=\"sa\">u</span><span class=\"s1\">'span'</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">String</span><span class=\"p\">(</span><span class=\"n\">css</span><span class=\"o\">=</span><span class=\"s1\">'span'</span><span class=\"p\">,</span> <span class=\"n\">callback</span><span class=\"o\">=</span><span class=\"nb\">int</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"s1\">'&lt;span&gt;1&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;'</span><span class=\"p\">)</span>\n<span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">]</span>\n</pre>\n</div>\n<div id=\"url\">\n<h3>Url</h3>\n<p><strong>Parameters</strong>: <a href=\"#name\" rel=\"nofollow\">name</a> (optional), <a href=\"#css-xpath\" rel=\"nofollow\">css / xpath</a> (optional, default <tt><span class=\"pre\">\"self::*\"</span></tt>), <a href=\"#quant\" rel=\"nofollow\">quant</a> (optional, default <tt>\"*\"</tt>), <a href=\"#attr\" rel=\"nofollow\">attr</a> (optional, default <tt>\"href\"</tt>), <a href=\"#callback\" rel=\"nofollow\">callback</a> (optional), <a href=\"#namespaces\" rel=\"nofollow\">namespaces</a> (optional)</p>\n<p>Behaves like <tt>String</tt> parser, but with two exceptions:</p>\n<ul>\n<li>default value for <tt>attr</tt> parameter is <tt>\"href\"</tt></li>\n<li>if you pass <tt>url</tt> parameter to <tt>parse()</tt> method, the absolute url will be constructed and returned</li>\n</ul>\n<p>If <tt>callback</tt> is specified, it is called <em>after</em> the absolute urls are constructed.</p>\n<p>Example:</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">from</span> <span class=\"nn\">xextract</span> <span class=\"kn\">import</span> <span class=\"n\">Url</span><span class=\"p\">,</span> <span class=\"n\">Prefix</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">content</span> <span class=\"o\">=</span> <span class=\"s1\">'&lt;div id=\"main\"&gt; &lt;a href=\"/test\"&gt;Link&lt;/a&gt; &lt;/div&gt;'</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">Url</span><span class=\"p\">(</span><span class=\"n\">css</span><span class=\"o\">=</span><span class=\"s1\">'a'</span><span class=\"p\">,</span> <span class=\"n\">quant</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"n\">content</span><span class=\"p\">)</span>\n<span class=\"sa\">u</span><span class=\"s1\">'/test'</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">Url</span><span class=\"p\">(</span><span class=\"n\">css</span><span class=\"o\">=</span><span class=\"s1\">'a'</span><span class=\"p\">,</span> <span class=\"n\">quant</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"n\">content</span><span class=\"p\">,</span> <span class=\"n\">url</span><span class=\"o\">=</span><span class=\"s1\">'http://github.com/Mimino666'</span><span class=\"p\">)</span>\n<span class=\"sa\">u</span><span class=\"s1\">'http://github.com/test'</span>  <span class=\"c1\"># absolute url address. Told ya!</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">Prefix</span><span class=\"p\">(</span><span class=\"n\">css</span><span class=\"o\">=</span><span class=\"s1\">'#main'</span><span class=\"p\">,</span> <span class=\"n\">children</span><span class=\"o\">=</span><span class=\"p\">[</span>\n<span class=\"o\">...</span>   <span class=\"n\">Url</span><span class=\"p\">(</span><span class=\"n\">css</span><span class=\"o\">=</span><span class=\"s1\">'a'</span><span class=\"p\">,</span> <span class=\"n\">quant</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n<span class=\"o\">...</span> <span class=\"p\">])</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"n\">content</span><span class=\"p\">,</span> <span class=\"n\">url</span><span class=\"o\">=</span><span class=\"s1\">'http://github.com/Mimino666'</span><span class=\"p\">)</span>  <span class=\"c1\"># you can pass url also to ancestor's parse(). It will propagate down.</span>\n<span class=\"sa\">u</span><span class=\"s1\">'http://github.com/test'</span>\n</pre>\n</div>\n<div id=\"datetime\">\n<h3>DateTime</h3>\n<p><strong>Parameters</strong>: <a href=\"#name\" rel=\"nofollow\">name</a> (optional), <a href=\"#css-xpath\" rel=\"nofollow\">css / xpath</a> (optional, default <tt><span class=\"pre\">\"self::*\"</span></tt>), <tt>format</tt> (<strong>required</strong>), <a href=\"#quant\" rel=\"nofollow\">quant</a> (optional, default <tt>\"*\"</tt>), <a href=\"#attr\" rel=\"nofollow\">attr</a> (optional, default <tt>\"_text\"</tt>), <a href=\"#callback\" rel=\"nofollow\">callback</a> (optional) <a href=\"#namespaces\" rel=\"nofollow\">namespaces</a> (optional)</p>\n<p>Returns the <tt>datetime.datetime</tt> object constructed out of the extracted data: <tt>datetime.strptime(extracted_data, format)</tt>.</p>\n<p><tt>format</tt> syntax is described in the <a href=\"https://docs.python.org/2/library/datetime.html#strftime-strptime-behavior\" rel=\"nofollow\">Python documentation</a>.</p>\n<p>If <tt>callback</tt> is specified, it is called <em>after</em> the datetime objects are constructed.</p>\n<p>Example:</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">from</span> <span class=\"nn\">xextract</span> <span class=\"kn\">import</span> <span class=\"n\">DateTime</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">DateTime</span><span class=\"p\">(</span><span class=\"n\">css</span><span class=\"o\">=</span><span class=\"s1\">'span'</span><span class=\"p\">,</span> <span class=\"n\">quant</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"nb\">format</span><span class=\"o\">=</span><span class=\"s1\">'</span><span class=\"si\">%d</span><span class=\"s1\">.%m.%Y %H:%M'</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"s1\">'&lt;span&gt;24.12.2015 5:30&lt;/span&gt;'</span><span class=\"p\">)</span>\n<span class=\"n\">datetime</span><span class=\"o\">.</span><span class=\"n\">datetime</span><span class=\"p\">(</span><span class=\"mi\">2015</span><span class=\"p\">,</span> <span class=\"mi\">12</span><span class=\"p\">,</span> <span class=\"mi\">24</span><span class=\"p\">,</span> <span class=\"mi\">50</span><span class=\"p\">,</span> <span class=\"mi\">30</span><span class=\"p\">)</span>\n</pre>\n</div>\n<div id=\"date\">\n<h3>Date</h3>\n<p><strong>Parameters</strong>: <a href=\"#name\" rel=\"nofollow\">name</a> (optional), <a href=\"#css-xpath\" rel=\"nofollow\">css / xpath</a> (optional, default <tt><span class=\"pre\">\"self::*\"</span></tt>), <tt>format</tt> (<strong>required</strong>), <a href=\"#quant\" rel=\"nofollow\">quant</a> (optional, default <tt>\"*\"</tt>), <a href=\"#attr\" rel=\"nofollow\">attr</a> (optional, default <tt>\"_text\"</tt>), <a href=\"#callback\" rel=\"nofollow\">callback</a> (optional) <a href=\"#namespaces\" rel=\"nofollow\">namespaces</a> (optional)</p>\n<p>Returns the <tt>datetime.date</tt> object constructed out of the extracted data: <tt>datetime.strptime(extracted_data, <span class=\"pre\">format).date()</span></tt>.</p>\n<p><tt>format</tt> syntax is described in the <a href=\"https://docs.python.org/2/library/datetime.html#strftime-strptime-behavior\" rel=\"nofollow\">Python documentation</a>.</p>\n<p>If <tt>callback</tt> is specified, it is called <em>after</em> the datetime objects are constructed.</p>\n<p>Example:</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">from</span> <span class=\"nn\">xextract</span> <span class=\"kn\">import</span> <span class=\"n\">Date</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">Date</span><span class=\"p\">(</span><span class=\"n\">css</span><span class=\"o\">=</span><span class=\"s1\">'span'</span><span class=\"p\">,</span> <span class=\"n\">quant</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"nb\">format</span><span class=\"o\">=</span><span class=\"s1\">'</span><span class=\"si\">%d</span><span class=\"s1\">.%m.%Y'</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"s1\">'&lt;span&gt;24.12.2015&lt;/span&gt;'</span><span class=\"p\">)</span>\n<span class=\"n\">datetime</span><span class=\"o\">.</span><span class=\"n\">date</span><span class=\"p\">(</span><span class=\"mi\">2015</span><span class=\"p\">,</span> <span class=\"mi\">12</span><span class=\"p\">,</span> <span class=\"mi\">24</span><span class=\"p\">)</span>\n</pre>\n</div>\n<div id=\"element\">\n<h3>Element</h3>\n<p><strong>Parameters</strong>: <a href=\"#name\" rel=\"nofollow\">name</a> (optional), <a href=\"#css-xpath\" rel=\"nofollow\">css / xpath</a> (optional, default <tt><span class=\"pre\">\"self::*\"</span></tt>), <a href=\"#quant\" rel=\"nofollow\">quant</a> (optional, default <tt>\"*\"</tt>), <a href=\"#callback\" rel=\"nofollow\">callback</a> (optional), <a href=\"#namespaces\" rel=\"nofollow\">namespaces</a> (optional)</p>\n<p>Returns lxml instance (<tt>lxml.etree._Element</tt>) of the matched element(s).\nIf you use xpath expression and match the text content of the element (e.g. <tt>text()</tt> or <tt>@attr</tt>), unicode is returned.</p>\n<p>If <tt>callback</tt> is specified, it is called with <tt>lxml.etree._Element</tt> instance.</p>\n<p>Example:</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">from</span> <span class=\"nn\">xextract</span> <span class=\"kn\">import</span> <span class=\"n\">Element</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">Element</span><span class=\"p\">(</span><span class=\"n\">css</span><span class=\"o\">=</span><span class=\"s1\">'span'</span><span class=\"p\">,</span> <span class=\"n\">quant</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"s1\">'&lt;span&gt;Hello&lt;/span&gt;'</span><span class=\"p\">)</span>\n<span class=\"o\">&lt;</span><span class=\"n\">Element</span> <span class=\"n\">span</span> <span class=\"n\">at</span> <span class=\"mh\">0x2ac2990</span><span class=\"o\">&gt;</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">Element</span><span class=\"p\">(</span><span class=\"n\">css</span><span class=\"o\">=</span><span class=\"s1\">'span'</span><span class=\"p\">,</span> <span class=\"n\">quant</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">callback</span><span class=\"o\">=</span><span class=\"k\">lambda</span> <span class=\"n\">el</span><span class=\"p\">:</span> <span class=\"n\">el</span><span class=\"o\">.</span><span class=\"n\">text</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"s1\">'&lt;span&gt;Hello&lt;/span&gt;'</span><span class=\"p\">)</span>\n<span class=\"sa\">u</span><span class=\"s1\">'Hello'</span>\n\n<span class=\"c1\"># same as above</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">Element</span><span class=\"p\">(</span><span class=\"n\">xpath</span><span class=\"o\">=</span><span class=\"s1\">'//span/text()'</span><span class=\"p\">,</span> <span class=\"n\">quant</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"s1\">'&lt;span&gt;Hello&lt;/span&gt;'</span><span class=\"p\">)</span>\n<span class=\"sa\">u</span><span class=\"s1\">'Hello'</span>\n</pre>\n</div>\n<div id=\"group\">\n<h3>Group</h3>\n<p><strong>Parameters</strong>: <a href=\"#name\" rel=\"nofollow\">name</a> (optional), <a href=\"#css-xpath\" rel=\"nofollow\">css / xpath</a> (optional, default <tt><span class=\"pre\">\"self::*\"</span></tt>), <a href=\"#children\" rel=\"nofollow\">children</a> (<strong>required</strong>), <a href=\"#quant\" rel=\"nofollow\">quant</a> (optional, default <tt>\"*\"</tt>), <a href=\"#callback\" rel=\"nofollow\">callback</a> (optional), <a href=\"#namespaces\" rel=\"nofollow\">namespaces</a> (optional)</p>\n<p>For each element matched by css/xpath selector returns the dictionary containing the data extracted by the parsers listed in <tt>children</tt> parameter.\nAll parsers listed in <tt>children</tt> parameter <strong>must</strong> have <tt>name</tt> specified - this is then used as the key in dictionary.</p>\n<p>Typical use case for this parser is when you want to parse structured data, e.g. list of user profiles, where each profile contains fields like name, address, etc. Use <tt>Group</tt> parser to group the fields of each user profile together.</p>\n<p>If <tt>callback</tt> is specified, it is called with the dictionary of parsed children values.</p>\n<p>Example:</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">from</span> <span class=\"nn\">xextract</span> <span class=\"kn\">import</span> <span class=\"n\">Group</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">content</span> <span class=\"o\">=</span> <span class=\"s1\">'&lt;ul&gt;&lt;li id=\"id1\"&gt;michal&lt;/li&gt; &lt;li id=\"id2\"&gt;peter&lt;/li&gt;&lt;/ul&gt;'</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">Group</span><span class=\"p\">(</span><span class=\"n\">css</span><span class=\"o\">=</span><span class=\"s1\">'li'</span><span class=\"p\">,</span> <span class=\"n\">quant</span><span class=\"o\">=</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"n\">children</span><span class=\"o\">=</span><span class=\"p\">[</span>\n<span class=\"o\">...</span>     <span class=\"n\">String</span><span class=\"p\">(</span><span class=\"n\">name</span><span class=\"o\">=</span><span class=\"s1\">'id'</span><span class=\"p\">,</span> <span class=\"n\">xpath</span><span class=\"o\">=</span><span class=\"s1\">'self::*'</span><span class=\"p\">,</span> <span class=\"n\">quant</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">attr</span><span class=\"o\">=</span><span class=\"s1\">'id'</span><span class=\"p\">),</span>\n<span class=\"o\">...</span>     <span class=\"n\">String</span><span class=\"p\">(</span><span class=\"n\">name</span><span class=\"o\">=</span><span class=\"s1\">'name'</span><span class=\"p\">,</span> <span class=\"n\">xpath</span><span class=\"o\">=</span><span class=\"s1\">'self::*'</span><span class=\"p\">,</span> <span class=\"n\">quant</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n<span class=\"o\">...</span> <span class=\"p\">])</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"n\">content</span><span class=\"p\">)</span>\n<span class=\"p\">[{</span><span class=\"s1\">'name'</span><span class=\"p\">:</span> <span class=\"sa\">u</span><span class=\"s1\">'michal'</span><span class=\"p\">,</span> <span class=\"s1\">'id'</span><span class=\"p\">:</span> <span class=\"sa\">u</span><span class=\"s1\">'id1'</span><span class=\"p\">},</span>\n <span class=\"p\">{</span><span class=\"s1\">'name'</span><span class=\"p\">:</span> <span class=\"sa\">u</span><span class=\"s1\">'peter'</span><span class=\"p\">,</span> <span class=\"s1\">'id'</span><span class=\"p\">:</span> <span class=\"sa\">u</span><span class=\"s1\">'id2'</span><span class=\"p\">}]</span>\n</pre>\n</div>\n<div id=\"prefix\">\n<h3>Prefix</h3>\n<p><strong>Parameters</strong>: <a href=\"#css-xpath\" rel=\"nofollow\">css / xpath</a> (optional, default <tt><span class=\"pre\">\"self::*\"</span></tt>), <a href=\"#children\" rel=\"nofollow\">children</a> (<strong>required</strong>), <a href=\"#namespaces\" rel=\"nofollow\">namespaces</a> (optional)</p>\n<p>This parser doesn\u2019t actually parse any data on its own. Instead you can use it, when many of your parsers share the same css/xpath selector prefix.</p>\n<p><tt>Prefix</tt> parser always returns a single dictionary containing the data extracted by the parsers listed in <tt>children</tt> parameter.\nAll parsers listed in <tt>children</tt> parameter <strong>must</strong> have <tt>name</tt> specified - this is then used as the key in dictionary.</p>\n<p>Example:</p>\n<pre><span class=\"c1\"># instead of...</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">String</span><span class=\"p\">(</span><span class=\"n\">css</span><span class=\"o\">=</span><span class=\"s1\">'#main .name'</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"o\">...</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">String</span><span class=\"p\">(</span><span class=\"n\">css</span><span class=\"o\">=</span><span class=\"s1\">'#main .date'</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"o\">...</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># ...you can use</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">from</span> <span class=\"nn\">xextract</span> <span class=\"kn\">import</span> <span class=\"n\">Prefix</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">Prefix</span><span class=\"p\">(</span><span class=\"n\">css</span><span class=\"o\">=</span><span class=\"s1\">'#main'</span><span class=\"p\">,</span> <span class=\"n\">children</span><span class=\"o\">=</span><span class=\"p\">[</span>\n<span class=\"o\">...</span>   <span class=\"n\">String</span><span class=\"p\">(</span><span class=\"n\">name</span><span class=\"o\">=</span><span class=\"s2\">\"name\"</span><span class=\"p\">,</span> <span class=\"n\">css</span><span class=\"o\">=</span><span class=\"s1\">'.name'</span><span class=\"p\">),</span>\n<span class=\"o\">...</span>   <span class=\"n\">String</span><span class=\"p\">(</span><span class=\"n\">name</span><span class=\"o\">=</span><span class=\"s2\">\"date\"</span><span class=\"p\">,</span> <span class=\"n\">css</span><span class=\"o\">=</span><span class=\"s1\">'.date'</span><span class=\"p\">)</span>\n<span class=\"o\">...</span> <span class=\"p\">])</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"o\">...</span><span class=\"p\">)</span>\n</pre>\n</div>\n</div>\n<div id=\"parser-parameters\">\n<h2>Parser parameters</h2>\n<div id=\"name\">\n<h3>name</h3>\n<p><strong>Parsers</strong>: <a href=\"#string\" rel=\"nofollow\">String</a>, <a href=\"#url\" rel=\"nofollow\">Url</a>, <a href=\"#datetime\" rel=\"nofollow\">DateTime</a>, <a href=\"#date\" rel=\"nofollow\">Date</a>, <a href=\"#element\" rel=\"nofollow\">Element</a>, <a href=\"#group\" rel=\"nofollow\">Group</a></p>\n<p><strong>Default value</strong>: <tt>None</tt></p>\n<p>If specified, then the extracted data will be returned in a dictionary, with the <tt>name</tt> as the key and the data as the value.</p>\n<p>All parsers listed in <tt>children</tt> parameter of <tt>Group</tt> or <tt>Prefix</tt> parser <strong>must</strong> have <tt>name</tt> specified.\nIf multiple children parsers have the same <tt>name</tt>, the behavior is undefined.</p>\n<p>Example:</p>\n<pre><span class=\"c1\"># when `name` is not specified, raw value is returned</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">String</span><span class=\"p\">(</span><span class=\"n\">css</span><span class=\"o\">=</span><span class=\"s1\">'span'</span><span class=\"p\">,</span> <span class=\"n\">quant</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"s1\">'&lt;span&gt;Hello!&lt;/span&gt;'</span><span class=\"p\">)</span>\n<span class=\"sa\">u</span><span class=\"s1\">'Hello!'</span>\n\n<span class=\"c1\"># when `name` is specified, dictionary is returned with `name` as the key</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">String</span><span class=\"p\">(</span><span class=\"n\">name</span><span class=\"o\">=</span><span class=\"s1\">'message'</span><span class=\"p\">,</span> <span class=\"n\">css</span><span class=\"o\">=</span><span class=\"s1\">'span'</span><span class=\"p\">,</span> <span class=\"n\">quant</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"s1\">'&lt;span&gt;Hello!&lt;/span&gt;'</span><span class=\"p\">)</span>\n<span class=\"p\">{</span><span class=\"s1\">'message'</span><span class=\"p\">:</span> <span class=\"sa\">u</span><span class=\"s1\">'Hello!'</span><span class=\"p\">}</span>\n</pre>\n</div>\n<div id=\"css-xpath\">\n<h3>css / xpath</h3>\n<p><strong>Parsers</strong>: <a href=\"#string\" rel=\"nofollow\">String</a>, <a href=\"#url\" rel=\"nofollow\">Url</a>, <a href=\"#datetime\" rel=\"nofollow\">DateTime</a>, <a href=\"#date\" rel=\"nofollow\">Date</a>, <a href=\"#element\" rel=\"nofollow\">Element</a>, <a href=\"#group\" rel=\"nofollow\">Group</a>, <a href=\"#prefix\" rel=\"nofollow\">Prefix</a></p>\n<p><strong>Default value (xpath)</strong>: <tt><span class=\"pre\">\"self::*\"</span></tt></p>\n<p>Use either <tt>css</tt> or <tt>xpath</tt> parameter (but not both) to select the elements from which to extract the data.</p>\n<p>Under the hood css selectors are translated into equivalent xpath selectors.</p>\n<p>For the children of <tt>Prefix</tt> or <tt>Group</tt> parsers, the elements are selected relative to the elements matched by the parent parser.</p>\n<p>Example:</p>\n<pre><span class=\"n\">Prefix</span><span class=\"p\">(</span><span class=\"n\">xpath</span><span class=\"o\">=</span><span class=\"s1\">'//*[@id=\"profile\"]'</span><span class=\"p\">,</span> <span class=\"n\">children</span><span class=\"o\">=</span><span class=\"p\">[</span>\n    <span class=\"c1\"># equivalent to: //*[@id=\"profile\"]/descendant-or-self::*[@class=\"name\"]</span>\n    <span class=\"n\">String</span><span class=\"p\">(</span><span class=\"n\">name</span><span class=\"o\">=</span><span class=\"s1\">'name'</span><span class=\"p\">,</span> <span class=\"n\">css</span><span class=\"o\">=</span><span class=\"s1\">'.name'</span><span class=\"p\">,</span> <span class=\"n\">quant</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">),</span>\n\n    <span class=\"c1\"># equivalent to: //*[@id=\"profile\"]/*[@class=\"title\"]</span>\n    <span class=\"n\">String</span><span class=\"p\">(</span><span class=\"n\">name</span><span class=\"o\">=</span><span class=\"s1\">'title'</span><span class=\"p\">,</span> <span class=\"n\">xpath</span><span class=\"o\">=</span><span class=\"s1\">'*[@class=\"title\"]'</span><span class=\"p\">,</span> <span class=\"n\">quant</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">),</span>\n\n    <span class=\"c1\"># equivalent to: //*[@class=\"subtitle\"]</span>\n    <span class=\"n\">String</span><span class=\"p\">(</span><span class=\"n\">name</span><span class=\"o\">=</span><span class=\"s1\">'subtitle'</span><span class=\"p\">,</span> <span class=\"n\">xpath</span><span class=\"o\">=</span><span class=\"s1\">'//*[@class=\"subtitle\"]'</span><span class=\"p\">,</span> <span class=\"n\">quant</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n<span class=\"p\">])</span>\n</pre>\n</div>\n<div id=\"quant\">\n<h3>quant</h3>\n<p><strong>Parsers</strong>: <a href=\"#string\" rel=\"nofollow\">String</a>, <a href=\"#url\" rel=\"nofollow\">Url</a>, <a href=\"#datetime\" rel=\"nofollow\">DateTime</a>, <a href=\"#date\" rel=\"nofollow\">Date</a>, <a href=\"#element\" rel=\"nofollow\">Element</a>, <a href=\"#group\" rel=\"nofollow\">Group</a></p>\n<p><strong>Default value</strong>: <tt>\"*\"</tt></p>\n<p><tt>quant</tt> specifies the expected number of elements to be matched with css/xpath selector. It serves two purposes:</p>\n<ol>\n<li>Number of matched elements is checked against the <tt>quant</tt> parameter. If the number of elements doesn\u2019t match the expected quantity, <tt>xextract.parsers.ParsingError</tt> exception is raised. This way you will be notified, when the website has changed its structure.</li>\n<li>It tells the parser whether to return a single extracted value or a list of values. See the table below.</li>\n</ol>\n<p>Syntax for <tt>quant</tt> mimics the regular expressions.\nYou can either pass the value as a string, single integer or tuple of two integers.</p>\n<p>Depending on the value of <tt>quant</tt>, the parser returns either a single extracted value or a list of values.</p>\n<table>\n<colgroup>\n<col>\n<col>\n<col>\n</colgroup>\n<thead>\n<tr><th>Value of <tt>quant</tt></th>\n<th>Meaning</th>\n<th>Extracted data</th>\n</tr>\n</thead>\n<tbody>\n<tr><td><tt>\"*\"</tt> (default)</td>\n<td>Zero or more elements.</td>\n<td>List of values</td>\n</tr>\n<tr><td><tt>\"+\"</tt></td>\n<td>One or more elements.</td>\n<td>List of values</td>\n</tr>\n<tr><td><tt><span class=\"pre\">\"?\"</span></tt></td>\n<td>Zero or one element.</td>\n<td>Single value or <tt>None</tt></td>\n</tr>\n<tr><td><tt>num</tt></td>\n<td><p>Exactly <tt>num</tt> elements.</p>\n<p>You can pass either string or integer.</p>\n</td>\n<td><p><tt>num</tt> == 0: <tt>None</tt></p>\n<p><tt>num</tt> == 1: Single value</p>\n<p><tt>num</tt> &gt; 1: List of values</p>\n</td>\n</tr>\n<tr><td><tt>(num1, num2)</tt></td>\n<td><p>Number of elements has to be between\n<tt>num1</tt> and <tt>num2</tt>, inclusive.</p>\n<p>You can pass either a string or 2-tuple.</p>\n</td>\n<td>List of values</td>\n</tr>\n</tbody>\n</table>\n<p>Example:</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">String</span><span class=\"p\">(</span><span class=\"n\">css</span><span class=\"o\">=</span><span class=\"s1\">'.full-name'</span><span class=\"p\">,</span> <span class=\"n\">quant</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"n\">content</span><span class=\"p\">)</span>  <span class=\"c1\"># return single value</span>\n<span class=\"sa\">u</span><span class=\"s1\">'John Rambo'</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">String</span><span class=\"p\">(</span><span class=\"n\">css</span><span class=\"o\">=</span><span class=\"s1\">'.full-name'</span><span class=\"p\">,</span> <span class=\"n\">quant</span><span class=\"o\">=</span><span class=\"s1\">'1'</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"n\">content</span><span class=\"p\">)</span>  <span class=\"c1\"># same as above</span>\n<span class=\"sa\">u</span><span class=\"s1\">'John Rambo'</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">String</span><span class=\"p\">(</span><span class=\"n\">css</span><span class=\"o\">=</span><span class=\"s1\">'.full-name'</span><span class=\"p\">,</span> <span class=\"n\">quant</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">2</span><span class=\"p\">))</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"n\">content</span><span class=\"p\">)</span>  <span class=\"c1\"># return list of values</span>\n<span class=\"p\">[</span><span class=\"sa\">u</span><span class=\"s1\">'John Rambo'</span><span class=\"p\">]</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">String</span><span class=\"p\">(</span><span class=\"n\">css</span><span class=\"o\">=</span><span class=\"s1\">'.full-name'</span><span class=\"p\">,</span> <span class=\"n\">quant</span><span class=\"o\">=</span><span class=\"s1\">'1,2'</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"n\">content</span><span class=\"p\">)</span>  <span class=\"c1\"># same as above</span>\n<span class=\"p\">[</span><span class=\"sa\">u</span><span class=\"s1\">'John Rambo'</span><span class=\"p\">]</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">String</span><span class=\"p\">(</span><span class=\"n\">css</span><span class=\"o\">=</span><span class=\"s1\">'.middle-name'</span><span class=\"p\">,</span> <span class=\"n\">quant</span><span class=\"o\">=</span><span class=\"s1\">'?'</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"n\">content</span><span class=\"p\">)</span>  <span class=\"c1\"># return single value or None</span>\n<span class=\"kc\">None</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">String</span><span class=\"p\">(</span><span class=\"n\">css</span><span class=\"o\">=</span><span class=\"s1\">'.job-titles'</span><span class=\"p\">,</span> <span class=\"n\">quant</span><span class=\"o\">=</span><span class=\"s1\">'+'</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"n\">content</span><span class=\"p\">)</span>  <span class=\"c1\"># return list of values</span>\n<span class=\"p\">[</span><span class=\"sa\">u</span><span class=\"s1\">'President'</span><span class=\"p\">,</span> <span class=\"sa\">u</span><span class=\"s1\">'US Senator'</span><span class=\"p\">,</span> <span class=\"sa\">u</span><span class=\"s1\">'State Senator'</span><span class=\"p\">,</span> <span class=\"sa\">u</span><span class=\"s1\">'Senior Lecturer in Law'</span><span class=\"p\">]</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">String</span><span class=\"p\">(</span><span class=\"n\">css</span><span class=\"o\">=</span><span class=\"s1\">'.friends'</span><span class=\"p\">,</span> <span class=\"n\">quant</span><span class=\"o\">=</span><span class=\"s1\">'*'</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"n\">content</span><span class=\"p\">)</span>  <span class=\"c1\"># return possibly empty list of values</span>\n<span class=\"p\">[]</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">String</span><span class=\"p\">(</span><span class=\"n\">css</span><span class=\"o\">=</span><span class=\"s1\">'.friends'</span><span class=\"p\">,</span> <span class=\"n\">quant</span><span class=\"o\">=</span><span class=\"s1\">'+'</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"n\">content</span><span class=\"p\">)</span>  <span class=\"c1\"># raise exception, when no elements are matched</span>\n<span class=\"n\">xextract</span><span class=\"o\">.</span><span class=\"n\">parsers</span><span class=\"o\">.</span><span class=\"n\">ParsingError</span><span class=\"p\">:</span> <span class=\"n\">Parser</span> <span class=\"n\">String</span> <span class=\"n\">matched</span> <span class=\"mi\">0</span> <span class=\"n\">elements</span> <span class=\"p\">(</span><span class=\"s2\">\"+\"</span> <span class=\"n\">expected</span><span class=\"p\">)</span><span class=\"o\">.</span>\n</pre>\n</div>\n<div id=\"attr\">\n<h3>attr</h3>\n<p><strong>Parsers</strong>: <a href=\"#string\" rel=\"nofollow\">String</a>, <a href=\"#url\" rel=\"nofollow\">Url</a>, <a href=\"#datetime\" rel=\"nofollow\">DateTime</a>, <a href=\"#date\" rel=\"nofollow\">Date</a></p>\n<p><strong>Default value</strong>: <tt>\"href\"</tt> for <tt>Url</tt> parser. <tt>\"_text\"</tt> otherwise.</p>\n<p>Use <tt>attr</tt> parameter to specify what data to extract from the matched element.</p>\n<table>\n<colgroup>\n<col>\n<col>\n</colgroup>\n<thead>\n<tr><th>Value of <tt>attr</tt></th>\n<th>Meaning</th>\n</tr>\n</thead>\n<tbody>\n<tr><td><tt>\"_text\"</tt></td>\n<td>Extract the text content of the matched element.</td>\n</tr>\n<tr><td><tt>\"_all_text\"</tt></td>\n<td>Extract and concatenate the text content of\nthe matched element and all its descendants.</td>\n</tr>\n<tr><td><tt>\"_name\"</tt></td>\n<td>Extract tag name of the matched element.</td>\n</tr>\n<tr><td><tt>att_name</tt></td>\n<td><p>Extract the value out of <tt>att_name</tt> attribute of\nthe matched element.</p>\n<p>If such attribute doesn\u2019t exist, empty string is\nreturned.</p>\n</td>\n</tr>\n</tbody>\n</table>\n<p>Example:</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">from</span> <span class=\"nn\">xextract</span> <span class=\"kn\">import</span> <span class=\"n\">String</span><span class=\"p\">,</span> <span class=\"n\">Url</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">content</span> <span class=\"o\">=</span> <span class=\"s1\">'&lt;span class=\"name\"&gt;Barack &lt;strong&gt;Obama&lt;/strong&gt; III.&lt;/span&gt; &lt;a href=\"/test\"&gt;Link&lt;/a&gt;'</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">String</span><span class=\"p\">(</span><span class=\"n\">css</span><span class=\"o\">=</span><span class=\"s1\">'.name'</span><span class=\"p\">,</span> <span class=\"n\">quant</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"n\">content</span><span class=\"p\">)</span>  <span class=\"c1\"># default attr is \"_text\"</span>\n<span class=\"sa\">u</span><span class=\"s1\">'Barack  III.'</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">String</span><span class=\"p\">(</span><span class=\"n\">css</span><span class=\"o\">=</span><span class=\"s1\">'.name'</span><span class=\"p\">,</span> <span class=\"n\">quant</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">attr</span><span class=\"o\">=</span><span class=\"s1\">'_text'</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"n\">content</span><span class=\"p\">)</span>  <span class=\"c1\"># same as above</span>\n<span class=\"sa\">u</span><span class=\"s1\">'Barack  III.'</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">String</span><span class=\"p\">(</span><span class=\"n\">css</span><span class=\"o\">=</span><span class=\"s1\">'.name'</span><span class=\"p\">,</span> <span class=\"n\">quant</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">attr</span><span class=\"o\">=</span><span class=\"s1\">'_all_text'</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"n\">content</span><span class=\"p\">)</span>  <span class=\"c1\"># all text</span>\n<span class=\"sa\">u</span><span class=\"s1\">'Barack Obama III.'</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">String</span><span class=\"p\">(</span><span class=\"n\">css</span><span class=\"o\">=</span><span class=\"s1\">'.name'</span><span class=\"p\">,</span> <span class=\"n\">quant</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">attr</span><span class=\"o\">=</span><span class=\"s1\">'_name'</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"n\">content</span><span class=\"p\">)</span>  <span class=\"c1\"># tag name</span>\n<span class=\"sa\">u</span><span class=\"s1\">'span'</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">Url</span><span class=\"p\">(</span><span class=\"n\">css</span><span class=\"o\">=</span><span class=\"s1\">'a'</span><span class=\"p\">,</span> <span class=\"n\">quant</span><span class=\"o\">=</span><span class=\"s1\">'1'</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"n\">content</span><span class=\"p\">)</span>  <span class=\"c1\"># Url extracts href by default</span>\n<span class=\"sa\">u</span><span class=\"s1\">'/test'</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">String</span><span class=\"p\">(</span><span class=\"n\">css</span><span class=\"o\">=</span><span class=\"s1\">'a'</span><span class=\"p\">,</span> <span class=\"n\">quant</span><span class=\"o\">=</span><span class=\"s1\">'1'</span><span class=\"p\">,</span> <span class=\"n\">attr</span><span class=\"o\">=</span><span class=\"s1\">'id'</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"n\">content</span><span class=\"p\">)</span>  <span class=\"c1\"># non-existent attributes return empty string</span>\n<span class=\"sa\">u</span><span class=\"s1\">''</span>\n</pre>\n</div>\n<div id=\"callback\">\n<h3>callback</h3>\n<p><strong>Parsers</strong>: <a href=\"#string\" rel=\"nofollow\">String</a>, <a href=\"#url\" rel=\"nofollow\">Url</a>, <a href=\"#datetime\" rel=\"nofollow\">DateTime</a>, <a href=\"#date\" rel=\"nofollow\">Date</a>, <a href=\"#element\" rel=\"nofollow\">Element</a>, <a href=\"#group\" rel=\"nofollow\">Group</a></p>\n<p>Provides an easy way to post-process extracted values.\nIt should be a function that takes a single argument, the extracted value, and returns the postprocessed value.</p>\n<p>Example:</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">String</span><span class=\"p\">(</span><span class=\"n\">css</span><span class=\"o\">=</span><span class=\"s1\">'span'</span><span class=\"p\">,</span> <span class=\"n\">callback</span><span class=\"o\">=</span><span class=\"nb\">int</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"s1\">'&lt;span&gt;1&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;'</span><span class=\"p\">)</span>\n<span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">]</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">Element</span><span class=\"p\">(</span><span class=\"n\">css</span><span class=\"o\">=</span><span class=\"s1\">'span'</span><span class=\"p\">,</span> <span class=\"n\">quant</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">callback</span><span class=\"o\">=</span><span class=\"k\">lambda</span> <span class=\"n\">el</span><span class=\"p\">:</span> <span class=\"n\">el</span><span class=\"o\">.</span><span class=\"n\">text</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"s1\">'&lt;span&gt;Hello&lt;/span&gt;'</span><span class=\"p\">)</span>\n<span class=\"sa\">u</span><span class=\"s1\">'Hello'</span>\n</pre>\n</div>\n<div id=\"children\">\n<h3>children</h3>\n<p><strong>Parsers</strong>: <a href=\"#group\" rel=\"nofollow\">Group</a>, <a href=\"#prefix\" rel=\"nofollow\">Prefix</a></p>\n<p>Specifies the children parsers for the <tt>Group</tt> and <tt>Prefix</tt> parsers.\nAll parsers listed in <tt>children</tt> parameter <strong>must</strong> have <tt>name</tt> specified</p>\n<p>Css/xpath selectors in the children parsers are relative to the selectors specified in the parent parser.</p>\n<p>Example:</p>\n<pre><span class=\"n\">Prefix</span><span class=\"p\">(</span><span class=\"n\">xpath</span><span class=\"o\">=</span><span class=\"s1\">'//*[@id=\"profile\"]'</span><span class=\"p\">,</span> <span class=\"n\">children</span><span class=\"o\">=</span><span class=\"p\">[</span>\n    <span class=\"c1\"># equivalent to: //*[@id=\"profile\"]/descendant-or-self::*[@class=\"name\"]</span>\n    <span class=\"n\">String</span><span class=\"p\">(</span><span class=\"n\">name</span><span class=\"o\">=</span><span class=\"s1\">'name'</span><span class=\"p\">,</span> <span class=\"n\">css</span><span class=\"o\">=</span><span class=\"s1\">'.name'</span><span class=\"p\">,</span> <span class=\"n\">quant</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">),</span>\n\n    <span class=\"c1\"># equivalent to: //*[@id=\"profile\"]/*[@class=\"title\"]</span>\n    <span class=\"n\">String</span><span class=\"p\">(</span><span class=\"n\">name</span><span class=\"o\">=</span><span class=\"s1\">'title'</span><span class=\"p\">,</span> <span class=\"n\">xpath</span><span class=\"o\">=</span><span class=\"s1\">'*[@class=\"title\"]'</span><span class=\"p\">,</span> <span class=\"n\">quant</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">),</span>\n\n    <span class=\"c1\"># equivalent to: //*[@class=\"subtitle\"]</span>\n    <span class=\"n\">String</span><span class=\"p\">(</span><span class=\"n\">name</span><span class=\"o\">=</span><span class=\"s1\">'subtitle'</span><span class=\"p\">,</span> <span class=\"n\">xpath</span><span class=\"o\">=</span><span class=\"s1\">'//*[@class=\"subtitle\"]'</span><span class=\"p\">,</span> <span class=\"n\">quant</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n<span class=\"p\">])</span>\n</pre>\n</div>\n<div id=\"namespaces\">\n<h3>namespaces</h3>\n<p><strong>Parsers</strong>: <a href=\"#string\" rel=\"nofollow\">String</a>, <a href=\"#url\" rel=\"nofollow\">Url</a>, <a href=\"#datetime\" rel=\"nofollow\">DateTime</a>, <a href=\"#date\" rel=\"nofollow\">Date</a>, <a href=\"#element\" rel=\"nofollow\">Element</a>, <a href=\"#group\" rel=\"nofollow\">Group</a>, <a href=\"#prefix\" rel=\"nofollow\">Prefix</a></p>\n<p>When parsing XML documents containing namespace prefixes, pass the dictionary mapping namespace prefixes to namespace URIs.\nUse then full name for elements in xpath selector in the form <tt>\"prefix:element\"</tt></p>\n<p>As for the moment, you <strong>cannot use default namespace</strong> for parsing (see <a href=\"http://lxml.de/FAQ.html#how-can-i-specify-a-default-namespace-for-xpath-expressions\" rel=\"nofollow\">lxml docs</a> for more information).  Just use an arbitrary prefix.</p>\n<p>Example:</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">content</span> <span class=\"o\">=</span> <span class=\"s1\">'''&lt;?xml version='1.0' encoding='UTF-8'?&gt;\n... &lt;movie xmlns=\"http://imdb.com/ns/\"&gt;\n...   &lt;title&gt;The Shawshank Redemption&lt;/title&gt;\n...   &lt;year&gt;1994&lt;/year&gt;\n... &lt;/movie&gt;'''</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">nsmap</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"s1\">'imdb'</span><span class=\"p\">:</span> <span class=\"s1\">'http://imdb.com/ns/'</span><span class=\"p\">}</span>  <span class=\"c1\"># use arbitrary prefix for default namespace</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">Prefix</span><span class=\"p\">(</span><span class=\"n\">xpath</span><span class=\"o\">=</span><span class=\"s1\">'//imdb:movie'</span><span class=\"p\">,</span> <span class=\"n\">namespaces</span><span class=\"o\">=</span><span class=\"n\">nsmap</span><span class=\"p\">,</span> <span class=\"n\">children</span><span class=\"o\">=</span><span class=\"p\">[</span>  <span class=\"c1\"># pass namespaces to the outermost parser</span>\n<span class=\"o\">...</span>   <span class=\"n\">String</span><span class=\"p\">(</span><span class=\"n\">name</span><span class=\"o\">=</span><span class=\"s1\">'title'</span><span class=\"p\">,</span> <span class=\"n\">xpath</span><span class=\"o\">=</span><span class=\"s1\">'imdb:title'</span><span class=\"p\">,</span> <span class=\"n\">quant</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">),</span>\n<span class=\"o\">...</span>   <span class=\"n\">String</span><span class=\"p\">(</span><span class=\"n\">name</span><span class=\"o\">=</span><span class=\"s1\">'year'</span><span class=\"p\">,</span> <span class=\"n\">xpath</span><span class=\"o\">=</span><span class=\"s1\">'imdb:year'</span><span class=\"p\">,</span> <span class=\"n\">quant</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n<span class=\"o\">...</span> <span class=\"p\">])</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"n\">content</span><span class=\"p\">)</span>\n<span class=\"p\">{</span><span class=\"s1\">'title'</span><span class=\"p\">:</span> <span class=\"sa\">u</span><span class=\"s1\">'The Shawshank Redemption'</span><span class=\"p\">,</span> <span class=\"s1\">'year'</span><span class=\"p\">:</span> <span class=\"sa\">u</span><span class=\"s1\">'1994'</span><span class=\"p\">}</span>\n</pre>\n</div>\n</div>\n<div id=\"html-vs-xml-parsing\">\n<h2>HTML vs. XML parsing</h2>\n<p>To extract data from HTML or XML document, simply call <tt>parse()</tt> method of the parser:</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">from</span> <span class=\"nn\">xextract</span> <span class=\"kn\">import</span> <span class=\"o\">*</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">parser</span> <span class=\"o\">=</span> <span class=\"n\">Prefix</span><span class=\"p\">(</span><span class=\"o\">...</span><span class=\"p\">,</span> <span class=\"n\">children</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"o\">...</span><span class=\"p\">])</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">extracted_data</span> <span class=\"o\">=</span> <span class=\"n\">parser</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"n\">content</span><span class=\"p\">)</span>\n</pre>\n<p><tt>content</tt> can be either string or unicode, containing the content of the document.</p>\n<p>Under the hood <strong>xextact</strong> uses either <tt>lxml.etree.XMLParser</tt> or <tt>lxml.etree.HTMLParser</tt> to parse the document.\nTo select the parser, <strong>xextract</strong> looks for <tt><span class=\"pre\">\"&lt;?xml\"</span></tt> string in the first 128 bytes of the document. If it is found, then <tt>XMLParser</tt> is used.</p>\n<p>To force either of the parsers, you can call <tt>parse_html()</tt> or <tt>parse_xml()</tt> method:</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">parser</span><span class=\"o\">.</span><span class=\"n\">parse_html</span><span class=\"p\">(</span><span class=\"n\">content</span><span class=\"p\">)</span>  <span class=\"c1\"># force lxml.etree.HTMLParser</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">parser</span><span class=\"o\">.</span><span class=\"n\">parse_xml</span><span class=\"p\">(</span><span class=\"n\">content</span><span class=\"p\">)</span>   <span class=\"c1\"># force lxml.etree.XMLParser</span>\n</pre>\n</div>\n\n          </div>"}, "last_serial": 6761524, "releases": {"0.0.1": [{"comment_text": "", "digests": {"md5": "dc89b6e5cb9324e656381db1063785bc", "sha256": "1c9864066ca47ed246c76c5ff864f39dc7cd29fa363c7f37bb8fc480c858ad0a"}, "downloads": -1, "filename": "xextract-0.0.1.win32.exe", "has_sig": false, "md5_digest": "dc89b6e5cb9324e656381db1063785bc", "packagetype": "bdist_wininst", "python_version": "any", "requires_python": null, "size": 202622, "upload_time": "2015-02-01T01:33:02", "upload_time_iso_8601": "2015-02-01T01:33:02.768669Z", "url": "https://files.pythonhosted.org/packages/50/32/b5e615d2cd951bb9df2f7d41fca2ed19cc5e608867038cd67fea24b0e1bf/xextract-0.0.1.win32.exe", "yanked": false}, {"comment_text": "", "digests": {"md5": "92dd25a9a99325989f0284d30da6a547", "sha256": "daea8083a29975fa9c403f0a0748df26b879ea96e61ac5b2c647b1c277f54486"}, "downloads": -1, "filename": "xextract-0.0.1.zip", "has_sig": false, "md5_digest": "92dd25a9a99325989f0284d30da6a547", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 8552, "upload_time": "2015-02-01T01:32:57", "upload_time_iso_8601": "2015-02-01T01:32:57.616230Z", "url": "https://files.pythonhosted.org/packages/3e/40/800a68d655ef114e0037056bcac3f00d594ce517fd8fde41ae47efea04d2/xextract-0.0.1.zip", "yanked": false}], "0.0.2": [{"comment_text": "", "digests": {"md5": "4d44d59187cb65862fadb37b17fb006b", "sha256": "0d05e09b7f3997d2a7d080a07060f3758cf2a04c326f58591349524f78c3be0e"}, "downloads": -1, "filename": "xextract-0.0.2.zip", "has_sig": false, "md5_digest": "4d44d59187cb65862fadb37b17fb006b", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 23158, "upload_time": "2015-03-24T11:54:05", "upload_time_iso_8601": "2015-03-24T11:54:05.767939Z", "url": "https://files.pythonhosted.org/packages/4e/8c/057ceac6a84d6202a019db6fad395ca23039e77e70c9aeb33e783cca440e/xextract-0.0.2.zip", "yanked": false}], "0.0.3": [{"comment_text": "", "digests": {"md5": "49323798d35016ed03931c6a3fae4ead", "sha256": "117a5f1f886da48b467165001977a954086e792b553690a28f99af00a559e9a5"}, "downloads": -1, "filename": "xextract-0.0.3.zip", "has_sig": false, "md5_digest": "49323798d35016ed03931c6a3fae4ead", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 23168, "upload_time": "2015-05-23T00:53:10", "upload_time_iso_8601": "2015-05-23T00:53:10.447846Z", "url": "https://files.pythonhosted.org/packages/71/56/469fe82b1a8e0fcfbd6d6c11508f18e8e85ae3b6bd2c604e38a2ccfbf27e/xextract-0.0.3.zip", "yanked": false}], "0.0.4": [{"comment_text": "", "digests": {"md5": "eb7424b3872029ce2df115db63a10858", "sha256": "a7db8e4f6df9f4b3c328908ac28f436696f19b63b762b2023f5ec3a4d20715c5"}, "downloads": -1, "filename": "xextract-0.0.4.zip", "has_sig": false, "md5_digest": "eb7424b3872029ce2df115db63a10858", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 23199, "upload_time": "2015-08-10T17:35:24", "upload_time_iso_8601": "2015-08-10T17:35:24.589324Z", "url": "https://files.pythonhosted.org/packages/c7/4e/bb288da2af6c4952235df24c719fb59aa13b9e3a36bfe43e381602ff001e/xextract-0.0.4.zip", "yanked": false}], "0.0.5": [], "0.0.6": [{"comment_text": "", "digests": {"md5": "181ea46096fc1df16d53dc461deaa66e", "sha256": "b84d5a29ed7507b6bb0a259949717c3a226e61736854b1fa2d3bd599da7eb538"}, "downloads": -1, "filename": "xextract-0.0.6.zip", "has_sig": false, "md5_digest": "181ea46096fc1df16d53dc461deaa66e", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 23226, "upload_time": "2016-01-20T12:50:20", "upload_time_iso_8601": "2016-01-20T12:50:20.329193Z", "url": "https://files.pythonhosted.org/packages/6f/cb/be18a5aee53dd48ed4d6d239ddce6bc16fee986af0c2ce8cf148e266808d/xextract-0.0.6.zip", "yanked": false}], "0.0.7": [{"comment_text": "", "digests": {"md5": "9118cffa28c47b9a7bca43bbf6763ed1", "sha256": "92e025d67717e18e12af248aa5c2b1c1c0f667790927e5a68c92b45c81f3e36d"}, "downloads": -1, "filename": "xextract-0.0.7.zip", "has_sig": false, "md5_digest": "9118cffa28c47b9a7bca43bbf6763ed1", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 23214, "upload_time": "2016-02-19T06:02:08", "upload_time_iso_8601": "2016-02-19T06:02:08.986249Z", "url": "https://files.pythonhosted.org/packages/c2/3d/b3d4ef596fc937d8d098aafbd532530e6c73fbc28d6bf9662f7ed81be892/xextract-0.0.7.zip", "yanked": false}], "0.0.8": [{"comment_text": "", "digests": {"md5": "043d1387099c49e595f7dbe26007dec4", "sha256": "de3f8a5cfbd07995642bf149306494b214fdc00b6cd5df14cdccffe008c0a8ee"}, "downloads": -1, "filename": "xextract-0.0.8.zip", "has_sig": false, "md5_digest": "043d1387099c49e595f7dbe26007dec4", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 23327, "upload_time": "2016-03-08T14:51:59", "upload_time_iso_8601": "2016-03-08T14:51:59.007143Z", "url": "https://files.pythonhosted.org/packages/6c/46/8be810421a6cf245003f3e4480317663d24405daf23c6cdbfa046760dc98/xextract-0.0.8.zip", "yanked": false}], "0.0.9": [{"comment_text": "", "digests": {"md5": "1d83c8065e119bac3a83319ff711621b", "sha256": "389127970e6389bb1e470ce3aacec5a16fa795104bc487f18325e476daabe54a"}, "downloads": -1, "filename": "xextract-0.0.9.zip", "has_sig": false, "md5_digest": "1d83c8065e119bac3a83319ff711621b", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 23378, "upload_time": "2016-03-08T15:58:10", "upload_time_iso_8601": "2016-03-08T15:58:10.231632Z", "url": "https://files.pythonhosted.org/packages/13/7d/20fcd25b9e7967f529cb5dca249e1fd054950e6205a46bdba9d7c1f9799d/xextract-0.0.9.zip", "yanked": false}], "0.1.0": [{"comment_text": "", "digests": {"md5": "d23c9bff0e05908e5ae115ed7bfcd8b5", "sha256": "37bef6155aa74ab8072a4007b3b02075d9216389e0e6f0224f170ec4baf56c8e"}, "downloads": -1, "filename": "xextract-0.1.0.zip", "has_sig": false, "md5_digest": "d23c9bff0e05908e5ae115ed7bfcd8b5", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 22777, "upload_time": "2016-03-28T19:59:28", "upload_time_iso_8601": "2016-03-28T19:59:28.478229Z", "url": "https://files.pythonhosted.org/packages/85/1f/efc216539e6151f39ebe4031854117b2945d5cdb891281f56aae879aaa1d/xextract-0.1.0.zip", "yanked": false}], "0.1.1": [{"comment_text": "", "digests": {"md5": "9f95b0036251ad37e0eac636d89942e4", "sha256": "c5502959fe84150b9f05d1a0f493f50acb232c426a63ba9ce74d1efe5653a730"}, "downloads": -1, "filename": "xextract-0.1.1.zip", "has_sig": false, "md5_digest": "9f95b0036251ad37e0eac636d89942e4", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 23382, "upload_time": "2016-04-14T13:59:15", "upload_time_iso_8601": "2016-04-14T13:59:15.359674Z", "url": "https://files.pythonhosted.org/packages/ab/ac/8f6a3f11bb19684805e1e1bc51f81b997e1e165ea6620a128b05880d2c54/xextract-0.1.1.zip", "yanked": false}], "0.1.2": [{"comment_text": "", "digests": {"md5": "aeaece987f31ead6877a77f60fd73fdc", "sha256": "0a44f9ca0a86b932204968ae3a54e62a98b5aec32394f7b801cc2a54e3f2c36b"}, "downloads": -1, "filename": "xextract-0.1.2.zip", "has_sig": false, "md5_digest": "aeaece987f31ead6877a77f60fd73fdc", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 23571, "upload_time": "2016-05-11T12:27:06", "upload_time_iso_8601": "2016-05-11T12:27:06.992607Z", "url": "https://files.pythonhosted.org/packages/13/92/e3cb1d30e1e38e4e701e1d82d0a7bfa2edfc294d1300e15108f97066cf9a/xextract-0.1.2.zip", "yanked": false}], "0.1.3": [{"comment_text": "", "digests": {"md5": "9bded3b350250505a540bfc42c89fa67", "sha256": "c5daaa94a1f0e2c5891234a7d893c5559d17f0d69e6604d2cf51850f70904eaa"}, "downloads": -1, "filename": "xextract-0.1.3.zip", "has_sig": false, "md5_digest": "9bded3b350250505a540bfc42c89fa67", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 24184, "upload_time": "2016-11-23T08:59:07", "upload_time_iso_8601": "2016-11-23T08:59:07.352715Z", "url": "https://files.pythonhosted.org/packages/0a/53/6f2756655f8776bc38a6ebbed4f5060addd93dfe646a6206ec9c5a8c2369/xextract-0.1.3.zip", "yanked": false}], "0.1.4": [{"comment_text": "", "digests": {"md5": "8e8b2a5ba99ea31d808df8328276135e", "sha256": "da01bf213993ba43c69cec00a701236145c7e86ebff6719fe4daa78dfe649b9c"}, "downloads": -1, "filename": "xextract-0.1.4.zip", "has_sig": false, "md5_digest": "8e8b2a5ba99ea31d808df8328276135e", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 24186, "upload_time": "2016-11-23T09:10:38", "upload_time_iso_8601": "2016-11-23T09:10:38.045837Z", "url": "https://files.pythonhosted.org/packages/cf/41/c7170b0b813e7ff037d3da48f5860cad26b0d04a37793f6ad763ce6fcd81/xextract-0.1.4.zip", "yanked": false}], "0.1.6": [{"comment_text": "", "digests": {"md5": "3c753fa8fc10281468d40ccc7cf9295b", "sha256": "c04df4156e66dc39ad10eb8bbabce35ed1dd9a95db05bedb1c2eba0aea4501fc"}, "downloads": -1, "filename": "xextract-0.1.6-py2-none-any.whl", "has_sig": false, "md5_digest": "3c753fa8fc10281468d40ccc7cf9295b", "packagetype": "bdist_wheel", "python_version": "py2", "requires_python": null, "size": 12413, "upload_time": "2020-03-05T10:26:45", "upload_time_iso_8601": "2020-03-05T10:26:45.186785Z", "url": "https://files.pythonhosted.org/packages/bd/87/8ab98068d67f9a745e6ff8ffd49060b96d640d1b8e3b2ad49f77e6d9422d/xextract-0.1.6-py2-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "1782c2be445fbfbbc17c8a7898a86fb4", "sha256": "e2e198ef96397c1d0b48b8b15177815947affb4578975bd436e0d4f1b7ab9434"}, "downloads": -1, "filename": "xextract-0.1.6.tar.gz", "has_sig": false, "md5_digest": "1782c2be445fbfbbc17c8a7898a86fb4", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 16936, "upload_time": "2020-03-05T10:26:47", "upload_time_iso_8601": "2020-03-05T10:26:47.186870Z", "url": "https://files.pythonhosted.org/packages/c5/8b/d55c9fd85c8c7731f3019a768141510f5991ed5c1f0f11b7b9d8cf0f5463/xextract-0.1.6.tar.gz", "yanked": false}], "0.1.7": [{"comment_text": "", "digests": {"md5": "93cc0301fd93fca83fe71e87c3e3471d", "sha256": "faa8f661b51fc3c822d0632c6141b69e2b66fac78cef510c6915aab76d96f4e8"}, "downloads": -1, "filename": "xextract-0.1.7-py2-none-any.whl", "has_sig": false, "md5_digest": "93cc0301fd93fca83fe71e87c3e3471d", "packagetype": "bdist_wheel", "python_version": "py2", "requires_python": null, "size": 12420, "upload_time": "2020-03-05T12:06:10", "upload_time_iso_8601": "2020-03-05T12:06:10.572215Z", "url": "https://files.pythonhosted.org/packages/70/fd/3a06b401b67e31f81029eb8788b157025e8b6de97ce6f97b91d861916b7f/xextract-0.1.7-py2-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "8eccd665d8bf321c86b26a4191911bf7", "sha256": "099b7c6afa81ed106324ad6b6769799edc31bc5de8105daffe318c3666abcb6f"}, "downloads": -1, "filename": "xextract-0.1.7.tar.gz", "has_sig": false, "md5_digest": "8eccd665d8bf321c86b26a4191911bf7", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 16939, "upload_time": "2020-03-05T12:06:14", "upload_time_iso_8601": "2020-03-05T12:06:14.586780Z", "url": "https://files.pythonhosted.org/packages/79/31/60bd2b9610ade9a79597426a0540d1c0abbcd93fd1936221be1c25e5d396/xextract-0.1.7.tar.gz", "yanked": false}], "0.1.8": [{"comment_text": "", "digests": {"md5": "120955c87f88cc1ef97c9520035d405b", "sha256": "cfeb97c654c298082a546676b9bba88d775b6bb8be75838f91daff23349b9e10"}, "downloads": -1, "filename": "xextract-0.1.8-py2-none-any.whl", "has_sig": false, "md5_digest": "120955c87f88cc1ef97c9520035d405b", "packagetype": "bdist_wheel", "python_version": "py2", "requires_python": null, "size": 12419, "upload_time": "2020-03-06T12:07:07", "upload_time_iso_8601": "2020-03-06T12:07:07.793817Z", "url": "https://files.pythonhosted.org/packages/45/fe/f59c93e99fe83d87dfddad8d7ea51c0cfe96c6dea3d3c45ac88f7be4dda8/xextract-0.1.8-py2-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "3ad7a1459458c51b96a603300f8c26a1", "sha256": "c2da185c7ae32886a7cdd9bce201a960c6fd8f92aad40a25afd3a1a857de0bad"}, "downloads": -1, "filename": "xextract-0.1.8.tar.gz", "has_sig": false, "md5_digest": "3ad7a1459458c51b96a603300f8c26a1", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 16936, "upload_time": "2020-03-06T12:07:12", "upload_time_iso_8601": "2020-03-06T12:07:12.695899Z", "url": "https://files.pythonhosted.org/packages/53/16/d16730c5617be36a725116263c7fccef039b32ed00ebbf7118afbf14fba7/xextract-0.1.8.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "120955c87f88cc1ef97c9520035d405b", "sha256": "cfeb97c654c298082a546676b9bba88d775b6bb8be75838f91daff23349b9e10"}, "downloads": -1, "filename": "xextract-0.1.8-py2-none-any.whl", "has_sig": false, "md5_digest": "120955c87f88cc1ef97c9520035d405b", "packagetype": "bdist_wheel", "python_version": "py2", "requires_python": null, "size": 12419, "upload_time": "2020-03-06T12:07:07", "upload_time_iso_8601": "2020-03-06T12:07:07.793817Z", "url": "https://files.pythonhosted.org/packages/45/fe/f59c93e99fe83d87dfddad8d7ea51c0cfe96c6dea3d3c45ac88f7be4dda8/xextract-0.1.8-py2-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "3ad7a1459458c51b96a603300f8c26a1", "sha256": "c2da185c7ae32886a7cdd9bce201a960c6fd8f92aad40a25afd3a1a857de0bad"}, "downloads": -1, "filename": "xextract-0.1.8.tar.gz", "has_sig": false, "md5_digest": "3ad7a1459458c51b96a603300f8c26a1", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 16936, "upload_time": "2020-03-06T12:07:12", "upload_time_iso_8601": "2020-03-06T12:07:12.695899Z", "url": "https://files.pythonhosted.org/packages/53/16/d16730c5617be36a725116263c7fccef039b32ed00ebbf7118afbf14fba7/xextract-0.1.8.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:25:40 2020"}