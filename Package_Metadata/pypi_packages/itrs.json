{"info": {"author": "Louis Dureuil <louis.dureuil@xinra.net>", "author_email": "Louis Dureuil <louis.dureuil@xinra.net>", "bugtrack_url": null, "classifiers": [], "description": "# Itrs\n\nRust's iterators in python, implemented in Rust!\n\n`Itrs` is a python native module that exposes to python an `Iterator` interface similar to Rust's [`Iterator` trait](https://doc.rust-lang.org/std/iter/trait.Iterator.html).\n\nThis means that, given the following innocent fibonacci generator:\n\n```py\n>>> def fibo(): \n...     yield 1 \n...     yield 2 \n...     current, next = 1, 2 \n...     while True: \n...         current, next = next, current + next \n...         yield next \n...\n```\n\ninstead of the following python code:\n\n```py\n>>> import itertools\n>>> # Euler problem #2\n>>> sum(x for x in itertools.takewhile(lambda x: x < 4_000_000, fibo()) if x % 2 == 0)\n4613732\n```\n\nyou can now write the following:\n\n```py\n>>> from itrs import Itrs\n>>> (Itrs(fibo()). \n...   take_while(lambda x: x < 4_000_000). \n...   filter(lambda x: x % 2 == 0). \n...   sum(0) \n... ) \n4613732\n```\n\n## But why, you madman?\n\n\nI dislike python's default iterator syntax that uses functions as combinators, because it becomes very difficult to read when using several of them. Some useful combinators and folding functions (such as `count`) are also missing, or available only in itertools.\n\nA second reason is as an exercice in using [PyO3](https://github.com/PyO3/pyo3) and rust's `Iterator` trait. This also allowed me to play with `Result` and `Option` types so I could get the type I wanted in all situations.\n\nAlso, because I'm a madman \ud83e\udd2a!\n\n## How do I use this?\n\n### From PyPI\n\nBuild from PyPI is only supported for x64 Linux at the moment.\n\nUsing ~~cargo~~ your favorite python installation method from PyPI:\n\n```bash\n$ pip install itrs\n```\n\nThen, from the virtualenv in which you --obviously-- executed the previous command, open a python interpreter and:\n\n```py\n>>> from itrs import Itrs\n>>>\n>>> # you can create Itrs objects from any iterable\n>>> it_array = Itrs([0, 1, 2])\n>>> it_str = Itrs(\"Intel the Beagle\")\n>>> def i_yield():\n>>>    for i in range(10):\n>>>        yield i\n>>> it_yield = Itrs(i_yield())\n>>> \n>>> # you can iterate on any itrs object using normal python syntax\n>>> for elem in it_array:\n>>>     print(elem)\n0\n1\n2\n>>> # Iterating a second time on a exhausted iterator yields no further result\n>>> for elem in it_array:\n>>>     print(elem)\n\n>>> # you can call methods on Itrs objects to create new iterators or produce results.\n>>> # That's the whole selling point of this!\n>>> it_str.filter(lambda x: x == ' ').count()\n2\n>>> [x for x in it_yield.skip(1).filter(lambda x: x % 2 == 0).map(lambda x: x * x)]\n[4, 16, 36, 64]\n```\n\n### Compiling the library from Rust\n\nCompiling from source *should* work with Linux, Windows or OSX indifferently, but was only tested under Linux.\nAs PyO3 requires nightly at the moment, a nightly toolchain of Rust is required to compile this repository.\n\nThe repository contains a `rust-toolchain` file containing a nightly toolchain that is known to work with the project.\n\nIf using `rustup`, you can install that toolchain with:\n\n```bash\n$ rustup toolchain install nightly-2019-09-04\n```\n\nThen, after cloning the repository, just:\n\n```bash\n$ cargo build --release\n```\n\nAfter the build completes, you will need to rename the produced binary by dropping the `lib` prefix, so it can be imported by python as intended:\n\n```bash\n$ mv target/release/{lib,}itrs.so\n```\n\nAlternatively, you can also build a wheel using [maturin](https://github.com/PyO3/maturin)\n\n```bash\n$ pip install maturin\n$ maturin build --release\n```\n\nand then install the wheel with:\n\n```bash\n$ pip install target/wheels/itrs-0.1.0-cp38-cp38-manylinux1_x86_64.whl\n```\n\nYou're done! You can now import `itrs` from a python shell with the `target/release` directory in your python path.\n\n## Should I use this in production?\n\nNo.\n\n* Even if python iterators suck, they are the standard, and using an external library to reimplement iterators should trigger a \"**WAT?**\" reaction in everyone around you\n* Using python iterators, you can write new function combinators. Adding new combinators to `Itrs` would involve monkey patching, and is not possible since `Itrs` is an extension type. Note that in rust, new combinators can be added using method syntax thanks to the trait system. This is what the [itertools crate](https://docs.rs/itertools/0.8.2/itertools/index.html) does, for example.\n* BTW, all iterator combinators aren't added as of yet.\n* Performance is bad. There are several reasons for this:\n    * Rust uses monomorphization of generic type parameters. This avoid the indirection of runtime polymorphism, and allows to inline the iterator code, which can then enable efficient optimizations at compile time. However, Python being an interpreted language without generics,it cannot take advantage of monomorphization, so the current design performs one allocation per combinator, which is far from efficient.\n    * The current implementation is naive and only attempts to reuse the functions defined by the `Iterator`\u00a0trait as much as possible. It also uses `Rc` rather than PyO3's provided `PyObject`, which might be inefficient considering we're already in the python runtime?\n", "description_content_type": "text/markdown; charset=UTF-8; variant=GFM", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "", "keywords": "", "license": "", "maintainer": "", "maintainer_email": "", "name": "itrs", "package_url": "https://pypi.org/project/itrs/", "platform": "", "project_url": "https://pypi.org/project/itrs/", "project_urls": null, "release_url": "https://pypi.org/project/itrs/0.1.1/", "requires_dist": null, "requires_python": "", "summary": "Itrs is a python native module that exposes to python an Iterator interface similar to Rust's Iterator trait. Implemented in Rust.", "version": "0.1.1", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>Itrs</h1>\n<p>Rust's iterators in python, implemented in Rust!</p>\n<p><code>Itrs</code> is a python native module that exposes to python an <code>Iterator</code> interface similar to Rust's <a href=\"https://doc.rust-lang.org/std/iter/trait.Iterator.html\" rel=\"nofollow\"><code>Iterator</code> trait</a>.</p>\n<p>This means that, given the following innocent fibonacci generator:</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"k\">def</span> <span class=\"nf\">fibo</span><span class=\"p\">():</span> \n<span class=\"o\">...</span>     <span class=\"k\">yield</span> <span class=\"mi\">1</span> \n<span class=\"o\">...</span>     <span class=\"k\">yield</span> <span class=\"mi\">2</span> \n<span class=\"o\">...</span>     <span class=\"n\">current</span><span class=\"p\">,</span> <span class=\"nb\">next</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span> \n<span class=\"o\">...</span>     <span class=\"k\">while</span> <span class=\"kc\">True</span><span class=\"p\">:</span> \n<span class=\"o\">...</span>         <span class=\"n\">current</span><span class=\"p\">,</span> <span class=\"nb\">next</span> <span class=\"o\">=</span> <span class=\"nb\">next</span><span class=\"p\">,</span> <span class=\"n\">current</span> <span class=\"o\">+</span> <span class=\"nb\">next</span> \n<span class=\"o\">...</span>         <span class=\"k\">yield</span> <span class=\"nb\">next</span> \n<span class=\"o\">...</span>\n</pre>\n<p>instead of the following python code:</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">import</span> <span class=\"nn\">itertools</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"c1\"># Euler problem #2</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"nb\">sum</span><span class=\"p\">(</span><span class=\"n\">x</span> <span class=\"k\">for</span> <span class=\"n\">x</span> <span class=\"ow\">in</span> <span class=\"n\">itertools</span><span class=\"o\">.</span><span class=\"n\">takewhile</span><span class=\"p\">(</span><span class=\"k\">lambda</span> <span class=\"n\">x</span><span class=\"p\">:</span> <span class=\"n\">x</span> <span class=\"o\">&lt;</span> <span class=\"mi\">4_000_000</span><span class=\"p\">,</span> <span class=\"n\">fibo</span><span class=\"p\">())</span> <span class=\"k\">if</span> <span class=\"n\">x</span> <span class=\"o\">%</span> <span class=\"mi\">2</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"p\">)</span>\n<span class=\"mi\">4613732</span>\n</pre>\n<p>you can now write the following:</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">from</span> <span class=\"nn\">itrs</span> <span class=\"kn\">import</span> <span class=\"n\">Itrs</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"p\">(</span><span class=\"n\">Itrs</span><span class=\"p\">(</span><span class=\"n\">fibo</span><span class=\"p\">())</span><span class=\"o\">.</span> \n<span class=\"o\">...</span>   <span class=\"n\">take_while</span><span class=\"p\">(</span><span class=\"k\">lambda</span> <span class=\"n\">x</span><span class=\"p\">:</span> <span class=\"n\">x</span> <span class=\"o\">&lt;</span> <span class=\"mi\">4_000_000</span><span class=\"p\">)</span><span class=\"o\">.</span> \n<span class=\"o\">...</span>   <span class=\"nb\">filter</span><span class=\"p\">(</span><span class=\"k\">lambda</span> <span class=\"n\">x</span><span class=\"p\">:</span> <span class=\"n\">x</span> <span class=\"o\">%</span> <span class=\"mi\">2</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"p\">)</span><span class=\"o\">.</span> \n<span class=\"o\">...</span>   <span class=\"nb\">sum</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">)</span> \n<span class=\"o\">...</span> <span class=\"p\">)</span> \n<span class=\"mi\">4613732</span>\n</pre>\n<h2>But why, you madman?</h2>\n<p>I dislike python's default iterator syntax that uses functions as combinators, because it becomes very difficult to read when using several of them. Some useful combinators and folding functions (such as <code>count</code>) are also missing, or available only in itertools.</p>\n<p>A second reason is as an exercice in using <a href=\"https://github.com/PyO3/pyo3\" rel=\"nofollow\">PyO3</a> and rust's <code>Iterator</code> trait. This also allowed me to play with <code>Result</code> and <code>Option</code> types so I could get the type I wanted in all situations.</p>\n<p>Also, because I'm a madman \ud83e\udd2a!</p>\n<h2>How do I use this?</h2>\n<h3>From PyPI</h3>\n<p>Build from PyPI is only supported for x64 Linux at the moment.</p>\n<p>Using <del>cargo</del> your favorite python installation method from PyPI:</p>\n<pre>$ pip install itrs\n</pre>\n<p>Then, from the virtualenv in which you --obviously-- executed the previous command, open a python interpreter and:</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">from</span> <span class=\"nn\">itrs</span> <span class=\"kn\">import</span> <span class=\"n\">Itrs</span>\n<span class=\"o\">&gt;&gt;&gt;</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"c1\"># you can create Itrs objects from any iterable</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">it_array</span> <span class=\"o\">=</span> <span class=\"n\">Itrs</span><span class=\"p\">([</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">])</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">it_str</span> <span class=\"o\">=</span> <span class=\"n\">Itrs</span><span class=\"p\">(</span><span class=\"s2\">\"Intel the Beagle\"</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"k\">def</span> <span class=\"nf\">i_yield</span><span class=\"p\">():</span>\n<span class=\"o\">&gt;&gt;&gt;</span>    <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"mi\">10</span><span class=\"p\">):</span>\n<span class=\"o\">&gt;&gt;&gt;</span>        <span class=\"k\">yield</span> <span class=\"n\">i</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">it_yield</span> <span class=\"o\">=</span> <span class=\"n\">Itrs</span><span class=\"p\">(</span><span class=\"n\">i_yield</span><span class=\"p\">())</span>\n<span class=\"o\">&gt;&gt;&gt;</span> \n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"c1\"># you can iterate on any itrs object using normal python syntax</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"k\">for</span> <span class=\"n\">elem</span> <span class=\"ow\">in</span> <span class=\"n\">it_array</span><span class=\"p\">:</span>\n<span class=\"o\">&gt;&gt;&gt;</span>     <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">elem</span><span class=\"p\">)</span>\n<span class=\"mi\">0</span>\n<span class=\"mi\">1</span>\n<span class=\"mi\">2</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"c1\"># Iterating a second time on a exhausted iterator yields no further result</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"k\">for</span> <span class=\"n\">elem</span> <span class=\"ow\">in</span> <span class=\"n\">it_array</span><span class=\"p\">:</span>\n<span class=\"o\">&gt;&gt;&gt;</span>     <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">elem</span><span class=\"p\">)</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"c1\"># you can call methods on Itrs objects to create new iterators or produce results.</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"c1\"># That's the whole selling point of this!</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">it_str</span><span class=\"o\">.</span><span class=\"n\">filter</span><span class=\"p\">(</span><span class=\"k\">lambda</span> <span class=\"n\">x</span><span class=\"p\">:</span> <span class=\"n\">x</span> <span class=\"o\">==</span> <span class=\"s1\">' '</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">count</span><span class=\"p\">()</span>\n<span class=\"mi\">2</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"p\">[</span><span class=\"n\">x</span> <span class=\"k\">for</span> <span class=\"n\">x</span> <span class=\"ow\">in</span> <span class=\"n\">it_yield</span><span class=\"o\">.</span><span class=\"n\">skip</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">filter</span><span class=\"p\">(</span><span class=\"k\">lambda</span> <span class=\"n\">x</span><span class=\"p\">:</span> <span class=\"n\">x</span> <span class=\"o\">%</span> <span class=\"mi\">2</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">map</span><span class=\"p\">(</span><span class=\"k\">lambda</span> <span class=\"n\">x</span><span class=\"p\">:</span> <span class=\"n\">x</span> <span class=\"o\">*</span> <span class=\"n\">x</span><span class=\"p\">)]</span>\n<span class=\"p\">[</span><span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"mi\">16</span><span class=\"p\">,</span> <span class=\"mi\">36</span><span class=\"p\">,</span> <span class=\"mi\">64</span><span class=\"p\">]</span>\n</pre>\n<h3>Compiling the library from Rust</h3>\n<p>Compiling from source <em>should</em> work with Linux, Windows or OSX indifferently, but was only tested under Linux.\nAs PyO3 requires nightly at the moment, a nightly toolchain of Rust is required to compile this repository.</p>\n<p>The repository contains a <code>rust-toolchain</code> file containing a nightly toolchain that is known to work with the project.</p>\n<p>If using <code>rustup</code>, you can install that toolchain with:</p>\n<pre>$ rustup toolchain install nightly-2019-09-04\n</pre>\n<p>Then, after cloning the repository, just:</p>\n<pre>$ cargo build --release\n</pre>\n<p>After the build completes, you will need to rename the produced binary by dropping the <code>lib</code> prefix, so it can be imported by python as intended:</p>\n<pre>$ mv target/release/<span class=\"o\">{</span>lib,<span class=\"o\">}</span>itrs.so\n</pre>\n<p>Alternatively, you can also build a wheel using <a href=\"https://github.com/PyO3/maturin\" rel=\"nofollow\">maturin</a></p>\n<pre>$ pip install maturin\n$ maturin build --release\n</pre>\n<p>and then install the wheel with:</p>\n<pre>$ pip install target/wheels/itrs-0.1.0-cp38-cp38-manylinux1_x86_64.whl\n</pre>\n<p>You're done! You can now import <code>itrs</code> from a python shell with the <code>target/release</code> directory in your python path.</p>\n<h2>Should I use this in production?</h2>\n<p>No.</p>\n<ul>\n<li>Even if python iterators suck, they are the standard, and using an external library to reimplement iterators should trigger a \"<strong>WAT?</strong>\" reaction in everyone around you</li>\n<li>Using python iterators, you can write new function combinators. Adding new combinators to <code>Itrs</code> would involve monkey patching, and is not possible since <code>Itrs</code> is an extension type. Note that in rust, new combinators can be added using method syntax thanks to the trait system. This is what the <a href=\"https://docs.rs/itertools/0.8.2/itertools/index.html\" rel=\"nofollow\">itertools crate</a> does, for example.</li>\n<li>BTW, all iterator combinators aren't added as of yet.</li>\n<li>Performance is bad. There are several reasons for this:\n<ul>\n<li>Rust uses monomorphization of generic type parameters. This avoid the indirection of runtime polymorphism, and allows to inline the iterator code, which can then enable efficient optimizations at compile time. However, Python being an interpreted language without generics,it cannot take advantage of monomorphization, so the current design performs one allocation per combinator, which is far from efficient.</li>\n<li>The current implementation is naive and only attempts to reuse the functions defined by the <code>Iterator</code>\u00a0trait as much as possible. It also uses <code>Rc</code> rather than PyO3's provided <code>PyObject</code>, which might be inefficient considering we're already in the python runtime?</li>\n</ul>\n</li>\n</ul>\n\n          </div>"}, "last_serial": 6521988, "releases": {"0.1.0": [{"comment_text": "", "digests": {"md5": "5b5b737fc8dddebb91dd2966176fe07e", "sha256": "ca38d6a46317ec2454834449b6049a2fe58cb5c7325d1ee00c8e2a789782468e"}, "downloads": -1, "filename": "itrs-0.1.0-cp38-cp38-manylinux1_x86_64.whl", "has_sig": false, "md5_digest": "5b5b737fc8dddebb91dd2966176fe07e", "packagetype": "bdist_wheel", "python_version": "cp38", "requires_python": null, "size": 159380, "upload_time": "2020-01-26T13:51:14", "upload_time_iso_8601": "2020-01-26T13:51:14.943303Z", "url": "https://files.pythonhosted.org/packages/6d/1e/5ba43e1d88efb598c133c83763a235438445254649ccd635813f55ada38c/itrs-0.1.0-cp38-cp38-manylinux1_x86_64.whl", "yanked": false}], "0.1.1": [{"comment_text": "", "digests": {"md5": "1878a2f2a5b31ab2b0f68bf607f85c4b", "sha256": "b42098587539b22dec0fbd704d879efaaa19e5804031b18c404d7b19eb016770"}, "downloads": -1, "filename": "itrs-0.1.1-cp38-cp38-manylinux1_x86_64.whl", "has_sig": false, "md5_digest": "1878a2f2a5b31ab2b0f68bf607f85c4b", "packagetype": "bdist_wheel", "python_version": "cp38", "requires_python": null, "size": 161684, "upload_time": "2020-01-26T13:59:11", "upload_time_iso_8601": "2020-01-26T13:59:11.070958Z", "url": "https://files.pythonhosted.org/packages/47/47/43397461f015bcedc4f24aa552f8b5555d8771ffe7810a30ea3b8ce2cc0f/itrs-0.1.1-cp38-cp38-manylinux1_x86_64.whl", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "1878a2f2a5b31ab2b0f68bf607f85c4b", "sha256": "b42098587539b22dec0fbd704d879efaaa19e5804031b18c404d7b19eb016770"}, "downloads": -1, "filename": "itrs-0.1.1-cp38-cp38-manylinux1_x86_64.whl", "has_sig": false, "md5_digest": "1878a2f2a5b31ab2b0f68bf607f85c4b", "packagetype": "bdist_wheel", "python_version": "cp38", "requires_python": null, "size": 161684, "upload_time": "2020-01-26T13:59:11", "upload_time_iso_8601": "2020-01-26T13:59:11.070958Z", "url": "https://files.pythonhosted.org/packages/47/47/43397461f015bcedc4f24aa552f8b5555d8771ffe7810a30ea3b8ce2cc0f/itrs-0.1.1-cp38-cp38-manylinux1_x86_64.whl", "yanked": false}], "timestamp": "Fri May  8 00:53:37 2020"}