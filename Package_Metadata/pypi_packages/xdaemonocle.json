{"info": {"author": "Jonathan Robson", "author_email": "jnrbsn@gmail.com", "bugtrack_url": null, "classifiers": ["Development Status :: 4 - Beta", "Intended Audience :: Developers", "Intended Audience :: System Administrators", "License :: OSI Approved :: MIT License", "Operating System :: MacOS :: MacOS X", "Operating System :: POSIX :: Linux", "Programming Language :: Python :: 2", "Programming Language :: Python :: 2.7"], "description": "daemonocle is a library for creating your own Unix-style daemons written in Python. It solves many\nproblems that other daemon libraries have and provides some really useful features you don't often\nsee in other daemons.\n\n.. contents:: **Table of Contents**\n  :backlinks: none\n\nInstallation\n------------\n\nTo install via pip::\n\n    pip install daemonocle\n\nOr download the source code and install manually::\n\n    git clone https://github.com/jnrbsn/daemonocle.git\n    cd daemonocle/\n    python setup.py install\n\nBasic Usage\n-----------\n\nHere's a **really really** basic example:\n\n.. code:: python\n\n    import sys\n    import time\n\n    import daemonocle\n\n    # This is your daemon. It sleeps, and then sleeps again.\n    def main():\n        while True:\n            time.sleep(10)\n\n    if __name__ == '__main__':\n        daemon = daemonocle.Daemon(\n            worker=main,\n            pidfile='/var/run/daemonocle_example.pid',\n        )\n        daemon.do_action(sys.argv[1])\n\nAnd here's the same example with logging and a `Shutdown Callback`_:\n\n.. code:: python\n\n    import logging\n    import sys\n    import time\n\n    import daemonocle\n\n    def cb_shutdown(message, code):\n        logging.info('Daemon is stopping')\n        logging.debug(message)\n\n    def main():\n        logging.basicConfig(\n            filename='/var/log/daemonocle_example.log',\n            level=logging.DEBUG, format='%(asctime)s [%(levelname)s] %(message)s',\n        )\n        logging.info('Daemon is starting')\n        while True:\n            logging.debug('Still running')\n            time.sleep(10)\n\n    if __name__ == '__main__':\n        daemon = daemonocle.Daemon(\n            worker=main,\n            shutdown_callback=cb_shutdown,\n            pidfile='/var/run/daemonocle_example.pid',\n        )\n        daemon.do_action(sys.argv[1])\n\nAnd here's what it looks like when you run it::\n\n    user@host:~$ python example.py start\n    Starting example.py ... OK\n    user@host:~$ python example.py status\n    example.py -- pid: 1234, status: running, uptime: 1m, %cpu: 0.0, %mem: 0.0\n    user@host:~$ python example.py stop\n    Stopping example.py ... OK\n    user@host:~$ cat /var/log/daemonocle_example.log\n    2014-05-04 12:39:21,090 [INFO] Daemon is starting\n    2014-05-04 12:39:21,091 [DEBUG] Still running\n    2014-05-04 12:39:31,091 [DEBUG] Still running\n    2014-05-04 12:39:41,091 [DEBUG] Still running\n    2014-05-04 12:39:51,093 [DEBUG] Still running\n    2014-05-04 12:40:01,094 [DEBUG] Still running\n    2014-05-04 12:40:07,113 [INFO] Daemon is stopping\n    2014-05-04 12:40:07,114 [DEBUG] Terminated by SIGTERM (15)\n\nFor more details, see the `Detailed Usage`_ section below.\n\nRationale\n---------\n\nIf you think about it, a lot of Unix daemons don't really know what the hell they're doing. Have you\never found yourself in a situation that looked something like this? ::\n\n    user@host:~$ sudo example start\n    starting example ... ok\n    user@host:~$ ps aux | grep example\n    user      1234  0.0  0.0   1234  1234 pts/1    S+   12:34   0:00 grep example\n    user@host:~$ sudo example start\n    starting example ... ok\n    user@host:~$ echo $?\n    0\n    user@host:~$ tail -f /var/log/example.log\n    ...\n\nOr something like this? ::\n\n    user@host:~$ sudo example stop\n    stopping example ... ok\n    user@host:~$ ps aux | grep example\n    user       123  0.0  0.0   1234  1234 ?        Ss   00:00   0:00 /usr/local/bin/example\n    user      1234  0.0  0.0   1234  1234 pts/1    S+   12:34   0:00 grep example\n    user@host:~$ sudo example stop\n    stopping example ... ok\n    user@host:~$ ps aux | grep example\n    user       123  0.0  0.0   1234  1234 ?        Ss   00:00   0:00 /usr/local/bin/example\n    user      1240  0.0  0.0   1234  1234 pts/1    S+   12:34   0:00 grep example\n    user@host:~$ sudo kill -9 123\n    ...\n\nOr something like this? ::\n\n    user@host:~$ sudo example status\n    Usage: example {start|stop|restart}\n    user@host:~$ ps aux | grep example\n    ...\n\nThese are just a few examples of unnecessarily common problems. It doesn't have to be this way.\n\n    **Note:** You might be thinking, \"Why not just write a smarter start/stop shell script wrapper\n    for your daemon that checks whether or not it actually started, actually stopped, etc.?\"\n    Seriously? **It doesn't have to be this way.** I believe daemons should be more self-aware. They\n    should handle their own problems most of the time, and your start/stop script should only be a\n    very thin wrapper around your daemon or simply a symlink to your daemon.\n\nThe Problem\n~~~~~~~~~~~\n\nIf you've ever dug deep into the nitty-gritty details of how daemonization works, you're probably\nfamiliar with the `standard \"double fork\" paradigm <http://bit.ly/stevens-daemon>`_ first introduced\nby W. Richard Stevens in the book `Advanced Programming in the UNIX Environment\n<http://amzn.com/0321637739>`_. One of the problems with the standard way to implement this is that\nif the final child dies immediately when it gets around to doing real work, the original parent\nprocess (the one that actually had control of your terminal) is long gone. So all you know is that\nthe process got forked, but you have no idea if it actually kept running for more than a fraction of\na second. And let's face it, one of the most likely times for a daemon to die is immediately after\nit starts (due to bad configuration, permissions, etc.).\n\nThe next problem mentioned in the section above is when you try to stop a daemon, it doesn't\nactually stop, and you have no idea that it didn't actually stop. This happens when a process\ndoesn't respond properly to a ``SIGTERM`` signal. It happens more often than it should. The problem\nis not necessarily the fact that it didn't stop. It's the fact that you didn't *know* that it didn't\nstop. The start/stop script knows that it successfully sent the signal and so it assumes success.\nThis also becomes a problem when your ``restart`` command blindly calls ``stop`` and then ``start``,\nbecause it will try to start a new instance of the daemon before the previous one has exited.\n\nThese are the biggest problems most daemons have in my opinion. daemonocle solves these problems and\nprovides many other \"fancy\" features.\n\nThe Solution\n~~~~~~~~~~~~\n\nThe problem with the daemon immediately dying on startup and you not knowing about it is solved by\nhaving the first child (the immediate parent of the final child) sleep for one second and then call\n``os.waitpid(pid, os.WNOHANG)`` to see if the process is still running. This is what daemonocle\ndoes. So if you're daemon dies within one second of starting, you'll know about it.\n\nThis problem with the daemon not stopping and you not knowing about it is solved by simply waiting\nfor the process to finish (with a timeout). This is what daemonocle does. (Note: When a timeout\noccurs, it doesn't try to send a ``SIGKILL``. This is not always what you'd want and often not a\ngood idea.)\n\nOther Useful Features\n~~~~~~~~~~~~~~~~~~~~~\n\nBelow are some other useful features that daemononcle provides that you might not find elsewhere.\n\nThe ``status`` Action\n+++++++++++++++++++++\n\nThere is a ``status`` action that not only displays whether or not the daemon is running and its\nPID, but also the uptime of the daemon and the % CPU and % memory usage of all the processes in the\nsame process group as the daemon (which are probably its children). So if you have a daemon that\nlaunches mulitple worker processes, the ``status`` action will show the % CPU and % memory usage of\nall the workers combined.\n\nIt might look something like this::\n\n    user@host:~$ python example.py status\n    example.py -- pid: 1234, status: running, uptime: 12d 3h 4m, %cpu: 12.4, %mem: 4.5\n\nSlightly Smarter ``restart`` Action\n+++++++++++++++++++++++++++++++++++\n\nHave you ever tried to restart a daemon only to realize that it's not actually running? Let me\nguess: it just gave you an error and didn't start the daemon. A lot of the time this is not a\nproblem, but if you're trying to restart the daemon in an automated way, it's more annoying to have\nto check if it's running and do either a ``start`` or ``restart`` accordingly. With daemonocle, if\nyou try to restart a daemon that's not running, it will give you a warning saying that it wasn't\nrunning and then start the daemon. This is often what people expect.\n\nSelf-Reload\n+++++++++++\n\nDaemons that use daemonocle have the ability to reload themselves by simply calling\n``daemon.reload()`` where ``daemon`` is your ``daemonocle.Daemon`` instance. The execution of the\ncurrent daemon halts wherever ``daemon.reload()`` was called, and a new daemon is started up to\nreplace the current one. From your code's perspective, it's pretty much the same as a doing a\n``restart`` except that it's initiated from within the daemon itself and there's no signal handling\ninvolved. Here's a basic example of a daemon that watches a config file and reloads itself when the\nconfig file changes:\n\n.. code:: python\n\n    import os\n    import sys\n    import time\n\n    import daemonocle\n\n    class FileWatcher(object):\n\n        def __init__(self, filename, daemon):\n            self._filename = filename\n            self._daemon = daemon\n            self._file_mtime = os.stat(self._filename).st_mtime\n\n        def file_has_changed(self):\n            current_mtime = os.stat(self._filename).st_mtime\n            if current_mtime != self._file_mtime:\n                self._file_mtime = current_mtime\n                return True\n            return False\n\n        def watch(self):\n            while True:\n                if self.file_has_changed():\n                    self._daemon.reload()\n                time.sleep(1)\n\n    if __name__ == '__main__':\n        daemon = daemonocle.Daemon(pidfile='/var/run/daemonocle_example.pid')\n        fw = FileWatcher(filename='/etc/daemonocle_example.conf', daemon=daemon)\n        daemon.worker = fw.watch\n        daemon.do_action(sys.argv[1])\n\nShutdown Callback\n+++++++++++++++++\n\nYou may have noticed from the `Basic Usage`_ section above that a ``shutdown_callback`` was defined.\nThis function gets called whenever the daemon is shutting down in a catchable way, which should be\nmost of the time except for a ``SIGKILL`` or if your server crashes unexpectedly or loses power or\nsomething like that. This function can be used for doing any sort of cleanup that your daemon needs\nto do. Also, if you want to log (to the logger of your choice) the reason for the shutdown and the\nintended exit code, you can use the ``message`` and ``code`` arguments that will be passed to your\ncallback (your callback must take these two arguments).\n\nNon-Detached Mode\n+++++++++++++++++\n\nThis is not particularly interesting per se, but it's worth noting that in non-detached mode, your\ndaemon will do everything else you've configured it to do (i.e. ``setuid``, ``setgid``, ``chroot``,\netc.) except actually detaching from your terminal. So while you're testing, you can get an\nextremely accurate view of how your daemon will behave in the wild. It's also worth noting that\nself-reloading works in non-detached mode, which was a little tricky to figure out initially.\n\nFile Descriptor Handling\n++++++++++++++++++++++++\n\nOne of the things that daemons typically do is close all open file descriptors and establish new\nones for ``STDIN``, ``STDOUT``, ``STDERR`` that just point to ``/dev/null``. This is fine most of\nthe time, but if your worker is an instance method of a class that opens files in its ``__init__()``\nmethod, then you'll run into problems if you're not careful. This is also a problem if you're\nimporting a module that leaves open files behind. For example, importing the\n`random <https://docs.python.org/3/library/random.html>`_ standard library module in Python 3\nresults in an open file descriptor for ``/dev/urandom``.\n\nSince this \"feature\" of daemons often causes more problems than it solves, and the problems it\ncauses sometimes have strange side-effects that make it very difficult to troubleshoot, this feature\nis optional and disabled by default in daemonocle via the ``close_open_files`` option.\n\nDetailed Usage\n--------------\n\nThe ``daemonocle.Daemon`` class is the main class for creating a daemon using daemonocle. Here's the\nconstructor signature for the class:\n\n.. code:: python\n\n    class daemonocle.Daemon(\n        worker=None, shutdown_callback=None, prog=None, pidfile=None, detach=True,\n        uid=None, gid=None, workdir='/', chrootdir=None, umask=022, stop_timeout=10,\n        close_open_files=False)\n\nAnd here are descriptions of all the arguments:\n\n**worker**\n    The function that does all the work for your daemon.\n\n**shutdown_callback**\n    This will get called anytime the daemon is shutting down. It should take a ``message`` and a\n    ``code`` argument. The message is a human readable message that explains why the daemon is\n    shutting down. It might useful to log this message. The code is the exit code with which it\n    intends to exit. See `Shutdown Callback`_ for more details.\n\n**prog**\n    The name of your program to use in output messages. Default: ``os.path.basename(sys.argv[0])``\n\n**pidfile**\n    The path to a PID file to use. It's not required to use a PID file, but if you don't, you won't\n    be able to use all the features you might expect. Make sure the user your daemon is running as\n    has permission to write to the directory this file is in.\n\n**detach**\n    Whether or not to detach from the terminal and go into the background. See `Non-Detached Mode`_\n    for more details. Default: ``True``\n\n**uid**\n    The user ID to switch to when the daemon starts. The default is not to switch users.\n\n**gid**\n    The group ID to switch to when the daemon starts. The default is not to switch groups.\n\n**workdir**\n    The path to a directory to change to when the daemon starts. Note that a file system cannot be\n    unmounted if a process has its working directory on that file system. So if you change the\n    default, be careful about what you change it to. Default: ``\"/\"``\n\n**chrootdir**\n    The path to a directory to set as the effective root directory when the daemon starts. The\n    default is not to do anything.\n\n**umask**\n    The file creation mask (\"umask\") for the process. Default: ``022``\n\n**stop_timeout**\n    Number of seconds to wait for the daemon to stop before throwing an error. Default: ``10``\n\n**close_open_files**\n    Whether or not to close all open files when the daemon detaches. Default: ``False``\n\nActions\n~~~~~~~\n\nThe default actions are ``start``, ``stop``, ``restart``, and ``status``. You can get a list of\navailable actions using the ``daemonocle.Daemon.list_actions()`` method. The recommended way to call\nan action is using the ``daemonocle.Daemon.do_action(action)`` method. The string name of an action\nis the same as the method name except with dashes in place of underscores.\n\nIf you want to create your own actions, simply subclass ``daemonocle.Daemon`` and add the\n``@daemonocle.expose_action`` decorator to your action method, and that's it.\n\nHere's an example:\n\n.. code:: python\n\n    import daemonocle\n\n    class MyDaemon(daemonocle.Daemon):\n\n        @daemonocle.expose_action\n        def full_status(self):\n            \"\"\"Get more detailed status of the daemon.\"\"\"\n            pass\n\nThen, if you did the basic ``daemon.do_action(sys.argv[1])`` like in all the examples above, you can\ncall your action with a command like ``python example.py full-status``.\n\nIntegration with mitsuhiko's click\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\ndaemonocle also provides an integration with `click <http://click.pocoo.org/>`_, the \"composable\ncommand line utility\". The integration is in the form of a custom command class\n``daemonocle.cli.DaemonCLI`` that you can use in conjunction with the ``@click.command()`` decorator\nto automatically generate a command line interface with subcommands for all your actions. It also\nautomatically daemonizes the decorated function. The decorated function becomes the worker, and the\nactions are automatically mapped from click to daemonocle.\n\nHere's an example:\n\n.. code:: python\n\n    import time\n\n    import click\n    from daemonocle.cli import DaemonCLI\n\n    @click.command(cls=DaemonCLI, daemon_params={'pidfile': '/var/run/example.pid'})\n    def main():\n        \"\"\"This is my awesome daemon. It pretends to do work in the background.\"\"\"\n        while True:\n            time.sleep(10)\n\n    if __name__ == '__main__':\n        main()\n\nRunning this example would look something like this::\n\n    user@host:~$ python example.py --help\n    Usage: example.py [<options>] <command> [<args>]...\n\n      This is my awesome daemon. It pretends to do work in the background.\n\n    Options:\n      --help  Show this message and exit.\n\n    Commands:\n      start    Start the daemon.\n      stop     Stop the daemon.\n      restart  Stop then start the daemon.\n      status   Get the status of the daemon.\n    user@host:~$ python example.py start --help\n    Usage: example.py start [<options>]\n\n      Start the daemon.\n\n    Options:\n      --debug  Do NOT detach and run in the background.\n      --help   Show this message and exit.\n\nThe ``daemonocle.cli.DaemonCLI`` class also accepts a ``daemon_class`` argument that can be a\nsubclass of ``daemonocle.Daemon``. It will use your custom class, automatically create subcommands\nfor any custom actions you've defined, and use the docstrings of the action methods as the help text\njust like click usually does.\n\nThis integration is entirely optional. daemonocle doesn't enforce any sort of argument parsing. You\ncan use argparse, optparse, or just plain ``sys.argv`` if you want.\n\nBugs, Requests, Questions, etc.\n-------------------------------\n\nPlease create an `issue on GitHub <https://github.com/jnrbsn/daemonocle/issues>`_.", "description_content_type": null, "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "http://github.com/jnrbsn/daemonocle", "keywords": "daemon daemonize fork unix cli", "license": "MIT", "maintainer": "", "maintainer_email": "", "name": "xdaemonocle", "package_url": "https://pypi.org/project/xdaemonocle/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/xdaemonocle/", "project_urls": {"Homepage": "http://github.com/jnrbsn/daemonocle"}, "release_url": "https://pypi.org/project/xdaemonocle/0.8.1/", "requires_dist": null, "requires_python": "", "summary": "A Python library for creating super fancy Unix daemons", "version": "0.8.1", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p>daemonocle is a library for creating your own Unix-style daemons written in Python. It solves many\nproblems that other daemon libraries have and provides some really useful features you don\u2019t often\nsee in other daemons.</p>\n<div id=\"table-of-contents\">\n<p><strong>Table of Contents</strong></p>\n<ul>\n<li><a href=\"#installation\" id=\"id1\" rel=\"nofollow\">Installation</a></li>\n<li><a href=\"#basic-usage\" id=\"id2\" rel=\"nofollow\">Basic Usage</a></li>\n<li><a href=\"#rationale\" id=\"id3\" rel=\"nofollow\">Rationale</a><ul>\n<li><a href=\"#the-problem\" id=\"id4\" rel=\"nofollow\">The Problem</a></li>\n<li><a href=\"#the-solution\" id=\"id5\" rel=\"nofollow\">The Solution</a></li>\n<li><a href=\"#other-useful-features\" id=\"id6\" rel=\"nofollow\">Other Useful Features</a><ul>\n<li><a href=\"#the-status-action\" id=\"id7\" rel=\"nofollow\">The <tt>status</tt> Action</a></li>\n<li><a href=\"#slightly-smarter-restart-action\" id=\"id8\" rel=\"nofollow\">Slightly Smarter <tt>restart</tt> Action</a></li>\n<li><a href=\"#self-reload\" id=\"id9\" rel=\"nofollow\">Self-Reload</a></li>\n<li><a href=\"#shutdown-callback\" id=\"id10\" rel=\"nofollow\">Shutdown Callback</a></li>\n<li><a href=\"#non-detached-mode\" id=\"id11\" rel=\"nofollow\">Non-Detached Mode</a></li>\n<li><a href=\"#file-descriptor-handling\" id=\"id12\" rel=\"nofollow\">File Descriptor Handling</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#detailed-usage\" id=\"id13\" rel=\"nofollow\">Detailed Usage</a><ul>\n<li><a href=\"#actions\" id=\"id14\" rel=\"nofollow\">Actions</a></li>\n<li><a href=\"#integration-with-mitsuhiko-s-click\" id=\"id15\" rel=\"nofollow\">Integration with mitsuhiko\u2019s click</a></li>\n</ul>\n</li>\n<li><a href=\"#bugs-requests-questions-etc\" id=\"id16\" rel=\"nofollow\">Bugs, Requests, Questions, etc.</a></li>\n</ul>\n</div>\n<div id=\"installation\">\n<h2>Installation</h2>\n<p>To install via pip:</p>\n<pre>pip install daemonocle\n</pre>\n<p>Or download the source code and install manually:</p>\n<pre>git clone https://github.com/jnrbsn/daemonocle.git\ncd daemonocle/\npython setup.py install\n</pre>\n</div>\n<div id=\"basic-usage\">\n<h2>Basic Usage</h2>\n<p>Here\u2019s a <strong>really really</strong> basic example:</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">sys</span>\n<span class=\"kn\">import</span> <span class=\"nn\">time</span>\n\n<span class=\"kn\">import</span> <span class=\"nn\">daemonocle</span>\n\n<span class=\"c1\"># This is your daemon. It sleeps, and then sleeps again.</span>\n<span class=\"k\">def</span> <span class=\"nf\">main</span><span class=\"p\">():</span>\n    <span class=\"k\">while</span> <span class=\"kc\">True</span><span class=\"p\">:</span>\n        <span class=\"n\">time</span><span class=\"o\">.</span><span class=\"n\">sleep</span><span class=\"p\">(</span><span class=\"mi\">10</span><span class=\"p\">)</span>\n\n<span class=\"k\">if</span> <span class=\"vm\">__name__</span> <span class=\"o\">==</span> <span class=\"s1\">'__main__'</span><span class=\"p\">:</span>\n    <span class=\"n\">daemon</span> <span class=\"o\">=</span> <span class=\"n\">daemonocle</span><span class=\"o\">.</span><span class=\"n\">Daemon</span><span class=\"p\">(</span>\n        <span class=\"n\">worker</span><span class=\"o\">=</span><span class=\"n\">main</span><span class=\"p\">,</span>\n        <span class=\"n\">pidfile</span><span class=\"o\">=</span><span class=\"s1\">'/var/run/daemonocle_example.pid'</span><span class=\"p\">,</span>\n    <span class=\"p\">)</span>\n    <span class=\"n\">daemon</span><span class=\"o\">.</span><span class=\"n\">do_action</span><span class=\"p\">(</span><span class=\"n\">sys</span><span class=\"o\">.</span><span class=\"n\">argv</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">])</span>\n</pre>\n<p>And here\u2019s the same example with logging and a <a href=\"#shutdown-callback\" rel=\"nofollow\">Shutdown Callback</a>:</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">logging</span>\n<span class=\"kn\">import</span> <span class=\"nn\">sys</span>\n<span class=\"kn\">import</span> <span class=\"nn\">time</span>\n\n<span class=\"kn\">import</span> <span class=\"nn\">daemonocle</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">cb_shutdown</span><span class=\"p\">(</span><span class=\"n\">message</span><span class=\"p\">,</span> <span class=\"n\">code</span><span class=\"p\">):</span>\n    <span class=\"n\">logging</span><span class=\"o\">.</span><span class=\"n\">info</span><span class=\"p\">(</span><span class=\"s1\">'Daemon is stopping'</span><span class=\"p\">)</span>\n    <span class=\"n\">logging</span><span class=\"o\">.</span><span class=\"n\">debug</span><span class=\"p\">(</span><span class=\"n\">message</span><span class=\"p\">)</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">main</span><span class=\"p\">():</span>\n    <span class=\"n\">logging</span><span class=\"o\">.</span><span class=\"n\">basicConfig</span><span class=\"p\">(</span>\n        <span class=\"n\">filename</span><span class=\"o\">=</span><span class=\"s1\">'/var/log/daemonocle_example.log'</span><span class=\"p\">,</span>\n        <span class=\"n\">level</span><span class=\"o\">=</span><span class=\"n\">logging</span><span class=\"o\">.</span><span class=\"n\">DEBUG</span><span class=\"p\">,</span> <span class=\"nb\">format</span><span class=\"o\">=</span><span class=\"s1\">'</span><span class=\"si\">%(asctime)s</span><span class=\"s1\"> [</span><span class=\"si\">%(levelname)s</span><span class=\"s1\">] </span><span class=\"si\">%(message)s</span><span class=\"s1\">'</span><span class=\"p\">,</span>\n    <span class=\"p\">)</span>\n    <span class=\"n\">logging</span><span class=\"o\">.</span><span class=\"n\">info</span><span class=\"p\">(</span><span class=\"s1\">'Daemon is starting'</span><span class=\"p\">)</span>\n    <span class=\"k\">while</span> <span class=\"kc\">True</span><span class=\"p\">:</span>\n        <span class=\"n\">logging</span><span class=\"o\">.</span><span class=\"n\">debug</span><span class=\"p\">(</span><span class=\"s1\">'Still running'</span><span class=\"p\">)</span>\n        <span class=\"n\">time</span><span class=\"o\">.</span><span class=\"n\">sleep</span><span class=\"p\">(</span><span class=\"mi\">10</span><span class=\"p\">)</span>\n\n<span class=\"k\">if</span> <span class=\"vm\">__name__</span> <span class=\"o\">==</span> <span class=\"s1\">'__main__'</span><span class=\"p\">:</span>\n    <span class=\"n\">daemon</span> <span class=\"o\">=</span> <span class=\"n\">daemonocle</span><span class=\"o\">.</span><span class=\"n\">Daemon</span><span class=\"p\">(</span>\n        <span class=\"n\">worker</span><span class=\"o\">=</span><span class=\"n\">main</span><span class=\"p\">,</span>\n        <span class=\"n\">shutdown_callback</span><span class=\"o\">=</span><span class=\"n\">cb_shutdown</span><span class=\"p\">,</span>\n        <span class=\"n\">pidfile</span><span class=\"o\">=</span><span class=\"s1\">'/var/run/daemonocle_example.pid'</span><span class=\"p\">,</span>\n    <span class=\"p\">)</span>\n    <span class=\"n\">daemon</span><span class=\"o\">.</span><span class=\"n\">do_action</span><span class=\"p\">(</span><span class=\"n\">sys</span><span class=\"o\">.</span><span class=\"n\">argv</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">])</span>\n</pre>\n<p>And here\u2019s what it looks like when you run it:</p>\n<pre>user@host:~$ python example.py start\nStarting example.py ... OK\nuser@host:~$ python example.py status\nexample.py -- pid: 1234, status: running, uptime: 1m, %cpu: 0.0, %mem: 0.0\nuser@host:~$ python example.py stop\nStopping example.py ... OK\nuser@host:~$ cat /var/log/daemonocle_example.log\n2014-05-04 12:39:21,090 [INFO] Daemon is starting\n2014-05-04 12:39:21,091 [DEBUG] Still running\n2014-05-04 12:39:31,091 [DEBUG] Still running\n2014-05-04 12:39:41,091 [DEBUG] Still running\n2014-05-04 12:39:51,093 [DEBUG] Still running\n2014-05-04 12:40:01,094 [DEBUG] Still running\n2014-05-04 12:40:07,113 [INFO] Daemon is stopping\n2014-05-04 12:40:07,114 [DEBUG] Terminated by SIGTERM (15)\n</pre>\n<p>For more details, see the <a href=\"#detailed-usage\" rel=\"nofollow\">Detailed Usage</a> section below.</p>\n</div>\n<div id=\"rationale\">\n<h2>Rationale</h2>\n<p>If you think about it, a lot of Unix daemons don\u2019t really know what the hell they\u2019re doing. Have you\never found yourself in a situation that looked something like this?</p>\n<pre>user@host:~$ sudo example start\nstarting example ... ok\nuser@host:~$ ps aux | grep example\nuser      1234  0.0  0.0   1234  1234 pts/1    S+   12:34   0:00 grep example\nuser@host:~$ sudo example start\nstarting example ... ok\nuser@host:~$ echo $?\n0\nuser@host:~$ tail -f /var/log/example.log\n...\n</pre>\n<p>Or something like this?</p>\n<pre>user@host:~$ sudo example stop\nstopping example ... ok\nuser@host:~$ ps aux | grep example\nuser       123  0.0  0.0   1234  1234 ?        Ss   00:00   0:00 /usr/local/bin/example\nuser      1234  0.0  0.0   1234  1234 pts/1    S+   12:34   0:00 grep example\nuser@host:~$ sudo example stop\nstopping example ... ok\nuser@host:~$ ps aux | grep example\nuser       123  0.0  0.0   1234  1234 ?        Ss   00:00   0:00 /usr/local/bin/example\nuser      1240  0.0  0.0   1234  1234 pts/1    S+   12:34   0:00 grep example\nuser@host:~$ sudo kill -9 123\n...\n</pre>\n<p>Or something like this?</p>\n<pre>user@host:~$ sudo example status\nUsage: example {start|stop|restart}\nuser@host:~$ ps aux | grep example\n...\n</pre>\n<p>These are just a few examples of unnecessarily common problems. It doesn\u2019t have to be this way.</p>\n<blockquote>\n<strong>Note:</strong> You might be thinking, \u201cWhy not just write a smarter start/stop shell script wrapper\nfor your daemon that checks whether or not it actually started, actually stopped, etc.?\u201d\nSeriously? <strong>It doesn\u2019t have to be this way.</strong> I believe daemons should be more self-aware. They\nshould handle their own problems most of the time, and your start/stop script should only be a\nvery thin wrapper around your daemon or simply a symlink to your daemon.</blockquote>\n<div id=\"the-problem\">\n<h3>The Problem</h3>\n<p>If you\u2019ve ever dug deep into the nitty-gritty details of how daemonization works, you\u2019re probably\nfamiliar with the <a href=\"http://bit.ly/stevens-daemon\" rel=\"nofollow\">standard \u201cdouble fork\u201d paradigm</a> first introduced\nby W. Richard Stevens in the book <a href=\"http://amzn.com/0321637739\" rel=\"nofollow\">Advanced Programming in the UNIX Environment</a>. One of the problems with the standard way to implement this is that\nif the final child dies immediately when it gets around to doing real work, the original parent\nprocess (the one that actually had control of your terminal) is long gone. So all you know is that\nthe process got forked, but you have no idea if it actually kept running for more than a fraction of\na second. And let\u2019s face it, one of the most likely times for a daemon to die is immediately after\nit starts (due to bad configuration, permissions, etc.).</p>\n<p>The next problem mentioned in the section above is when you try to stop a daemon, it doesn\u2019t\nactually stop, and you have no idea that it didn\u2019t actually stop. This happens when a process\ndoesn\u2019t respond properly to a <tt>SIGTERM</tt> signal. It happens more often than it should. The problem\nis not necessarily the fact that it didn\u2019t stop. It\u2019s the fact that you didn\u2019t <em>know</em> that it didn\u2019t\nstop. The start/stop script knows that it successfully sent the signal and so it assumes success.\nThis also becomes a problem when your <tt>restart</tt> command blindly calls <tt>stop</tt> and then <tt>start</tt>,\nbecause it will try to start a new instance of the daemon before the previous one has exited.</p>\n<p>These are the biggest problems most daemons have in my opinion. daemonocle solves these problems and\nprovides many other \u201cfancy\u201d features.</p>\n</div>\n<div id=\"the-solution\">\n<h3>The Solution</h3>\n<p>The problem with the daemon immediately dying on startup and you not knowing about it is solved by\nhaving the first child (the immediate parent of the final child) sleep for one second and then call\n<tt>os.waitpid(pid, os.WNOHANG)</tt> to see if the process is still running. This is what daemonocle\ndoes. So if you\u2019re daemon dies within one second of starting, you\u2019ll know about it.</p>\n<p>This problem with the daemon not stopping and you not knowing about it is solved by simply waiting\nfor the process to finish (with a timeout). This is what daemonocle does. (Note: When a timeout\noccurs, it doesn\u2019t try to send a <tt>SIGKILL</tt>. This is not always what you\u2019d want and often not a\ngood idea.)</p>\n</div>\n<div id=\"other-useful-features\">\n<h3>Other Useful Features</h3>\n<p>Below are some other useful features that daemononcle provides that you might not find elsewhere.</p>\n<div id=\"the-status-action\">\n<h4>The <tt>status</tt> Action</h4>\n<p>There is a <tt>status</tt> action that not only displays whether or not the daemon is running and its\nPID, but also the uptime of the daemon and the % CPU and % memory usage of all the processes in the\nsame process group as the daemon (which are probably its children). So if you have a daemon that\nlaunches mulitple worker processes, the <tt>status</tt> action will show the % CPU and % memory usage of\nall the workers combined.</p>\n<p>It might look something like this:</p>\n<pre>user@host:~$ python example.py status\nexample.py -- pid: 1234, status: running, uptime: 12d 3h 4m, %cpu: 12.4, %mem: 4.5\n</pre>\n</div>\n<div id=\"slightly-smarter-restart-action\">\n<h4>Slightly Smarter <tt>restart</tt> Action</h4>\n<p>Have you ever tried to restart a daemon only to realize that it\u2019s not actually running? Let me\nguess: it just gave you an error and didn\u2019t start the daemon. A lot of the time this is not a\nproblem, but if you\u2019re trying to restart the daemon in an automated way, it\u2019s more annoying to have\nto check if it\u2019s running and do either a <tt>start</tt> or <tt>restart</tt> accordingly. With daemonocle, if\nyou try to restart a daemon that\u2019s not running, it will give you a warning saying that it wasn\u2019t\nrunning and then start the daemon. This is often what people expect.</p>\n</div>\n<div id=\"self-reload\">\n<h4>Self-Reload</h4>\n<p>Daemons that use daemonocle have the ability to reload themselves by simply calling\n<tt>daemon.reload()</tt> where <tt>daemon</tt> is your <tt>daemonocle.Daemon</tt> instance. The execution of the\ncurrent daemon halts wherever <tt>daemon.reload()</tt> was called, and a new daemon is started up to\nreplace the current one. From your code\u2019s perspective, it\u2019s pretty much the same as a doing a\n<tt>restart</tt> except that it\u2019s initiated from within the daemon itself and there\u2019s no signal handling\ninvolved. Here\u2019s a basic example of a daemon that watches a config file and reloads itself when the\nconfig file changes:</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">os</span>\n<span class=\"kn\">import</span> <span class=\"nn\">sys</span>\n<span class=\"kn\">import</span> <span class=\"nn\">time</span>\n\n<span class=\"kn\">import</span> <span class=\"nn\">daemonocle</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">FileWatcher</span><span class=\"p\">(</span><span class=\"nb\">object</span><span class=\"p\">):</span>\n\n    <span class=\"k\">def</span> <span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">filename</span><span class=\"p\">,</span> <span class=\"n\">daemon</span><span class=\"p\">):</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_filename</span> <span class=\"o\">=</span> <span class=\"n\">filename</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_daemon</span> <span class=\"o\">=</span> <span class=\"n\">daemon</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_file_mtime</span> <span class=\"o\">=</span> <span class=\"n\">os</span><span class=\"o\">.</span><span class=\"n\">stat</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_filename</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">st_mtime</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">file_has_changed</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"n\">current_mtime</span> <span class=\"o\">=</span> <span class=\"n\">os</span><span class=\"o\">.</span><span class=\"n\">stat</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_filename</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">st_mtime</span>\n        <span class=\"k\">if</span> <span class=\"n\">current_mtime</span> <span class=\"o\">!=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_file_mtime</span><span class=\"p\">:</span>\n            <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_file_mtime</span> <span class=\"o\">=</span> <span class=\"n\">current_mtime</span>\n            <span class=\"k\">return</span> <span class=\"kc\">True</span>\n        <span class=\"k\">return</span> <span class=\"kc\">False</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">watch</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"k\">while</span> <span class=\"kc\">True</span><span class=\"p\">:</span>\n            <span class=\"k\">if</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">file_has_changed</span><span class=\"p\">():</span>\n                <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_daemon</span><span class=\"o\">.</span><span class=\"n\">reload</span><span class=\"p\">()</span>\n            <span class=\"n\">time</span><span class=\"o\">.</span><span class=\"n\">sleep</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n\n<span class=\"k\">if</span> <span class=\"vm\">__name__</span> <span class=\"o\">==</span> <span class=\"s1\">'__main__'</span><span class=\"p\">:</span>\n    <span class=\"n\">daemon</span> <span class=\"o\">=</span> <span class=\"n\">daemonocle</span><span class=\"o\">.</span><span class=\"n\">Daemon</span><span class=\"p\">(</span><span class=\"n\">pidfile</span><span class=\"o\">=</span><span class=\"s1\">'/var/run/daemonocle_example.pid'</span><span class=\"p\">)</span>\n    <span class=\"n\">fw</span> <span class=\"o\">=</span> <span class=\"n\">FileWatcher</span><span class=\"p\">(</span><span class=\"n\">filename</span><span class=\"o\">=</span><span class=\"s1\">'/etc/daemonocle_example.conf'</span><span class=\"p\">,</span> <span class=\"n\">daemon</span><span class=\"o\">=</span><span class=\"n\">daemon</span><span class=\"p\">)</span>\n    <span class=\"n\">daemon</span><span class=\"o\">.</span><span class=\"n\">worker</span> <span class=\"o\">=</span> <span class=\"n\">fw</span><span class=\"o\">.</span><span class=\"n\">watch</span>\n    <span class=\"n\">daemon</span><span class=\"o\">.</span><span class=\"n\">do_action</span><span class=\"p\">(</span><span class=\"n\">sys</span><span class=\"o\">.</span><span class=\"n\">argv</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">])</span>\n</pre>\n</div>\n<div id=\"shutdown-callback\">\n<h4>Shutdown Callback</h4>\n<p>You may have noticed from the <a href=\"#basic-usage\" rel=\"nofollow\">Basic Usage</a> section above that a <tt>shutdown_callback</tt> was defined.\nThis function gets called whenever the daemon is shutting down in a catchable way, which should be\nmost of the time except for a <tt>SIGKILL</tt> or if your server crashes unexpectedly or loses power or\nsomething like that. This function can be used for doing any sort of cleanup that your daemon needs\nto do. Also, if you want to log (to the logger of your choice) the reason for the shutdown and the\nintended exit code, you can use the <tt>message</tt> and <tt>code</tt> arguments that will be passed to your\ncallback (your callback must take these two arguments).</p>\n</div>\n<div id=\"non-detached-mode\">\n<h4>Non-Detached Mode</h4>\n<p>This is not particularly interesting per se, but it\u2019s worth noting that in non-detached mode, your\ndaemon will do everything else you\u2019ve configured it to do (i.e. <tt>setuid</tt>, <tt>setgid</tt>, <tt>chroot</tt>,\netc.) except actually detaching from your terminal. So while you\u2019re testing, you can get an\nextremely accurate view of how your daemon will behave in the wild. It\u2019s also worth noting that\nself-reloading works in non-detached mode, which was a little tricky to figure out initially.</p>\n</div>\n<div id=\"file-descriptor-handling\">\n<h4>File Descriptor Handling</h4>\n<p>One of the things that daemons typically do is close all open file descriptors and establish new\nones for <tt>STDIN</tt>, <tt>STDOUT</tt>, <tt>STDERR</tt> that just point to <tt>/dev/null</tt>. This is fine most of\nthe time, but if your worker is an instance method of a class that opens files in its <tt>__init__()</tt>\nmethod, then you\u2019ll run into problems if you\u2019re not careful. This is also a problem if you\u2019re\nimporting a module that leaves open files behind. For example, importing the\n<a href=\"https://docs.python.org/3/library/random.html\" rel=\"nofollow\">random</a> standard library module in Python 3\nresults in an open file descriptor for <tt>/dev/urandom</tt>.</p>\n<p>Since this \u201cfeature\u201d of daemons often causes more problems than it solves, and the problems it\ncauses sometimes have strange side-effects that make it very difficult to troubleshoot, this feature\nis optional and disabled by default in daemonocle via the <tt>close_open_files</tt> option.</p>\n</div>\n</div>\n</div>\n<div id=\"detailed-usage\">\n<h2>Detailed Usage</h2>\n<p>The <tt>daemonocle.Daemon</tt> class is the main class for creating a daemon using daemonocle. Here\u2019s the\nconstructor signature for the class:</p>\n<pre><span class=\"k\">class</span> <span class=\"nc\">daemonocle</span><span class=\"o\">.</span><span class=\"n\">Daemon</span><span class=\"p\">(</span>\n    <span class=\"n\">worker</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"n\">shutdown_callback</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"n\">prog</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"n\">pidfile</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"n\">detach</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">,</span>\n    <span class=\"n\">uid</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"n\">gid</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"n\">workdir</span><span class=\"o\">=</span><span class=\"s1\">'/'</span><span class=\"p\">,</span> <span class=\"n\">chrootdir</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"n\">umask</span><span class=\"o\">=</span><span class=\"mi\">022</span><span class=\"p\">,</span> <span class=\"n\">stop_timeout</span><span class=\"o\">=</span><span class=\"mi\">10</span><span class=\"p\">,</span>\n    <span class=\"n\">close_open_files</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">)</span>\n</pre>\n<p>And here are descriptions of all the arguments:</p>\n<dl>\n<dt><strong>worker</strong></dt>\n<dd>The function that does all the work for your daemon.</dd>\n<dt><strong>shutdown_callback</strong></dt>\n<dd>This will get called anytime the daemon is shutting down. It should take a <tt>message</tt> and a\n<tt>code</tt> argument. The message is a human readable message that explains why the daemon is\nshutting down. It might useful to log this message. The code is the exit code with which it\nintends to exit. See <a href=\"#shutdown-callback\" rel=\"nofollow\">Shutdown Callback</a> for more details.</dd>\n<dt><strong>prog</strong></dt>\n<dd>The name of your program to use in output messages. Default: <tt>os.path.basename(sys.argv[0])</tt></dd>\n<dt><strong>pidfile</strong></dt>\n<dd>The path to a PID file to use. It\u2019s not required to use a PID file, but if you don\u2019t, you won\u2019t\nbe able to use all the features you might expect. Make sure the user your daemon is running as\nhas permission to write to the directory this file is in.</dd>\n<dt><strong>detach</strong></dt>\n<dd>Whether or not to detach from the terminal and go into the background. See <a href=\"#non-detached-mode\" rel=\"nofollow\">Non-Detached Mode</a>\nfor more details. Default: <tt>True</tt></dd>\n<dt><strong>uid</strong></dt>\n<dd>The user ID to switch to when the daemon starts. The default is not to switch users.</dd>\n<dt><strong>gid</strong></dt>\n<dd>The group ID to switch to when the daemon starts. The default is not to switch groups.</dd>\n<dt><strong>workdir</strong></dt>\n<dd>The path to a directory to change to when the daemon starts. Note that a file system cannot be\nunmounted if a process has its working directory on that file system. So if you change the\ndefault, be careful about what you change it to. Default: <tt>\"/\"</tt></dd>\n<dt><strong>chrootdir</strong></dt>\n<dd>The path to a directory to set as the effective root directory when the daemon starts. The\ndefault is not to do anything.</dd>\n<dt><strong>umask</strong></dt>\n<dd>The file creation mask (\u201cumask\u201d) for the process. Default: <tt>022</tt></dd>\n<dt><strong>stop_timeout</strong></dt>\n<dd>Number of seconds to wait for the daemon to stop before throwing an error. Default: <tt>10</tt></dd>\n<dt><strong>close_open_files</strong></dt>\n<dd>Whether or not to close all open files when the daemon detaches. Default: <tt>False</tt></dd>\n</dl>\n<div id=\"actions\">\n<h3>Actions</h3>\n<p>The default actions are <tt>start</tt>, <tt>stop</tt>, <tt>restart</tt>, and <tt>status</tt>. You can get a list of\navailable actions using the <tt>daemonocle.Daemon.list_actions()</tt> method. The recommended way to call\nan action is using the <tt>daemonocle.Daemon.do_action(action)</tt> method. The string name of an action\nis the same as the method name except with dashes in place of underscores.</p>\n<p>If you want to create your own actions, simply subclass <tt>daemonocle.Daemon</tt> and add the\n<tt>@daemonocle.expose_action</tt> decorator to your action method, and that\u2019s it.</p>\n<p>Here\u2019s an example:</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">daemonocle</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">MyDaemon</span><span class=\"p\">(</span><span class=\"n\">daemonocle</span><span class=\"o\">.</span><span class=\"n\">Daemon</span><span class=\"p\">):</span>\n\n    <span class=\"nd\">@daemonocle</span><span class=\"o\">.</span><span class=\"n\">expose_action</span>\n    <span class=\"k\">def</span> <span class=\"nf\">full_status</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"sd\">\"\"\"Get more detailed status of the daemon.\"\"\"</span>\n        <span class=\"k\">pass</span>\n</pre>\n<p>Then, if you did the basic <tt>daemon.do_action(sys.argv[1])</tt> like in all the examples above, you can\ncall your action with a command like <tt>python example.py <span class=\"pre\">full-status</span></tt>.</p>\n</div>\n<div id=\"integration-with-mitsuhiko-s-click\">\n<h3>Integration with mitsuhiko\u2019s click</h3>\n<p>daemonocle also provides an integration with <a href=\"http://click.pocoo.org/\" rel=\"nofollow\">click</a>, the \u201ccomposable\ncommand line utility\u201d. The integration is in the form of a custom command class\n<tt>daemonocle.cli.DaemonCLI</tt> that you can use in conjunction with the <tt>@click.command()</tt> decorator\nto automatically generate a command line interface with subcommands for all your actions. It also\nautomatically daemonizes the decorated function. The decorated function becomes the worker, and the\nactions are automatically mapped from click to daemonocle.</p>\n<p>Here\u2019s an example:</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">time</span>\n\n<span class=\"kn\">import</span> <span class=\"nn\">click</span>\n<span class=\"kn\">from</span> <span class=\"nn\">daemonocle.cli</span> <span class=\"kn\">import</span> <span class=\"n\">DaemonCLI</span>\n\n<span class=\"nd\">@click</span><span class=\"o\">.</span><span class=\"n\">command</span><span class=\"p\">(</span><span class=\"bp\">cls</span><span class=\"o\">=</span><span class=\"n\">DaemonCLI</span><span class=\"p\">,</span> <span class=\"n\">daemon_params</span><span class=\"o\">=</span><span class=\"p\">{</span><span class=\"s1\">'pidfile'</span><span class=\"p\">:</span> <span class=\"s1\">'/var/run/example.pid'</span><span class=\"p\">})</span>\n<span class=\"k\">def</span> <span class=\"nf\">main</span><span class=\"p\">():</span>\n    <span class=\"sd\">\"\"\"This is my awesome daemon. It pretends to do work in the background.\"\"\"</span>\n    <span class=\"k\">while</span> <span class=\"kc\">True</span><span class=\"p\">:</span>\n        <span class=\"n\">time</span><span class=\"o\">.</span><span class=\"n\">sleep</span><span class=\"p\">(</span><span class=\"mi\">10</span><span class=\"p\">)</span>\n\n<span class=\"k\">if</span> <span class=\"vm\">__name__</span> <span class=\"o\">==</span> <span class=\"s1\">'__main__'</span><span class=\"p\">:</span>\n    <span class=\"n\">main</span><span class=\"p\">()</span>\n</pre>\n<p>Running this example would look something like this:</p>\n<pre>user@host:~$ python example.py --help\nUsage: example.py [&lt;options&gt;] &lt;command&gt; [&lt;args&gt;]...\n\n  This is my awesome daemon. It pretends to do work in the background.\n\nOptions:\n  --help  Show this message and exit.\n\nCommands:\n  start    Start the daemon.\n  stop     Stop the daemon.\n  restart  Stop then start the daemon.\n  status   Get the status of the daemon.\nuser@host:~$ python example.py start --help\nUsage: example.py start [&lt;options&gt;]\n\n  Start the daemon.\n\nOptions:\n  --debug  Do NOT detach and run in the background.\n  --help   Show this message and exit.\n</pre>\n<p>The <tt>daemonocle.cli.DaemonCLI</tt> class also accepts a <tt>daemon_class</tt> argument that can be a\nsubclass of <tt>daemonocle.Daemon</tt>. It will use your custom class, automatically create subcommands\nfor any custom actions you\u2019ve defined, and use the docstrings of the action methods as the help text\njust like click usually does.</p>\n<p>This integration is entirely optional. daemonocle doesn\u2019t enforce any sort of argument parsing. You\ncan use argparse, optparse, or just plain <tt>sys.argv</tt> if you want.</p>\n</div>\n</div>\n<div id=\"bugs-requests-questions-etc\">\n<h2>Bugs, Requests, Questions, etc.</h2>\n<p>Please create an <a href=\"https://github.com/jnrbsn/daemonocle/issues\" rel=\"nofollow\">issue on GitHub</a>.</p>\n</div>\n\n          </div>"}, "last_serial": 1907374, "releases": {"0.8.1": [{"comment_text": "", "digests": {"md5": "e9afe7dc51df87940f253ca9760e380e", "sha256": "ecdaee435b5fb42c22ba3f638efc5dffaf73100bb65b2f2013b83fdf12955dbb"}, "downloads": -1, "filename": "xdaemonocle-0.8.1.tar.gz", "has_sig": false, "md5_digest": "e9afe7dc51df87940f253ca9760e380e", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 18002, "upload_time": "2016-01-16T14:49:20", "upload_time_iso_8601": "2016-01-16T14:49:20.943102Z", "url": "https://files.pythonhosted.org/packages/5d/19/5c61a2f002e24ea17acc416ad25533c6652bf3b7c51b76e9469ed27e629a/xdaemonocle-0.8.1.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "e9afe7dc51df87940f253ca9760e380e", "sha256": "ecdaee435b5fb42c22ba3f638efc5dffaf73100bb65b2f2013b83fdf12955dbb"}, "downloads": -1, "filename": "xdaemonocle-0.8.1.tar.gz", "has_sig": false, "md5_digest": "e9afe7dc51df87940f253ca9760e380e", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 18002, "upload_time": "2016-01-16T14:49:20", "upload_time_iso_8601": "2016-01-16T14:49:20.943102Z", "url": "https://files.pythonhosted.org/packages/5d/19/5c61a2f002e24ea17acc416ad25533c6652bf3b7c51b76e9469ed27e629a/xdaemonocle-0.8.1.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:25:58 2020"}