{"info": {"author": "Dhruv Pathak", "author_email": "pathakdhruv9786@gmail.com", "bugtrack_url": null, "classifiers": ["License :: OSI Approved :: BSD License", "Operating System :: OS Independent", "Programming Language :: Python :: 3"], "description": "# GalDynPsr Package\n\nGalDynPsr is a package for calculating dynamical contributions in the period derivatives of pulsars in the Galactic field. It can calculate the fractional contributions or the excess terms, e.g. \\dot{P}/P|_excess where P is either the orbital period or the spin period. Various dynamical contributions, including the Shklovskii effect (the contribution due to the proper motion) or due to the acceleration of the pulsar caused by the gravitational potential of the Galaxy, can be calculated. Various methods or models to perform these tasks are available in the package. Using the measured values of the periods and period derivatives, GalDynPsr can even compute the \"intrinsic\" values of the period derivatives, provided no other extra contribution exist. \n\nDetails on various dynamical effects and various models to estimate those are available in Pathak and Bagchi (arXiv:1712.06590).\n\nBrief outline of usage of GalDynPsr is given below.\n\nQuestions and queries can be sent to Dhruv Pathak pathakdhruv9786 at gmail dot com\n\n# 1) After installing numpy, scipy, and galpy successfully, install GalDynPsr\n\npip3 install GalDynPsr\n\n### If wished, one can change the values of Rs (galactocentric cylindrical radius of the sun), Vs  (rotational speed of the sun) etc in parameters.in file that can be found inside the GalDynPsr (installed directory). \n## But remember that galpy also has these values defined in the file '$home/.galpyrc'. One can in principle change these values. \n# However, the Milky Way potential in galpy was fitted with Rs = 8.0 kpc and vs = 220.0 in galpy\n\n\n# 2) Import GalDynPsr in your code as\n\nimport GalDynPsr\n\n# 3) In all of the following modules, the ordering of the arguments of the functions are very important.\n\n# 4) Calculate excess terms of modelX ** Very important, model names are case sensitive!\n\nGalDynPsr.modelX.Expl(ldeg, sigl, bdeg, sigb, dkpc, sigd) and GalDynPsr.modelX.Exz(ldeg, sigl, bdeg, sigb, dkpc, sigd)\n\nThe function Expl() calculates the excess term due to the relative acceleration of the pulsar parallel to the Galactic plane and the function Exz() calculates the excess term due to the relative acceleration of the pulsar perpendicular to the Galactic plane. Total dynamical contribution will be the sum of above two terms. Both of the above functions takes the arguments as the Galactic longitude in degrees (say ldeg), uncertainty in the Galactic longitude in degrees (say sigl), the Galactic latitude in degrees (say bdeg), uncertainty in the Galactic latitude in degrees (say sigb), the distance of the pulsar from the solar system barycenter in kpc (say dkpc), and the uncertainty in the distance in kpc (say sigd); strictly in this order. One needs to assign the values of ldeg, sigl, bdeg, sigb, dkpc, and sigd before calling the above functions.\n\nThe models that do not involve galpy can return uncertainities in the excess terms following standard error propagation method, like \n\nmodelX.Errpl(ldeg, sigl, bdeg, sigb, dkpc, sigd) and modelX.Errz(ldeg, sigl, bdeg, sigb, dkpc, sigd) \n\nwhere the function Errpl() returns the uncertainty in the excess terms due to the relative acceleration of the pulsar parallel to the Galactic plane and Errz() returns the uncertainty in the excess terms due to the relative acceleration of the pulsar perpendicular to the Galactic plane. The arguments are the same as before, and needs to be assigend values before using the functions.\n\nRemeber to replace modelX by the model you  want to use, like modelA, modelLa, etc. Model names are case sensitive!\n\n# 5) Calculate the Shklovskii term\n\nThe Shklovskii term can be calculated as GalDynPsr.Shk.Exshk(dkpc, sigd, mu_alpha, sigmua, mu_delta, sigmud) and the error in the Shklovskii term as GalDynPsr.Shk.errShk(dkpc, sigd, mu_alpha, sigmua, mu_delta, sigmud)\n\nwhere mu_alpha is the proper motion in the Right Ascesion direction (mas/yr), mu_delta is the proper motion in the Declination direction (mas/yr), sigmua is the uncertainty in mu_alpha, and sigmud is the uncertainty in mu_delta. dkpc is as usual the distance of the pulsar from the solar system barycenter in kpc and sigd is the uncertainty in dkpc. One needs to assign the values of these parameters first.\n\n\n# 6) Print the basic parameters of the pulsars\n\nGalDynPsr.read_parameters.Rskpc returns the Galactocentric cylindrical radius of the sun.\n\nGalDynPsr.read_parameters.Vs returns the rotational speed of the sun.\n\nGalDynPsr.read_parameters.Rpkpc(ldeg, sigl, bdeg, sigb, dkpc, sigd) returns the value of Galactocentric cylindrical radius of the pulsar in kpc and GalDynPsr.read_parameters.z(ldeg, sigl, bdeg, sigb, dkpc, sigd) returns the verical height of the pulsar from the Galactic plane. The meaning of the arguments are as usual:\n\nOne can get the uncertainty in the Galactocentric cylindrical radius of the pulsar in kpc using GalDynPsr.read_parameters.ErrRpkpc(ldeg, sigl, bdeg, sigb, dkpc, sigd) and the uncertainty in the verical height as GalDynPsr.read_parameters.Errz(ldeg, sigl, bdeg, sigb, dkpc, sigd).\n\nObviously,  one first needs to assign the values of ldeg, sigl, bdeg, sigb, dkpc, and sigd.\n\n\n# 7) For a pulsar in a globular cluster, one can read the cluster parameters, e.g. the Galactic longitude, latitude and the distance from the Harric catalogue (GC_harris.txt coming with GalDynPsr), and calculate crude values of the dynamical terms\n\nOne first needs to import the module to read Harris cataloge as:\n\nimport GalDynPsr.ReadGC as readgc\n\nThen one can input the name of the cluster, e.g. readgc.gcinput(\"47Tuc\")\n\nThen the excess terms using modelX can be calculated as \n\nsigl=0.000001\nsigb=0.000001\nsigd=0.000001\n\nGalDynPsr.modelX.Expl(readgc.ldeg,sigl,readgc.bdeg,sigb,readgc.dkpc,sigd) # the parallel component\nGalDynPsr.modelX.Exz(readgc.ldeg,sigl,readgc.bdeg,sigb,readgc.dkpc,sig) # the perpendicular component\n\nNote that the Harris catalogue does not provide uncertainties in ldeg, bdeg and dkpc. That is why we need to define them before calculating the excess terms. As the pulsar parameters differ from the cluster parameters as in Harris catalogue, it is meaningless to calculate uncetrainities. So, one SHOULD simply call the above functions as:\n\nGalDynPsr.modelX.Expl(readgc.ldeg,0.0,readgc.bdeg,0.0,readgc.dkpc,0.0) # the parallel component\nGalDynPsr.modelX.Exz(readgc.ldeg,0.0,readgc.bdeg,0.0,readgc.dkpc,0.0) # the perpendicular component\n\n# 8) models involving galpy does not return error. However, that can be done using simulation. See Example-2 below.\n\n# 9) Calculation of instrinsic period. Ordering of the arguments is important.\n\n\nFirst assign values of ldeg, sigl, bdeg, sigb, dkpc, sigd (meaning of the parameters are as usual) and calculate the excess terms as usual:\n\nEx_pl =  GalDynPsr.modelA.Expl(ldeg, sigl, bdeg, sigb, dkpc, sigd) # excess term parallel to the Galactic plane\n\nEx_z =  GalDynPsr.modelA.Exz(ldeg, sigl, bdeg, sigb, dkpc, sigd) # excess term perpendicular to the Galactic plane\n\nerrpl =  GalDynPsr.modelA.Errpl(ldeg, sigl, bdeg, sigb, dkpc, sigd) # uncertainty in the parallel term\n\nerrz =  GalDynPsr.modelA.Errz(ldeg, sigl, bdeg, sigb, dkpc, sigd) # uncertainty in the parallel term\n\nEx_shk =  GalDynPsr.Shk.Exshk(dkpc, sigd, mu_alpha, sigmua, mu_delta, sigmud) # excess term due to the Shklovskii effect\n\nerrshk =  GalDynPsr.Shk.errShk(dkpc, sigd, mu_alpha, sigmua, mu_delta, sigmud) # uncertainties in the Shklovskii term\n\n\nNow assign the values of the period 'P' in seconds, the uncertainy in period 'sigP' in seconds, the measured value of the period derivative 'Pdot_obs' in seconds/seconds and the uncertainty in the measured value of the period derivative 'sigPdot' in seconds/seconds; and calculate the dynamically caused values of the period derivatives (in seconds/seconds) as:\n\nGalDynPsr.pdotint.PdotExpl(Ex_pl,P) # due to the parallel component of the acceleration\n\nGalDynPsr.pdotint.PdotExz(Ex_z,P) # due to the perpendicular component of the acceleration\n\nGalDynPsr.pdotint.PdotShk(Ex_shk,P) # due to the Shklovskii effect\n\nThe total dynamically caused value of Pdot is the addition of the above three terms. The intrinsic value of the period derivative can be calculated by subtracting that sum from the measured value of the period derivative. GalDynPsr can perform this task for us by:\n\nGalDynPsr.pdotint.Pdotint(Ex_pl,Ex_z,Ex_shk,Pdot_obs,P) \n\nThe total dynamical contribution in the period derivative, i.e. the sum of GalDynPsr.pdotint.PdotExpl(Ex_pl,P) and GalDynPsr.pdotint.PdotExz(Ex_z,P) can be printed as:\nGalDynPsr.pdotint.PdotGal(Ex_pl,Ex_z,P)\n\nOne can calculate the uncertainity in the above period drivatives as:\n\nGalDynPsr.pdotint.ErrPdotExpl(Ex_pl,errpl,P,sigP) # uncertainty in the planar contribution to the period derivative\n\nGalDynPsr.pdotint.ErrPdotExz(Ex_z,errz,P,sigP) # uncertainty in the perpendicular contribution to the period derivative\n\nGalDynPsr.pdotint.ErrPdotGal(Ex_pl,errpl,Ex_z,errz,P,sigP) # uncertainty in the sum of planar and perpendicular contributions to the period derivative\n\nGalDynPsr.pdotint.ErrPdotShk(Ex_shk,errshk,P,sigP) # uncertainty in the Shklovskii term contribution to the period derivative\n\nGalDynPsr.pdotint.ErrPdotint(Ex_pl,errpl,Ex_z,errz,Ex_shk,errshk,Pdot_obs,sigPdot_obs,P,sigP) # uncertainty in the intrinsic period derivative\n\n* Remember the fact that GalDynPsr reads the value of the period in seconds. Orbital periods are usually measured in days (or sometimes in hours). One needs to convert those values in seconds before calling GalDynPsr modules.\n\n\n\n### All the above points will be clearer from the following examples ################\n#####  Instructions to use GalDynPsr #####  \n\n# Call GalDynPsr as:-\n\n\nimport GalDynPsr\n\n\n\n\n## Provide the following values in your code ###\n\n# ldeg = Galactic logitude in degrees, bdeg = Galactic latitude in degrees, dkpc = distance to pulsar in kpc, sigl = error in ldeg, sigb = error in bdeg, sigd = error in dkpc\n\n########### Example-1 #################\nldeg =20.0\nsigl = 2.0\n\nbdeg = 45.0\nsigb = 0.2\n\ndkpc = 1.2\nsigd = 0.3\n\n\n\n############# Extract important parameters say values of Rp (in kpc) and z (in kpc) and errors in them  ##########\n\n\n\n\nRpkpc = GalDynPsr.read_parameters.Rpkpc(ldeg, sigl, bdeg, sigb, dkpc, sigd)\n\nzkpc = GalDynPsr.read_parameters.z(ldeg, sigl, bdeg, sigb, dkpc, sigd)\n\nErrRp = GalDynPsr.read_parameters.ErrRp(ldeg, sigl, bdeg, sigb, dkpc, sigd)\n\nErrz = GalDynPsr.read_parameters.Errz(ldeg, sigl, bdeg, sigb, dkpc, sigd)\n\n\n#################  Compute excess Shklovskii term. Here Exshk() calculates the dynamical contribution (or the excess term) due to Shklovskii effect and errShk() calculates the error in that #################################\n\n#### We need to provide the values of proper motion in right ascesion direction (with the corresponding error) and proper motion in the declination direction (with the corresponding error)########\n\n##mu_alpha = proper motion in Right Ascesion direction (mas/yr), mu_delta = proper motion in Declination direction (mas/yr), sigmua = error in mu_alpha, and sigmud = error in mu_delta\n\n\n\nmu_alpha = 22.0\nsigmua = 0.2\n\nmu_delta = 1.2\nsigmud = 0.3\n\n\nExcessSh = GalDynPsr.Shk.Exshk(dkpc, sigd, mu_alpha, sigmua, mu_delta, sigmud)\n\nsigmaExcessSh = GalDynPsr.Shk.errShk(dkpc, sigd, mu_alpha, sigmua, mu_delta, sigmud)\n\n\n\n### Example-1.1 ###\n\n### Model A (can propagate error)######\n\n\nApl = GalDynPsr.modelA.Expl(ldeg, sigl, bdeg, sigb, dkpc, sigd) #calculates the planar contribution to the excess term\n\nAz = GalDynPsr.modelA.Exz(ldeg, sigl, bdeg, sigb, dkpc, sigd) #calculates the perpendicular contribution to the excess term\n\n\nAplsigma = GalDynPsr.modelA.Errpl(ldeg, sigl, bdeg, sigb, dkpc, sigd) #calculates the error in the planar contribution to the excess term\n\nAzsigma = GalDynPsr.modelA.Errz(ldeg, sigl, bdeg, sigb, dkpc, sigd) #calculates the error in the perpendicular contribution to the excess term\n\n\ntotalA = Apl + Az\n\nSigmatotalA = math.sqrt(Aplsigma*Aplsigma+Azsigma*Azsigma) # assuming no correlation between excepp_pl and excess_z\n\n\n### Example-1.2 ###\n\n### Model B (can propagate error)######\n\n\nBpl = GalDynPsr.modelB.Expl(ldeg, sigl, bdeg, sigb, dkpc, sigd) #calculates the planar contribution to the excess term\n\nBz = GalDynPsr.modelB.Exz(ldeg, sigl, bdeg, sigb, dkpc, sigd) #calculates the perpendicular contribution to the excess term\n\n\nBplsigma = GalDynPsr.modelB.Errpl(ldeg, sigl, bdeg, sigb, dkpc, sigd) #calculates the error in the planar contribution to the excess term\n\nBzsigma = GalDynPsr.modelB.Errz(ldeg, sigl, bdeg, sigb, dkpc, sigd) #calculates the error in the perpendicular contribution to the excess term\n\n\ntotalB = Bpl + Bz\n\nSigmatotalB = math.sqrt(Bplsigma*Bplsigma+Bzsigma*Bzsigma) # assuming no correlation between excepp_pl and excess_z\n\n\n\n### Example-1.3 ###\n\n### Model C (can propagate error)######\n\n\nCpl = GalDynPsr.modelC.Expl(ldeg, sigl, bdeg, sigb, dkpc, sigd) #calculates the planar contribution to the excess term\n\nCz = GalDynPsr.modelC.Exz(ldeg, sigl, bdeg, sigb, dkpc, sigd) #calculates the perpendicular contribution to the excess term\n\n\nCplsigma = GalDynPsr.modelC.Errpl(ldeg, sigl, bdeg, sigb, dkpc, sigd) #calculates the error in the planar contribution to the excess term\n\nCzsigma = GalDynPsr.modelC.Errz(ldeg, sigl, bdeg, sigb, dkpc, sigd) #calculates the error in the perpendicular contribution to the excess term\n\n\ntotalC = Cpl + Cz\n\nSigmatotalC = math.sqrt(Cplsigma*Cplsigma+Czsigma*Czsigma) # assuming no correlation between excepp_pl and excess_z\n\n\n### Example-1.4 ###\n\n### Model D (can propagate error)######\n\n\nDpl = GalDynPsr.modelD.Expl(ldeg, sigl, bdeg, sigb, dkpc, sigd) #calculates the planar contribution to the excess term\n\nDz = GalDynPsr.modelD.Exz(ldeg, sigl, bdeg, sigb, dkpc, sigd) #calculates the perpendicular contribution to the excess term\n\n\nDplsigma = GalDynPsr.modelD.Errpl(ldeg, sigl, bdeg, sigb, dkpc, sigd) #calculates the error in the planar contribution to the excess term\n\nDzsigma = GalDynPsr.modelD.Errz(ldeg, sigl, bdeg, sigb, dkpc, sigd) #calculates the error in the perpendicular contribution to the excess term\n\n\ntotalD = Dpl + Dz\n\nSigmatotalD = math.sqrt(Dplsigma*Dplsigma+Dzsigma*Dzsigma) # assuming no correlation between excepp_pl and excess_z\n\n\n\n### Example-1.5 ###\n\n############  Model Ea (error only in parallel component)   ###############\n\n\nEapl = GalDynPsr.modelEa.Expl(ldeg, sigl, bdeg, sigb, dkpc, sigd) #calculates the planar contribution to the excess term\n\nSigmaEapl = GalDynPsr.modelEa.Errpl(ldeg, sigl, bdeg, sigb, dkpc, sigd) #calculates the error in the planar contribution to the excess term\n\nEaz = GalDynPsr.modelEa.Exz(ldeg, sigl, bdeg, sigb, dkpc, sigd) #calculates the perpendicular contribution to the excess term\n\ntotalEa = Eapl+Eaz\n\n\n### Example-1.6 ###\n\n############  Model Eb (error only in parallel component)   ###############\n\n\nEbpl = GalDynPsr.modelEb.Expl(ldeg, sigl, bdeg, sigb, dkpc, sigd) #calculates the planar contribution to the excess term\n\nSigmaEbpl = GalDynPsr.modelEb.Errpl(ldeg, sigl, bdeg, sigb, dkpc, sigd) #calculates the error in the planar contribution to the excess term\n\nEbz = GalDynPsr.modelEb.Exz(ldeg, sigl, bdeg, sigb, dkpc, sigd) #calculates the perpendicular contribution to the excess term\n\ntotalEb = Ebpl+Ebz\n\n\n### Example-1.7 ###\n\n############  Model Fa (error only in parallel component)   ###############\n\n\n\nFapl = GalDynPsr.modelFa.Expl(ldeg, sigl, bdeg, sigb, dkpc, sigd) #calculates the planar contribution to the excess term\n\nSigmaFapl = GalDynPsr.modelFa.Errpl(ldeg, sigl, bdeg, sigb, dkpc, sigd) #calculates the error in the planar contribution to the excess term\n\nFaz = GalDynPsr.modelFa.Exz(ldeg, sigl, bdeg, sigb, dkpc, sigd) #calculates the perpendicular contribution to the excess term\n\ntotalFa = Fapl+Faz\n\n\n\n### Example-1.8 ###\n\n############  Model Fb (error only in parallel component)   ###############\n\n\nFbpl = GalDynPsr.modelFb.Expl(ldeg, sigl, bdeg, sigb, dkpc, sigd) #calculates the planar contribution to the excess term\n\nSigmaFbpl = GalDynPsr.modelFb.Errpl(ldeg, sigl, bdeg, sigb, dkpc, sigd) #calculates the error in the planar contribution to the excess term\n\nFbz = GalDynPsr.modelFb.Exz(ldeg, sigl, bdeg, sigb, dkpc, sigd) #calculates the perpendicular contribution to the excess term\n\ntotalFb = Fbpl+Fbz\n\n\n### Example-1.9 ###\n\n############  Model Ga (error in perpendicular component)   ###############\n\n\nGapl = GalDynPsr.modelGa.Expl(ldeg, sigl, bdeg, sigb, dkpc, sigd) #calculates the planar contribution to the excess term\n\nGaz = GalDynPsr.modelGa.Exz(ldeg, sigl, bdeg, sigb, dkpc, sigd) #calculates the perpendicular contribution to the excess term\n\nSigmaGaz = GalDynPsr.modelGa.Errz(ldeg, sigl, bdeg, sigb, dkpc, sigd) #calculates the error in the perpendicular contribution to the excess term\n\ntotalGa = Gapl+Gaz\n\n\n### Example-1.10 ###\n\n############  Model Gb (error in perpendicular component)  ###############\n\n\nGbpl = GalDynPsr.modelGb.Expl(ldeg, sigl, bdeg, sigb, dkpc, sigd) #calculates the planar contribution to the excess term\n\nGbz = GalDynPsr.modelGb.Exz(ldeg, sigl, bdeg, sigb, dkpc, sigd) #calculates the perpendicular contribution to the excess term\n\nSigmaGbz = GalDynPsr.modelGb.Errz(ldeg, sigl, bdeg, sigb, dkpc, sigd) #calculates the error in the perpendicular contribution to the excess term\n\ntotalGb = Gbpl+Gbz\n\n\n\n\n### Example-1.11 ###\n\n############  Model Ha (error in perpendicular component)   ###############\n\n\nHapl = GalDynPsr.modelHa.Expl(ldeg, sigl, bdeg, sigb, dkpc, sigd) #calculates the planar contribution to the excess term\n\nHaz = GalDynPsr.modelHa.Exz(ldeg, sigl, bdeg, sigb, dkpc, sigd) #calculates the perpendicular contribution to the excess term\n\nSigmaHaz = GalDynPsr.modelHa.Errz(ldeg, sigl, bdeg, sigb, dkpc, sigd) #calculates the error in the perpendicular contribution to the excess term\n\ntotalHa = Hapl+Haz\n\n\n\n### Example-1.12 ###\n\n############  Model Hb (error in perpendicular component)   ###############\n\n\nHbpl = GalDynPsr.modelHb.Expl(ldeg, sigl, bdeg, sigb, dkpc, sigd) #calculates the planar contribution to the excess term\n\nHbz = GalDynPsr.modelHb.Exz(ldeg, sigl, bdeg, sigb, dkpc, sigd) #calculates the perpendicular contribution to the excess term\n\nSigmaHbz = GalDynPsr.modelHb.Errz(ldeg, sigl, bdeg, sigb, dkpc, sigd) #calculates the error in the perpendicular contribution to the excess term\n\ntotalHb = Hbpl+Hbz\n\n\n\n\n### Example-1.13 ###\n\n############  Model Ia (error in perpendicular component)  ###############\n\n\nIapl = GalDynPsr.modelIa.Expl(ldeg, sigl, bdeg, sigb, dkpc, sigd) #calculates the planar contribution to the excess term\n\nIaz = GalDynPsr.modelIa.Exz(ldeg, sigl, bdeg, sigb, dkpc, sigd) #calculates the perpendicular contribution to the excess term\n\nSigmaIaz = GalDynPsr.modelIa.Errz(ldeg, sigl, bdeg, sigb, dkpc, sigd) #calculates the error in the perpendicular contribution to the excess term\n\ntotalIa = Iapl+Iaz\n\n\n\n### Example-1.14 ###\n\n############  Model Ib (error in perpendicular component)   ###############\n\n\nIbpl = GalDynPsr.modelIb.Expl(ldeg, sigl, bdeg, sigb, dkpc, sigd) #calculates the planar contribution to the excess term\n\nIbz = GalDynPsr.modelIb.Exz(ldeg, sigl, bdeg, sigb, dkpc, sigd) #calculates the perpendicular contribution to the excess term\n\nSigmaIbz = GalDynPsr.modelIb.Errz(ldeg, sigl, bdeg, sigb, dkpc, sigd) #calculates the error in the perpendicular contribution to the excess term\n\ntotalIb = Ibpl+Ibz\n\n\n\n### Example-1.15 ###\n\n############  Model Ja (error in perpendicular component)   ###############\n\n\nJapl = GalDynPsr.modelJa.Expl(ldeg, sigl, bdeg, sigb, dkpc, sigd) #calculates the planar contribution to the excess term\n\nJaz = GalDynPsr.modelJa.Exz(ldeg, sigl, bdeg, sigb, dkpc, sigd) #calculates the perpendicular contribution to the excess term\n\nSigmaJaz = GalDynPsr.modelJa.Errz(ldeg, sigl, bdeg, sigb, dkpc, sigd) #calculates the error in the perpendicular contribution to the excess term\n\ntotalJa = Japl+Jaz\n\n\n### Example-1.16 ###\n\n############  Model Jb (error in perpendicular component)  ###############\n\n\nJbpl = GalDynPsr.modelJb.Expl(ldeg, sigl, bdeg, sigb, dkpc, sigd) #calculates the planar contribution to the excess term\n\nJbz = GalDynPsr.modelJb.Exz(ldeg, sigl, bdeg, sigb, dkpc, sigd) #calculates the perpendicular contribution to the excess term\n\nSigmaJbz = GalDynPsr.modelJb.Errz(ldeg, sigl, bdeg, sigb, dkpc, sigd) #calculates the error in the perpendicular contribution to the excess term\n\ntotalJb = Jbpl+Jbz\n\n\n\n### Example-1.17 ###\n\n############  Model Ka (full galpy, no error)  ###############\n\n\nKapl = GalDynPsr.modelLa.Expl(ldeg, sigl, bdeg, sigb, dkpc, sigd) #calculates the planar contribution to the excess term\n\nKaz = GalDynPsr.modelLa.Exz(ldeg, sigl, bdeg, sigb, dkpc, sigd) #calculates the perpendicular contribution to the excess term\n\ntotalKa = Kapl+Kaz\n\n\n\n### Example-1.18 ###\n\n############  Model Kb (full galpy, no error)   ###############\n\n\nKbpl = GalDynPsr.modelLa.Expl(ldeg, sigl, bdeg, sigb, dkpc, sigd) #calculates the planar contribution to the excess term\n\nKbz = GalDynPsr.modelLa.Exz(ldeg, sigl, bdeg, sigb, dkpc, sigd) #calculates the perpendicular contribution to the excess term\n\ntotalKb = Kbpl+Kbz\n\n\n\n\n### Example-1.19 ###\n############  Model La (full galpy, no error)   ###############\n\n\n\nLapl = GalDynPsr.modelLa.Expl(ldeg, sigl, bdeg, sigb, dkpc, sigd) #calculates the planar contribution to the excess term\n\nLaz = GalDynPsr.modelLa.Exz(ldeg, sigl, bdeg, sigb, dkpc, sigd) #calculates the perpendicular contribution to the excess term\n\ntotalLa = Lapl+Laz\n\n\n\n### Example-1.20 ###\n############  Model Lb (full galpy, no error)   ###############\n\n\n\nLbpl = GalDynPsr.modelLa.Expl(ldeg, sigl, bdeg, sigb, dkpc, sigd) #calculates the planar contribution to the excess term\n\nLbz = GalDynPsr.modelLa.Exz(ldeg, sigl, bdeg, sigb, dkpc, sigd) #calculates the perpendicular contribution to the excess term\n\ntotalLb = Lbpl+Lbz\n\n\n### Example-2  error estimation using  Model La (full galpy, no error)  ###\n\nimport numpy as np\nimport statistics as stat\nfrom astropy import units as u\nfrom astropy.coordinates import SkyCoord\nimport GalDynPsr\n\n\n\nNumber=50000 # number of instances to simulate\n\n\nmul, sigmal =   # define mean and standard deviation of l_degree\n\nmub, sigmab =    # define mean and standard deviation of b_degree\n\nmud, sigmad =     # define mean and standard deviation of d_kpc\n\n# now simulate 'Number' instances of l, b and d\n\nlsim = np.random.normal(mul, sigmal, Number)\n\nbsim = np.random.normal(mub, sigmab, Number)\n\ndsim = np.random.normal(mud, sigmad, Number)\n\n# declare arrays for excess_parallel, excess_z and excess_total\n\nLapl = []\nLaz = []\ntotalLa = []\n\n# now run GalDynPsr for 'Number' times\n\ncount = 0\nwhile (count < Number):   \n\n# randomly select l, b, d from the simulated values \n\n  x=np.random.random_integers(low=1, high=Number-1, size=3)\n\n\n  l=lsim[x[0]]\n  b=bsim[x[1]]\n  d=dsim[x[2]]\n\n# for each value of l, b, d, calculate excess_parallel, excess_z and excess_total\n\n  Lapl.append(GalDynPsr.modelLa.Expl(l, sigmal, b, sigmab, d, sigmad))\n  Laz.append(GalDynPsr.modelLa.Exz(l, sigmal, b, sigmab, d, sigmad))\n\n  totalLa=np.add(Lapl,Laz)\n\n\n  count = count + 1\n\n# now calculate mean and standard deviation of excess_parallel, excess_z and excess_total\n\nprint(stat.mean(Lapl), stat.stdev(Lapl), count)\nprint(stat.mean(Laz), stat.stdev(Laz), count)\nprint(stat.mean(totalLa), stat.stdev(totalLa), count)\n\n\n\n#############################\n######### For a Globular Cluster Pulsar #############################\n#Check names of Globular Clusters from GC_Harris.txt and write the name of the cluster. We do not include errors in this case.\n### Example 3 ###\n#Getting Excess_pl for model A for the GC 47Tuc:-\n#GalDynPsr.ReadGC.gcinput(\"GC Name\") finds the GC in the GC_Harris list and calculates the corresponding galactic coordinates and distance to the GC. Input the arguments to any model as:- (GalDynPsr.ReadGC.ldeg,0.,GalDynPsr.ReadGC.bdeg,0.,GalDynPsr.ReadGC.dkpc,0.)\n\n\n\nGalDynPsr.ReadGC.gcinput(\"47Tuc\")\n\nApl = GalDynPsr.modelA.Expl(GalDynPsr.ReadGC.ldeg,0.,GalDynPsr.ReadGC.bdeg,0.,GalDynPsr.ReadGC.dkpc,0.)\n\nAz = GalDynPsr.modelA.Exz(GalDynPsr.ReadGC.ldeg,0.,GalDynPsr.ReadGC.bdeg,0.,GalDynPsr.ReadGC.dkpc,0.)\n\n\n# Similarly for other models.\n\n\n\n#############################\n\n######################### For Intrinsic period derivative calculations ###############################\n\n## Parameters required for spin period derivative calcuations:- P = period in seconds, sigP = error in P in second, Pdot_obs = measured period derivative in ss^-1, sigPdot_obs = error in Pdot_obs\n\n#PdotExpl(Excess_pl,P) calculates the planar contribution to the period derivative \n\n#PdotExz(Excess_z,P) calculates the perpendicular contribution to the period derivative\n\n#PdotGal(Excess_pl,Excess_z,P) calculates the sum of planar and perpendicular contributions to the period derivative\n\n#PdotShk(Excess_shk,P) calculates the Shklovskii contribution to the period derivative\n\n#Pdotint(Excess_pl,Excess_z,Excess_shk,Pdot_obs,P) calculates the intrinsic period derivative\n\n\n#ErrPdotExpl(Excess_pl,error_Excess_pl,P,sigP) calculates the error in the planar contribution to the period derivative\n\n#ErrPdotExz(Excess_z,error_Excess_z,P,sigP) calculates the error in the perpendicular contribution to the period derivative\n\n#ErrPdotGal(Excess_pl,error_Excess_pl,Excess_z,error_Excess_z,P,sigP) calculates the error in the sum of planar and perpendicular contributions to the period derivative\n\n#ErrPdotShk(Excess_shk,error_Excess_shk,P,sigP) calculates the error in the Shklovskii contribution to the spin period derivative\n\n#ErrPdotint(Excess_pl,error_Excess_pl,Excess_z,error_Excess_z,Excess_shk,error_Excess_shk,Pdot_obs,sigPdot_obs,P,sigP) calculates the error in the intrinsic period derivative\n\n\n\n\n### Example 4 ###\n\n# Say using La\n\n\nldeg =20.0\nsigl = 2.0\n\nbdeg = 45.0\nsigb = 0.2\n\ndkpc = 1.2\nsigd = 0.3\n\nmu_alpha = 22.0\nsigmua = 0.2\n\nmu_delta = 1.2\nsigmud = 0.3\n\n# Example spin period and itsderivatives:-\n\n#P = 0.003061844088094608\n#sigP = 0.000000000000000015 \n\n#Pdot_obs = 0.959013e-20\n#sigPdot_obs = 0.000014e-20\n\n\n#Example orbital period and its derivatives (convert the period and corresponding error in seconds):-\n\nP = 1.198512575184*24.0*3600.0\n\nsigP = 0.000000000013*24.0*3600.0\n\n\nPdot_obs = 4.8e-14\nsigPdot_obs = 1.1e-14\n\n##\n\n\nEx_pl = GalDynPsr.modelA.Expl(ldeg, sigl, bdeg, sigb, dkpc, sigd)\n\nEx_z = GalDynPsr.modelA.Exz(ldeg, sigl, bdeg, sigb, dkpc, sigd)\n\nerrpl = GalDynPsr.modelA.Errpl(ldeg, sigl, bdeg, sigb, dkpc, sigd)\n\nerrz = GalDynPsr.modelA.Errz(ldeg, sigl, bdeg, sigb, dkpc, sigd)\n\nEx_shk = GalDynPsr.Shk.Exshk(dkpc, sigd, mu_alpha, sigmua, mu_delta, sigmud)\n\nerrshk = GalDynPsr.Shk.errShk(dkpc, sigd, mu_alpha, sigmua, mu_delta, sigmud)\n\n\n\nPdotExpl =  GalDynPsr.pdotint.PdotExpl(Ex_pl,P)\n\nPdotExz =  GalDynPsr.pdotint.PdotExz(Ex_z,P)\n\nPdotGal =  GalDynPsr.pdotint.PdotGal(Ex_pl,Ex_z,P)\n\nPdotShk =  GalDynPsr.pdotint.PdotShk(Ex_shk,P)\n\nPdotint = GalDynPsr.pdotint.Pdotint(Ex_pl,Ex_z,Ex_shk,Pdot_obs,P)\n\n\n#Errors in spin period derivatives:-\n\nErrPdotExpl =  GalDynPsr.pdotint.ErrPdotExpl(Ex_pl,errpl,P,sigP)\n\nErrPdotExz = GalDynPsr.pdotint.ErrPdotExz(Ex_z,errz,P,sigP)\n\nErrPdotGal =  GalDynPsr.pdotint.ErrPdotGal(Ex_pl,errpl,Ex_z,errz,P,sigP)\n\nErrPdotShk = GalDynPsr.pdotint.ErrPdotShk(Ex_shk,errshk,P,sigP)\n\nErrPdotint =  GalDynPsr.pdotint.ErrPdotint(Ex_pl,errpl,Ex_z,errz,Ex_shk,errshk,Pdot_obs,sigPdot_obs,P,sigP)\n\n\n\n\n#==========================================================================================\n##### Contents of the Package ####\n\nDatafiles:\n\nparameters.in: Input file contains values of different constants which are subject to change with improvements in measurements. User can change the values of constants if the need be.\n\nGC_Harris.txt: Names and Galactic coordinates of the Globular Clusters.\n\nREADME.txt: Contents of this README.md file inside package along with code files.\n\nDescription of different codes:\n\nread_parameters.py: contains parameters (constants) used in the package\n\n\nExcessZ.py:  Calculates az/c, both Nice-Taylor (1995) expression as well as our fit of HF2004\n\nExcesspl.py: Calculates apl/c. Can take any value of the slope parameter dv/dR from the parameter file. b0 = (Vs/Rs)*(dV/dR) = 0 is the conventional.\n\nmodelA.py: Model A - Calculates apl_old/c (i.e. b0 = 0; DT91) and az_NT95. \n\nmodelB.py: Model B - Calculates apl_old/c (i.e. b0 = 0; DT91) and az_HF04.\n\nmodelC.py: Model C - Calculates apl_new/c (i.e. dv/dR = -0.2; Reid2014) and az_NT95.\n\nmodelD.py: Model D - Calculates apl_new/c (i.e. dv/dR = -0.2; Reid2014) and az_HF04.\n\nmodelEa.py: Model Ea - Calculates apl_old/c (i.e. b0 = 0; DT91) and \u2018zforce\u2019 in galpy (without BH)\nmodelEb.py: Model Eb - Calculates apl_old/c (i.e. b0 = 0; DT91) and \u2018zforce\u2019 in galpy (with BH)\n\nmodelFa.py: Model Fa - Calculates apl_new/c (i.e. dv/dR = -0.2; Reid2014) and \u2018zforce\u2019 in galpy (without BH)\nmodelFb.py: Model Fb - Calculates apl_new/c (i.e. dv/dR = -0.2; Reid2014) and \u2018zforce\u2019 in galpy (with BH)\n\nmodelGa.py: Model Ga - Calculates apl/c using Vp'/Vs from galpy (without BH) and az_NT95\nmodelGb.py: Model Gb - Calculates apl/c using Vp'/Vs from galpy (with BH) and az_NT95\n\nmodelHa.py: Model Ha - Calculates \u2018Rforce\u2019 in galpy (without BH) and az_NT95\nmodelHb.py: Model Hb - Calculates \u2018Rforce\u2019 in galpy (with BH) and az_NT95\n\nmodelIa.py: Model Ia - Calculates apl/c using Vp'/Vs from galpy (without BH) and az_HF04\nmodelIb.py: Model Ib - Calculates apl/c using Vp'/Vs from galpy (with BH) and az_HF04\n\nmodelJa.py: Model Ja - Calculates \u2018Rforce\u2019 in galpy (without BH) and az_HF04\nmodelJb.py: Model Jb - Calculates \u2018Rforce\u2019 in galpy (with BH) and az_HF04\n\nmodelKa.py: Model Ka - Calculates apl/c using Vp'/Vs from galpy (without BH) and \u2018zforce\u2019 in galpy (without BH)\nmodelKb.py: Model Kb - Calculates apl/c using Vp'/Vs from galpy (with BH) and \u2018zforce\u2019 in galpy (with BH)\n\nmodelLa.py: Model La - Calculates \u2018Rforce\u2019 in galpy (without BH) and \u2018zforce\u2019 in galpy (without BH)\nmodelLb.py: Model Lb - Calculates \u2018Rforce\u2019 in galpy (with BH) and \u2018zforce\u2019 in galpy (with BH)\n\nShk.py: Calculates the Shklovskii term d(mu_T*mu_T)/c. Takes user input of proper motion in right ascension and declination.\n\ngalpyMWpl.py: Using vcirc function in galpy to get Vp'(without BH) and eventually apl/c \n\ngalpyMWBHpl.py: Using vcirc function in galpy to get Vp'(with BH) and eventually apl/c \n\ngalpyMWRfo.py: Using evaluateRforces function in galpy(without BH) to get apl/c \n\ngalpyMWBHRfo.py: Using evaluateRforces function in galpy(with BH) to get apl/c\n\nerr_excesspl_Damour.py: Calculates error for Excess_pl (DT91)\n\nerr_excesspl_Reid.py: Calculates error for Excess_pl (Reid2014)\n\nerr_HFhigh.py: Calculates error for Excess_z (our fit for HF04 data)\n\nerr_HFlow.py: Calculates error for Excess_z (our fit for HF04 data)\n\nerr_NT.py: Calculates error for Excess_z (NT95)\n\nerr_Shklovskii.py: Calculates error for Excess_Shk\n\n\n#==========================================================================================================================================\n\nThough the description of models is provided in the paper, for the sake of completeness we are still providing that here.\n\nDescription of Models:-\n\nModel-A: apl_old/c (i.e. b0 = 0; DT91) and Z_NT95\nModel-B: apl_old/c (i.e. b0 = 0; DT91) and Z_HF04\nModel-C: apl_new/c (i.e. dv/dR = -0.2; Reid2014) and Z_NT95\nModel-D: apl_new/c (i.e. dv/dR = -0.2; Reid2014) and Z_HF04\n\nModel-Ea: apl_old/c (i.e. b0 = 0; DT91) and \u2018zforce\u2019 in galpy (without BH)\nModel-Eb: apl_old/c (i.e. b0 = 0; DT91) and \u2018zforce\u2019 in galpy (with BH)\n\nModel-Fa: apl_new/c (i.e. dv/dR = -0.2; Reid2014) and \u2018zforce\u2019 in galpy (without BH)\nModel-Fb: apl_new/c (i.e. dv/dR = -0.2; Reid2014) and \u2018zforce\u2019 in galpy (with BH)\n\nModel-Ga: Using Vp'/Vs from galpy (without BH) and Z_NT95\nModel-Gb: Using Vp'/Vs from galpy (with BH) and Z_NT95\n\nModel-Ha: \u2018Rforce\u2019 in galpy (without BH) and Z_NT95\nModel-Hb: \u2018Rforce\u2019 in galpy (with BH) and Z_NT95\n\nModel-Ia: Using Vp'/Vs from galpy (without BH) and Z_HF04\nModel-Ib: Using Vp'/Vs from galpy (with BH) and Z_HF04\n\nModel-Ja: \u2018Rforce\u2019 in galpy (without BH) and Z_HF04\nModel-Jb: \u2018Rforce\u2019 in galpy (with BH) and Z_HF04\n\nModel-Ka: Using Vp'/Vs from galpy (without BH) and \u2018zforce\u2019 in galpy (without BH)\nModel-Kb: Using Vp'/Vs from galpy (with BH) and \u2018zforce\u2019 in galpy (with BH)\n\nModel-La: \u2018Rforce\u2019 in galpy (without BH) and \u2018zforce\u2019 in galpy (without BH)\nModel-Lb: \u2018Rforce\u2019 in galpy (with BH) and \u2018zforce\u2019 in galpy (with BH)\n\n\n\nReid2014: Reid M. J., Menten K. M., Brunthaler A., Zheng X. W., Dame T. M., 2014, ApJ, 783, 130.\n\nDT91: Damour T., Taylor J.H., 1991, ApJ, 366, 501.\n\nNT95: Nice D.J., Taylor J.H., 1995, ApJ, 441, 429.\n\nHF04: Holmberg J., Flynn C., 2004, MNRAS, 352, 440.\n\n\n############################################################\n\n\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/pathakdhruv/GalDynPsr", "keywords": "", "license": "New BSD", "maintainer": "", "maintainer_email": "", "name": "GalDynPsr", "package_url": "https://pypi.org/project/GalDynPsr/", "platform": "", "project_url": "https://pypi.org/project/GalDynPsr/", "project_urls": {"Homepage": "https://github.com/pathakdhruv/GalDynPsr"}, "release_url": "https://pypi.org/project/GalDynPsr/1.0.0/", "requires_dist": null, "requires_python": "", "summary": "A practise package", "version": "1.0.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>GalDynPsr Package</h1>\n<p>GalDynPsr is a package for calculating dynamical contributions in the period derivatives of pulsars in the Galactic field. It can calculate the fractional contributions or the excess terms, e.g. \\dot{P}/P|_excess where P is either the orbital period or the spin period. Various dynamical contributions, including the Shklovskii effect (the contribution due to the proper motion) or due to the acceleration of the pulsar caused by the gravitational potential of the Galaxy, can be calculated. Various methods or models to perform these tasks are available in the package. Using the measured values of the periods and period derivatives, GalDynPsr can even compute the \"intrinsic\" values of the period derivatives, provided no other extra contribution exist.</p>\n<p>Details on various dynamical effects and various models to estimate those are available in Pathak and Bagchi (arXiv:1712.06590).</p>\n<p>Brief outline of usage of GalDynPsr is given below.</p>\n<p>Questions and queries can be sent to Dhruv Pathak pathakdhruv9786 at gmail dot com</p>\n<h1>1) After installing numpy, scipy, and galpy successfully, install GalDynPsr</h1>\n<p>pip3 install GalDynPsr</p>\n<h3>If wished, one can change the values of Rs (galactocentric cylindrical radius of the sun), Vs  (rotational speed of the sun) etc in parameters.in file that can be found inside the GalDynPsr (installed directory).</h3>\n<h2>But remember that galpy also has these values defined in the file '$home/.galpyrc'. One can in principle change these values.</h2>\n<h1>However, the Milky Way potential in galpy was fitted with Rs = 8.0 kpc and vs = 220.0 in galpy</h1>\n<h1>2) Import GalDynPsr in your code as</h1>\n<p>import GalDynPsr</p>\n<h1>3) In all of the following modules, the ordering of the arguments of the functions are very important.</h1>\n<h1>4) Calculate excess terms of modelX ** Very important, model names are case sensitive!</h1>\n<p>GalDynPsr.modelX.Expl(ldeg, sigl, bdeg, sigb, dkpc, sigd) and GalDynPsr.modelX.Exz(ldeg, sigl, bdeg, sigb, dkpc, sigd)</p>\n<p>The function Expl() calculates the excess term due to the relative acceleration of the pulsar parallel to the Galactic plane and the function Exz() calculates the excess term due to the relative acceleration of the pulsar perpendicular to the Galactic plane. Total dynamical contribution will be the sum of above two terms. Both of the above functions takes the arguments as the Galactic longitude in degrees (say ldeg), uncertainty in the Galactic longitude in degrees (say sigl), the Galactic latitude in degrees (say bdeg), uncertainty in the Galactic latitude in degrees (say sigb), the distance of the pulsar from the solar system barycenter in kpc (say dkpc), and the uncertainty in the distance in kpc (say sigd); strictly in this order. One needs to assign the values of ldeg, sigl, bdeg, sigb, dkpc, and sigd before calling the above functions.</p>\n<p>The models that do not involve galpy can return uncertainities in the excess terms following standard error propagation method, like</p>\n<p>modelX.Errpl(ldeg, sigl, bdeg, sigb, dkpc, sigd) and modelX.Errz(ldeg, sigl, bdeg, sigb, dkpc, sigd)</p>\n<p>where the function Errpl() returns the uncertainty in the excess terms due to the relative acceleration of the pulsar parallel to the Galactic plane and Errz() returns the uncertainty in the excess terms due to the relative acceleration of the pulsar perpendicular to the Galactic plane. The arguments are the same as before, and needs to be assigend values before using the functions.</p>\n<p>Remeber to replace modelX by the model you  want to use, like modelA, modelLa, etc. Model names are case sensitive!</p>\n<h1>5) Calculate the Shklovskii term</h1>\n<p>The Shklovskii term can be calculated as GalDynPsr.Shk.Exshk(dkpc, sigd, mu_alpha, sigmua, mu_delta, sigmud) and the error in the Shklovskii term as GalDynPsr.Shk.errShk(dkpc, sigd, mu_alpha, sigmua, mu_delta, sigmud)</p>\n<p>where mu_alpha is the proper motion in the Right Ascesion direction (mas/yr), mu_delta is the proper motion in the Declination direction (mas/yr), sigmua is the uncertainty in mu_alpha, and sigmud is the uncertainty in mu_delta. dkpc is as usual the distance of the pulsar from the solar system barycenter in kpc and sigd is the uncertainty in dkpc. One needs to assign the values of these parameters first.</p>\n<h1>6) Print the basic parameters of the pulsars</h1>\n<p>GalDynPsr.read_parameters.Rskpc returns the Galactocentric cylindrical radius of the sun.</p>\n<p>GalDynPsr.read_parameters.Vs returns the rotational speed of the sun.</p>\n<p>GalDynPsr.read_parameters.Rpkpc(ldeg, sigl, bdeg, sigb, dkpc, sigd) returns the value of Galactocentric cylindrical radius of the pulsar in kpc and GalDynPsr.read_parameters.z(ldeg, sigl, bdeg, sigb, dkpc, sigd) returns the verical height of the pulsar from the Galactic plane. The meaning of the arguments are as usual:</p>\n<p>One can get the uncertainty in the Galactocentric cylindrical radius of the pulsar in kpc using GalDynPsr.read_parameters.ErrRpkpc(ldeg, sigl, bdeg, sigb, dkpc, sigd) and the uncertainty in the verical height as GalDynPsr.read_parameters.Errz(ldeg, sigl, bdeg, sigb, dkpc, sigd).</p>\n<p>Obviously,  one first needs to assign the values of ldeg, sigl, bdeg, sigb, dkpc, and sigd.</p>\n<h1>7) For a pulsar in a globular cluster, one can read the cluster parameters, e.g. the Galactic longitude, latitude and the distance from the Harric catalogue (GC_harris.txt coming with GalDynPsr), and calculate crude values of the dynamical terms</h1>\n<p>One first needs to import the module to read Harris cataloge as:</p>\n<p>import GalDynPsr.ReadGC as readgc</p>\n<p>Then one can input the name of the cluster, e.g. readgc.gcinput(\"47Tuc\")</p>\n<p>Then the excess terms using modelX can be calculated as</p>\n<p>sigl=0.000001\nsigb=0.000001\nsigd=0.000001</p>\n<p>GalDynPsr.modelX.Expl(readgc.ldeg,sigl,readgc.bdeg,sigb,readgc.dkpc,sigd) # the parallel component\nGalDynPsr.modelX.Exz(readgc.ldeg,sigl,readgc.bdeg,sigb,readgc.dkpc,sig) # the perpendicular component</p>\n<p>Note that the Harris catalogue does not provide uncertainties in ldeg, bdeg and dkpc. That is why we need to define them before calculating the excess terms. As the pulsar parameters differ from the cluster parameters as in Harris catalogue, it is meaningless to calculate uncetrainities. So, one SHOULD simply call the above functions as:</p>\n<p>GalDynPsr.modelX.Expl(readgc.ldeg,0.0,readgc.bdeg,0.0,readgc.dkpc,0.0) # the parallel component\nGalDynPsr.modelX.Exz(readgc.ldeg,0.0,readgc.bdeg,0.0,readgc.dkpc,0.0) # the perpendicular component</p>\n<h1>8) models involving galpy does not return error. However, that can be done using simulation. See Example-2 below.</h1>\n<h1>9) Calculation of instrinsic period. Ordering of the arguments is important.</h1>\n<p>First assign values of ldeg, sigl, bdeg, sigb, dkpc, sigd (meaning of the parameters are as usual) and calculate the excess terms as usual:</p>\n<p>Ex_pl =  GalDynPsr.modelA.Expl(ldeg, sigl, bdeg, sigb, dkpc, sigd) # excess term parallel to the Galactic plane</p>\n<p>Ex_z =  GalDynPsr.modelA.Exz(ldeg, sigl, bdeg, sigb, dkpc, sigd) # excess term perpendicular to the Galactic plane</p>\n<p>errpl =  GalDynPsr.modelA.Errpl(ldeg, sigl, bdeg, sigb, dkpc, sigd) # uncertainty in the parallel term</p>\n<p>errz =  GalDynPsr.modelA.Errz(ldeg, sigl, bdeg, sigb, dkpc, sigd) # uncertainty in the parallel term</p>\n<p>Ex_shk =  GalDynPsr.Shk.Exshk(dkpc, sigd, mu_alpha, sigmua, mu_delta, sigmud) # excess term due to the Shklovskii effect</p>\n<p>errshk =  GalDynPsr.Shk.errShk(dkpc, sigd, mu_alpha, sigmua, mu_delta, sigmud) # uncertainties in the Shklovskii term</p>\n<p>Now assign the values of the period 'P' in seconds, the uncertainy in period 'sigP' in seconds, the measured value of the period derivative 'Pdot_obs' in seconds/seconds and the uncertainty in the measured value of the period derivative 'sigPdot' in seconds/seconds; and calculate the dynamically caused values of the period derivatives (in seconds/seconds) as:</p>\n<p>GalDynPsr.pdotint.PdotExpl(Ex_pl,P) # due to the parallel component of the acceleration</p>\n<p>GalDynPsr.pdotint.PdotExz(Ex_z,P) # due to the perpendicular component of the acceleration</p>\n<p>GalDynPsr.pdotint.PdotShk(Ex_shk,P) # due to the Shklovskii effect</p>\n<p>The total dynamically caused value of Pdot is the addition of the above three terms. The intrinsic value of the period derivative can be calculated by subtracting that sum from the measured value of the period derivative. GalDynPsr can perform this task for us by:</p>\n<p>GalDynPsr.pdotint.Pdotint(Ex_pl,Ex_z,Ex_shk,Pdot_obs,P)</p>\n<p>The total dynamical contribution in the period derivative, i.e. the sum of GalDynPsr.pdotint.PdotExpl(Ex_pl,P) and GalDynPsr.pdotint.PdotExz(Ex_z,P) can be printed as:\nGalDynPsr.pdotint.PdotGal(Ex_pl,Ex_z,P)</p>\n<p>One can calculate the uncertainity in the above period drivatives as:</p>\n<p>GalDynPsr.pdotint.ErrPdotExpl(Ex_pl,errpl,P,sigP) # uncertainty in the planar contribution to the period derivative</p>\n<p>GalDynPsr.pdotint.ErrPdotExz(Ex_z,errz,P,sigP) # uncertainty in the perpendicular contribution to the period derivative</p>\n<p>GalDynPsr.pdotint.ErrPdotGal(Ex_pl,errpl,Ex_z,errz,P,sigP) # uncertainty in the sum of planar and perpendicular contributions to the period derivative</p>\n<p>GalDynPsr.pdotint.ErrPdotShk(Ex_shk,errshk,P,sigP) # uncertainty in the Shklovskii term contribution to the period derivative</p>\n<p>GalDynPsr.pdotint.ErrPdotint(Ex_pl,errpl,Ex_z,errz,Ex_shk,errshk,Pdot_obs,sigPdot_obs,P,sigP) # uncertainty in the intrinsic period derivative</p>\n<ul>\n<li>Remember the fact that GalDynPsr reads the value of the period in seconds. Orbital periods are usually measured in days (or sometimes in hours). One needs to convert those values in seconds before calling GalDynPsr modules.</li>\n</ul>\n<h3>All the above points will be clearer from the following examples</h3>\n<h5>Instructions to use GalDynPsr</h5>\n<h1>Call GalDynPsr as:-</h1>\n<p>import GalDynPsr</p>\n<h2>Provide the following values in your code</h2>\n<h1>ldeg = Galactic logitude in degrees, bdeg = Galactic latitude in degrees, dkpc = distance to pulsar in kpc, sigl = error in ldeg, sigb = error in bdeg, sigd = error in dkpc</h1>\n<p>########### Example-1 #################\nldeg =20.0\nsigl = 2.0</p>\n<p>bdeg = 45.0\nsigb = 0.2</p>\n<p>dkpc = 1.2\nsigd = 0.3</p>\n<p>############# Extract important parameters say values of Rp (in kpc) and z (in kpc) and errors in them  ##########</p>\n<p>Rpkpc = GalDynPsr.read_parameters.Rpkpc(ldeg, sigl, bdeg, sigb, dkpc, sigd)</p>\n<p>zkpc = GalDynPsr.read_parameters.z(ldeg, sigl, bdeg, sigb, dkpc, sigd)</p>\n<p>ErrRp = GalDynPsr.read_parameters.ErrRp(ldeg, sigl, bdeg, sigb, dkpc, sigd)</p>\n<p>Errz = GalDynPsr.read_parameters.Errz(ldeg, sigl, bdeg, sigb, dkpc, sigd)</p>\n<p>#################  Compute excess Shklovskii term. Here Exshk() calculates the dynamical contribution (or the excess term) due to Shklovskii effect and errShk() calculates the error in that #################################</p>\n<h4>We need to provide the values of proper motion in right ascesion direction (with the corresponding error) and proper motion in the declination direction (with the corresponding error)########</h4>\n<p>##mu_alpha = proper motion in Right Ascesion direction (mas/yr), mu_delta = proper motion in Declination direction (mas/yr), sigmua = error in mu_alpha, and sigmud = error in mu_delta</p>\n<p>mu_alpha = 22.0\nsigmua = 0.2</p>\n<p>mu_delta = 1.2\nsigmud = 0.3</p>\n<p>ExcessSh = GalDynPsr.Shk.Exshk(dkpc, sigd, mu_alpha, sigmua, mu_delta, sigmud)</p>\n<p>sigmaExcessSh = GalDynPsr.Shk.errShk(dkpc, sigd, mu_alpha, sigmua, mu_delta, sigmud)</p>\n<h3>Example-1.1</h3>\n<h3>Model A (can propagate error)######</h3>\n<p>Apl = GalDynPsr.modelA.Expl(ldeg, sigl, bdeg, sigb, dkpc, sigd) #calculates the planar contribution to the excess term</p>\n<p>Az = GalDynPsr.modelA.Exz(ldeg, sigl, bdeg, sigb, dkpc, sigd) #calculates the perpendicular contribution to the excess term</p>\n<p>Aplsigma = GalDynPsr.modelA.Errpl(ldeg, sigl, bdeg, sigb, dkpc, sigd) #calculates the error in the planar contribution to the excess term</p>\n<p>Azsigma = GalDynPsr.modelA.Errz(ldeg, sigl, bdeg, sigb, dkpc, sigd) #calculates the error in the perpendicular contribution to the excess term</p>\n<p>totalA = Apl + Az</p>\n<p>SigmatotalA = math.sqrt(Aplsigma<em>Aplsigma+Azsigma</em>Azsigma) # assuming no correlation between excepp_pl and excess_z</p>\n<h3>Example-1.2</h3>\n<h3>Model B (can propagate error)######</h3>\n<p>Bpl = GalDynPsr.modelB.Expl(ldeg, sigl, bdeg, sigb, dkpc, sigd) #calculates the planar contribution to the excess term</p>\n<p>Bz = GalDynPsr.modelB.Exz(ldeg, sigl, bdeg, sigb, dkpc, sigd) #calculates the perpendicular contribution to the excess term</p>\n<p>Bplsigma = GalDynPsr.modelB.Errpl(ldeg, sigl, bdeg, sigb, dkpc, sigd) #calculates the error in the planar contribution to the excess term</p>\n<p>Bzsigma = GalDynPsr.modelB.Errz(ldeg, sigl, bdeg, sigb, dkpc, sigd) #calculates the error in the perpendicular contribution to the excess term</p>\n<p>totalB = Bpl + Bz</p>\n<p>SigmatotalB = math.sqrt(Bplsigma<em>Bplsigma+Bzsigma</em>Bzsigma) # assuming no correlation between excepp_pl and excess_z</p>\n<h3>Example-1.3</h3>\n<h3>Model C (can propagate error)######</h3>\n<p>Cpl = GalDynPsr.modelC.Expl(ldeg, sigl, bdeg, sigb, dkpc, sigd) #calculates the planar contribution to the excess term</p>\n<p>Cz = GalDynPsr.modelC.Exz(ldeg, sigl, bdeg, sigb, dkpc, sigd) #calculates the perpendicular contribution to the excess term</p>\n<p>Cplsigma = GalDynPsr.modelC.Errpl(ldeg, sigl, bdeg, sigb, dkpc, sigd) #calculates the error in the planar contribution to the excess term</p>\n<p>Czsigma = GalDynPsr.modelC.Errz(ldeg, sigl, bdeg, sigb, dkpc, sigd) #calculates the error in the perpendicular contribution to the excess term</p>\n<p>totalC = Cpl + Cz</p>\n<p>SigmatotalC = math.sqrt(Cplsigma<em>Cplsigma+Czsigma</em>Czsigma) # assuming no correlation between excepp_pl and excess_z</p>\n<h3>Example-1.4</h3>\n<h3>Model D (can propagate error)######</h3>\n<p>Dpl = GalDynPsr.modelD.Expl(ldeg, sigl, bdeg, sigb, dkpc, sigd) #calculates the planar contribution to the excess term</p>\n<p>Dz = GalDynPsr.modelD.Exz(ldeg, sigl, bdeg, sigb, dkpc, sigd) #calculates the perpendicular contribution to the excess term</p>\n<p>Dplsigma = GalDynPsr.modelD.Errpl(ldeg, sigl, bdeg, sigb, dkpc, sigd) #calculates the error in the planar contribution to the excess term</p>\n<p>Dzsigma = GalDynPsr.modelD.Errz(ldeg, sigl, bdeg, sigb, dkpc, sigd) #calculates the error in the perpendicular contribution to the excess term</p>\n<p>totalD = Dpl + Dz</p>\n<p>SigmatotalD = math.sqrt(Dplsigma<em>Dplsigma+Dzsigma</em>Dzsigma) # assuming no correlation between excepp_pl and excess_z</p>\n<h3>Example-1.5</h3>\n<p>############  Model Ea (error only in parallel component)   ###############</p>\n<p>Eapl = GalDynPsr.modelEa.Expl(ldeg, sigl, bdeg, sigb, dkpc, sigd) #calculates the planar contribution to the excess term</p>\n<p>SigmaEapl = GalDynPsr.modelEa.Errpl(ldeg, sigl, bdeg, sigb, dkpc, sigd) #calculates the error in the planar contribution to the excess term</p>\n<p>Eaz = GalDynPsr.modelEa.Exz(ldeg, sigl, bdeg, sigb, dkpc, sigd) #calculates the perpendicular contribution to the excess term</p>\n<p>totalEa = Eapl+Eaz</p>\n<h3>Example-1.6</h3>\n<p>############  Model Eb (error only in parallel component)   ###############</p>\n<p>Ebpl = GalDynPsr.modelEb.Expl(ldeg, sigl, bdeg, sigb, dkpc, sigd) #calculates the planar contribution to the excess term</p>\n<p>SigmaEbpl = GalDynPsr.modelEb.Errpl(ldeg, sigl, bdeg, sigb, dkpc, sigd) #calculates the error in the planar contribution to the excess term</p>\n<p>Ebz = GalDynPsr.modelEb.Exz(ldeg, sigl, bdeg, sigb, dkpc, sigd) #calculates the perpendicular contribution to the excess term</p>\n<p>totalEb = Ebpl+Ebz</p>\n<h3>Example-1.7</h3>\n<p>############  Model Fa (error only in parallel component)   ###############</p>\n<p>Fapl = GalDynPsr.modelFa.Expl(ldeg, sigl, bdeg, sigb, dkpc, sigd) #calculates the planar contribution to the excess term</p>\n<p>SigmaFapl = GalDynPsr.modelFa.Errpl(ldeg, sigl, bdeg, sigb, dkpc, sigd) #calculates the error in the planar contribution to the excess term</p>\n<p>Faz = GalDynPsr.modelFa.Exz(ldeg, sigl, bdeg, sigb, dkpc, sigd) #calculates the perpendicular contribution to the excess term</p>\n<p>totalFa = Fapl+Faz</p>\n<h3>Example-1.8</h3>\n<p>############  Model Fb (error only in parallel component)   ###############</p>\n<p>Fbpl = GalDynPsr.modelFb.Expl(ldeg, sigl, bdeg, sigb, dkpc, sigd) #calculates the planar contribution to the excess term</p>\n<p>SigmaFbpl = GalDynPsr.modelFb.Errpl(ldeg, sigl, bdeg, sigb, dkpc, sigd) #calculates the error in the planar contribution to the excess term</p>\n<p>Fbz = GalDynPsr.modelFb.Exz(ldeg, sigl, bdeg, sigb, dkpc, sigd) #calculates the perpendicular contribution to the excess term</p>\n<p>totalFb = Fbpl+Fbz</p>\n<h3>Example-1.9</h3>\n<p>############  Model Ga (error in perpendicular component)   ###############</p>\n<p>Gapl = GalDynPsr.modelGa.Expl(ldeg, sigl, bdeg, sigb, dkpc, sigd) #calculates the planar contribution to the excess term</p>\n<p>Gaz = GalDynPsr.modelGa.Exz(ldeg, sigl, bdeg, sigb, dkpc, sigd) #calculates the perpendicular contribution to the excess term</p>\n<p>SigmaGaz = GalDynPsr.modelGa.Errz(ldeg, sigl, bdeg, sigb, dkpc, sigd) #calculates the error in the perpendicular contribution to the excess term</p>\n<p>totalGa = Gapl+Gaz</p>\n<h3>Example-1.10</h3>\n<p>############  Model Gb (error in perpendicular component)  ###############</p>\n<p>Gbpl = GalDynPsr.modelGb.Expl(ldeg, sigl, bdeg, sigb, dkpc, sigd) #calculates the planar contribution to the excess term</p>\n<p>Gbz = GalDynPsr.modelGb.Exz(ldeg, sigl, bdeg, sigb, dkpc, sigd) #calculates the perpendicular contribution to the excess term</p>\n<p>SigmaGbz = GalDynPsr.modelGb.Errz(ldeg, sigl, bdeg, sigb, dkpc, sigd) #calculates the error in the perpendicular contribution to the excess term</p>\n<p>totalGb = Gbpl+Gbz</p>\n<h3>Example-1.11</h3>\n<p>############  Model Ha (error in perpendicular component)   ###############</p>\n<p>Hapl = GalDynPsr.modelHa.Expl(ldeg, sigl, bdeg, sigb, dkpc, sigd) #calculates the planar contribution to the excess term</p>\n<p>Haz = GalDynPsr.modelHa.Exz(ldeg, sigl, bdeg, sigb, dkpc, sigd) #calculates the perpendicular contribution to the excess term</p>\n<p>SigmaHaz = GalDynPsr.modelHa.Errz(ldeg, sigl, bdeg, sigb, dkpc, sigd) #calculates the error in the perpendicular contribution to the excess term</p>\n<p>totalHa = Hapl+Haz</p>\n<h3>Example-1.12</h3>\n<p>############  Model Hb (error in perpendicular component)   ###############</p>\n<p>Hbpl = GalDynPsr.modelHb.Expl(ldeg, sigl, bdeg, sigb, dkpc, sigd) #calculates the planar contribution to the excess term</p>\n<p>Hbz = GalDynPsr.modelHb.Exz(ldeg, sigl, bdeg, sigb, dkpc, sigd) #calculates the perpendicular contribution to the excess term</p>\n<p>SigmaHbz = GalDynPsr.modelHb.Errz(ldeg, sigl, bdeg, sigb, dkpc, sigd) #calculates the error in the perpendicular contribution to the excess term</p>\n<p>totalHb = Hbpl+Hbz</p>\n<h3>Example-1.13</h3>\n<p>############  Model Ia (error in perpendicular component)  ###############</p>\n<p>Iapl = GalDynPsr.modelIa.Expl(ldeg, sigl, bdeg, sigb, dkpc, sigd) #calculates the planar contribution to the excess term</p>\n<p>Iaz = GalDynPsr.modelIa.Exz(ldeg, sigl, bdeg, sigb, dkpc, sigd) #calculates the perpendicular contribution to the excess term</p>\n<p>SigmaIaz = GalDynPsr.modelIa.Errz(ldeg, sigl, bdeg, sigb, dkpc, sigd) #calculates the error in the perpendicular contribution to the excess term</p>\n<p>totalIa = Iapl+Iaz</p>\n<h3>Example-1.14</h3>\n<p>############  Model Ib (error in perpendicular component)   ###############</p>\n<p>Ibpl = GalDynPsr.modelIb.Expl(ldeg, sigl, bdeg, sigb, dkpc, sigd) #calculates the planar contribution to the excess term</p>\n<p>Ibz = GalDynPsr.modelIb.Exz(ldeg, sigl, bdeg, sigb, dkpc, sigd) #calculates the perpendicular contribution to the excess term</p>\n<p>SigmaIbz = GalDynPsr.modelIb.Errz(ldeg, sigl, bdeg, sigb, dkpc, sigd) #calculates the error in the perpendicular contribution to the excess term</p>\n<p>totalIb = Ibpl+Ibz</p>\n<h3>Example-1.15</h3>\n<p>############  Model Ja (error in perpendicular component)   ###############</p>\n<p>Japl = GalDynPsr.modelJa.Expl(ldeg, sigl, bdeg, sigb, dkpc, sigd) #calculates the planar contribution to the excess term</p>\n<p>Jaz = GalDynPsr.modelJa.Exz(ldeg, sigl, bdeg, sigb, dkpc, sigd) #calculates the perpendicular contribution to the excess term</p>\n<p>SigmaJaz = GalDynPsr.modelJa.Errz(ldeg, sigl, bdeg, sigb, dkpc, sigd) #calculates the error in the perpendicular contribution to the excess term</p>\n<p>totalJa = Japl+Jaz</p>\n<h3>Example-1.16</h3>\n<p>############  Model Jb (error in perpendicular component)  ###############</p>\n<p>Jbpl = GalDynPsr.modelJb.Expl(ldeg, sigl, bdeg, sigb, dkpc, sigd) #calculates the planar contribution to the excess term</p>\n<p>Jbz = GalDynPsr.modelJb.Exz(ldeg, sigl, bdeg, sigb, dkpc, sigd) #calculates the perpendicular contribution to the excess term</p>\n<p>SigmaJbz = GalDynPsr.modelJb.Errz(ldeg, sigl, bdeg, sigb, dkpc, sigd) #calculates the error in the perpendicular contribution to the excess term</p>\n<p>totalJb = Jbpl+Jbz</p>\n<h3>Example-1.17</h3>\n<p>############  Model Ka (full galpy, no error)  ###############</p>\n<p>Kapl = GalDynPsr.modelLa.Expl(ldeg, sigl, bdeg, sigb, dkpc, sigd) #calculates the planar contribution to the excess term</p>\n<p>Kaz = GalDynPsr.modelLa.Exz(ldeg, sigl, bdeg, sigb, dkpc, sigd) #calculates the perpendicular contribution to the excess term</p>\n<p>totalKa = Kapl+Kaz</p>\n<h3>Example-1.18</h3>\n<p>############  Model Kb (full galpy, no error)   ###############</p>\n<p>Kbpl = GalDynPsr.modelLa.Expl(ldeg, sigl, bdeg, sigb, dkpc, sigd) #calculates the planar contribution to the excess term</p>\n<p>Kbz = GalDynPsr.modelLa.Exz(ldeg, sigl, bdeg, sigb, dkpc, sigd) #calculates the perpendicular contribution to the excess term</p>\n<p>totalKb = Kbpl+Kbz</p>\n<h3>Example-1.19</h3>\n<p>############  Model La (full galpy, no error)   ###############</p>\n<p>Lapl = GalDynPsr.modelLa.Expl(ldeg, sigl, bdeg, sigb, dkpc, sigd) #calculates the planar contribution to the excess term</p>\n<p>Laz = GalDynPsr.modelLa.Exz(ldeg, sigl, bdeg, sigb, dkpc, sigd) #calculates the perpendicular contribution to the excess term</p>\n<p>totalLa = Lapl+Laz</p>\n<h3>Example-1.20</h3>\n<p>############  Model Lb (full galpy, no error)   ###############</p>\n<p>Lbpl = GalDynPsr.modelLa.Expl(ldeg, sigl, bdeg, sigb, dkpc, sigd) #calculates the planar contribution to the excess term</p>\n<p>Lbz = GalDynPsr.modelLa.Exz(ldeg, sigl, bdeg, sigb, dkpc, sigd) #calculates the perpendicular contribution to the excess term</p>\n<p>totalLb = Lbpl+Lbz</p>\n<h3>Example-2  error estimation using  Model La (full galpy, no error)</h3>\n<p>import numpy as np\nimport statistics as stat\nfrom astropy import units as u\nfrom astropy.coordinates import SkyCoord\nimport GalDynPsr</p>\n<p>Number=50000 # number of instances to simulate</p>\n<p>mul, sigmal =   # define mean and standard deviation of l_degree</p>\n<p>mub, sigmab =    # define mean and standard deviation of b_degree</p>\n<p>mud, sigmad =     # define mean and standard deviation of d_kpc</p>\n<h1>now simulate 'Number' instances of l, b and d</h1>\n<p>lsim = np.random.normal(mul, sigmal, Number)</p>\n<p>bsim = np.random.normal(mub, sigmab, Number)</p>\n<p>dsim = np.random.normal(mud, sigmad, Number)</p>\n<h1>declare arrays for excess_parallel, excess_z and excess_total</h1>\n<p>Lapl = []\nLaz = []\ntotalLa = []</p>\n<h1>now run GalDynPsr for 'Number' times</h1>\n<p>count = 0\nwhile (count &lt; Number):</p>\n<h1>randomly select l, b, d from the simulated values</h1>\n<p>x=np.random.random_integers(low=1, high=Number-1, size=3)</p>\n<p>l=lsim[x[0]]\nb=bsim[x[1]]\nd=dsim[x[2]]</p>\n<h1>for each value of l, b, d, calculate excess_parallel, excess_z and excess_total</h1>\n<p>Lapl.append(GalDynPsr.modelLa.Expl(l, sigmal, b, sigmab, d, sigmad))\nLaz.append(GalDynPsr.modelLa.Exz(l, sigmal, b, sigmab, d, sigmad))</p>\n<p>totalLa=np.add(Lapl,Laz)</p>\n<p>count = count + 1</p>\n<h1>now calculate mean and standard deviation of excess_parallel, excess_z and excess_total</h1>\n<p>print(stat.mean(Lapl), stat.stdev(Lapl), count)\nprint(stat.mean(Laz), stat.stdev(Laz), count)\nprint(stat.mean(totalLa), stat.stdev(totalLa), count)</p>\n<p>#############################\n######### For a Globular Cluster Pulsar #############################\n#Check names of Globular Clusters from GC_Harris.txt and write the name of the cluster. We do not include errors in this case.</p>\n<h3>Example 3</h3>\n<p>#Getting Excess_pl for model A for the GC 47Tuc:-\n#GalDynPsr.ReadGC.gcinput(\"GC Name\") finds the GC in the GC_Harris list and calculates the corresponding galactic coordinates and distance to the GC. Input the arguments to any model as:- (GalDynPsr.ReadGC.ldeg,0.,GalDynPsr.ReadGC.bdeg,0.,GalDynPsr.ReadGC.dkpc,0.)</p>\n<p>GalDynPsr.ReadGC.gcinput(\"47Tuc\")</p>\n<p>Apl = GalDynPsr.modelA.Expl(GalDynPsr.ReadGC.ldeg,0.,GalDynPsr.ReadGC.bdeg,0.,GalDynPsr.ReadGC.dkpc,0.)</p>\n<p>Az = GalDynPsr.modelA.Exz(GalDynPsr.ReadGC.ldeg,0.,GalDynPsr.ReadGC.bdeg,0.,GalDynPsr.ReadGC.dkpc,0.)</p>\n<h1>Similarly for other models.</h1>\n<p>#############################</p>\n<p>######################### For Intrinsic period derivative calculations ###############################</p>\n<h2>Parameters required for spin period derivative calcuations:- P = period in seconds, sigP = error in P in second, Pdot_obs = measured period derivative in ss^-1, sigPdot_obs = error in Pdot_obs</h2>\n<p>#PdotExpl(Excess_pl,P) calculates the planar contribution to the period derivative</p>\n<p>#PdotExz(Excess_z,P) calculates the perpendicular contribution to the period derivative</p>\n<p>#PdotGal(Excess_pl,Excess_z,P) calculates the sum of planar and perpendicular contributions to the period derivative</p>\n<p>#PdotShk(Excess_shk,P) calculates the Shklovskii contribution to the period derivative</p>\n<p>#Pdotint(Excess_pl,Excess_z,Excess_shk,Pdot_obs,P) calculates the intrinsic period derivative</p>\n<p>#ErrPdotExpl(Excess_pl,error_Excess_pl,P,sigP) calculates the error in the planar contribution to the period derivative</p>\n<p>#ErrPdotExz(Excess_z,error_Excess_z,P,sigP) calculates the error in the perpendicular contribution to the period derivative</p>\n<p>#ErrPdotGal(Excess_pl,error_Excess_pl,Excess_z,error_Excess_z,P,sigP) calculates the error in the sum of planar and perpendicular contributions to the period derivative</p>\n<p>#ErrPdotShk(Excess_shk,error_Excess_shk,P,sigP) calculates the error in the Shklovskii contribution to the spin period derivative</p>\n<p>#ErrPdotint(Excess_pl,error_Excess_pl,Excess_z,error_Excess_z,Excess_shk,error_Excess_shk,Pdot_obs,sigPdot_obs,P,sigP) calculates the error in the intrinsic period derivative</p>\n<h3>Example 4</h3>\n<h1>Say using La</h1>\n<p>ldeg =20.0\nsigl = 2.0</p>\n<p>bdeg = 45.0\nsigb = 0.2</p>\n<p>dkpc = 1.2\nsigd = 0.3</p>\n<p>mu_alpha = 22.0\nsigmua = 0.2</p>\n<p>mu_delta = 1.2\nsigmud = 0.3</p>\n<h1>Example spin period and itsderivatives:-</h1>\n<p>#P = 0.003061844088094608\n#sigP = 0.000000000000000015</p>\n<p>#Pdot_obs = 0.959013e-20\n#sigPdot_obs = 0.000014e-20</p>\n<p>#Example orbital period and its derivatives (convert the period and corresponding error in seconds):-</p>\n<p>P = 1.198512575184<em>24.0</em>3600.0</p>\n<p>sigP = 0.000000000013<em>24.0</em>3600.0</p>\n<p>Pdot_obs = 4.8e-14\nsigPdot_obs = 1.1e-14</p>\n<h2></h2>\n<p>Ex_pl = GalDynPsr.modelA.Expl(ldeg, sigl, bdeg, sigb, dkpc, sigd)</p>\n<p>Ex_z = GalDynPsr.modelA.Exz(ldeg, sigl, bdeg, sigb, dkpc, sigd)</p>\n<p>errpl = GalDynPsr.modelA.Errpl(ldeg, sigl, bdeg, sigb, dkpc, sigd)</p>\n<p>errz = GalDynPsr.modelA.Errz(ldeg, sigl, bdeg, sigb, dkpc, sigd)</p>\n<p>Ex_shk = GalDynPsr.Shk.Exshk(dkpc, sigd, mu_alpha, sigmua, mu_delta, sigmud)</p>\n<p>errshk = GalDynPsr.Shk.errShk(dkpc, sigd, mu_alpha, sigmua, mu_delta, sigmud)</p>\n<p>PdotExpl =  GalDynPsr.pdotint.PdotExpl(Ex_pl,P)</p>\n<p>PdotExz =  GalDynPsr.pdotint.PdotExz(Ex_z,P)</p>\n<p>PdotGal =  GalDynPsr.pdotint.PdotGal(Ex_pl,Ex_z,P)</p>\n<p>PdotShk =  GalDynPsr.pdotint.PdotShk(Ex_shk,P)</p>\n<p>Pdotint = GalDynPsr.pdotint.Pdotint(Ex_pl,Ex_z,Ex_shk,Pdot_obs,P)</p>\n<p>#Errors in spin period derivatives:-</p>\n<p>ErrPdotExpl =  GalDynPsr.pdotint.ErrPdotExpl(Ex_pl,errpl,P,sigP)</p>\n<p>ErrPdotExz = GalDynPsr.pdotint.ErrPdotExz(Ex_z,errz,P,sigP)</p>\n<p>ErrPdotGal =  GalDynPsr.pdotint.ErrPdotGal(Ex_pl,errpl,Ex_z,errz,P,sigP)</p>\n<p>ErrPdotShk = GalDynPsr.pdotint.ErrPdotShk(Ex_shk,errshk,P,sigP)</p>\n<p>ErrPdotint =  GalDynPsr.pdotint.ErrPdotint(Ex_pl,errpl,Ex_z,errz,Ex_shk,errshk,Pdot_obs,sigPdot_obs,P,sigP)</p>\n<p>#==========================================================================================</p>\n<h5>Contents of the Package</h5>\n<p>Datafiles:</p>\n<p>parameters.in: Input file contains values of different constants which are subject to change with improvements in measurements. User can change the values of constants if the need be.</p>\n<p>GC_Harris.txt: Names and Galactic coordinates of the Globular Clusters.</p>\n<p>README.txt: Contents of this README.md file inside package along with code files.</p>\n<p>Description of different codes:</p>\n<p>read_parameters.py: contains parameters (constants) used in the package</p>\n<p>ExcessZ.py:  Calculates az/c, both Nice-Taylor (1995) expression as well as our fit of HF2004</p>\n<p>Excesspl.py: Calculates apl/c. Can take any value of the slope parameter dv/dR from the parameter file. b0 = (Vs/Rs)*(dV/dR) = 0 is the conventional.</p>\n<p>modelA.py: Model A - Calculates apl_old/c (i.e. b0 = 0; DT91) and az_NT95.</p>\n<p>modelB.py: Model B - Calculates apl_old/c (i.e. b0 = 0; DT91) and az_HF04.</p>\n<p>modelC.py: Model C - Calculates apl_new/c (i.e. dv/dR = -0.2; Reid2014) and az_NT95.</p>\n<p>modelD.py: Model D - Calculates apl_new/c (i.e. dv/dR = -0.2; Reid2014) and az_HF04.</p>\n<p>modelEa.py: Model Ea - Calculates apl_old/c (i.e. b0 = 0; DT91) and \u2018zforce\u2019 in galpy (without BH)\nmodelEb.py: Model Eb - Calculates apl_old/c (i.e. b0 = 0; DT91) and \u2018zforce\u2019 in galpy (with BH)</p>\n<p>modelFa.py: Model Fa - Calculates apl_new/c (i.e. dv/dR = -0.2; Reid2014) and \u2018zforce\u2019 in galpy (without BH)\nmodelFb.py: Model Fb - Calculates apl_new/c (i.e. dv/dR = -0.2; Reid2014) and \u2018zforce\u2019 in galpy (with BH)</p>\n<p>modelGa.py: Model Ga - Calculates apl/c using Vp'/Vs from galpy (without BH) and az_NT95\nmodelGb.py: Model Gb - Calculates apl/c using Vp'/Vs from galpy (with BH) and az_NT95</p>\n<p>modelHa.py: Model Ha - Calculates \u2018Rforce\u2019 in galpy (without BH) and az_NT95\nmodelHb.py: Model Hb - Calculates \u2018Rforce\u2019 in galpy (with BH) and az_NT95</p>\n<p>modelIa.py: Model Ia - Calculates apl/c using Vp'/Vs from galpy (without BH) and az_HF04\nmodelIb.py: Model Ib - Calculates apl/c using Vp'/Vs from galpy (with BH) and az_HF04</p>\n<p>modelJa.py: Model Ja - Calculates \u2018Rforce\u2019 in galpy (without BH) and az_HF04\nmodelJb.py: Model Jb - Calculates \u2018Rforce\u2019 in galpy (with BH) and az_HF04</p>\n<p>modelKa.py: Model Ka - Calculates apl/c using Vp'/Vs from galpy (without BH) and \u2018zforce\u2019 in galpy (without BH)\nmodelKb.py: Model Kb - Calculates apl/c using Vp'/Vs from galpy (with BH) and \u2018zforce\u2019 in galpy (with BH)</p>\n<p>modelLa.py: Model La - Calculates \u2018Rforce\u2019 in galpy (without BH) and \u2018zforce\u2019 in galpy (without BH)\nmodelLb.py: Model Lb - Calculates \u2018Rforce\u2019 in galpy (with BH) and \u2018zforce\u2019 in galpy (with BH)</p>\n<p>Shk.py: Calculates the Shklovskii term d(mu_T*mu_T)/c. Takes user input of proper motion in right ascension and declination.</p>\n<p>galpyMWpl.py: Using vcirc function in galpy to get Vp'(without BH) and eventually apl/c</p>\n<p>galpyMWBHpl.py: Using vcirc function in galpy to get Vp'(with BH) and eventually apl/c</p>\n<p>galpyMWRfo.py: Using evaluateRforces function in galpy(without BH) to get apl/c</p>\n<p>galpyMWBHRfo.py: Using evaluateRforces function in galpy(with BH) to get apl/c</p>\n<p>err_excesspl_Damour.py: Calculates error for Excess_pl (DT91)</p>\n<p>err_excesspl_Reid.py: Calculates error for Excess_pl (Reid2014)</p>\n<p>err_HFhigh.py: Calculates error for Excess_z (our fit for HF04 data)</p>\n<p>err_HFlow.py: Calculates error for Excess_z (our fit for HF04 data)</p>\n<p>err_NT.py: Calculates error for Excess_z (NT95)</p>\n<p>err_Shklovskii.py: Calculates error for Excess_Shk</p>\n<p>#==========================================================================================================================================</p>\n<p>Though the description of models is provided in the paper, for the sake of completeness we are still providing that here.</p>\n<p>Description of Models:-</p>\n<p>Model-A: apl_old/c (i.e. b0 = 0; DT91) and Z_NT95\nModel-B: apl_old/c (i.e. b0 = 0; DT91) and Z_HF04\nModel-C: apl_new/c (i.e. dv/dR = -0.2; Reid2014) and Z_NT95\nModel-D: apl_new/c (i.e. dv/dR = -0.2; Reid2014) and Z_HF04</p>\n<p>Model-Ea: apl_old/c (i.e. b0 = 0; DT91) and \u2018zforce\u2019 in galpy (without BH)\nModel-Eb: apl_old/c (i.e. b0 = 0; DT91) and \u2018zforce\u2019 in galpy (with BH)</p>\n<p>Model-Fa: apl_new/c (i.e. dv/dR = -0.2; Reid2014) and \u2018zforce\u2019 in galpy (without BH)\nModel-Fb: apl_new/c (i.e. dv/dR = -0.2; Reid2014) and \u2018zforce\u2019 in galpy (with BH)</p>\n<p>Model-Ga: Using Vp'/Vs from galpy (without BH) and Z_NT95\nModel-Gb: Using Vp'/Vs from galpy (with BH) and Z_NT95</p>\n<p>Model-Ha: \u2018Rforce\u2019 in galpy (without BH) and Z_NT95\nModel-Hb: \u2018Rforce\u2019 in galpy (with BH) and Z_NT95</p>\n<p>Model-Ia: Using Vp'/Vs from galpy (without BH) and Z_HF04\nModel-Ib: Using Vp'/Vs from galpy (with BH) and Z_HF04</p>\n<p>Model-Ja: \u2018Rforce\u2019 in galpy (without BH) and Z_HF04\nModel-Jb: \u2018Rforce\u2019 in galpy (with BH) and Z_HF04</p>\n<p>Model-Ka: Using Vp'/Vs from galpy (without BH) and \u2018zforce\u2019 in galpy (without BH)\nModel-Kb: Using Vp'/Vs from galpy (with BH) and \u2018zforce\u2019 in galpy (with BH)</p>\n<p>Model-La: \u2018Rforce\u2019 in galpy (without BH) and \u2018zforce\u2019 in galpy (without BH)\nModel-Lb: \u2018Rforce\u2019 in galpy (with BH) and \u2018zforce\u2019 in galpy (with BH)</p>\n<p>Reid2014: Reid M. J., Menten K. M., Brunthaler A., Zheng X. W., Dame T. M., 2014, ApJ, 783, 130.</p>\n<p>DT91: Damour T., Taylor J.H., 1991, ApJ, 366, 501.</p>\n<p>NT95: Nice D.J., Taylor J.H., 1995, ApJ, 441, 429.</p>\n<p>HF04: Holmberg J., Flynn C., 2004, MNRAS, 352, 440.</p>\n<p>############################################################</p>\n\n          </div>"}, "last_serial": 4371394, "releases": {"0.0.1": [{"comment_text": "", "digests": {"md5": "98b8a7c8d37513e8141ca7ba40733242", "sha256": "1fa756a97f592e7d13a3c4e6c2eab53a9c15a3106769cb3f98ca98b8db235e7c"}, "downloads": -1, "filename": "GalDynPsr-0.0.1-py3-none-any.whl", "has_sig": false, "md5_digest": "98b8a7c8d37513e8141ca7ba40733242", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 37598, "upload_time": "2018-10-10T14:44:30", "upload_time_iso_8601": "2018-10-10T14:44:30.673660Z", "url": "https://files.pythonhosted.org/packages/7a/5a/b71bd511a7cb8d233e4f332cb7c6ffeeda36c19101bea0b11d6120cddc45/GalDynPsr-0.0.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "4d543f58600a438e0453be0b26498db6", "sha256": "1c56a0218144a075e3e282155787367add44e1140b644cb298d8cf34d4803544"}, "downloads": -1, "filename": "GalDynPsr-0.0.1.tar.gz", "has_sig": false, "md5_digest": "4d543f58600a438e0453be0b26498db6", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 34005, "upload_time": "2018-10-10T14:44:33", "upload_time_iso_8601": "2018-10-10T14:44:33.452411Z", "url": "https://files.pythonhosted.org/packages/69/a8/b7b7bf5b6f8a1210e6cf7a34aa12090b7719f0f87f4578bce2a46ca01f3a/GalDynPsr-0.0.1.tar.gz", "yanked": false}], "1.0.0": [{"comment_text": "", "digests": {"md5": "5879dbca91322f1cbb7b4c2404391d15", "sha256": "44a0ceb89a056e714e7544ba5756fafbdea1df0f9b2c685627de124f723e1d64"}, "downloads": -1, "filename": "GalDynPsr-1.0.0-py3-none-any.whl", "has_sig": false, "md5_digest": "5879dbca91322f1cbb7b4c2404391d15", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 38732, "upload_time": "2018-10-13T09:11:29", "upload_time_iso_8601": "2018-10-13T09:11:29.844775Z", "url": "https://files.pythonhosted.org/packages/28/32/01e2fd1c0e5d8ab24d74f98b94b85aa86d3ff21116bcb5e5f4f7afbd0aa7/GalDynPsr-1.0.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "5a314195538e85111ed2acd99901499c", "sha256": "19f3acfed6c2a0f92fa9de9eff7c5dc57f7bccee77c739d4d5f30b797b83bdc5"}, "downloads": -1, "filename": "GalDynPsr-1.0.0.tar.gz", "has_sig": false, "md5_digest": "5a314195538e85111ed2acd99901499c", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 37878, "upload_time": "2018-10-13T09:11:32", "upload_time_iso_8601": "2018-10-13T09:11:32.709486Z", "url": "https://files.pythonhosted.org/packages/af/fa/c40c65af5e718572726111949963f38de6309dee8b903c2a79d90c28c684/GalDynPsr-1.0.0.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "5879dbca91322f1cbb7b4c2404391d15", "sha256": "44a0ceb89a056e714e7544ba5756fafbdea1df0f9b2c685627de124f723e1d64"}, "downloads": -1, "filename": "GalDynPsr-1.0.0-py3-none-any.whl", "has_sig": false, "md5_digest": "5879dbca91322f1cbb7b4c2404391d15", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 38732, "upload_time": "2018-10-13T09:11:29", "upload_time_iso_8601": "2018-10-13T09:11:29.844775Z", "url": "https://files.pythonhosted.org/packages/28/32/01e2fd1c0e5d8ab24d74f98b94b85aa86d3ff21116bcb5e5f4f7afbd0aa7/GalDynPsr-1.0.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "5a314195538e85111ed2acd99901499c", "sha256": "19f3acfed6c2a0f92fa9de9eff7c5dc57f7bccee77c739d4d5f30b797b83bdc5"}, "downloads": -1, "filename": "GalDynPsr-1.0.0.tar.gz", "has_sig": false, "md5_digest": "5a314195538e85111ed2acd99901499c", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 37878, "upload_time": "2018-10-13T09:11:32", "upload_time_iso_8601": "2018-10-13T09:11:32.709486Z", "url": "https://files.pythonhosted.org/packages/af/fa/c40c65af5e718572726111949963f38de6309dee8b903c2a79d90c28c684/GalDynPsr-1.0.0.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:59:18 2020"}