{"info": {"author": "Foley Lab", "author_email": "foleyj10@wpunj.edu", "bugtrack_url": null, "classifiers": ["License :: OSI Approved :: GNU General Public License (GPL)", "Operating System :: MacOS :: MacOS X", "Operating System :: Microsoft :: Windows :: Windows 10", "Operating System :: POSIX :: Linux", "Programming Language :: Python :: 3"], "description": "<img src=\"Logo/WPtherml.png\" alt=\"drawing\" width=\"200\"/> \nPioneering the design of materials for harnessing heat.\n\n## Overview\nWPTherml stands for **W**illiam **P**aterson University's tool for **Th**ermal **E**nergy and **R**adiation management with **M**ulti **L**ayer nanostructures.\nThe vision of this software package is to provide an easy-to-use platform for the design of materials with tailored optical and thermal properties for\nthe vast number of energy applications where control of absorption and emission of radiation, or conversion of heat to radiation or vice versa, is paramount.\nThe optical properties are treated within classical electrodynamics, and the current version uses the Transfer Matrix Method to rigorously solve Maxwell's equations\nfor layered isotropic media.  WPTherml was conceived and developed by the [Foley Lab](https://foleylab.github.io) at William Paterson University. More details of the Transfer Matrix equations, along will the full mathematical formulation currently implemented in WPTherml, can be found in\nthe [documentation](https://github.com/FoleyLab/wptherml/blob/master/docs/Equations.pdf).\n\n## Quick Start\n- WPTherml is written in Python 3 and requires the numpy, scipy, and matplotlib packages.  Current installation of the Anaconda Python 3 package should provide all you need \non Windows, Mac, or Linux platforms\n- To install from github: \n   * `git clone https://github.com/FoleyLab/wptherml.git`\n   * `cd wptherml`\n   * `python3 setup.py install`\n\n- To run unit tests from cloned repository:\n   * `cd test`\n   * `python3 -m pytest test.py`\n\n- The test script for running unit tests can be downloaded [here](https://github.com/FoleyLab/wptherml/blob/master/example/test/test.py)\n\n- To install with pip3:\n   * `pip3 install wptherml`\n\n\n- Open a new .py file in your favorite text editor or IDE, e.g.\n\n`vim example.py`\n\nThe capabilities of this package are contained within a class called multilayer.  A basic example \nof a script that imports the multilayer class, computes the reflectivity of 20 nm gold film coated with 50 nm of \nTiO2 and 100 nm SiO2, and plots\nit using pyplot follows:\n\n```python\nfrom wptherml.wpml import multilayer\nfrom matplotlib import pyplot as plt\n\n### dictionary that stores basic properties \n### of the multilayer structure you want to simulate\nstructure = {\n        ### actual materials the structure is made from... note terminal layers are air and\n   \t### top-side layer (layer upon which light is incident) is SiO2.\n        ### Refractive index values are stored in the attribute self.n\n        'Material_List': ['Air', 'SiO2', 'TiO2', 'Au', 'Air'],\n        ### thickness of each layer... terminal layers must be set to zero\n        ### values are stored in attribute self.d\n        'Thickness_List': [0, 100e-9, 50e-9, 20e-9,  0],\n         ### range of wavelengths optical properties will be calculated for\n         ### values are stored in the array self.lam\n        'Lambda_List': [400e-9, 800e-9, 1000]\n        }\n\n### create the instance called coated_au_film\ncoated_au_film = multilayer(structure)\n\n### create a plot of the reflectivity of the coated au film - use red lines\n### the wavelengths are stored in SI units so we will multiply by 1e9 to \n### plot them in nanometers\nplt.plot(1e9*coated_au_film.lambda_array, coated_au_film.reflectivity_array, 'red')\nplt.show()\n```\n{: .language-python}\n\n- Save this script and run it either in the terminal as\n\n`python3 example.py`\n\nwhere example.py is the name of the file you created, or if you were doing this in an IDE, execute it within your IDE!\n\nThe schematic that illustrates the above example is shown in the figure below. Note the ordering of the \nlayers in the picture and how they are specified through Material_List and Thickness_List relative to \nthe incident, reflected, transmitted, and thermally-emitted light.\n\n<img src=\"docs/Convention.png\" alt=\"drawing\" width=\"500\"/>\n\n\nThere are illustrative examples of using the features of the multilayer class contained in Jupyter notebooks within this repository, including:\n\n- [Validation of Basic Optical Properties](https://github.com/FoleyLab/wptherml/blob/master/example/Validate_Fresnel.ipynb)\n\n- [Examples of Computing Basic Optical Properties](https://github.com/FoleyLab/wptherml/blob/master/example/Example1.ipynb)\n\n- [Modeling Incandescent Sources](https://github.com/FoleyLab/wptherml/blob/master/example/Example2.ipynb)\n\n- [Modeling Radiative Cooling Surfaces](https://github.com/FoleyLab/wptherml/blob/master/example/Validate_Cooling.ipynb)\n\n- [Video Demo for Radiative Cooling](https://youtu.be/LC4TrnB8JK4)\n\nMore will be added in the near future!\n\n\n## Playlist\nThe developers of WPTherml compiled a thematic [Spotify Playlist called \"Everything Thermal\"](https://open.spotify.com/playlist/1Vb7MV4WwjOMMHLbrX4TNN); we hope it will inspire you to imagine new possibilities for \nharnessing heat and thermal radiation!\n\n## Features List\n1. Computes Reflectivity, Transmissivity, and Absorptivity/Emissivity spectrum of arbitrary multi-layered planar structures using the Transfer Matrix Method\n2. Computes Thermal Emission spectrum at a given temperature of multi-layer structure as emissivity * Blackbody spectrum \n3. Computes solar power absorbed from absorptivity * AM1.5 spectrum\n4. From the quantities above, the following performance-related quantities can be computed for various thermal-related applications:\n   * Spectral Efficiency of (S)TPV Emitters for a given PV\n   * Useful Power Density (S)TPV Emitters for a given PV\n   * Short Circuit Current Density (S)TPV Emitter for a given PV\n   * TPV Efficiency (S)TPV Emitters for a given PV\n   * Absorber Efficiency for STPV Absorbers for a given concentration factor\n   * Luminous Efficiency/Luminous Efficacy of Incandescent bulb filaments\n   * Cooling Power for day-time radiative cooling for a given ambient temperature and temperature of the multi-layer\n5. From optical quantities, the following analysis can be performed\n   * Identify Surface Plasmon Polariton modes\n   * Identify Perfectly Absorbing modes\n   * Rendering of color of a multi-layer at cool temperatures and at elevated temperatures\n\nThe calculations of the quantities above are facilitated by a class called *multilayer*.  The *multilayer* class parses a dictionary for key \nstructural data like the material and thicknesses that comprise the multi-layer structure being modeled, the types of applications one wants to\nconsider the multi-layer structure for.  The following is the complete list of dictionary keys the *multilayer* class will recognize, along with\nthe data the user can supply in association with each key:\n```python\n'Lambda_List' # a list of three floats that includes in order (i) shortest wavelength in meters, (ii) longest wavelength in meters, and (iii) total number of wavelengths where you would like the optical quantities to be evaluated.  (Default is [400e-9,6000e-9,1000])\n\n'Thickness_List' # a list of floats that specify the thickness in meters of each layer.  Note that the terminal layers (first and last) must have thickness of 0. (Default is [0, 900e-9, 0].)\n\n'Material_List' # a list of strings that specify the materials in each layer (Default is ['Air', 'W', 'Air'].  \nThe following strings are currently recognized for the following supported materials:\n   * 'Air' - keyword for Air\n   * 'SiO2' - keyword for Glass\n   * 'HfO2' - keyword for Hafnium Oxide\n   * 'Al2O3' - keyword for Aluminum Oxide\n   * 'TiO2' - keyword for Titanium Oxide\n   * 'AlN'  - keyword for Aluminum Nitride\n   * 'TiN' - keyword for Titanium Nitride\n   * 'Ag' - keyword for Silver\n   * 'Au' - keyword for Gold\n   * 'Pd' - keyword for Palladium\n   * 'Pt' - keyword for Platinum\n   * 'W' - keyword for Tungsten\n\n'Temperature'  # a float specifying the temperature of the multi-layer structure in Kelvin.  (Default is 300 K)\n\n'PV_Temperature' # a float specifying the temperature of a PV cell in a (S)TPV device in Kelvin.  (Default is 300 K).\n\n'Ambient_Temperature' # a float specifying the ambient temperature in Kelvin for radiative cooling applications. (Default is 300 K).\n\n'STPV_EMIT' # an int where '1' means compute properties associated with (S)TPV emitters. (Default is 0, do not compute these quantities).\n\n'STPV_ABS' # an int where '1' means compute properties associated with STPV/Concentrated Solar absorbers. (Default is 0).\n\n'COOLING' # an int where '1' means compute properties associated with radiative cooling. (Default is 0).\n\n'LIGHTBULB' # an int where '1' means compute properties associated with incandescent sources. (Default is 0).\n\n'COLOR' # an int where '1' means compute and display the ambient and thermal color of a structure. (Default is 0).\n\n'EXPLICIT_ANGLE' # an int where '1' means compute the optical properties and thermal emission at a range of angles and, when applicable, compute performance properties with explicit angular dependence.  (Default is 0, meaning most quantities will be computed assuming the emissivity does not depend upon angle.)\n\n'DEG' # an int that specifies the number of different angles that will be considered \nin the calculation of optical and thermal emission properties as a function of angle. (Default is 7, which has been observed to give reasonably good accuracy when all angular integrals are performed using Gauss-Legendre quadrature).\n```\n{: .language-python}\n## Method and attribute list for multilayer class\nGiven the input parameters specified above, the *multilayer* class uses different methods to compute properties relevant for thermal applications, and those properties are stored as attributes\nof the *multilayer* object.  The following is a list of methods of the *multilayer* class and their related attributes:\n\n\n```python\n\tdef inline_structure(structure):\n       \t### a method to parse input parameters from a dictionary (here called structure, all currently-supported dictionary \n       \t### keys are defined above.  This method is called by the __init__ and defines the following attributes:\n\n\tself.lambda_array \t# the list of wavelengths in meters that will be used to evaluate optical and thermal spectra\n\tself.d\t\t  \t# the list of thicknesses that define the geometry of the multilayer\n\tself.matlist      \t# the list of strings that specify the materials\n\tself.n\t\t  \t# the 2D arrays of refractive index values for each material for each wavelength (inner index specifies material, outter index wavelength)\n\tself.T_ml         \t# the temperature of the multi-layer in Kelvin\n\tself.T_cell       \t# the temperature of the PV cell in Kelvin\n\tself.T_amb      \t# the ambient temperature in Kelvin\n\tself.stpv_emitter_calc  # the flag that determines if (S)TPV emitter properties will be computed\n\tself.stpv_absorber_calc # the flag that determines if (S)TPV absorber properties will be computed\n\tself.cooling_calc    \t# the flag that determines if radiative cooling properties will be computed\n\tself.lightbulb_calc     # the flag that determines if incandescent properties will be computed\n\tself.color_calc \t# the flag that determines if colors will be rendered\n\tself.explicit_angle \t# the flag that determines if explicit angle-dependence of optical properties will be considered\n\tself.deg\t\t# the number of different angles that will be computed for angle-dependent optical properties\n  ```\n{: .language-python}\nIn addition to the attributes that are explicitly set by parsing user input, several more attributes that are arrays will be \nallocated based on attributes defined by inline_structure:\n```python\n\t### The following are always created\n\tself.reflectivity_array \t# initialized as an array of zeros the same length as self.lambda_array\n\tself.transmissivity_array\t# initialized as an array of zeros the same length as self.lambda_array\n\tself.emissivity_array\t\t# initialized as an array of zeros the same length as self.lambda_array\n\tself.thermal_emission_array\t# initialized as an array of zeros the same length as self.lambda_array\n\n\t### The following are created if self.explicit_angle == 1\n\tself.x\t\t\t\t# points from Gauss-Legendre grid of degree self.deg from 0 to 1\n\tself.t\t\t\t\t# self.deg angles on Gauss-Legendre grid transformed to be between 0 and pi/2\n\tself.w\t\t\t\t# self.deg weights from Gauss-Legendre grid transformed to be between 0 and pi/2\n\n\tself.reflectivity_array_p       # initialized as a 2D array of zeros, inner dimension same as self.deg and outter same as self.lambda_array\n        self.reflectivity_array_s       # initialized as a 2D array of zeros, inner dimension same as self.deg and outter same as self.lambda_array\n        self.transmissivity_array_p     # initialized as a 2D array of zeros, inner dimension same as self.deg and outter same as self.lambda_array\n        self.transmissivity_array_s     # initialized as a 2D array of zeros, inner dimension same as self.deg and outter same as self.lambda_array\n        self.emissivity_array_p         # initialized as a 2D array of zeros, inner dimension same as self.deg and outter same as self.lambda_array\n        self.emissivity_array_s         # initialized as a 2D array of zeros, inner dimension same as self.deg and outter same as self.lambda_array\n        self.thermal_emission_array_p   # initialized as a 2D array of zeros, inner dimension same as self.deg and outter same as self.lambda_array\n        self.thermal_emission_array_s   # initialized as a 2D array of zeros, inner dimension same as self.deg and outter same as self.lambda_array\n```\n{: .language-python}\n```python\n''' Method to compute optical properties of reflectivity, transmissivity, and \nemissivity of structure as a function of wavelength assuming normal incidence '''\ndef fresnel()\n\n### Upon execution, the following arrays are filled with their respective values\n### for every wavelength in self.lambda_array\nself.reflectivity_array\nself.transmissivity_array\nself.emissivity_array\n```\n{: .language-python}\n```python\n''' Method to compute optical properties of reflectivity, transmissivity, and \nemissivity of structure as a function of wavelength and angle, both p- and s-polarizations\nare considered '''\ndef fresnel_ea()\n\n### Upon execution, the following arrays are filled with their respective values\n### for every wavelength in self.lambda_array and every angle in self.t\nself.reflectivity_array_p\nself.reflectivity_array_s\nself.transmissivity_array_p\nself.transmissivity_array_s\nself.emissivity_array_p\nself.emissivity_array_s\n```\n{: .language-python}\n```python\n''' Method to compute thermal emission spectrum of a structure at a given temperature;\nnote temperature specified by self.T_ml '''\ndef thermal_emission()\n\n### Upon execution, the following arrays are computed for every wavelength in self.lambda_array\n### for temperature given by self.T_ml\nself.BBs   # Blackbody spectrum\nself.thermal_emission_array ## thermal emission of structure defined as Blackbody * emissivity\n```\n{: .language-python}\n\n```python\n''' Method to compute thermal emission spectrum of a structure at a given temperature for a range of angles '''\ndef thermal_emission_ea()\n\n### Upon execution, the following arrays are computed for every wavelength in self.lambda_array\n### and every angle in self.t for temperature given by self.T_ml\nself.thermal_emission_array_p ## thermal emission of structure defined as Blackbody * p-polarized emissivity\nself.thermal_emission_array_s ## thermal emission of structure defined as Blackbody * s-polarized emissivity\n```\n{: .language-python}\n```python\n''' Method to compute optical properties of reflectivity, transmissivity, \nand emissivity as a function of angle for a given polarization self.pol and wavelength lambda_0 '''\ndef angular_fresnel(self, lambda_0)\n\n### Upon execution, the following arrays are computed for 180 angles between 0 and pi/2\nself.r_vs_theta # reflectivity\nself.t_vs_theta # transmissivity\nself.eps_vs_theta # emissivity\n```\n{: .language-python}\n```python\n''' The following three methods compute figures of merit relevant for STPV emitters for a given\n    temperature self.T_ml, PV type self.PV and bandgap self.lbg, and PV temperature self.T_cell.\n    These methods assume the emissivity does not change with angle, and perform an analytic\n    integration over solid angles that make the computations much quicker, though also less realistic.'''\nself.stpv_se() # compute the spectral efficiency and stores it in the attribute self.spectral_efficiency_val\nself.stpv_pd() # computes the useful power density and stores it in the attribute self.power_density_val\nself.stpv_etatpv() # computes the TPV emitter efficiency and stores it in the attribute self.tpv_efficiency_val\n```\n{: .language-python}\n```python\n''' The following methods compute figures of merit relevant for STPV emitters for a given\n    temperature self.T_ml, PV type self.PV and bandgap self.lbg, and PV temperature self.T_cell.\n    These methods explicitly account for the angular dependence of the emissivity, making these calculations\n    more realistic but also more time consuming. '''\nself.stpv_se_ea() # compute the spectral efficiency and stores it in the attribute self.spectral_efficiency_val\nself.stpv_pd_ea() # computes the useful power density and stores it in the attribute self.power_density_val\nself.stpv_etatpv_ea() # computes the TPV emitter efficiency and stores it in the attribute self.tpv_efficiency_val\n```\n{: .language-python}\n```python\n''' The following methods compute the absorber efficiency of a STPV or concentrated solar absorber at a \n    given temperature self.T_ml '''\ndef stpv_etaabs_ea() # computes absorber efficiency and stores it in the attribute self.absorber_efficiency_val\n```\n{: .language-python}\n```python\n''' method to render color of a structure from its thermal emission at a given temperature self.T_ml '''\ndef thermal_color()\n''' method to render color of a structure from its reflection spectrum '''\ndef ambient_color()\n''' method to render color in a +/- 5nm band around the wavelength lambda '''\ndef pure_color(lambda)\n```\n{: .language-python}\n```python\n''' Method to compute the luminous efficiency of a structure at temperature self.T_ml.\n    Stores value to self.luminous_efficiency_val '''\ndef luminous_efficiency()\n\n''' Method to compute the radiative cooling power of a structure at temperature self.T_ml in ambient\n    temperature self.T_amb while being illuminated by the AM1.5 spectrum.  Upon execution, the relevant\n    values are stored to the attributes self.radiative_power_val (this is the flux that cools the structure),\n    self.atmospheric_power_val (part of flux that warms the structure) and self.solar_power_val (part of the flux \n    that warms the structure).'''\ndef cooling_power()\n\n\n''' Method  to add a layer to the structure; material of the layer to be added will be specified by 'material' argument\n    and thickness of the layer will be specified by the 'thickness' argument.  The layer will be inserted after\n    the 'layer_number' layer.  The method will also update spectral and performance quantities after the layer is\n    added; the instance name will be preserved after execution, so this is like a mutation operation.'''\ndef insert_layer(layer_number, material, thickness)\n\n''' Method to extract the array of refractive index values associated with a specific layer; the method returns \n    this array.  '''\ndef layer_ri(layer_number)\n\n''' Method to define the refractive index of an existing layer (specified by layer_number) as an alloy\n    of material_1 and material_2 with a specified volume_fraction of material_1 in material_2 according\n    to either the Maxwell-Garnett or the Bruggeman effective medium theory.  Using 'Bruggeman' as the\n    argument for model will use Bruggeman's effective medium theory, while any other string will default\n    to Maxwell-Garnett theory. Optical properties and performance figures are NOT updated upon execution of this method.'''\ndef layer_alloy(layer_number, volume_fraction, material_1, material_2, model)\n\n''' Method to define the refractive index of an existing layer (specified by layer number) as a single\n    complex number (specified by refractive_index_value) for all wavelengths.  Optical properties and performance figures are NOT updated upon execution of this method.'''\ndef layer_static_ri(layer_number, refractive_index_value)\n\n''' Method to compute complex wavevector magnitude associated with the surface plasmon polariton mode on a given multi-layer\n    structure at a wavelength specified by the int wavelength_index, where self.lambda_array[wavelength_index] returns\n    the wavelength you are interested in in meters.  Upon completion, the spp wavevector is stored in\n    self.spp_resonance_val '''\ndef find_spp(wavelength_index)\n\n''' Method to compute complex wavevector magnitude associated with the perfectly absorbing mode on a given multi-layer\n    structure at a wavelength specified by the int wavelength_index, where self.lambda_array[wavelength_index] returns\n    the wavelength you are interested in in meters.  Upon completion, the pa wavevector is stored in\n    self.pa_resonance_val '''\ndef find_pa()\n```\n{: .language-python}\n\n## Extending the multilayer class\n\nThe multilayer class should provide a convenient mechanism for extension of the package to include \nadditional applications (which might require different manipulations of the Fresnel \nquantities stored as the attributes self.reflectivity_array, self.emissivity_array, \nself.transmissivity_array, or the thermal emission stored as the attribute \nself.thermal_emission_array), or to include different classes of structures \n(non-planar structures, for example, where the same attributes self.reflectivity_array, etc., \nwould be computed by a different method than the transfer matrix method).  The typical \nworkflow to extend the capabilities of the package could include\n\n- Identifying any new properties that will be computed by the \nextension and adding appropriate attributes to the multilayer class\n- Adding one or more functions to the libraries (stpvlib, etc.) \nthat manipulates the Fresnel and/or thermal emission quantites as \nrequired to compute the new desired property\n- Adding one or more multilayer methods to call the new library functions \nand store the resulting data in new or existing multilayer attributes as appropriate.\n\n\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://foleylab.github.io/wptherml/", "keywords": "", "license": "", "maintainer": "", "maintainer_email": "", "name": "wptherml", "package_url": "https://pypi.org/project/wptherml/", "platform": "", "project_url": "https://pypi.org/project/wptherml/", "project_urls": {"Homepage": "https://foleylab.github.io/wptherml/"}, "release_url": "https://pypi.org/project/wptherml/1.0.0/", "requires_dist": null, "requires_python": "", "summary": "A Python package for the design of materials for harnessing heat.", "version": "1.0.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            <img alt=\"drawing\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/67e4087b34dbd682d1b242e63b133621cda8a473/4c6f676f2f5750746865726d6c2e706e67\" width=\"200\"> \nPioneering the design of materials for harnessing heat.\n<h2>Overview</h2>\n<p>WPTherml stands for <strong>W</strong>illiam <strong>P</strong>aterson University's tool for <strong>Th</strong>ermal <strong>E</strong>nergy and <strong>R</strong>adiation management with <strong>M</strong>ulti <strong>L</strong>ayer nanostructures.\nThe vision of this software package is to provide an easy-to-use platform for the design of materials with tailored optical and thermal properties for\nthe vast number of energy applications where control of absorption and emission of radiation, or conversion of heat to radiation or vice versa, is paramount.\nThe optical properties are treated within classical electrodynamics, and the current version uses the Transfer Matrix Method to rigorously solve Maxwell's equations\nfor layered isotropic media.  WPTherml was conceived and developed by the <a href=\"https://foleylab.github.io\" rel=\"nofollow\">Foley Lab</a> at William Paterson University. More details of the Transfer Matrix equations, along will the full mathematical formulation currently implemented in WPTherml, can be found in\nthe <a href=\"https://github.com/FoleyLab/wptherml/blob/master/docs/Equations.pdf\" rel=\"nofollow\">documentation</a>.</p>\n<h2>Quick Start</h2>\n<ul>\n<li>\n<p>WPTherml is written in Python 3 and requires the numpy, scipy, and matplotlib packages.  Current installation of the Anaconda Python 3 package should provide all you need\non Windows, Mac, or Linux platforms</p>\n</li>\n<li>\n<p>To install from github:</p>\n<ul>\n<li><code>git clone https://github.com/FoleyLab/wptherml.git</code></li>\n<li><code>cd wptherml</code></li>\n<li><code>python3 setup.py install</code></li>\n</ul>\n</li>\n<li>\n<p>To run unit tests from cloned repository:</p>\n<ul>\n<li><code>cd test</code></li>\n<li><code>python3 -m pytest test.py</code></li>\n</ul>\n</li>\n<li>\n<p>The test script for running unit tests can be downloaded <a href=\"https://github.com/FoleyLab/wptherml/blob/master/example/test/test.py\" rel=\"nofollow\">here</a></p>\n</li>\n<li>\n<p>To install with pip3:</p>\n<ul>\n<li><code>pip3 install wptherml</code></li>\n</ul>\n</li>\n<li>\n<p>Open a new .py file in your favorite text editor or IDE, e.g.</p>\n</li>\n</ul>\n<p><code>vim example.py</code></p>\n<p>The capabilities of this package are contained within a class called multilayer.  A basic example\nof a script that imports the multilayer class, computes the reflectivity of 20 nm gold film coated with 50 nm of\nTiO2 and 100 nm SiO2, and plots\nit using pyplot follows:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">wptherml.wpml</span> <span class=\"kn\">import</span> <span class=\"n\">multilayer</span>\n<span class=\"kn\">from</span> <span class=\"nn\">matplotlib</span> <span class=\"kn\">import</span> <span class=\"n\">pyplot</span> <span class=\"k\">as</span> <span class=\"n\">plt</span>\n\n<span class=\"c1\">### dictionary that stores basic properties </span>\n<span class=\"c1\">### of the multilayer structure you want to simulate</span>\n<span class=\"n\">structure</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n        <span class=\"c1\">### actual materials the structure is made from... note terminal layers are air and</span>\n   \t<span class=\"c1\">### top-side layer (layer upon which light is incident) is SiO2.</span>\n        <span class=\"c1\">### Refractive index values are stored in the attribute self.n</span>\n        <span class=\"s1\">'Material_List'</span><span class=\"p\">:</span> <span class=\"p\">[</span><span class=\"s1\">'Air'</span><span class=\"p\">,</span> <span class=\"s1\">'SiO2'</span><span class=\"p\">,</span> <span class=\"s1\">'TiO2'</span><span class=\"p\">,</span> <span class=\"s1\">'Au'</span><span class=\"p\">,</span> <span class=\"s1\">'Air'</span><span class=\"p\">],</span>\n        <span class=\"c1\">### thickness of each layer... terminal layers must be set to zero</span>\n        <span class=\"c1\">### values are stored in attribute self.d</span>\n        <span class=\"s1\">'Thickness_List'</span><span class=\"p\">:</span> <span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mf\">100e-9</span><span class=\"p\">,</span> <span class=\"mf\">50e-9</span><span class=\"p\">,</span> <span class=\"mf\">20e-9</span><span class=\"p\">,</span>  <span class=\"mi\">0</span><span class=\"p\">],</span>\n         <span class=\"c1\">### range of wavelengths optical properties will be calculated for</span>\n         <span class=\"c1\">### values are stored in the array self.lam</span>\n        <span class=\"s1\">'Lambda_List'</span><span class=\"p\">:</span> <span class=\"p\">[</span><span class=\"mf\">400e-9</span><span class=\"p\">,</span> <span class=\"mf\">800e-9</span><span class=\"p\">,</span> <span class=\"mi\">1000</span><span class=\"p\">]</span>\n        <span class=\"p\">}</span>\n\n<span class=\"c1\">### create the instance called coated_au_film</span>\n<span class=\"n\">coated_au_film</span> <span class=\"o\">=</span> <span class=\"n\">multilayer</span><span class=\"p\">(</span><span class=\"n\">structure</span><span class=\"p\">)</span>\n\n<span class=\"c1\">### create a plot of the reflectivity of the coated au film - use red lines</span>\n<span class=\"c1\">### the wavelengths are stored in SI units so we will multiply by 1e9 to </span>\n<span class=\"c1\">### plot them in nanometers</span>\n<span class=\"n\">plt</span><span class=\"o\">.</span><span class=\"n\">plot</span><span class=\"p\">(</span><span class=\"mf\">1e9</span><span class=\"o\">*</span><span class=\"n\">coated_au_film</span><span class=\"o\">.</span><span class=\"n\">lambda_array</span><span class=\"p\">,</span> <span class=\"n\">coated_au_film</span><span class=\"o\">.</span><span class=\"n\">reflectivity_array</span><span class=\"p\">,</span> <span class=\"s1\">'red'</span><span class=\"p\">)</span>\n<span class=\"n\">plt</span><span class=\"o\">.</span><span class=\"n\">show</span><span class=\"p\">()</span>\n</pre>\n<p>{: .language-python}</p>\n<ul>\n<li>Save this script and run it either in the terminal as</li>\n</ul>\n<p><code>python3 example.py</code></p>\n<p>where example.py is the name of the file you created, or if you were doing this in an IDE, execute it within your IDE!</p>\n<p>The schematic that illustrates the above example is shown in the figure below. Note the ordering of the\nlayers in the picture and how they are specified through Material_List and Thickness_List relative to\nthe incident, reflected, transmitted, and thermally-emitted light.</p>\n<img alt=\"drawing\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/232ad24daadb72b896663a9a67c95b29d5f68635/646f63732f436f6e76656e74696f6e2e706e67\" width=\"500\">\n<p>There are illustrative examples of using the features of the multilayer class contained in Jupyter notebooks within this repository, including:</p>\n<ul>\n<li>\n<p><a href=\"https://github.com/FoleyLab/wptherml/blob/master/example/Validate_Fresnel.ipynb\" rel=\"nofollow\">Validation of Basic Optical Properties</a></p>\n</li>\n<li>\n<p><a href=\"https://github.com/FoleyLab/wptherml/blob/master/example/Example1.ipynb\" rel=\"nofollow\">Examples of Computing Basic Optical Properties</a></p>\n</li>\n<li>\n<p><a href=\"https://github.com/FoleyLab/wptherml/blob/master/example/Example2.ipynb\" rel=\"nofollow\">Modeling Incandescent Sources</a></p>\n</li>\n<li>\n<p><a href=\"https://github.com/FoleyLab/wptherml/blob/master/example/Validate_Cooling.ipynb\" rel=\"nofollow\">Modeling Radiative Cooling Surfaces</a></p>\n</li>\n<li>\n<p><a href=\"https://youtu.be/LC4TrnB8JK4\" rel=\"nofollow\">Video Demo for Radiative Cooling</a></p>\n</li>\n</ul>\n<p>More will be added in the near future!</p>\n<h2>Playlist</h2>\n<p>The developers of WPTherml compiled a thematic <a href=\"https://open.spotify.com/playlist/1Vb7MV4WwjOMMHLbrX4TNN\" rel=\"nofollow\">Spotify Playlist called \"Everything Thermal\"</a>; we hope it will inspire you to imagine new possibilities for\nharnessing heat and thermal radiation!</p>\n<h2>Features List</h2>\n<ol>\n<li>Computes Reflectivity, Transmissivity, and Absorptivity/Emissivity spectrum of arbitrary multi-layered planar structures using the Transfer Matrix Method</li>\n<li>Computes Thermal Emission spectrum at a given temperature of multi-layer structure as emissivity * Blackbody spectrum</li>\n<li>Computes solar power absorbed from absorptivity * AM1.5 spectrum</li>\n<li>From the quantities above, the following performance-related quantities can be computed for various thermal-related applications:\n<ul>\n<li>Spectral Efficiency of (S)TPV Emitters for a given PV</li>\n<li>Useful Power Density (S)TPV Emitters for a given PV</li>\n<li>Short Circuit Current Density (S)TPV Emitter for a given PV</li>\n<li>TPV Efficiency (S)TPV Emitters for a given PV</li>\n<li>Absorber Efficiency for STPV Absorbers for a given concentration factor</li>\n<li>Luminous Efficiency/Luminous Efficacy of Incandescent bulb filaments</li>\n<li>Cooling Power for day-time radiative cooling for a given ambient temperature and temperature of the multi-layer</li>\n</ul>\n</li>\n<li>From optical quantities, the following analysis can be performed\n<ul>\n<li>Identify Surface Plasmon Polariton modes</li>\n<li>Identify Perfectly Absorbing modes</li>\n<li>Rendering of color of a multi-layer at cool temperatures and at elevated temperatures</li>\n</ul>\n</li>\n</ol>\n<p>The calculations of the quantities above are facilitated by a class called <em>multilayer</em>.  The <em>multilayer</em> class parses a dictionary for key\nstructural data like the material and thicknesses that comprise the multi-layer structure being modeled, the types of applications one wants to\nconsider the multi-layer structure for.  The following is the complete list of dictionary keys the <em>multilayer</em> class will recognize, along with\nthe data the user can supply in association with each key:</p>\n<pre><span class=\"s1\">'Lambda_List'</span> <span class=\"c1\"># a list of three floats that includes in order (i) shortest wavelength in meters, (ii) longest wavelength in meters, and (iii) total number of wavelengths where you would like the optical quantities to be evaluated.  (Default is [400e-9,6000e-9,1000])</span>\n\n<span class=\"s1\">'Thickness_List'</span> <span class=\"c1\"># a list of floats that specify the thickness in meters of each layer.  Note that the terminal layers (first and last) must have thickness of 0. (Default is [0, 900e-9, 0].)</span>\n\n<span class=\"s1\">'Material_List'</span> <span class=\"c1\"># a list of strings that specify the materials in each layer (Default is ['Air', 'W', 'Air'].  </span>\n<span class=\"n\">The</span> <span class=\"n\">following</span> <span class=\"n\">strings</span> <span class=\"n\">are</span> <span class=\"n\">currently</span> <span class=\"n\">recognized</span> <span class=\"k\">for</span> <span class=\"n\">the</span> <span class=\"n\">following</span> <span class=\"n\">supported</span> <span class=\"n\">materials</span><span class=\"p\">:</span>\n   <span class=\"o\">*</span> <span class=\"s1\">'Air'</span> <span class=\"o\">-</span> <span class=\"n\">keyword</span> <span class=\"k\">for</span> <span class=\"n\">Air</span>\n   <span class=\"o\">*</span> <span class=\"s1\">'SiO2'</span> <span class=\"o\">-</span> <span class=\"n\">keyword</span> <span class=\"k\">for</span> <span class=\"n\">Glass</span>\n   <span class=\"o\">*</span> <span class=\"s1\">'HfO2'</span> <span class=\"o\">-</span> <span class=\"n\">keyword</span> <span class=\"k\">for</span> <span class=\"n\">Hafnium</span> <span class=\"n\">Oxide</span>\n   <span class=\"o\">*</span> <span class=\"s1\">'Al2O3'</span> <span class=\"o\">-</span> <span class=\"n\">keyword</span> <span class=\"k\">for</span> <span class=\"n\">Aluminum</span> <span class=\"n\">Oxide</span>\n   <span class=\"o\">*</span> <span class=\"s1\">'TiO2'</span> <span class=\"o\">-</span> <span class=\"n\">keyword</span> <span class=\"k\">for</span> <span class=\"n\">Titanium</span> <span class=\"n\">Oxide</span>\n   <span class=\"o\">*</span> <span class=\"s1\">'AlN'</span>  <span class=\"o\">-</span> <span class=\"n\">keyword</span> <span class=\"k\">for</span> <span class=\"n\">Aluminum</span> <span class=\"n\">Nitride</span>\n   <span class=\"o\">*</span> <span class=\"s1\">'TiN'</span> <span class=\"o\">-</span> <span class=\"n\">keyword</span> <span class=\"k\">for</span> <span class=\"n\">Titanium</span> <span class=\"n\">Nitride</span>\n   <span class=\"o\">*</span> <span class=\"s1\">'Ag'</span> <span class=\"o\">-</span> <span class=\"n\">keyword</span> <span class=\"k\">for</span> <span class=\"n\">Silver</span>\n   <span class=\"o\">*</span> <span class=\"s1\">'Au'</span> <span class=\"o\">-</span> <span class=\"n\">keyword</span> <span class=\"k\">for</span> <span class=\"n\">Gold</span>\n   <span class=\"o\">*</span> <span class=\"s1\">'Pd'</span> <span class=\"o\">-</span> <span class=\"n\">keyword</span> <span class=\"k\">for</span> <span class=\"n\">Palladium</span>\n   <span class=\"o\">*</span> <span class=\"s1\">'Pt'</span> <span class=\"o\">-</span> <span class=\"n\">keyword</span> <span class=\"k\">for</span> <span class=\"n\">Platinum</span>\n   <span class=\"o\">*</span> <span class=\"s1\">'W'</span> <span class=\"o\">-</span> <span class=\"n\">keyword</span> <span class=\"k\">for</span> <span class=\"n\">Tungsten</span>\n\n<span class=\"s1\">'Temperature'</span>  <span class=\"c1\"># a float specifying the temperature of the multi-layer structure in Kelvin.  (Default is 300 K)</span>\n\n<span class=\"s1\">'PV_Temperature'</span> <span class=\"c1\"># a float specifying the temperature of a PV cell in a (S)TPV device in Kelvin.  (Default is 300 K).</span>\n\n<span class=\"s1\">'Ambient_Temperature'</span> <span class=\"c1\"># a float specifying the ambient temperature in Kelvin for radiative cooling applications. (Default is 300 K).</span>\n\n<span class=\"s1\">'STPV_EMIT'</span> <span class=\"c1\"># an int where '1' means compute properties associated with (S)TPV emitters. (Default is 0, do not compute these quantities).</span>\n\n<span class=\"s1\">'STPV_ABS'</span> <span class=\"c1\"># an int where '1' means compute properties associated with STPV/Concentrated Solar absorbers. (Default is 0).</span>\n\n<span class=\"s1\">'COOLING'</span> <span class=\"c1\"># an int where '1' means compute properties associated with radiative cooling. (Default is 0).</span>\n\n<span class=\"s1\">'LIGHTBULB'</span> <span class=\"c1\"># an int where '1' means compute properties associated with incandescent sources. (Default is 0).</span>\n\n<span class=\"s1\">'COLOR'</span> <span class=\"c1\"># an int where '1' means compute and display the ambient and thermal color of a structure. (Default is 0).</span>\n\n<span class=\"s1\">'EXPLICIT_ANGLE'</span> <span class=\"c1\"># an int where '1' means compute the optical properties and thermal emission at a range of angles and, when applicable, compute performance properties with explicit angular dependence.  (Default is 0, meaning most quantities will be computed assuming the emissivity does not depend upon angle.)</span>\n\n<span class=\"s1\">'DEG'</span> <span class=\"c1\"># an int that specifies the number of different angles that will be considered </span>\n<span class=\"ow\">in</span> <span class=\"n\">the</span> <span class=\"n\">calculation</span> <span class=\"n\">of</span> <span class=\"n\">optical</span> <span class=\"ow\">and</span> <span class=\"n\">thermal</span> <span class=\"n\">emission</span> <span class=\"n\">properties</span> <span class=\"k\">as</span> <span class=\"n\">a</span> <span class=\"n\">function</span> <span class=\"n\">of</span> <span class=\"n\">angle</span><span class=\"o\">.</span> <span class=\"p\">(</span><span class=\"n\">Default</span> <span class=\"ow\">is</span> <span class=\"mi\">7</span><span class=\"p\">,</span> <span class=\"n\">which</span> <span class=\"n\">has</span> <span class=\"n\">been</span> <span class=\"n\">observed</span> <span class=\"n\">to</span> <span class=\"n\">give</span> <span class=\"n\">reasonably</span> <span class=\"n\">good</span> <span class=\"n\">accuracy</span> <span class=\"n\">when</span> <span class=\"nb\">all</span> <span class=\"n\">angular</span> <span class=\"n\">integrals</span> <span class=\"n\">are</span> <span class=\"n\">performed</span> <span class=\"n\">using</span> <span class=\"n\">Gauss</span><span class=\"o\">-</span><span class=\"n\">Legendre</span> <span class=\"n\">quadrature</span><span class=\"p\">)</span><span class=\"o\">.</span>\n</pre>\n<p>{: .language-python}</p>\n<h2>Method and attribute list for multilayer class</h2>\n<p>Given the input parameters specified above, the <em>multilayer</em> class uses different methods to compute properties relevant for thermal applications, and those properties are stored as attributes\nof the <em>multilayer</em> object.  The following is a list of methods of the <em>multilayer</em> class and their related attributes:</p>\n<pre>\t<span class=\"k\">def</span> <span class=\"nf\">inline_structure</span><span class=\"p\">(</span><span class=\"n\">structure</span><span class=\"p\">):</span>\n       \t<span class=\"c1\">### a method to parse input parameters from a dictionary (here called structure, all currently-supported dictionary </span>\n       \t<span class=\"c1\">### keys are defined above.  This method is called by the __init__ and defines the following attributes:</span>\n\n\t<span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">lambda_array</span> \t<span class=\"c1\"># the list of wavelengths in meters that will be used to evaluate optical and thermal spectra</span>\n\t<span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">d</span>\t\t  \t<span class=\"c1\"># the list of thicknesses that define the geometry of the multilayer</span>\n\t<span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">matlist</span>      \t<span class=\"c1\"># the list of strings that specify the materials</span>\n\t<span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">n</span>\t\t  \t<span class=\"c1\"># the 2D arrays of refractive index values for each material for each wavelength (inner index specifies material, outter index wavelength)</span>\n\t<span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">T_ml</span>         \t<span class=\"c1\"># the temperature of the multi-layer in Kelvin</span>\n\t<span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">T_cell</span>       \t<span class=\"c1\"># the temperature of the PV cell in Kelvin</span>\n\t<span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">T_amb</span>      \t<span class=\"c1\"># the ambient temperature in Kelvin</span>\n\t<span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">stpv_emitter_calc</span>  <span class=\"c1\"># the flag that determines if (S)TPV emitter properties will be computed</span>\n\t<span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">stpv_absorber_calc</span> <span class=\"c1\"># the flag that determines if (S)TPV absorber properties will be computed</span>\n\t<span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">cooling_calc</span>    \t<span class=\"c1\"># the flag that determines if radiative cooling properties will be computed</span>\n\t<span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">lightbulb_calc</span>     <span class=\"c1\"># the flag that determines if incandescent properties will be computed</span>\n\t<span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">color_calc</span> \t<span class=\"c1\"># the flag that determines if colors will be rendered</span>\n\t<span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">explicit_angle</span> \t<span class=\"c1\"># the flag that determines if explicit angle-dependence of optical properties will be considered</span>\n\t<span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">deg</span>\t\t<span class=\"c1\"># the number of different angles that will be computed for angle-dependent optical properties</span>\n</pre>\n<p>{: .language-python}\nIn addition to the attributes that are explicitly set by parsing user input, several more attributes that are arrays will be\nallocated based on attributes defined by inline_structure:</p>\n<pre>\t<span class=\"c1\">### The following are always created</span>\n\t<span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">reflectivity_array</span> \t<span class=\"c1\"># initialized as an array of zeros the same length as self.lambda_array</span>\n\t<span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">transmissivity_array</span>\t<span class=\"c1\"># initialized as an array of zeros the same length as self.lambda_array</span>\n\t<span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">emissivity_array</span>\t\t<span class=\"c1\"># initialized as an array of zeros the same length as self.lambda_array</span>\n\t<span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">thermal_emission_array</span>\t<span class=\"c1\"># initialized as an array of zeros the same length as self.lambda_array</span>\n\n\t<span class=\"c1\">### The following are created if self.explicit_angle == 1</span>\n\t<span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">x</span>\t\t\t\t<span class=\"c1\"># points from Gauss-Legendre grid of degree self.deg from 0 to 1</span>\n\t<span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">t</span>\t\t\t\t<span class=\"c1\"># self.deg angles on Gauss-Legendre grid transformed to be between 0 and pi/2</span>\n\t<span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">w</span>\t\t\t\t<span class=\"c1\"># self.deg weights from Gauss-Legendre grid transformed to be between 0 and pi/2</span>\n\n\t<span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">reflectivity_array_p</span>       <span class=\"c1\"># initialized as a 2D array of zeros, inner dimension same as self.deg and outter same as self.lambda_array</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">reflectivity_array_s</span>       <span class=\"c1\"># initialized as a 2D array of zeros, inner dimension same as self.deg and outter same as self.lambda_array</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">transmissivity_array_p</span>     <span class=\"c1\"># initialized as a 2D array of zeros, inner dimension same as self.deg and outter same as self.lambda_array</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">transmissivity_array_s</span>     <span class=\"c1\"># initialized as a 2D array of zeros, inner dimension same as self.deg and outter same as self.lambda_array</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">emissivity_array_p</span>         <span class=\"c1\"># initialized as a 2D array of zeros, inner dimension same as self.deg and outter same as self.lambda_array</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">emissivity_array_s</span>         <span class=\"c1\"># initialized as a 2D array of zeros, inner dimension same as self.deg and outter same as self.lambda_array</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">thermal_emission_array_p</span>   <span class=\"c1\"># initialized as a 2D array of zeros, inner dimension same as self.deg and outter same as self.lambda_array</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">thermal_emission_array_s</span>   <span class=\"c1\"># initialized as a 2D array of zeros, inner dimension same as self.deg and outter same as self.lambda_array</span>\n</pre>\n<p>{: .language-python}</p>\n<pre><span class=\"sd\">''' Method to compute optical properties of reflectivity, transmissivity, and </span>\n<span class=\"sd\">emissivity of structure as a function of wavelength assuming normal incidence '''</span>\n<span class=\"k\">def</span> <span class=\"nf\">fresnel</span><span class=\"p\">()</span>\n\n<span class=\"c1\">### Upon execution, the following arrays are filled with their respective values</span>\n<span class=\"c1\">### for every wavelength in self.lambda_array</span>\n<span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">reflectivity_array</span>\n<span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">transmissivity_array</span>\n<span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">emissivity_array</span>\n</pre>\n<p>{: .language-python}</p>\n<pre><span class=\"sd\">''' Method to compute optical properties of reflectivity, transmissivity, and </span>\n<span class=\"sd\">emissivity of structure as a function of wavelength and angle, both p- and s-polarizations</span>\n<span class=\"sd\">are considered '''</span>\n<span class=\"k\">def</span> <span class=\"nf\">fresnel_ea</span><span class=\"p\">()</span>\n\n<span class=\"c1\">### Upon execution, the following arrays are filled with their respective values</span>\n<span class=\"c1\">### for every wavelength in self.lambda_array and every angle in self.t</span>\n<span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">reflectivity_array_p</span>\n<span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">reflectivity_array_s</span>\n<span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">transmissivity_array_p</span>\n<span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">transmissivity_array_s</span>\n<span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">emissivity_array_p</span>\n<span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">emissivity_array_s</span>\n</pre>\n<p>{: .language-python}</p>\n<pre><span class=\"sd\">''' Method to compute thermal emission spectrum of a structure at a given temperature;</span>\n<span class=\"sd\">note temperature specified by self.T_ml '''</span>\n<span class=\"k\">def</span> <span class=\"nf\">thermal_emission</span><span class=\"p\">()</span>\n\n<span class=\"c1\">### Upon execution, the following arrays are computed for every wavelength in self.lambda_array</span>\n<span class=\"c1\">### for temperature given by self.T_ml</span>\n<span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">BBs</span>   <span class=\"c1\"># Blackbody spectrum</span>\n<span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">thermal_emission_array</span> <span class=\"c1\">## thermal emission of structure defined as Blackbody * emissivity</span>\n</pre>\n<p>{: .language-python}</p>\n<pre><span class=\"sd\">''' Method to compute thermal emission spectrum of a structure at a given temperature for a range of angles '''</span>\n<span class=\"k\">def</span> <span class=\"nf\">thermal_emission_ea</span><span class=\"p\">()</span>\n\n<span class=\"c1\">### Upon execution, the following arrays are computed for every wavelength in self.lambda_array</span>\n<span class=\"c1\">### and every angle in self.t for temperature given by self.T_ml</span>\n<span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">thermal_emission_array_p</span> <span class=\"c1\">## thermal emission of structure defined as Blackbody * p-polarized emissivity</span>\n<span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">thermal_emission_array_s</span> <span class=\"c1\">## thermal emission of structure defined as Blackbody * s-polarized emissivity</span>\n</pre>\n<p>{: .language-python}</p>\n<pre><span class=\"sd\">''' Method to compute optical properties of reflectivity, transmissivity, </span>\n<span class=\"sd\">and emissivity as a function of angle for a given polarization self.pol and wavelength lambda_0 '''</span>\n<span class=\"k\">def</span> <span class=\"nf\">angular_fresnel</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">lambda_0</span><span class=\"p\">)</span>\n\n<span class=\"c1\">### Upon execution, the following arrays are computed for 180 angles between 0 and pi/2</span>\n<span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">r_vs_theta</span> <span class=\"c1\"># reflectivity</span>\n<span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">t_vs_theta</span> <span class=\"c1\"># transmissivity</span>\n<span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">eps_vs_theta</span> <span class=\"c1\"># emissivity</span>\n</pre>\n<p>{: .language-python}</p>\n<pre><span class=\"sd\">''' The following three methods compute figures of merit relevant for STPV emitters for a given</span>\n<span class=\"sd\">    temperature self.T_ml, PV type self.PV and bandgap self.lbg, and PV temperature self.T_cell.</span>\n<span class=\"sd\">    These methods assume the emissivity does not change with angle, and perform an analytic</span>\n<span class=\"sd\">    integration over solid angles that make the computations much quicker, though also less realistic.'''</span>\n<span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">stpv_se</span><span class=\"p\">()</span> <span class=\"c1\"># compute the spectral efficiency and stores it in the attribute self.spectral_efficiency_val</span>\n<span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">stpv_pd</span><span class=\"p\">()</span> <span class=\"c1\"># computes the useful power density and stores it in the attribute self.power_density_val</span>\n<span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">stpv_etatpv</span><span class=\"p\">()</span> <span class=\"c1\"># computes the TPV emitter efficiency and stores it in the attribute self.tpv_efficiency_val</span>\n</pre>\n<p>{: .language-python}</p>\n<pre><span class=\"sd\">''' The following methods compute figures of merit relevant for STPV emitters for a given</span>\n<span class=\"sd\">    temperature self.T_ml, PV type self.PV and bandgap self.lbg, and PV temperature self.T_cell.</span>\n<span class=\"sd\">    These methods explicitly account for the angular dependence of the emissivity, making these calculations</span>\n<span class=\"sd\">    more realistic but also more time consuming. '''</span>\n<span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">stpv_se_ea</span><span class=\"p\">()</span> <span class=\"c1\"># compute the spectral efficiency and stores it in the attribute self.spectral_efficiency_val</span>\n<span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">stpv_pd_ea</span><span class=\"p\">()</span> <span class=\"c1\"># computes the useful power density and stores it in the attribute self.power_density_val</span>\n<span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">stpv_etatpv_ea</span><span class=\"p\">()</span> <span class=\"c1\"># computes the TPV emitter efficiency and stores it in the attribute self.tpv_efficiency_val</span>\n</pre>\n<p>{: .language-python}</p>\n<pre><span class=\"sd\">''' The following methods compute the absorber efficiency of a STPV or concentrated solar absorber at a </span>\n<span class=\"sd\">    given temperature self.T_ml '''</span>\n<span class=\"k\">def</span> <span class=\"nf\">stpv_etaabs_ea</span><span class=\"p\">()</span> <span class=\"c1\"># computes absorber efficiency and stores it in the attribute self.absorber_efficiency_val</span>\n</pre>\n<p>{: .language-python}</p>\n<pre><span class=\"sd\">''' method to render color of a structure from its thermal emission at a given temperature self.T_ml '''</span>\n<span class=\"k\">def</span> <span class=\"nf\">thermal_color</span><span class=\"p\">()</span>\n<span class=\"sd\">''' method to render color of a structure from its reflection spectrum '''</span>\n<span class=\"k\">def</span> <span class=\"nf\">ambient_color</span><span class=\"p\">()</span>\n<span class=\"sd\">''' method to render color in a +/- 5nm band around the wavelength lambda '''</span>\n<span class=\"k\">def</span> <span class=\"nf\">pure_color</span><span class=\"p\">(</span><span class=\"k\">lambda</span><span class=\"p\">)</span>\n</pre>\n<p>{: .language-python}</p>\n<pre><span class=\"sd\">''' Method to compute the luminous efficiency of a structure at temperature self.T_ml.</span>\n<span class=\"sd\">    Stores value to self.luminous_efficiency_val '''</span>\n<span class=\"k\">def</span> <span class=\"nf\">luminous_efficiency</span><span class=\"p\">()</span>\n\n<span class=\"sd\">''' Method to compute the radiative cooling power of a structure at temperature self.T_ml in ambient</span>\n<span class=\"sd\">    temperature self.T_amb while being illuminated by the AM1.5 spectrum.  Upon execution, the relevant</span>\n<span class=\"sd\">    values are stored to the attributes self.radiative_power_val (this is the flux that cools the structure),</span>\n<span class=\"sd\">    self.atmospheric_power_val (part of flux that warms the structure) and self.solar_power_val (part of the flux </span>\n<span class=\"sd\">    that warms the structure).'''</span>\n<span class=\"k\">def</span> <span class=\"nf\">cooling_power</span><span class=\"p\">()</span>\n\n\n<span class=\"sd\">''' Method  to add a layer to the structure; material of the layer to be added will be specified by 'material' argument</span>\n<span class=\"sd\">    and thickness of the layer will be specified by the 'thickness' argument.  The layer will be inserted after</span>\n<span class=\"sd\">    the 'layer_number' layer.  The method will also update spectral and performance quantities after the layer is</span>\n<span class=\"sd\">    added; the instance name will be preserved after execution, so this is like a mutation operation.'''</span>\n<span class=\"k\">def</span> <span class=\"nf\">insert_layer</span><span class=\"p\">(</span><span class=\"n\">layer_number</span><span class=\"p\">,</span> <span class=\"n\">material</span><span class=\"p\">,</span> <span class=\"n\">thickness</span><span class=\"p\">)</span>\n\n<span class=\"sd\">''' Method to extract the array of refractive index values associated with a specific layer; the method returns </span>\n<span class=\"sd\">    this array.  '''</span>\n<span class=\"k\">def</span> <span class=\"nf\">layer_ri</span><span class=\"p\">(</span><span class=\"n\">layer_number</span><span class=\"p\">)</span>\n\n<span class=\"sd\">''' Method to define the refractive index of an existing layer (specified by layer_number) as an alloy</span>\n<span class=\"sd\">    of material_1 and material_2 with a specified volume_fraction of material_1 in material_2 according</span>\n<span class=\"sd\">    to either the Maxwell-Garnett or the Bruggeman effective medium theory.  Using 'Bruggeman' as the</span>\n<span class=\"sd\">    argument for model will use Bruggeman's effective medium theory, while any other string will default</span>\n<span class=\"sd\">    to Maxwell-Garnett theory. Optical properties and performance figures are NOT updated upon execution of this method.'''</span>\n<span class=\"k\">def</span> <span class=\"nf\">layer_alloy</span><span class=\"p\">(</span><span class=\"n\">layer_number</span><span class=\"p\">,</span> <span class=\"n\">volume_fraction</span><span class=\"p\">,</span> <span class=\"n\">material_1</span><span class=\"p\">,</span> <span class=\"n\">material_2</span><span class=\"p\">,</span> <span class=\"n\">model</span><span class=\"p\">)</span>\n\n<span class=\"sd\">''' Method to define the refractive index of an existing layer (specified by layer number) as a single</span>\n<span class=\"sd\">    complex number (specified by refractive_index_value) for all wavelengths.  Optical properties and performance figures are NOT updated upon execution of this method.'''</span>\n<span class=\"k\">def</span> <span class=\"nf\">layer_static_ri</span><span class=\"p\">(</span><span class=\"n\">layer_number</span><span class=\"p\">,</span> <span class=\"n\">refractive_index_value</span><span class=\"p\">)</span>\n\n<span class=\"sd\">''' Method to compute complex wavevector magnitude associated with the surface plasmon polariton mode on a given multi-layer</span>\n<span class=\"sd\">    structure at a wavelength specified by the int wavelength_index, where self.lambda_array[wavelength_index] returns</span>\n<span class=\"sd\">    the wavelength you are interested in in meters.  Upon completion, the spp wavevector is stored in</span>\n<span class=\"sd\">    self.spp_resonance_val '''</span>\n<span class=\"k\">def</span> <span class=\"nf\">find_spp</span><span class=\"p\">(</span><span class=\"n\">wavelength_index</span><span class=\"p\">)</span>\n\n<span class=\"sd\">''' Method to compute complex wavevector magnitude associated with the perfectly absorbing mode on a given multi-layer</span>\n<span class=\"sd\">    structure at a wavelength specified by the int wavelength_index, where self.lambda_array[wavelength_index] returns</span>\n<span class=\"sd\">    the wavelength you are interested in in meters.  Upon completion, the pa wavevector is stored in</span>\n<span class=\"sd\">    self.pa_resonance_val '''</span>\n<span class=\"k\">def</span> <span class=\"nf\">find_pa</span><span class=\"p\">()</span>\n</pre>\n<p>{: .language-python}</p>\n<h2>Extending the multilayer class</h2>\n<p>The multilayer class should provide a convenient mechanism for extension of the package to include\nadditional applications (which might require different manipulations of the Fresnel\nquantities stored as the attributes self.reflectivity_array, self.emissivity_array,\nself.transmissivity_array, or the thermal emission stored as the attribute\nself.thermal_emission_array), or to include different classes of structures\n(non-planar structures, for example, where the same attributes self.reflectivity_array, etc.,\nwould be computed by a different method than the transfer matrix method).  The typical\nworkflow to extend the capabilities of the package could include</p>\n<ul>\n<li>Identifying any new properties that will be computed by the\nextension and adding appropriate attributes to the multilayer class</li>\n<li>Adding one or more functions to the libraries (stpvlib, etc.)\nthat manipulates the Fresnel and/or thermal emission quantites as\nrequired to compute the new desired property</li>\n<li>Adding one or more multilayer methods to call the new library functions\nand store the resulting data in new or existing multilayer attributes as appropriate.</li>\n</ul>\n\n          </div>"}, "last_serial": 6825274, "releases": {"1.0.0": [{"comment_text": "", "digests": {"md5": "5d15b03435d321d8bb005597cba6349a", "sha256": "404ef52f546dd87b498afd25df67234e3c53d128add01af3a615931538a16182"}, "downloads": -1, "filename": "wptherml-1.0.0-py3.7.egg", "has_sig": false, "md5_digest": "5d15b03435d321d8bb005597cba6349a", "packagetype": "bdist_egg", "python_version": "3.7", "requires_python": null, "size": 1098124, "upload_time": "2019-08-20T15:23:17", "upload_time_iso_8601": "2019-08-20T15:23:17.098511Z", "url": "https://files.pythonhosted.org/packages/85/de/244c7fd0b88fd3444424817b496a681d89ee7480a5e1f18a9675e508a106/wptherml-1.0.0-py3.7.egg", "yanked": false}, {"comment_text": "", "digests": {"md5": "e2d501e23b4320ea180e1141d5c3d4fa", "sha256": "042acd5ccc1482af6a7163be36cf19a635df344d226304ba78654e24e5a7b961"}, "downloads": -1, "filename": "wptherml-1.0.0-py3-none-any.whl", "has_sig": false, "md5_digest": "e2d501e23b4320ea180e1141d5c3d4fa", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 1085076, "upload_time": "2019-08-20T15:23:14", "upload_time_iso_8601": "2019-08-20T15:23:14.750805Z", "url": "https://files.pythonhosted.org/packages/20/2e/484f8af5ba3516407d226cdd2aec810aab905b947d2a4d49c933ae4932e9/wptherml-1.0.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "279f5e70ace4cebd79fd2693922cc9ec", "sha256": "e5296840be7037a903a448c5df9034001de9dbd625e714779b0e9368eb591e4d"}, "downloads": -1, "filename": "wptherml-1.0.0.tar.gz", "has_sig": false, "md5_digest": "279f5e70ace4cebd79fd2693922cc9ec", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 3263390, "upload_time": "2019-08-20T15:23:19", "upload_time_iso_8601": "2019-08-20T15:23:19.445297Z", "url": "https://files.pythonhosted.org/packages/48/f9/6d9fd4f40a32532d8f4a406efef3a6ecedda0078f147fa68e04dd14e9f4b/wptherml-1.0.0.tar.gz", "yanked": false}], "1.0.11b0": [{"comment_text": "", "digests": {"md5": "329c16ed4d7881ac091e74e78c2b8c1f", "sha256": "2f441b90e47c7c56a9cef577bde81871e6694498a41e21c2df5bf6d94acddc70"}, "downloads": -1, "filename": "wptherml-1.0.11b0-py3-none-any.whl", "has_sig": false, "md5_digest": "329c16ed4d7881ac091e74e78c2b8c1f", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 1423810, "upload_time": "2019-07-01T10:26:39", "upload_time_iso_8601": "2019-07-01T10:26:39.658696Z", "url": "https://files.pythonhosted.org/packages/7f/e9/f735b263c64674cbb41adcd89871385bd9274478b94fe1db4ae68546c3e0/wptherml-1.0.11b0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "df245d42f74e499270dae0b5b23099ff", "sha256": "3ca04e894914b211ff2ba98e875817ccbd52520d2e4c81b8cac53a4fe23b1b68"}, "downloads": -1, "filename": "wptherml-1.0.11b0.tar.gz", "has_sig": false, "md5_digest": "df245d42f74e499270dae0b5b23099ff", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 5780068, "upload_time": "2019-07-01T10:26:44", "upload_time_iso_8601": "2019-07-01T10:26:44.506001Z", "url": "https://files.pythonhosted.org/packages/0a/83/000089f1b77b8064d29858d497f1a73636480bb60cea4c8457201351134f/wptherml-1.0.11b0.tar.gz", "yanked": false}], "1.0.12b0": [{"comment_text": "", "digests": {"md5": "f939d603aa3d66382393877463c5ba53", "sha256": "eb7d5db06208ee4d472158964aa2968b2cfd0198c93d551ce9077f92db6d27b9"}, "downloads": -1, "filename": "wptherml-1.0.12b0-py3-none-any.whl", "has_sig": false, "md5_digest": "f939d603aa3d66382393877463c5ba53", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 1614282, "upload_time": "2019-07-05T13:34:46", "upload_time_iso_8601": "2019-07-05T13:34:46.160248Z", "url": "https://files.pythonhosted.org/packages/8a/e3/335e8229b8678f708cb0a273c92ab50c023f2b2dd55c0fbff73c94a60895/wptherml-1.0.12b0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "8bd962e4f35d396ac8cc720e2d86134b", "sha256": "6dcb41b550a466266cbb12da43183ad5005ab187bb193698f323c0af1e114d37"}, "downloads": -1, "filename": "wptherml-1.0.12b0.tar.gz", "has_sig": false, "md5_digest": "8bd962e4f35d396ac8cc720e2d86134b", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 3797783, "upload_time": "2019-07-05T13:34:50", "upload_time_iso_8601": "2019-07-05T13:34:50.294986Z", "url": "https://files.pythonhosted.org/packages/15/eb/cca635e561441b8398857a49fb48f3e01327963327ddb57a123e9f2c3369/wptherml-1.0.12b0.tar.gz", "yanked": false}], "1.0.13b0": [{"comment_text": "", "digests": {"md5": "6de59b93a7eb853a1fe25acc84b83700", "sha256": "e1458a3dc386a913598f11886582be968798851bc611dcfb9bccab6415c08c60"}, "downloads": -1, "filename": "wptherml-1.0.13b0-py3-none-any.whl", "has_sig": false, "md5_digest": "6de59b93a7eb853a1fe25acc84b83700", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 1085955, "upload_time": "2019-07-10T14:43:21", "upload_time_iso_8601": "2019-07-10T14:43:21.434863Z", "url": "https://files.pythonhosted.org/packages/9f/4b/af15ca52db105fdd285be3d404bd0fbf57988c022eddbaa24ebeb1586730/wptherml-1.0.13b0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "96abb63c0fc6d288a976d11a70730d92", "sha256": "c750a3898a07e5ce9a6945cce4f8d8a41ecdd08094a359f2c130bece9150a6b3"}, "downloads": -1, "filename": "wptherml-1.0.13b0.tar.gz", "has_sig": false, "md5_digest": "96abb63c0fc6d288a976d11a70730d92", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 3270990, "upload_time": "2019-07-10T14:43:41", "upload_time_iso_8601": "2019-07-10T14:43:41.250414Z", "url": "https://files.pythonhosted.org/packages/44/8c/aad53d6cdfda80a00974ae7d8b5fa0066f5ebe996c93f8489bbea729d75a/wptherml-1.0.13b0.tar.gz", "yanked": false}], "1.0.14b0": [{"comment_text": "", "digests": {"md5": "8ab003df1fe83466778ee6a9b2c51976", "sha256": "08e692a15c0707546480beb9a1598dfb8bb45c82609b9e3ea8c09427b978771f"}, "downloads": -1, "filename": "wptherml-1.0.14b0-py3-none-any.whl", "has_sig": false, "md5_digest": "8ab003df1fe83466778ee6a9b2c51976", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 1091778, "upload_time": "2019-08-03T16:39:39", "upload_time_iso_8601": "2019-08-03T16:39:39.411679Z", "url": "https://files.pythonhosted.org/packages/ab/c1/a781c6958ea28a24738c5612053cb168f6e575672ea9dfc7b927a69c6e8e/wptherml-1.0.14b0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "d81eb13a80dfc596d8dbdc62872601c0", "sha256": "778a4dd2ee4d155d31f68bead2789572ed14928f9aed19f039a1c12dbdc0b55e"}, "downloads": -1, "filename": "wptherml-1.0.14b0.tar.gz", "has_sig": false, "md5_digest": "d81eb13a80dfc596d8dbdc62872601c0", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 3271006, "upload_time": "2019-08-03T16:39:43", "upload_time_iso_8601": "2019-08-03T16:39:43.258993Z", "url": "https://files.pythonhosted.org/packages/d0/2d/3ed880777b7c827872108457619188f53c5de6dc6354933a1cdbb522a590/wptherml-1.0.14b0.tar.gz", "yanked": false}], "1.11b0": [{"comment_text": "", "digests": {"md5": "12a58b43a07402632037c4eb56791cbd", "sha256": "bcce9063d603501b6bfafe5d8f9c7d0f1a1302e77ecbb29684dcc381998f39cb"}, "downloads": -1, "filename": "wptherml-1.11b0-py3.7.egg", "has_sig": false, "md5_digest": "12a58b43a07402632037c4eb56791cbd", "packagetype": "bdist_egg", "python_version": "3.7", "requires_python": null, "size": 1151594, "upload_time": "2020-03-17T01:17:16", "upload_time_iso_8601": "2020-03-17T01:17:16.939410Z", "url": "https://files.pythonhosted.org/packages/79/0c/adeaa86564023881e5a13917d973b54b605917e1c2774cde94246c55bb95/wptherml-1.11b0-py3.7.egg", "yanked": false}, {"comment_text": "", "digests": {"md5": "9a9ac1d33e70ae3a8e643842aede45d0", "sha256": "43afba9dafe80aa59d9a5f5753a16391ee56b41b5cfc644a330fb9887a8325ed"}, "downloads": -1, "filename": "wptherml-1.11b0-py3-none-any.whl", "has_sig": false, "md5_digest": "9a9ac1d33e70ae3a8e643842aede45d0", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 1130914, "upload_time": "2020-03-17T01:17:15", "upload_time_iso_8601": "2020-03-17T01:17:15.238830Z", "url": "https://files.pythonhosted.org/packages/02/5e/3c5ce8b0a1b73523d9af18d08392631f58021e1f951f19a7753f3c7b5311/wptherml-1.11b0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "d75291dcca02bc56fbe735a8cae9c281", "sha256": "68d455000063cb4f7eb73c048eba7a2383e4e3564f4acc79c51f92a7dfb0a6ca"}, "downloads": -1, "filename": "wptherml-1.11b0.tar.gz", "has_sig": false, "md5_digest": "d75291dcca02bc56fbe735a8cae9c281", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 3439551, "upload_time": "2020-03-17T01:17:20", "upload_time_iso_8601": "2020-03-17T01:17:20.101630Z", "url": "https://files.pythonhosted.org/packages/bf/ec/ba33872fee5c32c15c5f59ea34710758fe7b79b36fca3d4f5d15face7aa5/wptherml-1.11b0.tar.gz", "yanked": false}], "1.1b0": [{"comment_text": "", "digests": {"md5": "5be94ed71a2603927138b67cb8d7e559", "sha256": "115902c82681fd3e73fdfcb2546fd6b000555b9a08c379dc03b5b1f1a76d9c1d"}, "downloads": -1, "filename": "wptherml-1.1b0-py2.7.egg", "has_sig": false, "md5_digest": "5be94ed71a2603927138b67cb8d7e559", "packagetype": "bdist_egg", "python_version": "2.7", "requires_python": null, "size": 1152454, "upload_time": "2020-03-16T21:47:12", "upload_time_iso_8601": "2020-03-16T21:47:12.473533Z", "url": "https://files.pythonhosted.org/packages/ed/67/2f4b548f54fa28abebd408d542a96243d9ba30fa46381e682474664e4fb8/wptherml-1.1b0-py2.7.egg", "yanked": false}, {"comment_text": "", "digests": {"md5": "77529339e3feb371be84e3f2d5ab8756", "sha256": "da29505dd3b9ff90482240d6cee790915d2947af4f24c8b919d80c8ee4009e97"}, "downloads": -1, "filename": "wptherml-1.1b0-py3-none-any.whl", "has_sig": false, "md5_digest": "77529339e3feb371be84e3f2d5ab8756", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 1131207, "upload_time": "2020-03-16T21:47:09", "upload_time_iso_8601": "2020-03-16T21:47:09.982309Z", "url": "https://files.pythonhosted.org/packages/17/38/fca738b5ae162da6f768a7507462ffcb8333a3c7a2184a0f2aa1e4566e58/wptherml-1.1b0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "3bc130e95cf60370258d3a6ee7171aff", "sha256": "c449139a0859733384edb4286f19834813ac60ddefbc3d4e7a5df15c9ccc7ab8"}, "downloads": -1, "filename": "wptherml-1.1b0.tar.gz", "has_sig": false, "md5_digest": "3bc130e95cf60370258d3a6ee7171aff", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 3440023, "upload_time": "2020-03-16T21:47:15", "upload_time_iso_8601": "2020-03-16T21:47:15.688039Z", "url": "https://files.pythonhosted.org/packages/7a/4c/bcf79c2ccfb207f73064c008f2e3a2d58a73975f5763508f0ccbd6442853/wptherml-1.1b0.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "5d15b03435d321d8bb005597cba6349a", "sha256": "404ef52f546dd87b498afd25df67234e3c53d128add01af3a615931538a16182"}, "downloads": -1, "filename": "wptherml-1.0.0-py3.7.egg", "has_sig": false, "md5_digest": "5d15b03435d321d8bb005597cba6349a", "packagetype": "bdist_egg", "python_version": "3.7", "requires_python": null, "size": 1098124, "upload_time": "2019-08-20T15:23:17", "upload_time_iso_8601": "2019-08-20T15:23:17.098511Z", "url": "https://files.pythonhosted.org/packages/85/de/244c7fd0b88fd3444424817b496a681d89ee7480a5e1f18a9675e508a106/wptherml-1.0.0-py3.7.egg", "yanked": false}, {"comment_text": "", "digests": {"md5": "e2d501e23b4320ea180e1141d5c3d4fa", "sha256": "042acd5ccc1482af6a7163be36cf19a635df344d226304ba78654e24e5a7b961"}, "downloads": -1, "filename": "wptherml-1.0.0-py3-none-any.whl", "has_sig": false, "md5_digest": "e2d501e23b4320ea180e1141d5c3d4fa", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 1085076, "upload_time": "2019-08-20T15:23:14", "upload_time_iso_8601": "2019-08-20T15:23:14.750805Z", "url": "https://files.pythonhosted.org/packages/20/2e/484f8af5ba3516407d226cdd2aec810aab905b947d2a4d49c933ae4932e9/wptherml-1.0.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "279f5e70ace4cebd79fd2693922cc9ec", "sha256": "e5296840be7037a903a448c5df9034001de9dbd625e714779b0e9368eb591e4d"}, "downloads": -1, "filename": "wptherml-1.0.0.tar.gz", "has_sig": false, "md5_digest": "279f5e70ace4cebd79fd2693922cc9ec", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 3263390, "upload_time": "2019-08-20T15:23:19", "upload_time_iso_8601": "2019-08-20T15:23:19.445297Z", "url": "https://files.pythonhosted.org/packages/48/f9/6d9fd4f40a32532d8f4a406efef3a6ecedda0078f147fa68e04dd14e9f4b/wptherml-1.0.0.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:27:31 2020"}