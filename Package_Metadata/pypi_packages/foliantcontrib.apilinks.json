{"info": {"author": "Daniil Minukhin", "author_email": "ddddsa@gmail.com", "bugtrack_url": null, "classifiers": ["Development Status :: 5 - Production/Stable", "Environment :: Console", "Intended Audience :: Developers", "License :: OSI Approved :: MIT License", "Operating System :: OS Independent", "Programming Language :: Python", "Topic :: Documentation", "Topic :: Utilities"], "description": "# apilinks Preprocessor for Foliant\n\nPreprocessor for replacing API *reference*s in markdown files with links to actual method description on the API documentation web-page.\n\n## Installation\n\n```shell\n$ pip install foliantcontrib.apilinks\n```\n\n## Quick Start\n\nSay, you have an API documentation hosted at the url http://example.com/api-docs\n\nOn this page you have HTML headings before each method description which look like this:\n\n```html\n<h2 id=\"get-user-authenticate\">GET user/authenticate</h2>\n```\n\nYou want references to these methods in your documentation to be replaced with the links to the actual method descriptions. Your references look like this:\n\n```\nTo authenticate user use API method `GET user/authenticate`.\n```\n\nNow all you need to do is add the apilinks preprocessor into your foliant.yml and state your API url in its options like this:\n\n```yaml\npreprocessors:\n    - apilinks:\n        API:\n            My-API:\n                url: http://example.com/api-docs\n```\n\nHere:\n\n- `API` is a required section;\n- `My-API` is a local name of your API. Right now it is not very important but will come in handy in the next example;\n- `url` is a string with full url to your API documentation web-page. It will be used to validate references and to construct a link to method.\n\nAfter foliant applies the preprocessor your document will be transformed into this:\n\n```\nTo authenticate user use API method [GET user/authenticate](http://example.com/api-docs/#get-user-authenticate).\n```\n\nNotice that preprocessor figured out the correct anchor `#get-user-authenticate` by himself. Now instead of plain name of the method you've got a link to the method description!\n\nOk, what if I have two different APIs: client API and admin API?\n\nNo problem, put both of them into your config:\n\n```yaml\npreprocessors:\n    - apilinks:\n        API:\n            Client-API:\n                url: http://example.com/client/api-docs\n            Admin-API:\n                url: http://example.com/admin/api-docs\n```\n\nNow this source:\n\n```\nTo authenticate user use API method `GET user/authenticate`.\nTo ban user from the website use admin API method `POST admin/ban_user/{user_id}`\n```\n\nWill be transformed by apilinks into this:\n\n```\nTo authenticate user use API method [GET user/authenticate](http://example.com/client/api-docs/#get-user-authenticate).\nTo ban user from the website use admin API method [POST admin/ban_user/{user_id}](http://example.com/admin/api-docs/#post-admin-ban_user-user_id)\n```\n\nNotice that apilinks determined that the first reference is from Client API, and the second one is from the Admin API. How is that possible? Easy: preprocessor parses each API url from the config and stores their methods before looking for references. When the time comes to process the references it already has a list of all methods to validate your reference and to determine which API link should be inserted.\n\nBut what if we have the same-named method in both of our APIs? In this case you will see a warning:\n\n```\nWARNING: GET /service/healthcheck is present in several APIs (Client-API, Admin-API). Please, use prefix. Skipping\n```\n\nIt suggests us to use prefix, and by that it means to prefix the reference by the local name of the API in config. Like that:\n\n```\nCheck status of the server through Client API: `Client-API: GET /service/healthcheck`\nDo the same through Admin API: `Admin-API: GET /service/healthcheck`\n```\n\nHere `Client-API: ` and `Admin-API: ` are prefixes. And they should be the same as your API names in the config.\n\nNow each reference will be replaced with the link to corresponding API web-page.\n\n***\n\napilinks is a highly customizable preprocessor. You can tune:\n\n- the format of the references;\n- the output string which will replace the reference;\n- the format of the headings in your API web-page;\n- and more!\n\nFor details look through the following sections.\n\nGlossary:\n\n- **reference** \u2014 reference to an API method in the source file. The one to be replaced with the link, e.g. `GET user/config`\n- **verb** \u2014 HTTP method, e.g. `GET`, `POST`, etc.\n- **command** \u2014 resource used to represent method on the API documentation webpage, e.g. `/service/healthcheck`.\n- **endpoint prefix** \u2014 A prefix from server root to the command. If the command is `/user/status` and full resource is `/api/v0/user/satus` then the endpoint-prefix should be stated `/api/v0`. In references you can use either full resource (`{endpoint_prefix}/{command}`) or just the command. apilinks will sort it out for you.\n- **output** \u2014 string, which will replace the *reference*.\n- **header** \u2014 HTML header on the API documentation web-page of the method description, e.g. `<h2 id=\"get-user-config\">GET user/config</h2>`\n- **anchor** \u2014 web-anchor leading to the specific *header* on the API documentation web-page, e.g. `#get-user-config`\n\n## How Does It Work?\n\nPreprocessor can work in *online* and *offline* modes.\n\n**In offline mode** it merely replaces *references* to API methods with links to their description. The references are catched by a regular expression. The link url is taken from config and the link *anchor* is generated from the reference automatically.\n\nYou can have several different APIs stated in the config. You can use prefixes to point out which API is being *reference*d. Prefixes format may be customized  in the configuration but by default you do it like this: `Client-API: GET user/name`. Here '*Client-API*' is a prefix.\n\nIf you don't use prefix in the *reference* preprocessor will suppose that you meant the default API, which is marked by `default` option in config. If none of them is marked \u2014 goes for the first in list.\n\n**In online mode** things are getting interesting. Preprocessor actually goes to each of the API web-pages, and collects all method **headers** (right now only `h2` headers are supported). Then it goes through your document's source: when it meets a *reference*, it looks through all the collected methods and replaces the reference with the correct link to it. If method is not found \u2014 preprocessor will show warning and leave the reference unchanged. Same will happen if there are several methods with this name in different APIs.\n\nPrefixes, explained before, are supported too.\n\n## Config\n\nTo enable the preprocessor, add `apilinks` to `preprocessors` section in the project config:\n\n```yaml\npreprocessors:\n  - apilinks\n```\n\nThe preprocessor has a lot of options. For your convenience the required options are marked *(required)*; and those options which are used in customization are marked *(optional)*. Most likely you will need just one or two of the latter.\n\n```yaml\npreprocessors:\n- apilinks:\n    targets:\n        - site\n    offline: False\n    trim_if_targets:\n        - pdf\n    prefix_to_ignore: Ignore\n    reference:\n        - regex: *ref_pattern\n          only_with_prefixes: false\n          only_defined_prefixes: true\n          output_template: '[{verb} {command}]({url})'\n          trim_template: '`{verb} {command}`'\n    API:\n        Client-API:\n            url: http://example.com/api/client\n            default: true\n            header_template: '{verb} {command}'\n        Admin-API:\n            url: http://example.com/api/client\n            header_template: '{command}'\n            endpoint-prefix: /api/v0\n```\n\n\n`prefix_to_ignore`\n:   *(optional)* A default prefix for ignoring references. If apilinks meets a reference with this prefix it leaves it unchanged. Default: `Ignore`\n\n`targets`\n:   *(optional)* List of supported targets for `foliant make` command. If target is not listed here \u2014 preprocessor won't be applied. If the list is empty \u2014 preprocessor will be applied for any target. Default: `[]`\n\n`offline`\n:   *(optional)* Option determining whether the preprocessor will work in *online* or *offline* mode. Details in the **How Does It Work?** and **Online and Offline Modes Comparison** sections. Default: `False`\n\n`trim_if_targets`\n:   *(optional)* List of targets for `foliant make` command for which the prefixes from all *references* in the text will be cut out. Default: `[]`\n\n> Only those references whose prefixes are defined in the `API` section (described below) are affected by this option. All references with unlisted prefixes will not be trimmed.\n\n`reference`\n:   *(optional)* A subsection for listing all the types of references you are going to catch in the text, and their properties. Options for this section are listed below.\n\n***\n\n**Reference options**\n`regex`\n:   *(optional)* regular expression used to catch *references* in the source. Look for details in the **Capturing References** section.\nDefault:\n\n```\n(?P<source>`((?P<prefix>[\\w-]+):\\s*)?(?P<verb>OPTIONS|GET|HEAD|POST|PUT|DELETE|TRACE|CONNECT|PATCH|LINK|UNLINK)\\s+(?P<command>\\S+)`)\n```\n\n`only_with_prefixes`\n:   *(optional)* if this is `true`, only *references* with prefix will be transformed. Ordinary links like `GET user/info` will be ignored. Default: `false`\n\n`only_defined_prefixes`\n:   *(optional)* if this is `true` all references whose prefix is not listed in the `API` section (described below) will be ignored, left unchanged. References without prefix are not affected by this option. Default: `false`.\n\n`output_template`\n:   *(optional)* A template string describing the *output* which will replace the *reference*. More info in the **Customizing Output** section. Default: `'[{verb} {command}]({url})'`\n\n`trim_template`\n:   *(optional)* Only for targets listed in `trim_if_targets` option. Tune this template if you want to customize how apilinks cuts out prefixes. The reference will be replaced with text based on this template. Default: ```'`{verb} {command}`'```\n\n***\n\n`API`\n:   *(required)* A subsection for listing all the APIs and their properties. Under this section there should be a separate subsection for each API. The section name represents the API name and, at the same time, the *prefix* used in the references. You need to add at least one API subsection for preprocessor to work.\n\n***\n\n**API properties**\n\n`url`\n:   *(required)* An API documentation web-page URL. It will be used to construct the full link to the method. In online mode it will also be parsed by preprocessor for validation.\n\n`default`\n:   *(optional)* Only for offline mode. Marker to define the default API. If several APIs are marked default, preprocessor will choose the first of them. If none is marked default \u2014 the first API in the list will be chosen. The value of this item should be `true`.\n\n`header_template`\n:   *(optional)* A template string describing the format of the headings in the API documentation web-page. Details in **parsing API web-page** section. Default: `'{verb} {command}'`\n\n`endpoint-prefix`\n:   *(optional)* The endpoint prefix from the server root to API methods. If is stated \u2014 apilinks can divide the command in the reference and search for it more accurately. Also you could use it in templates. More info coming soon. Default: `''`\n\n## Online and Offline Modes Comparison\n\nLet's study an example and look how the behavior of the preprocessor will change in online and offline modes.\n\nWe have three APIs described in the config:\n\n```yaml\npreprocessors:\n  - apilinks:\n      API:\n        Admin-API:\n            url: http://example.com/api/client\n        Client-API:\n            url: http://example.com/api/client\n            default: true\n            header_template: '{verb} {command}'\n        Remote-API:\n            url: https://remote.net/api-ref/\n            header_template: '{command}'\n```\n\nNow let's look at different examples of the text used in Markdown source and how it is going to be transformed in Offline and Online modes\n\n**Example 1**\nSource:\n\n```\nUnprefixed link which only exists in Remote API: `GET system/info`.\n```\n\nIn *Offline mode* preprocessor won't do any checks and just replace the reference with the link to default API from the config:\n\n```\nUnprefixed link which only exists in Remote API: [GET system/info](http://example.com/api/client/#get-system-info).\n```\n\nThis is certainly a wrong decision, but it is our fault, we sould have added the prefix to the reference.\n\nBut let's look what will happen in *Online mode*:\n\n```\nUnprefixed link which only exists in Remote API: [GET system/info](https://remote.net/api-ref/#system-info).\n```\n\nWithout any prefix the preprocessor determined that it should choose the Remote API to replace this reference because this method exists only on its page. The `default` option is just ignored in this mode.\n\nBy the way, notice how anchors differ in the two examples. For Remote API preprocessor used its header template to reconstruct the anchor, dropping the verb from it.\n\n**Example 2**\nSource:\n\n```\nUnprefixed link with misprint: `GET user/sttus`.\nThe link is incorrect, there's no such method in any of the APIs.\n```\n\nIn *Offline mode* preprocessor won't do any checks again. No magic, the reference will be replaced with the link to default API from the config:\n\n```\nUnprefixed link with misprint: [GET user/sttus](http://example.com/api/client/#get-user-sttus).\nThe link is incorrect, there's no such method in any of the APIs.\n```\n\nIn *Online mode* preprocessor won't be able to find the method during validation and the reference won't be replaced at all:\n\n```\nUnprefixed link with misprint: `GET user/sttus`.\nThe link is incorrect, there's no such method in any of the APIs.\n```\n\nDuring the Foliant project assembly you will see a warning message:\n\n```\nWARNING: Cannot find method GET user/sttus. Skipping\n```\n\n**Example 3**\nSource:\n\n```\nPrefixed link to the Admin API: `Admin-API: POST user/ban_forever`.\n```\n\nIn *Offline mode* preprocessor will notice the prefix and will be able to replace the reference with an appropriate link:\n\n```\nPrefixed link to the Admin API: [POST user/ban_forever](http://example.com/api/client/#post-user-ban_forever).\n```\n\nNotice that prefix disappeared from the text. If you wish it to stay there \u2014 edit the `output_template` option to something like this: `'{prefix}: {verb} {command}'`.\n\nIn *Online mode* the result will be exactly the same. Preprocessor will check the Admin-API methods, find there the referenced method and replace it in the text:\n\n```\nPrefixed link to the Admin API: [POST user/ban_forever](http://example.com/api/client/#post-user-ban_forever).\n```\n\n**Example 4**\n\n```\nPrefixed link to the Remote API with a misprint: `Remote-API: GET billling/info`.\nOh no, the method is incorrect again.\n```\n\nIn *Offline mode* preprocessor will perform no checks and just replace the reference with the link to Remote API:\n\n```\nPrefixed link to the Remote API with a misprint: [GET billling/info](https://remote.net/api-ref/#get-billling-info).\nOh no, the method is incorrect again.\n```\n\n*Online mode*, on the other hand, will make its homework. It will check whether the Remote API actually has the method *GET billling/info*. Finding out that it hasn't it will leave the reference unchanged:\n\n```\nPrefixed link to the Remote API with a misprint: `Remote-API: GET billling/info`.\nOh no, the method is incorrect again.\n```\n\n...and warn us with the message:\n\n```\nWARNING: Cannot find method GET billling/info in Remote-API. Skipping\n```\n\n**Example 5**\n\n```\nNow let's reference a method which is present in both Client and Admin APIs: `GET service/healthcheck`.\n```\n\nIn *Offline mode* preprocessor will just replace the reference with a link to default API:\n\n```\nNow let's reference a method which is present in both Client and Admin APIs: [GET service/healthcheck](http://example.com/api/client/#get-service-healthcheck).\n```\n\nBut in *Online mode* preprocessor will go through all API method lists. It will find several mentions of this exact method and, confused, won't replace the reference at all:\n\n```\nNow let's reference a method which is present in both Client and Admin APIs: `GET service/healthcheck`.\n```\n\nYou will also see a warning:\n\n```\nWARNING: GET /service/healthcheck is present in several APIs (Admin-API, Client-API). Please, use prefix. Skipping\n```\n\n## Capturing References\n\napilinks uses regular expressions to capture *references* to API methods in Markdown files.\n\nThe default reg-ex is as following:\n\n```re\n(?P<source>`((?P<prefix>[\\w-]+):\\s*)?(?P<verb>OPTIONS|GET|HEAD|POST|PUT|DELETE|TRACE|CONNECT|PATCH|LINK|UNLINK)\\s+(?P<command>\\S+)`)\n```\n\nThis expression accepts references like these:\n\n- `Client-API: GET user/info`\n- `UPDATE user/details`\n\n> Notice that default expression uses *Named Capturing Groups*. You would probably want to use all of them too if you are to redefine the expression. Though not all of them are required, see the table below.\n\nGroup | Required | Description\n----- | -------- | -----------\nsource | YES | The full original reference string\nprefix | NO | Prefix pointing to the name of the API from config\nverb | NO | HTTP verb as `GET`, `POST`, etc\ncommand | YES | the full method resource as it is stated in the API header (may include endpoint prefix)\n\nTo redefine the regular expression add an option `reg-regex` to the preprocessor config.\n\nFor example, if you want to capture ONLY references with prefixes you may use the following:\n\n```yaml\npreprocessors:\n  - apilinks:\n      reference:\n      - regex: '(?P<source>`((?P<prefix>[\\w-]+):\\s*)(?P<verb>POST|GET|PUT|UPDATE|DELETE)\\s+(?P<command>\\S+)`)'\n```\n\n> This example is for illustrative purposes only. You can achieve the same goal by just switching on the `only_with_prefixes` option.\n\nNow the references without prefix (`UPDATE user/details`) will be ignored.\n\n## Customizing Output\n\nYou can customize the *output*-string which will replace the *reference* string. To do that add a template into your config-file.\n\nA *template* is a string which may contain properties, surrounded by curly braces. These properties will be replaced with the values, and all the rest will remain unchanged.\n\nFor example, look at the default template:\n\n```yaml\npreprocessors:\n  - apilinks:\n    reference:\n      - output_template: '[{verb} {command}]({url})',\n```\n\n> Don't forget the single quotes around the template. This way we say to yaml engine that this is a string for it not to be confused with curly braces.\n\nWith the default template, the reference string will be replaced by something like that:\n\n```\n[GET user/info](http://example.com/api/#get-user-info)\n```\n\nIf you don't want references to be transfromed into links, use your own template. Properties you may use in the template:\n\nproperty | description | example\n-------- | ----------- | -------\nurl | Full url to the method description | `http://example.com/api/#get-user-info`\nsource | Full original reference string | \\``Client-API: GET user/info`\\`\nprefix | Prefix used in the reference | `Client-API`\nverb | HTTP verb used in the reference | `GET`\ncommand | API command being referenced with endpoint prefix removed | `user/info`\nendpoint_prefix | Endpoint prefix to the API (if `endpoint-prefix` option is filled in) | `/api/v0`\n\n## Parsing API Web-page\n\napilinks goes through the API web-page content and gathers all the methods which are described there.\n\nTo do this preprocessor scans each HTML `h2` tag and stores its `id` attribute (which is an *anchor* of the link to be constructed) and the contents of the tag (the *heading* itself).\n\nFor example in this link:\n\n```html\n<h2 id=\"get-user-info\">GET user/info</h2>\n```\n\nthe anchor would be `get-user-info` and the heading would be `GET user/info`.\n\nTo construct the link to the method description we will have to create the correct anchor for it. To create an anchor we would need to reconstruct the heading first. But the heading format may be arbitrary and that's why we need the `header_template` config option.\n\nThe `header_template` is a string which may contain properties, surrounded by curly braces. These properties will be replaced with the values, when preprocessor will attempt to reconstruct the heading. All the rest will remain unchanged.\n\nFor example, if your API headings look like this:\n\n```\n<h2 id=\"method-user-info-get\">Method user/info (GET)</h2>\n```\n\nYou should use the following option:\n\n```yaml\n...\nAPI:\n    Client-API:\n        header_template: 'Method {command} ({verb})'\n...\n```\n\n> Don't forget the single quotes around the template. This way we say to yaml engine that this is a string.\n\nIf your headers do not have a verb at all:\n\n```\n<h2 id=\"user-info\">user/info</h2>\n```\n\nYou should use the following option:\n\n```yaml\n...\nAPI:\n    Client-API:\n        header_template: '{command}'\n...\n```\n\nProperties you may use in the template:\n\nproperty | description | example\n-------- | ----------- | -------\nverb | HTTP verb used in the reference | `GET`\ncommand | API command being referenced | `user/info`\nendpoint_prefix | Endpoint prefix to the API (if `endpoint-prefix` option is filled in) | `/api/v0`\n\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/foliant-docs/foliantcontrib.apilinks", "keywords": "", "license": "MIT", "maintainer": "", "maintainer_email": "", "name": "foliantcontrib.apilinks", "package_url": "https://pypi.org/project/foliantcontrib.apilinks/", "platform": "any", "project_url": "https://pypi.org/project/foliantcontrib.apilinks/", "project_urls": {"Homepage": "https://github.com/foliant-docs/foliantcontrib.apilinks"}, "release_url": "https://pypi.org/project/foliantcontrib.apilinks/1.1.3/", "requires_dist": ["foliant (>=1.0.8)", "foliantcontrib.utils.combined-options", "lxml"], "requires_python": "", "summary": "Preprocessor for replacing references to API methods with links to their description.", "version": "1.1.3", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>apilinks Preprocessor for Foliant</h1>\n<p>Preprocessor for replacing API <em>reference</em>s in markdown files with links to actual method description on the API documentation web-page.</p>\n<h2>Installation</h2>\n<pre>$ pip install foliantcontrib.apilinks\n</pre>\n<h2>Quick Start</h2>\n<p>Say, you have an API documentation hosted at the url <a href=\"http://example.com/api-docs\" rel=\"nofollow\">http://example.com/api-docs</a></p>\n<p>On this page you have HTML headings before each method description which look like this:</p>\n<pre><span class=\"p\">&lt;</span><span class=\"nt\">h2</span> <span class=\"na\">id</span><span class=\"o\">=</span><span class=\"s\">\"get-user-authenticate\"</span><span class=\"p\">&gt;</span>GET user/authenticate<span class=\"p\">&lt;/</span><span class=\"nt\">h2</span><span class=\"p\">&gt;</span>\n</pre>\n<p>You want references to these methods in your documentation to be replaced with the links to the actual method descriptions. Your references look like this:</p>\n<pre><code>To authenticate user use API method `GET user/authenticate`.\n</code></pre>\n<p>Now all you need to do is add the apilinks preprocessor into your foliant.yml and state your API url in its options like this:</p>\n<pre><span class=\"nt\">preprocessors</span><span class=\"p\">:</span>\n    <span class=\"p p-Indicator\">-</span> <span class=\"nt\">apilinks</span><span class=\"p\">:</span>\n        <span class=\"nt\">API</span><span class=\"p\">:</span>\n            <span class=\"nt\">My-API</span><span class=\"p\">:</span>\n                <span class=\"nt\">url</span><span class=\"p\">:</span> <span class=\"l l-Scalar l-Scalar-Plain\">http://example.com/api-docs</span>\n</pre>\n<p>Here:</p>\n<ul>\n<li><code>API</code> is a required section;</li>\n<li><code>My-API</code> is a local name of your API. Right now it is not very important but will come in handy in the next example;</li>\n<li><code>url</code> is a string with full url to your API documentation web-page. It will be used to validate references and to construct a link to method.</li>\n</ul>\n<p>After foliant applies the preprocessor your document will be transformed into this:</p>\n<pre><code>To authenticate user use API method [GET user/authenticate](http://example.com/api-docs/#get-user-authenticate).\n</code></pre>\n<p>Notice that preprocessor figured out the correct anchor <code>#get-user-authenticate</code> by himself. Now instead of plain name of the method you've got a link to the method description!</p>\n<p>Ok, what if I have two different APIs: client API and admin API?</p>\n<p>No problem, put both of them into your config:</p>\n<pre><span class=\"nt\">preprocessors</span><span class=\"p\">:</span>\n    <span class=\"p p-Indicator\">-</span> <span class=\"nt\">apilinks</span><span class=\"p\">:</span>\n        <span class=\"nt\">API</span><span class=\"p\">:</span>\n            <span class=\"nt\">Client-API</span><span class=\"p\">:</span>\n                <span class=\"nt\">url</span><span class=\"p\">:</span> <span class=\"l l-Scalar l-Scalar-Plain\">http://example.com/client/api-docs</span>\n            <span class=\"nt\">Admin-API</span><span class=\"p\">:</span>\n                <span class=\"nt\">url</span><span class=\"p\">:</span> <span class=\"l l-Scalar l-Scalar-Plain\">http://example.com/admin/api-docs</span>\n</pre>\n<p>Now this source:</p>\n<pre><code>To authenticate user use API method `GET user/authenticate`.\nTo ban user from the website use admin API method `POST admin/ban_user/{user_id}`\n</code></pre>\n<p>Will be transformed by apilinks into this:</p>\n<pre><code>To authenticate user use API method [GET user/authenticate](http://example.com/client/api-docs/#get-user-authenticate).\nTo ban user from the website use admin API method [POST admin/ban_user/{user_id}](http://example.com/admin/api-docs/#post-admin-ban_user-user_id)\n</code></pre>\n<p>Notice that apilinks determined that the first reference is from Client API, and the second one is from the Admin API. How is that possible? Easy: preprocessor parses each API url from the config and stores their methods before looking for references. When the time comes to process the references it already has a list of all methods to validate your reference and to determine which API link should be inserted.</p>\n<p>But what if we have the same-named method in both of our APIs? In this case you will see a warning:</p>\n<pre><code>WARNING: GET /service/healthcheck is present in several APIs (Client-API, Admin-API). Please, use prefix. Skipping\n</code></pre>\n<p>It suggests us to use prefix, and by that it means to prefix the reference by the local name of the API in config. Like that:</p>\n<pre><code>Check status of the server through Client API: `Client-API: GET /service/healthcheck`\nDo the same through Admin API: `Admin-API: GET /service/healthcheck`\n</code></pre>\n<p>Here <code>Client-API:</code> and <code>Admin-API:</code> are prefixes. And they should be the same as your API names in the config.</p>\n<p>Now each reference will be replaced with the link to corresponding API web-page.</p>\n<hr>\n<p>apilinks is a highly customizable preprocessor. You can tune:</p>\n<ul>\n<li>the format of the references;</li>\n<li>the output string which will replace the reference;</li>\n<li>the format of the headings in your API web-page;</li>\n<li>and more!</li>\n</ul>\n<p>For details look through the following sections.</p>\n<p>Glossary:</p>\n<ul>\n<li><strong>reference</strong> \u2014 reference to an API method in the source file. The one to be replaced with the link, e.g. <code>GET user/config</code></li>\n<li><strong>verb</strong> \u2014 HTTP method, e.g. <code>GET</code>, <code>POST</code>, etc.</li>\n<li><strong>command</strong> \u2014 resource used to represent method on the API documentation webpage, e.g. <code>/service/healthcheck</code>.</li>\n<li><strong>endpoint prefix</strong> \u2014 A prefix from server root to the command. If the command is <code>/user/status</code> and full resource is <code>/api/v0/user/satus</code> then the endpoint-prefix should be stated <code>/api/v0</code>. In references you can use either full resource (<code>{endpoint_prefix}/{command}</code>) or just the command. apilinks will sort it out for you.</li>\n<li><strong>output</strong> \u2014 string, which will replace the <em>reference</em>.</li>\n<li><strong>header</strong> \u2014 HTML header on the API documentation web-page of the method description, e.g. <code>&lt;h2 id=\"get-user-config\"&gt;GET user/config&lt;/h2&gt;</code></li>\n<li><strong>anchor</strong> \u2014 web-anchor leading to the specific <em>header</em> on the API documentation web-page, e.g. <code>#get-user-config</code></li>\n</ul>\n<h2>How Does It Work?</h2>\n<p>Preprocessor can work in <em>online</em> and <em>offline</em> modes.</p>\n<p><strong>In offline mode</strong> it merely replaces <em>references</em> to API methods with links to their description. The references are catched by a regular expression. The link url is taken from config and the link <em>anchor</em> is generated from the reference automatically.</p>\n<p>You can have several different APIs stated in the config. You can use prefixes to point out which API is being <em>reference</em>d. Prefixes format may be customized  in the configuration but by default you do it like this: <code>Client-API: GET user/name</code>. Here '<em>Client-API</em>' is a prefix.</p>\n<p>If you don't use prefix in the <em>reference</em> preprocessor will suppose that you meant the default API, which is marked by <code>default</code> option in config. If none of them is marked \u2014 goes for the first in list.</p>\n<p><strong>In online mode</strong> things are getting interesting. Preprocessor actually goes to each of the API web-pages, and collects all method <strong>headers</strong> (right now only <code>h2</code> headers are supported). Then it goes through your document's source: when it meets a <em>reference</em>, it looks through all the collected methods and replaces the reference with the correct link to it. If method is not found \u2014 preprocessor will show warning and leave the reference unchanged. Same will happen if there are several methods with this name in different APIs.</p>\n<p>Prefixes, explained before, are supported too.</p>\n<h2>Config</h2>\n<p>To enable the preprocessor, add <code>apilinks</code> to <code>preprocessors</code> section in the project config:</p>\n<pre><span class=\"nt\">preprocessors</span><span class=\"p\">:</span>\n  <span class=\"p p-Indicator\">-</span> <span class=\"l l-Scalar l-Scalar-Plain\">apilinks</span>\n</pre>\n<p>The preprocessor has a lot of options. For your convenience the required options are marked <em>(required)</em>; and those options which are used in customization are marked <em>(optional)</em>. Most likely you will need just one or two of the latter.</p>\n<pre><span class=\"nt\">preprocessors</span><span class=\"p\">:</span>\n<span class=\"p p-Indicator\">-</span> <span class=\"nt\">apilinks</span><span class=\"p\">:</span>\n    <span class=\"nt\">targets</span><span class=\"p\">:</span>\n        <span class=\"p p-Indicator\">-</span> <span class=\"l l-Scalar l-Scalar-Plain\">site</span>\n    <span class=\"nt\">offline</span><span class=\"p\">:</span> <span class=\"l l-Scalar l-Scalar-Plain\">False</span>\n    <span class=\"nt\">trim_if_targets</span><span class=\"p\">:</span>\n        <span class=\"p p-Indicator\">-</span> <span class=\"l l-Scalar l-Scalar-Plain\">pdf</span>\n    <span class=\"nt\">prefix_to_ignore</span><span class=\"p\">:</span> <span class=\"l l-Scalar l-Scalar-Plain\">Ignore</span>\n    <span class=\"nt\">reference</span><span class=\"p\">:</span>\n        <span class=\"p p-Indicator\">-</span> <span class=\"nt\">regex</span><span class=\"p\">:</span> <span class=\"nv\">*ref_pattern</span>\n          <span class=\"nt\">only_with_prefixes</span><span class=\"p\">:</span> <span class=\"l l-Scalar l-Scalar-Plain\">false</span>\n          <span class=\"nt\">only_defined_prefixes</span><span class=\"p\">:</span> <span class=\"l l-Scalar l-Scalar-Plain\">true</span>\n          <span class=\"nt\">output_template</span><span class=\"p\">:</span> <span class=\"s\">'[{verb}</span><span class=\"nv\"> </span><span class=\"s\">{command}]({url})'</span>\n          <span class=\"nt\">trim_template</span><span class=\"p\">:</span> <span class=\"s\">'`{verb}</span><span class=\"nv\"> </span><span class=\"s\">{command}`'</span>\n    <span class=\"nt\">API</span><span class=\"p\">:</span>\n        <span class=\"nt\">Client-API</span><span class=\"p\">:</span>\n            <span class=\"nt\">url</span><span class=\"p\">:</span> <span class=\"l l-Scalar l-Scalar-Plain\">http://example.com/api/client</span>\n            <span class=\"nt\">default</span><span class=\"p\">:</span> <span class=\"l l-Scalar l-Scalar-Plain\">true</span>\n            <span class=\"nt\">header_template</span><span class=\"p\">:</span> <span class=\"s\">'{verb}</span><span class=\"nv\"> </span><span class=\"s\">{command}'</span>\n        <span class=\"nt\">Admin-API</span><span class=\"p\">:</span>\n            <span class=\"nt\">url</span><span class=\"p\">:</span> <span class=\"l l-Scalar l-Scalar-Plain\">http://example.com/api/client</span>\n            <span class=\"nt\">header_template</span><span class=\"p\">:</span> <span class=\"s\">'{command}'</span>\n            <span class=\"nt\">endpoint-prefix</span><span class=\"p\">:</span> <span class=\"l l-Scalar l-Scalar-Plain\">/api/v0</span>\n</pre>\n<p><code>prefix_to_ignore</code>\n:   <em>(optional)</em> A default prefix for ignoring references. If apilinks meets a reference with this prefix it leaves it unchanged. Default: <code>Ignore</code></p>\n<p><code>targets</code>\n:   <em>(optional)</em> List of supported targets for <code>foliant make</code> command. If target is not listed here \u2014 preprocessor won't be applied. If the list is empty \u2014 preprocessor will be applied for any target. Default: <code>[]</code></p>\n<p><code>offline</code>\n:   <em>(optional)</em> Option determining whether the preprocessor will work in <em>online</em> or <em>offline</em> mode. Details in the <strong>How Does It Work?</strong> and <strong>Online and Offline Modes Comparison</strong> sections. Default: <code>False</code></p>\n<p><code>trim_if_targets</code>\n:   <em>(optional)</em> List of targets for <code>foliant make</code> command for which the prefixes from all <em>references</em> in the text will be cut out. Default: <code>[]</code></p>\n<blockquote>\n<p>Only those references whose prefixes are defined in the <code>API</code> section (described below) are affected by this option. All references with unlisted prefixes will not be trimmed.</p>\n</blockquote>\n<p><code>reference</code>\n:   <em>(optional)</em> A subsection for listing all the types of references you are going to catch in the text, and their properties. Options for this section are listed below.</p>\n<hr>\n<p><strong>Reference options</strong>\n<code>regex</code>\n:   <em>(optional)</em> regular expression used to catch <em>references</em> in the source. Look for details in the <strong>Capturing References</strong> section.\nDefault:</p>\n<pre><code>(?P&lt;source&gt;`((?P&lt;prefix&gt;[\\w-]+):\\s*)?(?P&lt;verb&gt;OPTIONS|GET|HEAD|POST|PUT|DELETE|TRACE|CONNECT|PATCH|LINK|UNLINK)\\s+(?P&lt;command&gt;\\S+)`)\n</code></pre>\n<p><code>only_with_prefixes</code>\n:   <em>(optional)</em> if this is <code>true</code>, only <em>references</em> with prefix will be transformed. Ordinary links like <code>GET user/info</code> will be ignored. Default: <code>false</code></p>\n<p><code>only_defined_prefixes</code>\n:   <em>(optional)</em> if this is <code>true</code> all references whose prefix is not listed in the <code>API</code> section (described below) will be ignored, left unchanged. References without prefix are not affected by this option. Default: <code>false</code>.</p>\n<p><code>output_template</code>\n:   <em>(optional)</em> A template string describing the <em>output</em> which will replace the <em>reference</em>. More info in the <strong>Customizing Output</strong> section. Default: <code>'[{verb} {command}]({url})'</code></p>\n<p><code>trim_template</code>\n:   <em>(optional)</em> Only for targets listed in <code>trim_if_targets</code> option. Tune this template if you want to customize how apilinks cuts out prefixes. The reference will be replaced with text based on this template. Default: <code>'`{verb} {command}`'</code></p>\n<hr>\n<p><code>API</code>\n:   <em>(required)</em> A subsection for listing all the APIs and their properties. Under this section there should be a separate subsection for each API. The section name represents the API name and, at the same time, the <em>prefix</em> used in the references. You need to add at least one API subsection for preprocessor to work.</p>\n<hr>\n<p><strong>API properties</strong></p>\n<p><code>url</code>\n:   <em>(required)</em> An API documentation web-page URL. It will be used to construct the full link to the method. In online mode it will also be parsed by preprocessor for validation.</p>\n<p><code>default</code>\n:   <em>(optional)</em> Only for offline mode. Marker to define the default API. If several APIs are marked default, preprocessor will choose the first of them. If none is marked default \u2014 the first API in the list will be chosen. The value of this item should be <code>true</code>.</p>\n<p><code>header_template</code>\n:   <em>(optional)</em> A template string describing the format of the headings in the API documentation web-page. Details in <strong>parsing API web-page</strong> section. Default: <code>'{verb} {command}'</code></p>\n<p><code>endpoint-prefix</code>\n:   <em>(optional)</em> The endpoint prefix from the server root to API methods. If is stated \u2014 apilinks can divide the command in the reference and search for it more accurately. Also you could use it in templates. More info coming soon. Default: <code>''</code></p>\n<h2>Online and Offline Modes Comparison</h2>\n<p>Let's study an example and look how the behavior of the preprocessor will change in online and offline modes.</p>\n<p>We have three APIs described in the config:</p>\n<pre><span class=\"nt\">preprocessors</span><span class=\"p\">:</span>\n  <span class=\"p p-Indicator\">-</span> <span class=\"nt\">apilinks</span><span class=\"p\">:</span>\n      <span class=\"nt\">API</span><span class=\"p\">:</span>\n        <span class=\"nt\">Admin-API</span><span class=\"p\">:</span>\n            <span class=\"nt\">url</span><span class=\"p\">:</span> <span class=\"l l-Scalar l-Scalar-Plain\">http://example.com/api/client</span>\n        <span class=\"nt\">Client-API</span><span class=\"p\">:</span>\n            <span class=\"nt\">url</span><span class=\"p\">:</span> <span class=\"l l-Scalar l-Scalar-Plain\">http://example.com/api/client</span>\n            <span class=\"nt\">default</span><span class=\"p\">:</span> <span class=\"l l-Scalar l-Scalar-Plain\">true</span>\n            <span class=\"nt\">header_template</span><span class=\"p\">:</span> <span class=\"s\">'{verb}</span><span class=\"nv\"> </span><span class=\"s\">{command}'</span>\n        <span class=\"nt\">Remote-API</span><span class=\"p\">:</span>\n            <span class=\"nt\">url</span><span class=\"p\">:</span> <span class=\"l l-Scalar l-Scalar-Plain\">https://remote.net/api-ref/</span>\n            <span class=\"nt\">header_template</span><span class=\"p\">:</span> <span class=\"s\">'{command}'</span>\n</pre>\n<p>Now let's look at different examples of the text used in Markdown source and how it is going to be transformed in Offline and Online modes</p>\n<p><strong>Example 1</strong>\nSource:</p>\n<pre><code>Unprefixed link which only exists in Remote API: `GET system/info`.\n</code></pre>\n<p>In <em>Offline mode</em> preprocessor won't do any checks and just replace the reference with the link to default API from the config:</p>\n<pre><code>Unprefixed link which only exists in Remote API: [GET system/info](http://example.com/api/client/#get-system-info).\n</code></pre>\n<p>This is certainly a wrong decision, but it is our fault, we sould have added the prefix to the reference.</p>\n<p>But let's look what will happen in <em>Online mode</em>:</p>\n<pre><code>Unprefixed link which only exists in Remote API: [GET system/info](https://remote.net/api-ref/#system-info).\n</code></pre>\n<p>Without any prefix the preprocessor determined that it should choose the Remote API to replace this reference because this method exists only on its page. The <code>default</code> option is just ignored in this mode.</p>\n<p>By the way, notice how anchors differ in the two examples. For Remote API preprocessor used its header template to reconstruct the anchor, dropping the verb from it.</p>\n<p><strong>Example 2</strong>\nSource:</p>\n<pre><code>Unprefixed link with misprint: `GET user/sttus`.\nThe link is incorrect, there's no such method in any of the APIs.\n</code></pre>\n<p>In <em>Offline mode</em> preprocessor won't do any checks again. No magic, the reference will be replaced with the link to default API from the config:</p>\n<pre><code>Unprefixed link with misprint: [GET user/sttus](http://example.com/api/client/#get-user-sttus).\nThe link is incorrect, there's no such method in any of the APIs.\n</code></pre>\n<p>In <em>Online mode</em> preprocessor won't be able to find the method during validation and the reference won't be replaced at all:</p>\n<pre><code>Unprefixed link with misprint: `GET user/sttus`.\nThe link is incorrect, there's no such method in any of the APIs.\n</code></pre>\n<p>During the Foliant project assembly you will see a warning message:</p>\n<pre><code>WARNING: Cannot find method GET user/sttus. Skipping\n</code></pre>\n<p><strong>Example 3</strong>\nSource:</p>\n<pre><code>Prefixed link to the Admin API: `Admin-API: POST user/ban_forever`.\n</code></pre>\n<p>In <em>Offline mode</em> preprocessor will notice the prefix and will be able to replace the reference with an appropriate link:</p>\n<pre><code>Prefixed link to the Admin API: [POST user/ban_forever](http://example.com/api/client/#post-user-ban_forever).\n</code></pre>\n<p>Notice that prefix disappeared from the text. If you wish it to stay there \u2014 edit the <code>output_template</code> option to something like this: <code>'{prefix}: {verb} {command}'</code>.</p>\n<p>In <em>Online mode</em> the result will be exactly the same. Preprocessor will check the Admin-API methods, find there the referenced method and replace it in the text:</p>\n<pre><code>Prefixed link to the Admin API: [POST user/ban_forever](http://example.com/api/client/#post-user-ban_forever).\n</code></pre>\n<p><strong>Example 4</strong></p>\n<pre><code>Prefixed link to the Remote API with a misprint: `Remote-API: GET billling/info`.\nOh no, the method is incorrect again.\n</code></pre>\n<p>In <em>Offline mode</em> preprocessor will perform no checks and just replace the reference with the link to Remote API:</p>\n<pre><code>Prefixed link to the Remote API with a misprint: [GET billling/info](https://remote.net/api-ref/#get-billling-info).\nOh no, the method is incorrect again.\n</code></pre>\n<p><em>Online mode</em>, on the other hand, will make its homework. It will check whether the Remote API actually has the method <em>GET billling/info</em>. Finding out that it hasn't it will leave the reference unchanged:</p>\n<pre><code>Prefixed link to the Remote API with a misprint: `Remote-API: GET billling/info`.\nOh no, the method is incorrect again.\n</code></pre>\n<p>...and warn us with the message:</p>\n<pre><code>WARNING: Cannot find method GET billling/info in Remote-API. Skipping\n</code></pre>\n<p><strong>Example 5</strong></p>\n<pre><code>Now let's reference a method which is present in both Client and Admin APIs: `GET service/healthcheck`.\n</code></pre>\n<p>In <em>Offline mode</em> preprocessor will just replace the reference with a link to default API:</p>\n<pre><code>Now let's reference a method which is present in both Client and Admin APIs: [GET service/healthcheck](http://example.com/api/client/#get-service-healthcheck).\n</code></pre>\n<p>But in <em>Online mode</em> preprocessor will go through all API method lists. It will find several mentions of this exact method and, confused, won't replace the reference at all:</p>\n<pre><code>Now let's reference a method which is present in both Client and Admin APIs: `GET service/healthcheck`.\n</code></pre>\n<p>You will also see a warning:</p>\n<pre><code>WARNING: GET /service/healthcheck is present in several APIs (Admin-API, Client-API). Please, use prefix. Skipping\n</code></pre>\n<h2>Capturing References</h2>\n<p>apilinks uses regular expressions to capture <em>references</em> to API methods in Markdown files.</p>\n<p>The default reg-ex is as following:</p>\n<pre>(?P&lt;source&gt;`((?P&lt;prefix&gt;[\\w-]+):\\s*)?(?P&lt;verb&gt;OPTIONS|GET|HEAD|POST|PUT|DELETE|TRACE|CONNECT|PATCH|LINK|UNLINK)\\s+(?P&lt;command&gt;\\S+)`)\n</pre>\n<p>This expression accepts references like these:</p>\n<ul>\n<li><code>Client-API: GET user/info</code></li>\n<li><code>UPDATE user/details</code></li>\n</ul>\n<blockquote>\n<p>Notice that default expression uses <em>Named Capturing Groups</em>. You would probably want to use all of them too if you are to redefine the expression. Though not all of them are required, see the table below.</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Group</th>\n<th>Required</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>source</td>\n<td>YES</td>\n<td>The full original reference string</td>\n</tr>\n<tr>\n<td>prefix</td>\n<td>NO</td>\n<td>Prefix pointing to the name of the API from config</td>\n</tr>\n<tr>\n<td>verb</td>\n<td>NO</td>\n<td>HTTP verb as <code>GET</code>, <code>POST</code>, etc</td>\n</tr>\n<tr>\n<td>command</td>\n<td>YES</td>\n<td>the full method resource as it is stated in the API header (may include endpoint prefix)</td>\n</tr></tbody></table>\n<p>To redefine the regular expression add an option <code>reg-regex</code> to the preprocessor config.</p>\n<p>For example, if you want to capture ONLY references with prefixes you may use the following:</p>\n<pre><span class=\"nt\">preprocessors</span><span class=\"p\">:</span>\n  <span class=\"p p-Indicator\">-</span> <span class=\"nt\">apilinks</span><span class=\"p\">:</span>\n      <span class=\"nt\">reference</span><span class=\"p\">:</span>\n      <span class=\"p p-Indicator\">-</span> <span class=\"nt\">regex</span><span class=\"p\">:</span> <span class=\"s\">'(?P&lt;source&gt;`((?P&lt;prefix&gt;[\\w-]+):\\s*)(?P&lt;verb&gt;POST|GET|PUT|UPDATE|DELETE)\\s+(?P&lt;command&gt;\\S+)`)'</span>\n</pre>\n<blockquote>\n<p>This example is for illustrative purposes only. You can achieve the same goal by just switching on the <code>only_with_prefixes</code> option.</p>\n</blockquote>\n<p>Now the references without prefix (<code>UPDATE user/details</code>) will be ignored.</p>\n<h2>Customizing Output</h2>\n<p>You can customize the <em>output</em>-string which will replace the <em>reference</em> string. To do that add a template into your config-file.</p>\n<p>A <em>template</em> is a string which may contain properties, surrounded by curly braces. These properties will be replaced with the values, and all the rest will remain unchanged.</p>\n<p>For example, look at the default template:</p>\n<pre><span class=\"nt\">preprocessors</span><span class=\"p\">:</span>\n  <span class=\"p p-Indicator\">-</span> <span class=\"nt\">apilinks</span><span class=\"p\">:</span>\n    <span class=\"nt\">reference</span><span class=\"p\">:</span>\n      <span class=\"p p-Indicator\">-</span> <span class=\"nt\">output_template</span><span class=\"p\">:</span> <span class=\"s\">'[{verb}</span><span class=\"nv\"> </span><span class=\"s\">{command}]({url})'</span><span class=\"err\">,</span>\n</pre>\n<blockquote>\n<p>Don't forget the single quotes around the template. This way we say to yaml engine that this is a string for it not to be confused with curly braces.</p>\n</blockquote>\n<p>With the default template, the reference string will be replaced by something like that:</p>\n<pre><code>[GET user/info](http://example.com/api/#get-user-info)\n</code></pre>\n<p>If you don't want references to be transfromed into links, use your own template. Properties you may use in the template:</p>\n<table>\n<thead>\n<tr>\n<th>property</th>\n<th>description</th>\n<th>example</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>url</td>\n<td>Full url to the method description</td>\n<td><code>http://example.com/api/#get-user-info</code></td>\n</tr>\n<tr>\n<td>source</td>\n<td>Full original reference string</td>\n<td>`<code>Client-API: GET user/info</code>`</td>\n</tr>\n<tr>\n<td>prefix</td>\n<td>Prefix used in the reference</td>\n<td><code>Client-API</code></td>\n</tr>\n<tr>\n<td>verb</td>\n<td>HTTP verb used in the reference</td>\n<td><code>GET</code></td>\n</tr>\n<tr>\n<td>command</td>\n<td>API command being referenced with endpoint prefix removed</td>\n<td><code>user/info</code></td>\n</tr>\n<tr>\n<td>endpoint_prefix</td>\n<td>Endpoint prefix to the API (if <code>endpoint-prefix</code> option is filled in)</td>\n<td><code>/api/v0</code></td>\n</tr></tbody></table>\n<h2>Parsing API Web-page</h2>\n<p>apilinks goes through the API web-page content and gathers all the methods which are described there.</p>\n<p>To do this preprocessor scans each HTML <code>h2</code> tag and stores its <code>id</code> attribute (which is an <em>anchor</em> of the link to be constructed) and the contents of the tag (the <em>heading</em> itself).</p>\n<p>For example in this link:</p>\n<pre><span class=\"p\">&lt;</span><span class=\"nt\">h2</span> <span class=\"na\">id</span><span class=\"o\">=</span><span class=\"s\">\"get-user-info\"</span><span class=\"p\">&gt;</span>GET user/info<span class=\"p\">&lt;/</span><span class=\"nt\">h2</span><span class=\"p\">&gt;</span>\n</pre>\n<p>the anchor would be <code>get-user-info</code> and the heading would be <code>GET user/info</code>.</p>\n<p>To construct the link to the method description we will have to create the correct anchor for it. To create an anchor we would need to reconstruct the heading first. But the heading format may be arbitrary and that's why we need the <code>header_template</code> config option.</p>\n<p>The <code>header_template</code> is a string which may contain properties, surrounded by curly braces. These properties will be replaced with the values, when preprocessor will attempt to reconstruct the heading. All the rest will remain unchanged.</p>\n<p>For example, if your API headings look like this:</p>\n<pre><code>&lt;h2 id=\"method-user-info-get\"&gt;Method user/info (GET)&lt;/h2&gt;\n</code></pre>\n<p>You should use the following option:</p>\n<pre><span class=\"nn\">...</span>\n<span class=\"nt\">API</span><span class=\"p\">:</span>\n    <span class=\"nt\">Client-API</span><span class=\"p\">:</span>\n        <span class=\"nt\">header_template</span><span class=\"p\">:</span> <span class=\"s\">'Method</span><span class=\"nv\"> </span><span class=\"s\">{command}</span><span class=\"nv\"> </span><span class=\"s\">({verb})'</span>\n<span class=\"nn\">...</span>\n</pre>\n<blockquote>\n<p>Don't forget the single quotes around the template. This way we say to yaml engine that this is a string.</p>\n</blockquote>\n<p>If your headers do not have a verb at all:</p>\n<pre><code>&lt;h2 id=\"user-info\"&gt;user/info&lt;/h2&gt;\n</code></pre>\n<p>You should use the following option:</p>\n<pre><span class=\"nn\">...</span>\n<span class=\"nt\">API</span><span class=\"p\">:</span>\n    <span class=\"nt\">Client-API</span><span class=\"p\">:</span>\n        <span class=\"nt\">header_template</span><span class=\"p\">:</span> <span class=\"s\">'{command}'</span>\n<span class=\"nn\">...</span>\n</pre>\n<p>Properties you may use in the template:</p>\n<table>\n<thead>\n<tr>\n<th>property</th>\n<th>description</th>\n<th>example</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>verb</td>\n<td>HTTP verb used in the reference</td>\n<td><code>GET</code></td>\n</tr>\n<tr>\n<td>command</td>\n<td>API command being referenced</td>\n<td><code>user/info</code></td>\n</tr>\n<tr>\n<td>endpoint_prefix</td>\n<td>Endpoint prefix to the API (if <code>endpoint-prefix</code> option is filled in)</td>\n<td><code>/api/v0</code></td>\n</tr></tbody></table>\n\n          </div>"}, "last_serial": 5790264, "releases": {"1.0.0": [{"comment_text": "", "digests": {"md5": "670245aee5ceab3a5bf7993db2ac411a", "sha256": "d751bc4f1804b70fbbc6892dafaea408d6794ff627ebec0cd78b8acaf6c622f8"}, "downloads": -1, "filename": "foliantcontrib.apilinks-1.0.0-py3-none-any.whl", "has_sig": false, "md5_digest": "670245aee5ceab3a5bf7993db2ac411a", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 10431, "upload_time": "2018-11-29T07:40:30", "upload_time_iso_8601": "2018-11-29T07:40:30.546379Z", "url": "https://files.pythonhosted.org/packages/79/78/9e8c47115379dc47f51f273ad51d431070ba7a0cf51ade80a694365e166e/foliantcontrib.apilinks-1.0.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "595eaf680ef81399d08a0e893d5cb4f7", "sha256": "40fecfa1010e2bf0db6ef60c2ba837e6fed4dc2e44809011d9395199612e9668"}, "downloads": -1, "filename": "foliantcontrib.apilinks-1.0.0.tar.gz", "has_sig": false, "md5_digest": "595eaf680ef81399d08a0e893d5cb4f7", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 15752, "upload_time": "2018-11-29T07:40:32", "upload_time_iso_8601": "2018-11-29T07:40:32.682220Z", "url": "https://files.pythonhosted.org/packages/14/a0/cc262ba02a69845910fbf7b2eb0aca835e6fd2613afb0b29f4e748b63cd5/foliantcontrib.apilinks-1.0.0.tar.gz", "yanked": false}], "1.0.1": [{"comment_text": "", "digests": {"md5": "65137f1d208ebc3cfb5d29536c72cf40", "sha256": "ab0aaaa5f32fc82758d6a0a58713c485f67af1639b3860a04071eebfae12b6a1"}, "downloads": -1, "filename": "foliantcontrib.apilinks-1.0.1-py3-none-any.whl", "has_sig": false, "md5_digest": "65137f1d208ebc3cfb5d29536c72cf40", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 11422, "upload_time": "2018-11-29T10:21:05", "upload_time_iso_8601": "2018-11-29T10:21:05.196695Z", "url": "https://files.pythonhosted.org/packages/f9/7c/b318b5a47ba00aad3a7a7d84edc6ddffc29c02f9803e7855afe38a650783/foliantcontrib.apilinks-1.0.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "57ef19c7a0a19dd10aba5d8a138d2ab1", "sha256": "fd8f4ac5f110a88300e8b321ee58adf54af4421200e957f1ff7bba4cd0f60473"}, "downloads": -1, "filename": "foliantcontrib.apilinks-1.0.1.tar.gz", "has_sig": false, "md5_digest": "57ef19c7a0a19dd10aba5d8a138d2ab1", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 16035, "upload_time": "2018-11-29T10:21:06", "upload_time_iso_8601": "2018-11-29T10:21:06.798782Z", "url": "https://files.pythonhosted.org/packages/57/b8/b4debc72cb9be8d1c8387fe48d7ea3f84d06823ebdc2de99e427fe1fd667/foliantcontrib.apilinks-1.0.1.tar.gz", "yanked": false}], "1.0.2": [{"comment_text": "", "digests": {"md5": "f97d77a81fc6e6a4ec681039708ff27d", "sha256": "cdf4e8c1766ab7479727f456eb7ad52ee4c7ef8492c497b02000da425902d94d"}, "downloads": -1, "filename": "foliantcontrib.apilinks-1.0.2-py3-none-any.whl", "has_sig": false, "md5_digest": "f97d77a81fc6e6a4ec681039708ff27d", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 11747, "upload_time": "2018-11-29T13:03:48", "upload_time_iso_8601": "2018-11-29T13:03:48.134799Z", "url": "https://files.pythonhosted.org/packages/8e/b5/37d348fbb08f21ef2d0dc00a8741b7dd51706111c91bf12d1b8ad7f876d4/foliantcontrib.apilinks-1.0.2-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "08565b4fb17db8cf22bf610b1c5cdf5d", "sha256": "9f01bbdd99875583bd363364902e31c67fa1574cb5b8958784f65dc5606f93ee"}, "downloads": -1, "filename": "foliantcontrib.apilinks-1.0.2.tar.gz", "has_sig": false, "md5_digest": "08565b4fb17db8cf22bf610b1c5cdf5d", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 16650, "upload_time": "2018-11-29T13:03:49", "upload_time_iso_8601": "2018-11-29T13:03:49.674564Z", "url": "https://files.pythonhosted.org/packages/7f/50/5bc39334cea3e99c0d16707425308e5ec9937eef5fccc881c1f7f1b9b374/foliantcontrib.apilinks-1.0.2.tar.gz", "yanked": false}], "1.0.3": [{"comment_text": "", "digests": {"md5": "88d54901c2342c28ef1269de449da9bc", "sha256": "6b4b7d301a51dc8603caf11c0c5f62de2af3f0da7eb894967493701227db6ff4"}, "downloads": -1, "filename": "foliantcontrib.apilinks-1.0.3-py3-none-any.whl", "has_sig": false, "md5_digest": "88d54901c2342c28ef1269de449da9bc", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 11834, "upload_time": "2018-11-29T14:20:00", "upload_time_iso_8601": "2018-11-29T14:20:00.401764Z", "url": "https://files.pythonhosted.org/packages/a6/d8/207f0ba58cf21c82422973ecd7b43601c8190cdecd2af94d4148f8eac6c2/foliantcontrib.apilinks-1.0.3-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "843c04967c69c19606aee234714a37d6", "sha256": "64d3d7e903aa8dbd22897b4dfb2c616c05f6204df218475e2a46bcfb8260c898"}, "downloads": -1, "filename": "foliantcontrib.apilinks-1.0.3.tar.gz", "has_sig": false, "md5_digest": "843c04967c69c19606aee234714a37d6", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 16780, "upload_time": "2018-11-29T14:20:01", "upload_time_iso_8601": "2018-11-29T14:20:01.594579Z", "url": "https://files.pythonhosted.org/packages/91/e3/331fff77f4a119d7c96aa5d39eaef00772d2e2fafa27eb1f05454c0b1a01/foliantcontrib.apilinks-1.0.3.tar.gz", "yanked": false}], "1.0.4": [{"comment_text": "", "digests": {"md5": "bb2c23fa99b0cb2a4b06e4d9cad04d2b", "sha256": "030fdb99c0a70d38ac86b569fa0a0a611cd20bd927bb07e2293afc0882653f43"}, "downloads": -1, "filename": "foliantcontrib.apilinks-1.0.4-py3-none-any.whl", "has_sig": false, "md5_digest": "bb2c23fa99b0cb2a4b06e4d9cad04d2b", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 13735, "upload_time": "2018-12-03T13:58:23", "upload_time_iso_8601": "2018-12-03T13:58:23.841165Z", "url": "https://files.pythonhosted.org/packages/f0/26/a829b3bcc60c323e070353dbe95e8233ce5967479125cdb133ce86f691d8/foliantcontrib.apilinks-1.0.4-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "81164760f8a309b98a8881a8de2cfc42", "sha256": "2d660265167caf951b064df4b464a8ac0ff3ab7dd314dd52cd8ed067aa969358"}, "downloads": -1, "filename": "foliantcontrib.apilinks-1.0.4.tar.gz", "has_sig": false, "md5_digest": "81164760f8a309b98a8881a8de2cfc42", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 18289, "upload_time": "2018-12-03T13:58:25", "upload_time_iso_8601": "2018-12-03T13:58:25.691779Z", "url": "https://files.pythonhosted.org/packages/b8/2b/a9eab232a49d0e44ab5887bdbfa38c4df767f98440c0e7c4bfd9e4f563f6/foliantcontrib.apilinks-1.0.4.tar.gz", "yanked": false}], "1.0.5": [{"comment_text": "", "digests": {"md5": "d79d8ceff278fdd9798f3924ae272e7a", "sha256": "f093953018f20c28c6530430655f21d6d26d6fca5a1ccc6e4eff63d36b929371"}, "downloads": -1, "filename": "foliantcontrib.apilinks-1.0.5-py3-none-any.whl", "has_sig": false, "md5_digest": "d79d8ceff278fdd9798f3924ae272e7a", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 14093, "upload_time": "2018-12-04T12:11:33", "upload_time_iso_8601": "2018-12-04T12:11:33.197658Z", "url": "https://files.pythonhosted.org/packages/17/98/98f45a05e493c7b860e43b2b0c665b5bf8e539b3c3ade188038276d73dfe/foliantcontrib.apilinks-1.0.5-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "2507b6b9a5f662d4c8220f59f4357606", "sha256": "acfba10d9c066d2fa6dae9ea92db403b76b4056f300d3936048143d7064ac50c"}, "downloads": -1, "filename": "foliantcontrib.apilinks-1.0.5.tar.gz", "has_sig": false, "md5_digest": "2507b6b9a5f662d4c8220f59f4357606", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 18499, "upload_time": "2018-12-04T12:11:35", "upload_time_iso_8601": "2018-12-04T12:11:35.032478Z", "url": "https://files.pythonhosted.org/packages/12/e8/6a3e0971fb5bc27605e132af13954a6cd3ab6bc9a316a1cb9d36846603cf/foliantcontrib.apilinks-1.0.5.tar.gz", "yanked": false}], "1.1.0": [{"comment_text": "", "digests": {"md5": "3abfc72314fa671979005f285d99b1d7", "sha256": "59a08d872f936ef62431f24a974d4636edd85f694a6292f1e317cbbe0d7a368a"}, "downloads": -1, "filename": "foliantcontrib.apilinks-1.1.0-py3-none-any.whl", "has_sig": false, "md5_digest": "3abfc72314fa671979005f285d99b1d7", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 16217, "upload_time": "2018-12-13T09:35:56", "upload_time_iso_8601": "2018-12-13T09:35:56.463462Z", "url": "https://files.pythonhosted.org/packages/27/81/96c4dee7eec78b8ead5fa120a753bacd946529606f5350a79d09624c580a/foliantcontrib.apilinks-1.1.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "307fdb274449eaea1fe1e0fbd233bff7", "sha256": "2076ee6428f9295e6653283297f6cee16c66dee4b813d46ec5757d243f7edca9"}, "downloads": -1, "filename": "foliantcontrib.apilinks-1.1.0.tar.gz", "has_sig": false, "md5_digest": "307fdb274449eaea1fe1e0fbd233bff7", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 20479, "upload_time": "2018-12-13T09:35:58", "upload_time_iso_8601": "2018-12-13T09:35:58.158648Z", "url": "https://files.pythonhosted.org/packages/3b/6d/92c5c24d41a60d5be943e788f45c3953e2c1ca14a9f1a5d96777a5477cdc/foliantcontrib.apilinks-1.1.0.tar.gz", "yanked": false}], "1.1.1": [{"comment_text": "", "digests": {"md5": "8cff9ce1acda5a7b2baedab95141c350", "sha256": "1fde87252791fe1caa455930ac2d4938606fe8c053ae0dc0df5acc16dac559fd"}, "downloads": -1, "filename": "foliantcontrib.apilinks-1.1.1-py3-none-any.whl", "has_sig": false, "md5_digest": "8cff9ce1acda5a7b2baedab95141c350", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 16265, "upload_time": "2019-01-21T11:34:03", "upload_time_iso_8601": "2019-01-21T11:34:03.834707Z", "url": "https://files.pythonhosted.org/packages/47/20/31fe66c850ffd1a987766c34867eef02687a82bc0e636a9d01ec77555149/foliantcontrib.apilinks-1.1.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "7e27e654740e013eb7e595cb5044318b", "sha256": "f7f9c21b65c4813543df79205a2a95ef849430171194cd12e0839bdac43eb1ba"}, "downloads": -1, "filename": "foliantcontrib.apilinks-1.1.1.tar.gz", "has_sig": false, "md5_digest": "7e27e654740e013eb7e595cb5044318b", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 20529, "upload_time": "2019-01-21T11:34:05", "upload_time_iso_8601": "2019-01-21T11:34:05.560542Z", "url": "https://files.pythonhosted.org/packages/01/fd/966bc00622676a64d14344bf7eb55aa8d1d5e2a520e36cec00e9062d927c/foliantcontrib.apilinks-1.1.1.tar.gz", "yanked": false}], "1.1.3": [{"comment_text": "", "digests": {"md5": "74a94ca81d2e8dd7b0f39b4ec3598185", "sha256": "5097e67ae451acc58fbb533b9d5e3d7404b58db719eab8c737325604c1486765"}, "downloads": -1, "filename": "foliantcontrib.apilinks-1.1.3-py3-none-any.whl", "has_sig": false, "md5_digest": "74a94ca81d2e8dd7b0f39b4ec3598185", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 14751, "upload_time": "2019-02-14T11:07:31", "upload_time_iso_8601": "2019-02-14T11:07:31.803350Z", "url": "https://files.pythonhosted.org/packages/a6/f9/753958e522091e598b8bdf79dd8ace67e77d08455c12f467897a5748c734/foliantcontrib.apilinks-1.1.3-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "37d2ec3040697fc986271d7c8c400541", "sha256": "c9e0e2fc0ecc70674e2ca93215895ec16ed2122f7b5107e7ad807ce73f355132"}, "downloads": -1, "filename": "foliantcontrib.apilinks-1.1.3.tar.gz", "has_sig": false, "md5_digest": "37d2ec3040697fc986271d7c8c400541", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 19414, "upload_time": "2019-02-14T11:07:33", "upload_time_iso_8601": "2019-02-14T11:07:33.273526Z", "url": "https://files.pythonhosted.org/packages/5b/93/dd016847c70f9677f34404724a177c9babf98dd28a5edab1999087d5ed12/foliantcontrib.apilinks-1.1.3.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "74a94ca81d2e8dd7b0f39b4ec3598185", "sha256": "5097e67ae451acc58fbb533b9d5e3d7404b58db719eab8c737325604c1486765"}, "downloads": -1, "filename": "foliantcontrib.apilinks-1.1.3-py3-none-any.whl", "has_sig": false, "md5_digest": "74a94ca81d2e8dd7b0f39b4ec3598185", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 14751, "upload_time": "2019-02-14T11:07:31", "upload_time_iso_8601": "2019-02-14T11:07:31.803350Z", "url": "https://files.pythonhosted.org/packages/a6/f9/753958e522091e598b8bdf79dd8ace67e77d08455c12f467897a5748c734/foliantcontrib.apilinks-1.1.3-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "37d2ec3040697fc986271d7c8c400541", "sha256": "c9e0e2fc0ecc70674e2ca93215895ec16ed2122f7b5107e7ad807ce73f355132"}, "downloads": -1, "filename": "foliantcontrib.apilinks-1.1.3.tar.gz", "has_sig": false, "md5_digest": "37d2ec3040697fc986271d7c8c400541", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 19414, "upload_time": "2019-02-14T11:07:33", "upload_time_iso_8601": "2019-02-14T11:07:33.273526Z", "url": "https://files.pythonhosted.org/packages/5b/93/dd016847c70f9677f34404724a177c9babf98dd28a5edab1999087d5ed12/foliantcontrib.apilinks-1.1.3.tar.gz", "yanked": false}], "timestamp": "Fri May  8 01:01:10 2020"}