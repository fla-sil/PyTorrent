{"info": {"author": "Jon Nylander", "author_email": "pellepim@gmail.com", "bugtrack_url": null, "classifiers": ["License :: OSI Approved :: MIT License", "Operating System :: OS Independent", "Programming Language :: Python :: 3"], "description": "[![CircleCI](https://circleci.com/gh/pellepim/turoboro.svg?style=shield)](https://circleci.com/gh/pellepim/turoboro)\n\n# turoboro\nA python library for specifying recurring time rules and getting timestamps in return.\n\nTypical usage would be to articulate the behaviour of recurring rules and to get exact points\nin time where those rules ought to be executed.\n\nI.e this library answers the following questions: \n\nGiven a recurring rule,\n\n1. when is the next time it happens?\n2. when are all of the times it happens?\n3. when are `n` times it happens?\n\nSay for example you want to find out at what specific UTC time the rule \"every thursday of every\nthird week of every second month at 8 o'clock UTC\" would happen.\n\nAsk turoboro! \n\nHowever, this is very much work in progress. So... basically don't use this library yet.\n\n# Installation\n\n    $ pip install turoboro\n    \n# Usage\n\nturoboro allows you to set up recurring rules of three main times:\n\n1. With an end-date, or\n2. that end after a certain number of occurrences, or\n3. that are infinite.\n\nAll recurring rules must have a start `datetime` (defaults to now).\n\nLets go through them one at a time.\n\n## Daily rule examples\n\n    >>> import turoboro\n    >>> from datetime import datetime\n    >>> rule = turoboro.DailyRule(start=datetime(2014, 1, 1))\n    >>> rule\n    {\"end\": null, \"every_nth_day\": 1, \"except_days\": null, \"except_months\": null, \"on_hour\": 0, \"repeat\": null, \"rule\": \"daily\", \"start\": \"2014-01-01T00:00:00+00:00\", \"timezone\": \"UTC\"}\n    >>> rule.every_nth_day(2).on_hour(8)\n    {\"end\": null, \"every_nth_day\": 2, \"except_days\": null, \"except_months\": null, \"on_hour\": 8, \"repeat\": null, \"rule\": \"daily\", \"start\": \"2014-01-01T08:00:00+00:00\", \"timezone\": \"UTC\"}\n    >>> rule.except_weekdays(*turoboro.WEEKEND)\n    {\"end\": null, \"every_nth_day\": 2, \"except_days\": [5, 6], \"except_months\": null, \"on_hour\": 8, \"repeat\": null, \"rule\": \"daily\", \"start\": \"2014-01-01T08:00:00+00:00\", \"timezone\": \"UTC\"}\n    >>> rule.end_on(datetime(2014, 1, 31))\n    {\"end\": \"2014-02-01T00:00:00+00:00\", \"every_nth_day\": 2, \"except_days\": [5, 6], \"except_months\": null, \"on_hour\": 8, \"repeat\": null, \"rule\": \"daily\", \"start\": \"2014-01-01T08:00:00+00:00\", \"timezone\": \"UTC\"}\n \nAlright, now we have an instance of the `DailyRule` class.\n\nYou can also instantiate the exact same thing using only a constructor:\n\n    >>> rule = turoboro.DailyRule(\n    ...     datetime(2014, 1, 1), every_nth_day=2, except_weekdays=turoboro.WEEKEND,\n    ...     end_on=datetime(2014, 1, 31), on_hour=8\n    ... )\n\nOr with a factory method using the \"pure\" json spec:\n\n    >>> rule = turoboro.Rule.from_json_spec({\n        \"end\": \"2014-02-01T00:00:00+00:00\",\n        \"every_nth_day\": 2,\n        \"except_days\": [5, 6],\n        \"except_months\": null,\n        \"on_hour\": 8,\n        \"repeat\": null,\n        \"rule\": \"daily\",\n        \"start\": \"2014-01-01T08:00:00+00:00\",\n        \"timezone\": \"UTC\"\n    })\n    \n\nLets see what actual times this resolves to.\n\n    >>> computed = rule.compute()\n    >>> computed.first\n    '2014-01-01T08:00:00'\n    >>> computed.last\n    '2014-01-31T08:00:00'\n    >>> computed.count\n    12\n    >>> computed.all\n    ['2014-01-01T08:00:00', '2014-01-03T08:00:00', '2014-01-07T08:00:00', '2014-01-09T08:00:00',\n     '2014-01-13T08:00:00', '2014-01-15T08:00:00', '2014-01-17T08:00:00', '2014-01-21T08:00:00',\n     '2014-01-23T08:00:00', '2014-01-27T08:00:00', '2014-01-29T08:00:00', '2014-01-31T08:00:00']\n    \nAs a convenience, you can get a handle on a generator function that will iterate through the\nentire set, as such:\n\n    >>> result = rule.result()\n    >>> next(result)\n    '2014-01-01T08:00:00'\n    >>> next(result)\n    '2014-01-03T08:00:00'\n    >>> [r for r in result]\n    ['2014-01-07T08:00:00', '2014-01-09T08:00:00', '2014-01-13T08:00:00', '2014-01-15T08:00:00',\n    '2014-01-17T08:00:00', '2014-01-21T08:00:00', '2014-01-23T08:00:00', '2014-01-27T08:00:00',\n    '2014-01-29T08:00:00', '2014-01-31T08:00:00']\n\n## Variations of the daily rule\n\nYou don't have to provide an end date - you can instead provide a number of occurrences\nor in the lingo of `turoboro`: `repeat_n_times`. As such:\n\n    >>> rule.repeat_n_times(10)\n    # ValueError: You may not specify both an end date and a repeat count\n\nOops, lets first kill the end date, (because lets be explicit with our intentions.)\n    \n    >>> rule.end_on(None).repeat_n_times(100)\n    {\"end\": null, \"every_nth_day\": 2, \"except_days\": [5, 6], \"except_months\": null, \"on_hour\": 8, \"repeat\": 100, \"rule\": \"daily\", \"start\": \"2014-01-01T08:00:00+00:00\", \"timezone\": \"UTC\"}\n    \nYou can also let your rule be infinite by omitting to provide an end date or a number of \noccurrences. The `computed.first`, `computed.last` and `computed.all` attributes will still\nbehave as if the result is a bounded set (defaults to 100 occurrences). However, by\nusing the `rule.result()` generator function you can iterate forward beyond the bounds that\n`rule.compute()` would give. Not infinitely far though, so iterating through the generator\nwill eventually come to a stop, how quickly depends on the batch size that you specify with\nthe keyword `max_count_if_infinite`. A `max_count_if_infinite=2` will likely give you results\nseveral years into the future.\n\n    >>> result = rule.result(max_count_if_infinite=2)\n    >>> [r for r in result] # 1974 results\n    \nIn essence - iterating through an infinite set of datetimes isn't very useful. Since, well...\nthey will never end. However, once you have an \"infinite\" rule you can always find the next\nupcoming set of valid datetimes by simply telling `compute` or `result` and specify the\n`from_dt` parameter, such as:\n\n    >>> result = rule.result(from_dt=datetime.utcnow())\n    >>> next(result)\n    '2019-06-26T08:00:00'", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/pellepim/turoboro", "keywords": "", "license": "", "maintainer": "", "maintainer_email": "", "name": "turoboro", "package_url": "https://pypi.org/project/turoboro/", "platform": "", "project_url": "https://pypi.org/project/turoboro/", "project_urls": {"Homepage": "https://github.com/pellepim/turoboro"}, "release_url": "https://pypi.org/project/turoboro/0.0.4/", "requires_dist": null, "requires_python": "", "summary": "A python library for specifying recurring time rules and getting timestamps in return.", "version": "0.0.4", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p><a href=\"https://circleci.com/gh/pellepim/turoboro\" rel=\"nofollow\"><img alt=\"CircleCI\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/74cf10587d6dde8ddf0b5f22dfcebff09f20447c/68747470733a2f2f636972636c6563692e636f6d2f67682f70656c6c6570696d2f7475726f626f726f2e7376673f7374796c653d736869656c64\"></a></p>\n<h1>turoboro</h1>\n<p>A python library for specifying recurring time rules and getting timestamps in return.</p>\n<p>Typical usage would be to articulate the behaviour of recurring rules and to get exact points\nin time where those rules ought to be executed.</p>\n<p>I.e this library answers the following questions:</p>\n<p>Given a recurring rule,</p>\n<ol>\n<li>when is the next time it happens?</li>\n<li>when are all of the times it happens?</li>\n<li>when are <code>n</code> times it happens?</li>\n</ol>\n<p>Say for example you want to find out at what specific UTC time the rule \"every thursday of every\nthird week of every second month at 8 o'clock UTC\" would happen.</p>\n<p>Ask turoboro!</p>\n<p>However, this is very much work in progress. So... basically don't use this library yet.</p>\n<h1>Installation</h1>\n<pre><code>$ pip install turoboro\n</code></pre>\n<h1>Usage</h1>\n<p>turoboro allows you to set up recurring rules of three main times:</p>\n<ol>\n<li>With an end-date, or</li>\n<li>that end after a certain number of occurrences, or</li>\n<li>that are infinite.</li>\n</ol>\n<p>All recurring rules must have a start <code>datetime</code> (defaults to now).</p>\n<p>Lets go through them one at a time.</p>\n<h2>Daily rule examples</h2>\n<pre><code>&gt;&gt;&gt; import turoboro\n&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; rule = turoboro.DailyRule(start=datetime(2014, 1, 1))\n&gt;&gt;&gt; rule\n{\"end\": null, \"every_nth_day\": 1, \"except_days\": null, \"except_months\": null, \"on_hour\": 0, \"repeat\": null, \"rule\": \"daily\", \"start\": \"2014-01-01T00:00:00+00:00\", \"timezone\": \"UTC\"}\n&gt;&gt;&gt; rule.every_nth_day(2).on_hour(8)\n{\"end\": null, \"every_nth_day\": 2, \"except_days\": null, \"except_months\": null, \"on_hour\": 8, \"repeat\": null, \"rule\": \"daily\", \"start\": \"2014-01-01T08:00:00+00:00\", \"timezone\": \"UTC\"}\n&gt;&gt;&gt; rule.except_weekdays(*turoboro.WEEKEND)\n{\"end\": null, \"every_nth_day\": 2, \"except_days\": [5, 6], \"except_months\": null, \"on_hour\": 8, \"repeat\": null, \"rule\": \"daily\", \"start\": \"2014-01-01T08:00:00+00:00\", \"timezone\": \"UTC\"}\n&gt;&gt;&gt; rule.end_on(datetime(2014, 1, 31))\n{\"end\": \"2014-02-01T00:00:00+00:00\", \"every_nth_day\": 2, \"except_days\": [5, 6], \"except_months\": null, \"on_hour\": 8, \"repeat\": null, \"rule\": \"daily\", \"start\": \"2014-01-01T08:00:00+00:00\", \"timezone\": \"UTC\"}\n</code></pre>\n<p>Alright, now we have an instance of the <code>DailyRule</code> class.</p>\n<p>You can also instantiate the exact same thing using only a constructor:</p>\n<pre><code>&gt;&gt;&gt; rule = turoboro.DailyRule(\n...     datetime(2014, 1, 1), every_nth_day=2, except_weekdays=turoboro.WEEKEND,\n...     end_on=datetime(2014, 1, 31), on_hour=8\n... )\n</code></pre>\n<p>Or with a factory method using the \"pure\" json spec:</p>\n<pre><code>&gt;&gt;&gt; rule = turoboro.Rule.from_json_spec({\n    \"end\": \"2014-02-01T00:00:00+00:00\",\n    \"every_nth_day\": 2,\n    \"except_days\": [5, 6],\n    \"except_months\": null,\n    \"on_hour\": 8,\n    \"repeat\": null,\n    \"rule\": \"daily\",\n    \"start\": \"2014-01-01T08:00:00+00:00\",\n    \"timezone\": \"UTC\"\n})\n</code></pre>\n<p>Lets see what actual times this resolves to.</p>\n<pre><code>&gt;&gt;&gt; computed = rule.compute()\n&gt;&gt;&gt; computed.first\n'2014-01-01T08:00:00'\n&gt;&gt;&gt; computed.last\n'2014-01-31T08:00:00'\n&gt;&gt;&gt; computed.count\n12\n&gt;&gt;&gt; computed.all\n['2014-01-01T08:00:00', '2014-01-03T08:00:00', '2014-01-07T08:00:00', '2014-01-09T08:00:00',\n '2014-01-13T08:00:00', '2014-01-15T08:00:00', '2014-01-17T08:00:00', '2014-01-21T08:00:00',\n '2014-01-23T08:00:00', '2014-01-27T08:00:00', '2014-01-29T08:00:00', '2014-01-31T08:00:00']\n</code></pre>\n<p>As a convenience, you can get a handle on a generator function that will iterate through the\nentire set, as such:</p>\n<pre><code>&gt;&gt;&gt; result = rule.result()\n&gt;&gt;&gt; next(result)\n'2014-01-01T08:00:00'\n&gt;&gt;&gt; next(result)\n'2014-01-03T08:00:00'\n&gt;&gt;&gt; [r for r in result]\n['2014-01-07T08:00:00', '2014-01-09T08:00:00', '2014-01-13T08:00:00', '2014-01-15T08:00:00',\n'2014-01-17T08:00:00', '2014-01-21T08:00:00', '2014-01-23T08:00:00', '2014-01-27T08:00:00',\n'2014-01-29T08:00:00', '2014-01-31T08:00:00']\n</code></pre>\n<h2>Variations of the daily rule</h2>\n<p>You don't have to provide an end date - you can instead provide a number of occurrences\nor in the lingo of <code>turoboro</code>: <code>repeat_n_times</code>. As such:</p>\n<pre><code>&gt;&gt;&gt; rule.repeat_n_times(10)\n# ValueError: You may not specify both an end date and a repeat count\n</code></pre>\n<p>Oops, lets first kill the end date, (because lets be explicit with our intentions.)</p>\n<pre><code>&gt;&gt;&gt; rule.end_on(None).repeat_n_times(100)\n{\"end\": null, \"every_nth_day\": 2, \"except_days\": [5, 6], \"except_months\": null, \"on_hour\": 8, \"repeat\": 100, \"rule\": \"daily\", \"start\": \"2014-01-01T08:00:00+00:00\", \"timezone\": \"UTC\"}\n</code></pre>\n<p>You can also let your rule be infinite by omitting to provide an end date or a number of\noccurrences. The <code>computed.first</code>, <code>computed.last</code> and <code>computed.all</code> attributes will still\nbehave as if the result is a bounded set (defaults to 100 occurrences). However, by\nusing the <code>rule.result()</code> generator function you can iterate forward beyond the bounds that\n<code>rule.compute()</code> would give. Not infinitely far though, so iterating through the generator\nwill eventually come to a stop, how quickly depends on the batch size that you specify with\nthe keyword <code>max_count_if_infinite</code>. A <code>max_count_if_infinite=2</code> will likely give you results\nseveral years into the future.</p>\n<pre><code>&gt;&gt;&gt; result = rule.result(max_count_if_infinite=2)\n&gt;&gt;&gt; [r for r in result] # 1974 results\n</code></pre>\n<p>In essence - iterating through an infinite set of datetimes isn't very useful. Since, well...\nthey will never end. However, once you have an \"infinite\" rule you can always find the next\nupcoming set of valid datetimes by simply telling <code>compute</code> or <code>result</code> and specify the\n<code>from_dt</code> parameter, such as:</p>\n<pre><code>&gt;&gt;&gt; result = rule.result(from_dt=datetime.utcnow())\n&gt;&gt;&gt; next(result)\n'2019-06-26T08:00:00'\n</code></pre>\n\n          </div>"}, "last_serial": 5824305, "releases": {"0.0.1": [{"comment_text": "", "digests": {"md5": "b7a2dc74ccff2b0d00e80c880e7ea2b0", "sha256": "195b8892d2dfee6b6b8fca492fce7574c020cd2755b6e00589842e69c995e931"}, "downloads": -1, "filename": "turoboro-0.0.1.tar.gz", "has_sig": false, "md5_digest": "b7a2dc74ccff2b0d00e80c880e7ea2b0", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 4959, "upload_time": "2019-06-23T19:09:53", "upload_time_iso_8601": "2019-06-23T19:09:53.565753Z", "url": "https://files.pythonhosted.org/packages/73/8d/b32801e650fd16120aa88c1e5bbce8b4212011e21d58349a50d147631fa4/turoboro-0.0.1.tar.gz", "yanked": false}], "0.0.2": [{"comment_text": "", "digests": {"md5": "a7961d45021a7c46c5a2a27e5545a231", "sha256": "803cfa546349f843bf9793f5b72a941cfa588b7990c0aedae94dbfcf9811a546"}, "downloads": -1, "filename": "turoboro-0.0.2.tar.gz", "has_sig": false, "md5_digest": "a7961d45021a7c46c5a2a27e5545a231", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 7230, "upload_time": "2019-06-24T23:03:10", "upload_time_iso_8601": "2019-06-24T23:03:10.126271Z", "url": "https://files.pythonhosted.org/packages/85/bd/5f0b5442ec92ba03b4e308cd930b967235e97280edd6dcb5a45d8b50d2cf/turoboro-0.0.2.tar.gz", "yanked": false}], "0.0.3": [{"comment_text": "", "digests": {"md5": "68c0965b2c085e3fd0579d2f8f72674e", "sha256": "227d13f426005a2c0c208a7c195b2b41d7a8576262ecf5e9d99ccaea3023547e"}, "downloads": -1, "filename": "turoboro-0.0.3.tar.gz", "has_sig": false, "md5_digest": "68c0965b2c085e3fd0579d2f8f72674e", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 10415, "upload_time": "2019-09-13T07:44:07", "upload_time_iso_8601": "2019-09-13T07:44:07.457163Z", "url": "https://files.pythonhosted.org/packages/52/59/190f62abded9eec64ca90feb4e587bad5206c675db3e06f9046f791e075a/turoboro-0.0.3.tar.gz", "yanked": false}], "0.0.4": [{"comment_text": "", "digests": {"md5": "549f2f84fdb33621d6e4cf43ad9e3297", "sha256": "4cabb58985828655392828ba989e119e6a6b3431846573b599ded1cae1683362"}, "downloads": -1, "filename": "turoboro-0.0.4.tar.gz", "has_sig": false, "md5_digest": "549f2f84fdb33621d6e4cf43ad9e3297", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 10423, "upload_time": "2019-09-13T07:53:08", "upload_time_iso_8601": "2019-09-13T07:53:08.996833Z", "url": "https://files.pythonhosted.org/packages/7c/c2/0c9983e17dfefc5d1bbeda90756daa497149cfb6ec3450fb7d59d34a4918/turoboro-0.0.4.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "549f2f84fdb33621d6e4cf43ad9e3297", "sha256": "4cabb58985828655392828ba989e119e6a6b3431846573b599ded1cae1683362"}, "downloads": -1, "filename": "turoboro-0.0.4.tar.gz", "has_sig": false, "md5_digest": "549f2f84fdb33621d6e4cf43ad9e3297", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 10423, "upload_time": "2019-09-13T07:53:08", "upload_time_iso_8601": "2019-09-13T07:53:08.996833Z", "url": "https://files.pythonhosted.org/packages/7c/c2/0c9983e17dfefc5d1bbeda90756daa497149cfb6ec3450fb7d59d34a4918/turoboro-0.0.4.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:44:32 2020"}