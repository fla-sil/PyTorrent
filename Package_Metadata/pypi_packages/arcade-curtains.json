{"info": {"author": "See AUTHORS", "author_email": "\"TODO@gmail.com\"", "bugtrack_url": null, "classifiers": ["Development Status :: 4 - Beta", "License :: OSI Approved :: MIT License", "Operating System :: MacOS :: MacOS X", "Operating System :: Microsoft :: Windows", "Operating System :: POSIX", "Programming Language :: Python", "Programming Language :: Python :: 3.6"], "description": "[![Build Status](https://travis-ci.com/maarten-dp/arcade-curtains.svg?branch=master)](https://travis-ci.com/maarten-dp/arcade-curtains)\n[![Codecov](https://codecov.io/gh/maarten-dp/arcade-curtains/branch/master/graph/badge.svg)](https://codecov.io/gh/maarten-dp/arcade-curtains)\n[![PyPI version](https://badge.fury.io/py/arcade-curtains.svg)](https://pypi.org/project/arcade-curtains/)\n\n![A simple animation maker](https://raw.githubusercontent.com/maarten-dp/arcade-curtains/master/assets/animation_maker.gif)\n\nA simple animation maker app written in 170 lines (300-ish if you include the code to enable the UI Button elements) using Arcade and Arcade-Curtains. [Have a look at the code!](https://github.com/maarten-dp/arcade-curtains/blob/master/examples/animation_maker.py)\n\n![Showcasing curtains](https://raw.githubusercontent.com/maarten-dp/arcade-curtains/master/assets/pokimans.gif)\n\nA small game showcasing all features in Arcade-Curtains. It's a fight scene inspired by Pok\u00e9mon/Final Fantasy written in 500 lines, using only primitive shapes (combining these shapes, makes up for a good amount of those 500 lines ;) ). [Have a look at the code!](https://github.com/maarten-dp/arcade-curtains/blob/master/examples/pokimans.py)\n\n## Introduction\n\nArcade-curtains is a basic scene and event manager for [Arcade](https://github.com/pvcraven/arcade). The main goal is to provide a way to write event driven games instead of plastering your code with ifs and elses. This is achieved by writing handlers for events.\n\n![Showcasing scenes](https://raw.githubusercontent.com/maarten-dp/arcade-curtains/master/assets/theatre.gif)\n\nA gif showcasing scenes. [Have a look at the code!](https://github.com/maarten-dp/arcade-curtains/blob/master/examples/theatre.py)\n\n## ToC\n- [Introduction](#introduction)\n- [ToC](#toc)\n  * [Events](#events)\n  * [Scenes](#scenes)\n  * [Animations](#animations)\n  * [Drawbacks](#drawbacks)\n- [Getting started](#getting-started)\n  * [Binding Curtains to Arcade](#binding-curtains-to-arcade)\n  * [Creating a Scene](#creating-a-scene)\n  * [Sprite events](#sprite-events)\n  * [Global events](#global-events)\n- [Animations](#animations-1)\n  * [Sprite.animate()](#spriteanimate--)\n  * [KeyFrames](#keyframes)\n  * [Sequences](#sequences)\n  * [Looping Sequences](#looping-sequences)\n  * [Reversing Sequences](#reversing-sequences)\n  * [Callbacks](#callbacks)\n  * [Chaining animations](#chaining-animations)\n  * [Animation utility functions](#animation-utility-functions)\n    + [KeyFrame from sprite](#keyframe-from-sprite)\n    + [Sequence from sprite](#sequence-from-sprite)\n- [Helpers](#helpers)\n  * [General utilities](#general-utilities)\n    + [delay_set_attribute](#delay-set-attribute)\n    + [Position helper](#position-helper)\n  * [ObservableSprite](#observablesprite)\n    + [before_change/after_change events](#before-change-after-change-events)\n    + [triggers](#triggers)\n  * [Widgets](#widgets)\n    + [AnchorPoint](#anchorpoint)\n    + [Widget](#widget)\n\n\n### Events\n\nThere are two types of events.\n\nSprite mouse events:\n- `up`\n- `down`\n- `click`\n- `hover`\n- `out`\n- `drag`\n\nGlobal events:\n- `frame`\n- `before_draw`\n- `after_draw`\n- `key`\n\nYou can attach your event handlers on a per sprite basis. Meaning each sprite/event combination could have a unique handler.\n\n### Scenes\n\nScenes are a way to pipe events to a certain context. You can define sprites and events in one scene, and they will become inactive when you enter another scene, for which you can define a whole new set of sprites and events. It also allows you to write some setup or teardown code when entering or leaving scenes.\n\nWhen switching from one scene to another, the context and state of the previous scene is still retained. Meaning you can easily switch between scenes and continue where you previously had left off. A quick example would be accessing a menu or inventory in the middle of a level.\n\n### Animations\n\nThis library provides a way to animate sprites in a fire-and-forget way. You provide a start state, an end state, and if desired intermediate states as well. The library will then take care of animating your sprite between those states, at a given duration. An advanced example, of what types of animations this library supports, can be found in the assets folder.\n\n### Drawbacks\n\nEventhough this way of writing games allows for a more modular approach, ultimately leading to more readable code, it's easy to lose track of execution flow when debugging. Therefore it is advised to write your handlers to directly handle what you want to achieve instead of diverging into a number of different code paths based on the state of the game.\n\nIn addition to this, the library has not yet been benchmarked and so it's not known at what point the event handler gets saturated.\n\n## Getting started\n\n### Binding Curtains to Arcade\n\nAs the library itself is pretty basic, getting started is fairly easy.\nThe first thing you have to do is create an instance of the Curtains class, and bind it to your Arcade window.\n\n```python\nimport arcade\nfrom arcade_curtains import Curtains\n\n\nclass Window(arcade.Window):\n    def __init__(self):\n        super().__init__(SCREEN_WIDTH, SCREEN_HEIGHT, SCREEN_TITLE)\n        self.curtains = Curtains(self)\n```\n\nor\n\n```python\nimport arcade\nfrom arcade_curtains import Curtains\n\n\nclass Window(arcade.Window):\n    def __init__(self):\n        super().__init__(SCREEN_WIDTH, SCREEN_HEIGHT, SCREEN_TITLE)\n\ncurtains = Curtains()\nwindow = Window()\ncurtains.bind(window)\n```\n\nWhen you bind the Curtains instance to an Arcade window, it will immediately bind itself to the window event methods (e.g. `update`, `on_draw`, `on_mouse_motion`). From then on, it will pipe the events to the event manager of the currently selected scene.\n\nYou are still able to overload these Arcade window methods as normal, but it is not advised to do so. If you do, know that the code written in these functions will be executed first, and Curtains handlers after.\n\n### Creating a Scene\n\nScenes are the basis of this library, and when using curtains, every game needs at least one.\n\nOnce you've defined your Curtains instance, you can add a scene to it. But to be able to do this, you will have to subclass the `BaseScene` class provided by `arcade-curtains` and overload the setup method.\nIn the setup method you can run all code that is making sprites, spritelists and linking your handlers.\n\nAnything subclassing `BaseScene` will auto detect `SpriteList` instances and auto draw on each frame.\n\n```python\nimport arcade\nfrom arcade_curtains import Curtains, BaseScene\n\n\nclass MyOpeningScene(BaseScene):\n    def setup(self):\n        # Actors will automatically be picked up and drawn on each frame\n        self.actors = arcade.SpriteList()\n        self.actor = arcade.Sprite()\n\n\nclass Window(arcade.Window):\n    def __init__(self):\n        super().__init__(SCREEN_WIDTH, SCREEN_HEIGHT, SCREEN_TITLE)\n        self.curtains = Curtains(self)\n        self.curtains.add_scene('opening_scene', MyOpeningScene())\n        self.curtains.set_scene('opening_scene')\n```\n\n### Sprite events\n\nNow that we've initialized curtains to have a scene, we can start adding events.\n\nAs explained above, there are two types of events. Unfortunately, these types are still a bit obfuscated at this point and are treated the same way, from a code point of view. The only difference is that for the sprite events, you need to give the sprite to the manager when registering a handler.\n\nSprite events usually occur when an interraction is being done with a specific sprite.\nLet's create a scene with one actor and add a `hover`, `out` and `click` event.\n\n```python\nimport arcade\nfrom arcade_curtains import BaseScene\n\nfrom .my_custom_sprites import CustomSprite\n\n\ndef paint_border(sprite, x, y):\n    sprite.set_border_texture()\n\n\ndef unpaint_border(sprite, x, y):\n    sprite.unset_border_texture()\n\n\ndef kill_actor(sprite, x, y):\n    sprite.play_death_animation(callback=sprite.kill)\n\n\nclass MyOpeningScene(BaseScene):\n    def setup(self):\n        self.actors = arcade.SpriteList()\n        self.actor = CustomSprite()\n\n        # add a hover event to this scene that paints a border whenever the mouse hovers over the sprite\n        self.events.hover(self.actor, paint_border)\n        # add an out event that reverts back to the original texture\n        self.events.out(self.actor, unpaint_border)\n        # and one that kills the actor when clicked\n        self.events.click(self.actor, kill_actor)\n```\n\nYou are able to provide default arguments to pass to the callback function in the following manner:\n\n```python\nevents.click(self.actor, kill_actor, {'method': 'very slowly'})\n```\n\n### Global events\n\nSome events are not linkable to a sprite, but you would still like to define some handlers to it. For instance the `frame` event, which is triggered at every frame. You could treat it as a sprite event, but it wouldn't make sense as it doesn't get triggered due to sprite interaction. Instead, you can just attach a handler function, that interracts with the desired sprite, to the `frame` event.\n\n\n```python\nimport arcade\nfrom arcade_curtains import BaseScene\n\n\nclass CustomSprite(arcade.Sprite):\n    def spin(self, delta_time):\n        self.angle += delta_time\n        self.angle %= 360\n\n\nclass MyOpeningScene(BaseScene):\n    def setup(self):\n        self.actors = arcade.SpriteList()\n        self.actor = CustomSprite()\n\n        self.events.frame(sprite.spin)\n```\n\nAlternatively you can add a handler that doesn't interract with a sprite in any way.\n\n```python\nimport random\n\nimport arcade\nfrom arcade_curtains import BaseScene\n\nCOLORS = [getattr(arcade.color, color) for color in dir(arcade.color)]\n\n\ndef trip_balls(delta):\n    arcade.set_background_color(random.choice(COLORS))\n\n\nclass MyOpeningScene(BaseScene):\n    def setup(self):\n        self.events.frame(trip_balls)\n```\n\nAdding keyboard events is equally easy, and uses the arcade keymap to define handlers\n\n```python\nimport sys\n\nimport arcade\n\nfrom arcade_curtains import BaseScene\n\n\ndef exit(key):\n    sys.exit(0)\n\n\nclass MyOpeningScene(BaseScene):\n    def setup(self):\n        self.events.key(arcade.key.ESCAPE, exit)\n```\n\n## Animations\n\nAnimations in Arcade-Curtains should be easy to achieve. For this reason, the arcade `Sprite` class has been outfitted with an additional method, deftly named `animate()`.\nDon't worry, you won't lose this method if you subclass `arcade.Sprite`.\n\nUsing the `animate` method will allow you to make an animation between the start and end states of your sprite. If you'd like more control, and intermediate states, the library provides additional objects to build more complex animations\n\n### Sprite.animate()\n\nThe easiest and fastest way to get started is the `animate` method that is newly exposed on any Sprite instance.\n\n```python\nimport arcade\nfrom arcade_curtains import BaseScene\n\n\nclass MyOpeningScene(BaseScene):\n    def setup(self):\n        self.actors = arcade.SpriteList()\n        self.actor = arcade.Sprite()\n        self.actors.append(self.actor)\n\n    def enter_scene(self, previous_scene):\n        self.actor.animate(\n            duration=1, # duration of the animation in seconds\n            position=(100, 100), # will move the sprite from its current position to (100, 100) in 1 second\n        )\n```\n\nWhen this method is called, it will use the `AnimationManager` of the current active scene. If needed, it can be given a manager explicitly.\n\n```python\nimport arcade\nfrom arcade_curtains import BaseScene\n\n\nclass MyOpeningScene(BaseScene):\n    def leave_scene(self, next_scene):\n        next_scene.actor.animate(\n            duration=1, # duration of the animation in seconds\n            position=(100, 100),\n            manager=next_scene.animations\n        )\n```\n\n### KeyFrames\n\nIf you'd like some more control over your animation, you can make use of `KeyFrame`s to define the states you'd like to visit during your animation, and wrap them up in a `Sequence`.\n\n`KeyFrames` allow you to define a state in which you want your sprite to be in at a certain point in time. The `KeyFrame` class allows you to set any of the attributes you would a sprite to set it's state.\n\n```python\nfrom arcade_curtains import KeyFrame\n\nframe = KeyFrame(\n    center_x=10,\n    center_y=10,\n    position=(10, 10), # position will be considered if both center_x/center_y and position are set\n    angle=50,\n    scale=1,\n    width=100,\n    height=100, # width/height will be considered if both widht/height and scale are set\n    alpha=255,\n    # left = 100,\n    # right = 100,\n    # top = 100,\n    # bottom = 100,\n)\n```\n\n### Sequences\n\n`Sequence`s are used to glue together the `KeyFrame`s you've defined. Because you might want to set the state of your sprite with the same `KeyFrame` at different times of your animation, the `Sequence` class is where we define at which states in time we want to reach the state.\n\n```python\nfrom arcade_curtains import KeyFrame, Sequence\n\nframe1 = KeyFrame(position=(10, 10))\nframe2 = KeyFrame(position=(100, 100))\n\nseq = Sequence()\nseq.add_keyframe(0, frame1) # We want the sprite to reach the state of frame 1 after 0 seconds\nseq.add_keyframe(1, frame2) # We want the sprite to reach the state of frame 2 after 1 second\nseq.add_keyframe(2, frame1) # We want the sprite to reach the state of frame 1 again after 2 seconds\n\n# The animation duration of this sequence is 2 seconds.\n```\n\nOnce you have a `Sequence`, you can then fire it explicitly by using the scene's animation manager, or pass it to the `animate` method of your sprite.\n\n```python\nimport arcade\nfrom arcade_curtains import BaseScene, KeyFrame, Sequence\n\n\nclass MyOpeningScene(BaseScene):\n    def setup(self):\n        self.actors = arcade.SpriteList()\n        self.actor = arcade.Sprite()\n        self.actors.append(self.actor)\n\n    def enter_scene(self, previous_scene):\n        seq = Sequence()\n        seq.add_keyframes(\n            (0, KeyFrame(angle=0)),\n            (1, KeyFrame(angle=180))\n        )\n        self.actor.animate(seq)\n        # Alternatively use self.animations.fire(self.actor, seq)\n```\n\nAlternatively, you are able to interact with a Sequence in the following way\n\n```python\nimport arcade\nfrom arcade_curtains import BaseScene, KeyFrame, Sequence\n\n\nclass MyOpeningScene(BaseScene):\n    def setup(self):\n        self.actors = arcade.SpriteList()\n        self.actor = arcade.Sprite()\n        self.actors.append(self.actor)\n\n    def enter_scene(self, previous_scene):\n        seq = Sequence()\n        seq[0].frame = KeyFrame(angle=0)\n        seq[1].frame = KeyFrame(angle=180)\n        seq[.5].callback = self.actor.do_something\n        self.actor.animate(seq)\n```\n\n### Looping Sequences\n\nYou can choose to have your sequence loop indefinitely. Once it had reached the final keyframe, it will restart its animation at the first keyframe.\n\n```python\nfrom arcade_curtains import Sequence\n\nseq = Sequence(loop=True)\n```\n\n### Reversing Sequences\n\nYou can reverse a sequence, causing the last keyframe to be animated first.\n\n```python\nfrom arcade_curtains import Sequence\n\nseq = Sequence(is_reversed=True)\n```\n\n### Callbacks\n\nBoth the Sprite method `animate`, and `Sequence.add_keyframe` allow you to execute a callback when a certain keyframe is reached. When defining a callback using `sprite.animate`, the callback defaults to the last `KeyFrame`.\n\n```python\nfrom arcade_curtains import KeyFrame, Sequence\nfrom my_game.triggers import trigger_end_animation_handler\n\nseq = Sequence()\nseq.add_keyframe(0, KeyFrame(position=(10, 10)))\nseq.add_keyframe(1, KeyFrame(position=(100, 100)), callback=trigger_end_animation_handler)\n```\n\nYou can also define callbacks independently from keyframes, to be executed when a certain point in time is reached within your animation.\n\n```python\nfrom arcade_curtains import KeyFrame, Sequence\nfrom my_game.triggers import set_sprite_attack_intent_animation\n\nseq = Sequence()\nseq.add_keyframe(0, KeyFrame(position=(10, 10)))\nseq.add_keyframe(1, KeyFrame(position=(100, 100)))\n\nseq.add_callback(.5, callback=set_sprite_attack_intent_animation)\n```\n\n### Chaining animations\n\nSometimes you'd only like to start an animation once another is done. Well then, I have good news for you, friend!\n\nOf course, you could just chain callbacks to achieve this, but this library provides a way to do it hastle free, and with the possibility to loop and have it's own \"end of chain\" callback.\n\n\n```python\nfrom arcade_curtains import KeyFrame, Sequence\nfrom my_game.triggers import set_sprite_attack_intent_animation\nfrom my_game.scenes import start_scene\n\nseq1 = Sequence()\nseq1.add_keyframes(\n    (0, KeyFrame(position=(10, 10))),\n    (1, KeyFrame(position=(100, 100)))\n)\nseq2 = Sequence()\nseq2.add_keyframes(\n    (0, KeyFrame(position=(100, 100))),\n    (1, KeyFrame(position=(10, 10))\n)\n\nchain = Chain(loop=True)\nchain.add_sequences(\n    (my_first_sprite, sequence1),\n    (my_second_sprite, sequence2)\n)\n\nstart_scene.animations.fire(None, chain)\n\n```\n\n### Animation utility functions\n\n#### KeyFrame from sprite\n\nCreate a keyframe from the current state of a sprite\n\n```python\nfrom arcade_curtains import KeyFrame\n\nframe = KeyFrame.from_sprite(my_sprite)\nframe = KeyFrame.from_sprite(my_sprite, only_keys=['angle', 'scale'])\n```\n\n#### Sequence from sprite\n\nCreate a sequence with one keyframe at the 0 point in time, from the current state of a sprite\n\n```python\nfrom arcade_curtains import Sequence\n\nseq = Sequence.from_sprite(my_sprite)\n```\n\n## Helpers\n\nThis module provides a number of interesting things to allow you to write your game faster and more smoothly.\n\n### General utilities\n\n#### delay_set_attribute\n\nThis is a small helper function that allows you to set an attribute on an object as a callback.\n\n```python\n# Will set the health attribute to 10 when clicked\nevents.click(sprite, delay_set_attribute(sprite, 'health', 10))\n```\n\n#### Position helper\n\n`arcade.Sprite`s and everything that subclasses it are outfitted with `topleft`, `topright`, `bottomleft`, `bottomright` coordinates. It functions the same as position, meaning it returns an x and a y coordinate.\n\nA small disclaimer, to be conform with position, the return values of these properties are (x, y) which is the inverse of the naming, but \"lefttop\" doesn't really roll off the tongue.\n\n### ObservableSprite\n\nAn `ObservableSprite` is a subclass from `arcade.Sprite` that allows you to attach handlers to attribute modifications.\n\n#### before_change/after_change events\n\nYou can define a callback and have it be called whenever the targetted attribute changes\n\n```python\nsprite.before_change('health', controller.validate_health_change)\nsprite.after_change('health', controller.notify_health_change)\n```\n\nIn the example below, the bottom circle is being moved every frame and has an `after_change` handler defined, to set the second sprite, as followed\n\n```python\nmod = 1\ndef keep_pace(sprite, attribute, old, new):\n    setattr(sprite2, attribute, new)\n\nsprite1.after_change('center_x', keep_pace)\n```\n\n![Showcasing Anchor](https://raw.githubusercontent.com/maarten-dp/arcade-curtains/master/assets/observe.gif)\n\n#### triggers\n\nAn `ObservableSprite` allows you to define a trigger that is run whenever a certain condition is met. For instance, you want your handler to run if health is equal or below 0.\n\n```python\nfrom arcade_curtains import TriggerAttr\n# Build a triggerable attribute definition\nhealth = TriggerAttr('health')\nsprite.trigger(health < 0, sprite.die)\n```\n\n### Widgets\n\nA `Widget` is a baseclass for grouping `Sprite`s into a widget. It allows a number of sprites to work together, while still maintaining the fine grained control over each sprite. `Widget`s use `AnchorPoint`s underneath to work as a group.\n\n#### AnchorPoint\n\nAn `AnchorPoint` is an object that is just an `x, y` coordinate, but you can affix sprites to this anchor. Whenever you move the anchor, all affixed sprites move with it.\n\n```python\nsprite1.position = (100, 100)\nsprite2.position = (200, 200)\nanchor = AnchorPoint.from_sprite(sprite1, 'position')\nanchor.dock(sprite2)\n# Will move sprite1 and sprite2 relative to the anchor\nanchor.position = (300, 300)\nassert sprite1.position == (300, 300)\nassert sprite2.position == (400, 400)\n```\n\nThis example shows all orbs are being anchored on an anchorpoint that is defined on the largest orb's position. When moving the large orb, the smaller, orbing orbs are moved as well\n\n![Showcasing Anchor](https://raw.githubusercontent.com/maarten-dp/arcade-curtains/master/assets/anchor.gif)\n\n#### Widget\n\nYou can consider a `Widget` to be a \"view\" where you can define your sprites relative to the (0, 0) coordinate. `Widget` starting coordinates will be inferred from the defined sprites within the widget. After initialisation you are able to manipulate these, to move your widget to the desired location.\n\nThe baseclass is outfitted with a `self.sprites` where you can add the sprites defined in your widget. After initializing your widget, you will have to register a spritelist to have your sprites drawn on screen.\n\n```python\nclass MyWidget(Widget):\n    def setup_widget(self):\n        sprite1 = arcade.Sprite(TEXTURE1)\n        sprite1.bottomleft = (0, 0)\n        sprite2 = arcade.Sprite(TEXTURE2)\n        sprite2.bottomleft = sprite1.topleft\n        self.sprites.extend([sprite1, sprite2])\n\nspritelist = arcade.SpriteList()\nwidget = MyWidget()\nwidget.position = (SCREEN_WIDTH / 2, SCREEN_HEIGHT / 2)\n# register the sprites to an arcade spritelist\nwidget.register(spritelist)\n```\n\n\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/maarten-dp/arcade-curtains", "keywords": "", "license": "", "maintainer": "", "maintainer_email": "", "name": "arcade-curtains", "package_url": "https://pypi.org/project/arcade-curtains/", "platform": "", "project_url": "https://pypi.org/project/arcade-curtains/", "project_urls": {"Homepage": "https://github.com/maarten-dp/arcade-curtains"}, "release_url": "https://pypi.org/project/arcade-curtains/0.2.0/", "requires_dist": ["arcade", "dataclasses", "pbr (>=3.0)", "scipy"], "requires_python": "", "summary": "A scene and event manager for python arcade", "version": "0.2.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p><a href=\"https://travis-ci.com/maarten-dp/arcade-curtains\" rel=\"nofollow\"><img alt=\"Build Status\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/49979c99795043ac77f84aa31c20c588c5c17455/68747470733a2f2f7472617669732d63692e636f6d2f6d61617274656e2d64702f6172636164652d6375727461696e732e7376673f6272616e63683d6d6173746572\"></a>\n<a href=\"https://codecov.io/gh/maarten-dp/arcade-curtains\" rel=\"nofollow\"><img alt=\"Codecov\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/2e778537a89b7cd63f6275b2d8ebf769cf213619/68747470733a2f2f636f6465636f762e696f2f67682f6d61617274656e2d64702f6172636164652d6375727461696e732f6272616e63682f6d61737465722f67726170682f62616467652e737667\"></a>\n<a href=\"https://pypi.org/project/arcade-curtains/\" rel=\"nofollow\"><img alt=\"PyPI version\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/3d6f4835c757bfb6ed0a6f1486b37ce9897cc33d/68747470733a2f2f62616467652e667572792e696f2f70792f6172636164652d6375727461696e732e737667\"></a></p>\n<p><img alt=\"A simple animation maker\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/55a7eec8c8fb5519f154c4275141c64a7a39cd99/68747470733a2f2f7261772e67697468756275736572636f6e74656e742e636f6d2f6d61617274656e2d64702f6172636164652d6375727461696e732f6d61737465722f6173736574732f616e696d6174696f6e5f6d616b65722e676966\"></p>\n<p>A simple animation maker app written in 170 lines (300-ish if you include the code to enable the UI Button elements) using Arcade and Arcade-Curtains. <a href=\"https://github.com/maarten-dp/arcade-curtains/blob/master/examples/animation_maker.py\" rel=\"nofollow\">Have a look at the code!</a></p>\n<p><img alt=\"Showcasing curtains\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/da3438e3d79c32f27d6682ce6ffb85b731be1489/68747470733a2f2f7261772e67697468756275736572636f6e74656e742e636f6d2f6d61617274656e2d64702f6172636164652d6375727461696e732f6d61737465722f6173736574732f706f6b696d616e732e676966\"></p>\n<p>A small game showcasing all features in Arcade-Curtains. It's a fight scene inspired by Pok\u00e9mon/Final Fantasy written in 500 lines, using only primitive shapes (combining these shapes, makes up for a good amount of those 500 lines ;) ). <a href=\"https://github.com/maarten-dp/arcade-curtains/blob/master/examples/pokimans.py\" rel=\"nofollow\">Have a look at the code!</a></p>\n<h2>Introduction</h2>\n<p>Arcade-curtains is a basic scene and event manager for <a href=\"https://github.com/pvcraven/arcade\" rel=\"nofollow\">Arcade</a>. The main goal is to provide a way to write event driven games instead of plastering your code with ifs and elses. This is achieved by writing handlers for events.</p>\n<p><img alt=\"Showcasing scenes\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/3dc3d5a1f37a9eb13e6895b001ac530f4b4f7c49/68747470733a2f2f7261772e67697468756275736572636f6e74656e742e636f6d2f6d61617274656e2d64702f6172636164652d6375727461696e732f6d61737465722f6173736574732f746865617472652e676966\"></p>\n<p>A gif showcasing scenes. <a href=\"https://github.com/maarten-dp/arcade-curtains/blob/master/examples/theatre.py\" rel=\"nofollow\">Have a look at the code!</a></p>\n<h2>ToC</h2>\n<ul>\n<li><a href=\"#introduction\" rel=\"nofollow\">Introduction</a></li>\n<li><a href=\"#toc\" rel=\"nofollow\">ToC</a>\n<ul>\n<li><a href=\"#events\" rel=\"nofollow\">Events</a></li>\n<li><a href=\"#scenes\" rel=\"nofollow\">Scenes</a></li>\n<li><a href=\"#animations\" rel=\"nofollow\">Animations</a></li>\n<li><a href=\"#drawbacks\" rel=\"nofollow\">Drawbacks</a></li>\n</ul>\n</li>\n<li><a href=\"#getting-started\" rel=\"nofollow\">Getting started</a>\n<ul>\n<li><a href=\"#binding-curtains-to-arcade\" rel=\"nofollow\">Binding Curtains to Arcade</a></li>\n<li><a href=\"#creating-a-scene\" rel=\"nofollow\">Creating a Scene</a></li>\n<li><a href=\"#sprite-events\" rel=\"nofollow\">Sprite events</a></li>\n<li><a href=\"#global-events\" rel=\"nofollow\">Global events</a></li>\n</ul>\n</li>\n<li><a href=\"#animations-1\" rel=\"nofollow\">Animations</a>\n<ul>\n<li><a href=\"#spriteanimate--\" rel=\"nofollow\">Sprite.animate()</a></li>\n<li><a href=\"#keyframes\" rel=\"nofollow\">KeyFrames</a></li>\n<li><a href=\"#sequences\" rel=\"nofollow\">Sequences</a></li>\n<li><a href=\"#looping-sequences\" rel=\"nofollow\">Looping Sequences</a></li>\n<li><a href=\"#reversing-sequences\" rel=\"nofollow\">Reversing Sequences</a></li>\n<li><a href=\"#callbacks\" rel=\"nofollow\">Callbacks</a></li>\n<li><a href=\"#chaining-animations\" rel=\"nofollow\">Chaining animations</a></li>\n<li><a href=\"#animation-utility-functions\" rel=\"nofollow\">Animation utility functions</a>\n<ul>\n<li><a href=\"#keyframe-from-sprite\" rel=\"nofollow\">KeyFrame from sprite</a></li>\n<li><a href=\"#sequence-from-sprite\" rel=\"nofollow\">Sequence from sprite</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#helpers\" rel=\"nofollow\">Helpers</a>\n<ul>\n<li><a href=\"#general-utilities\" rel=\"nofollow\">General utilities</a>\n<ul>\n<li><a href=\"#delay-set-attribute\" rel=\"nofollow\">delay_set_attribute</a></li>\n<li><a href=\"#position-helper\" rel=\"nofollow\">Position helper</a></li>\n</ul>\n</li>\n<li><a href=\"#observablesprite\" rel=\"nofollow\">ObservableSprite</a>\n<ul>\n<li><a href=\"#before-change-after-change-events\" rel=\"nofollow\">before_change/after_change events</a></li>\n<li><a href=\"#triggers\" rel=\"nofollow\">triggers</a></li>\n</ul>\n</li>\n<li><a href=\"#widgets\" rel=\"nofollow\">Widgets</a>\n<ul>\n<li><a href=\"#anchorpoint\" rel=\"nofollow\">AnchorPoint</a></li>\n<li><a href=\"#widget\" rel=\"nofollow\">Widget</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3>Events</h3>\n<p>There are two types of events.</p>\n<p>Sprite mouse events:</p>\n<ul>\n<li><code>up</code></li>\n<li><code>down</code></li>\n<li><code>click</code></li>\n<li><code>hover</code></li>\n<li><code>out</code></li>\n<li><code>drag</code></li>\n</ul>\n<p>Global events:</p>\n<ul>\n<li><code>frame</code></li>\n<li><code>before_draw</code></li>\n<li><code>after_draw</code></li>\n<li><code>key</code></li>\n</ul>\n<p>You can attach your event handlers on a per sprite basis. Meaning each sprite/event combination could have a unique handler.</p>\n<h3>Scenes</h3>\n<p>Scenes are a way to pipe events to a certain context. You can define sprites and events in one scene, and they will become inactive when you enter another scene, for which you can define a whole new set of sprites and events. It also allows you to write some setup or teardown code when entering or leaving scenes.</p>\n<p>When switching from one scene to another, the context and state of the previous scene is still retained. Meaning you can easily switch between scenes and continue where you previously had left off. A quick example would be accessing a menu or inventory in the middle of a level.</p>\n<h3>Animations</h3>\n<p>This library provides a way to animate sprites in a fire-and-forget way. You provide a start state, an end state, and if desired intermediate states as well. The library will then take care of animating your sprite between those states, at a given duration. An advanced example, of what types of animations this library supports, can be found in the assets folder.</p>\n<h3>Drawbacks</h3>\n<p>Eventhough this way of writing games allows for a more modular approach, ultimately leading to more readable code, it's easy to lose track of execution flow when debugging. Therefore it is advised to write your handlers to directly handle what you want to achieve instead of diverging into a number of different code paths based on the state of the game.</p>\n<p>In addition to this, the library has not yet been benchmarked and so it's not known at what point the event handler gets saturated.</p>\n<h2>Getting started</h2>\n<h3>Binding Curtains to Arcade</h3>\n<p>As the library itself is pretty basic, getting started is fairly easy.\nThe first thing you have to do is create an instance of the Curtains class, and bind it to your Arcade window.</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">arcade</span>\n<span class=\"kn\">from</span> <span class=\"nn\">arcade_curtains</span> <span class=\"kn\">import</span> <span class=\"n\">Curtains</span>\n\n\n<span class=\"k\">class</span> <span class=\"nc\">Window</span><span class=\"p\">(</span><span class=\"n\">arcade</span><span class=\"o\">.</span><span class=\"n\">Window</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"nb\">super</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"n\">SCREEN_WIDTH</span><span class=\"p\">,</span> <span class=\"n\">SCREEN_HEIGHT</span><span class=\"p\">,</span> <span class=\"n\">SCREEN_TITLE</span><span class=\"p\">)</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">curtains</span> <span class=\"o\">=</span> <span class=\"n\">Curtains</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">)</span>\n</pre>\n<p>or</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">arcade</span>\n<span class=\"kn\">from</span> <span class=\"nn\">arcade_curtains</span> <span class=\"kn\">import</span> <span class=\"n\">Curtains</span>\n\n\n<span class=\"k\">class</span> <span class=\"nc\">Window</span><span class=\"p\">(</span><span class=\"n\">arcade</span><span class=\"o\">.</span><span class=\"n\">Window</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"nb\">super</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"n\">SCREEN_WIDTH</span><span class=\"p\">,</span> <span class=\"n\">SCREEN_HEIGHT</span><span class=\"p\">,</span> <span class=\"n\">SCREEN_TITLE</span><span class=\"p\">)</span>\n\n<span class=\"n\">curtains</span> <span class=\"o\">=</span> <span class=\"n\">Curtains</span><span class=\"p\">()</span>\n<span class=\"n\">window</span> <span class=\"o\">=</span> <span class=\"n\">Window</span><span class=\"p\">()</span>\n<span class=\"n\">curtains</span><span class=\"o\">.</span><span class=\"n\">bind</span><span class=\"p\">(</span><span class=\"n\">window</span><span class=\"p\">)</span>\n</pre>\n<p>When you bind the Curtains instance to an Arcade window, it will immediately bind itself to the window event methods (e.g. <code>update</code>, <code>on_draw</code>, <code>on_mouse_motion</code>). From then on, it will pipe the events to the event manager of the currently selected scene.</p>\n<p>You are still able to overload these Arcade window methods as normal, but it is not advised to do so. If you do, know that the code written in these functions will be executed first, and Curtains handlers after.</p>\n<h3>Creating a Scene</h3>\n<p>Scenes are the basis of this library, and when using curtains, every game needs at least one.</p>\n<p>Once you've defined your Curtains instance, you can add a scene to it. But to be able to do this, you will have to subclass the <code>BaseScene</code> class provided by <code>arcade-curtains</code> and overload the setup method.\nIn the setup method you can run all code that is making sprites, spritelists and linking your handlers.</p>\n<p>Anything subclassing <code>BaseScene</code> will auto detect <code>SpriteList</code> instances and auto draw on each frame.</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">arcade</span>\n<span class=\"kn\">from</span> <span class=\"nn\">arcade_curtains</span> <span class=\"kn\">import</span> <span class=\"n\">Curtains</span><span class=\"p\">,</span> <span class=\"n\">BaseScene</span>\n\n\n<span class=\"k\">class</span> <span class=\"nc\">MyOpeningScene</span><span class=\"p\">(</span><span class=\"n\">BaseScene</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"nf\">setup</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"c1\"># Actors will automatically be picked up and drawn on each frame</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">actors</span> <span class=\"o\">=</span> <span class=\"n\">arcade</span><span class=\"o\">.</span><span class=\"n\">SpriteList</span><span class=\"p\">()</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">actor</span> <span class=\"o\">=</span> <span class=\"n\">arcade</span><span class=\"o\">.</span><span class=\"n\">Sprite</span><span class=\"p\">()</span>\n\n\n<span class=\"k\">class</span> <span class=\"nc\">Window</span><span class=\"p\">(</span><span class=\"n\">arcade</span><span class=\"o\">.</span><span class=\"n\">Window</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"nb\">super</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"n\">SCREEN_WIDTH</span><span class=\"p\">,</span> <span class=\"n\">SCREEN_HEIGHT</span><span class=\"p\">,</span> <span class=\"n\">SCREEN_TITLE</span><span class=\"p\">)</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">curtains</span> <span class=\"o\">=</span> <span class=\"n\">Curtains</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">)</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">curtains</span><span class=\"o\">.</span><span class=\"n\">add_scene</span><span class=\"p\">(</span><span class=\"s1\">'opening_scene'</span><span class=\"p\">,</span> <span class=\"n\">MyOpeningScene</span><span class=\"p\">())</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">curtains</span><span class=\"o\">.</span><span class=\"n\">set_scene</span><span class=\"p\">(</span><span class=\"s1\">'opening_scene'</span><span class=\"p\">)</span>\n</pre>\n<h3>Sprite events</h3>\n<p>Now that we've initialized curtains to have a scene, we can start adding events.</p>\n<p>As explained above, there are two types of events. Unfortunately, these types are still a bit obfuscated at this point and are treated the same way, from a code point of view. The only difference is that for the sprite events, you need to give the sprite to the manager when registering a handler.</p>\n<p>Sprite events usually occur when an interraction is being done with a specific sprite.\nLet's create a scene with one actor and add a <code>hover</code>, <code>out</code> and <code>click</code> event.</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">arcade</span>\n<span class=\"kn\">from</span> <span class=\"nn\">arcade_curtains</span> <span class=\"kn\">import</span> <span class=\"n\">BaseScene</span>\n\n<span class=\"kn\">from</span> <span class=\"nn\">.my_custom_sprites</span> <span class=\"kn\">import</span> <span class=\"n\">CustomSprite</span>\n\n\n<span class=\"k\">def</span> <span class=\"nf\">paint_border</span><span class=\"p\">(</span><span class=\"n\">sprite</span><span class=\"p\">,</span> <span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">y</span><span class=\"p\">):</span>\n    <span class=\"n\">sprite</span><span class=\"o\">.</span><span class=\"n\">set_border_texture</span><span class=\"p\">()</span>\n\n\n<span class=\"k\">def</span> <span class=\"nf\">unpaint_border</span><span class=\"p\">(</span><span class=\"n\">sprite</span><span class=\"p\">,</span> <span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">y</span><span class=\"p\">):</span>\n    <span class=\"n\">sprite</span><span class=\"o\">.</span><span class=\"n\">unset_border_texture</span><span class=\"p\">()</span>\n\n\n<span class=\"k\">def</span> <span class=\"nf\">kill_actor</span><span class=\"p\">(</span><span class=\"n\">sprite</span><span class=\"p\">,</span> <span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">y</span><span class=\"p\">):</span>\n    <span class=\"n\">sprite</span><span class=\"o\">.</span><span class=\"n\">play_death_animation</span><span class=\"p\">(</span><span class=\"n\">callback</span><span class=\"o\">=</span><span class=\"n\">sprite</span><span class=\"o\">.</span><span class=\"n\">kill</span><span class=\"p\">)</span>\n\n\n<span class=\"k\">class</span> <span class=\"nc\">MyOpeningScene</span><span class=\"p\">(</span><span class=\"n\">BaseScene</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"nf\">setup</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">actors</span> <span class=\"o\">=</span> <span class=\"n\">arcade</span><span class=\"o\">.</span><span class=\"n\">SpriteList</span><span class=\"p\">()</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">actor</span> <span class=\"o\">=</span> <span class=\"n\">CustomSprite</span><span class=\"p\">()</span>\n\n        <span class=\"c1\"># add a hover event to this scene that paints a border whenever the mouse hovers over the sprite</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">events</span><span class=\"o\">.</span><span class=\"n\">hover</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">actor</span><span class=\"p\">,</span> <span class=\"n\">paint_border</span><span class=\"p\">)</span>\n        <span class=\"c1\"># add an out event that reverts back to the original texture</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">events</span><span class=\"o\">.</span><span class=\"n\">out</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">actor</span><span class=\"p\">,</span> <span class=\"n\">unpaint_border</span><span class=\"p\">)</span>\n        <span class=\"c1\"># and one that kills the actor when clicked</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">events</span><span class=\"o\">.</span><span class=\"n\">click</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">actor</span><span class=\"p\">,</span> <span class=\"n\">kill_actor</span><span class=\"p\">)</span>\n</pre>\n<p>You are able to provide default arguments to pass to the callback function in the following manner:</p>\n<pre><span class=\"n\">events</span><span class=\"o\">.</span><span class=\"n\">click</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">actor</span><span class=\"p\">,</span> <span class=\"n\">kill_actor</span><span class=\"p\">,</span> <span class=\"p\">{</span><span class=\"s1\">'method'</span><span class=\"p\">:</span> <span class=\"s1\">'very slowly'</span><span class=\"p\">})</span>\n</pre>\n<h3>Global events</h3>\n<p>Some events are not linkable to a sprite, but you would still like to define some handlers to it. For instance the <code>frame</code> event, which is triggered at every frame. You could treat it as a sprite event, but it wouldn't make sense as it doesn't get triggered due to sprite interaction. Instead, you can just attach a handler function, that interracts with the desired sprite, to the <code>frame</code> event.</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">arcade</span>\n<span class=\"kn\">from</span> <span class=\"nn\">arcade_curtains</span> <span class=\"kn\">import</span> <span class=\"n\">BaseScene</span>\n\n\n<span class=\"k\">class</span> <span class=\"nc\">CustomSprite</span><span class=\"p\">(</span><span class=\"n\">arcade</span><span class=\"o\">.</span><span class=\"n\">Sprite</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"nf\">spin</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">delta_time</span><span class=\"p\">):</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">angle</span> <span class=\"o\">+=</span> <span class=\"n\">delta_time</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">angle</span> <span class=\"o\">%=</span> <span class=\"mi\">360</span>\n\n\n<span class=\"k\">class</span> <span class=\"nc\">MyOpeningScene</span><span class=\"p\">(</span><span class=\"n\">BaseScene</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"nf\">setup</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">actors</span> <span class=\"o\">=</span> <span class=\"n\">arcade</span><span class=\"o\">.</span><span class=\"n\">SpriteList</span><span class=\"p\">()</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">actor</span> <span class=\"o\">=</span> <span class=\"n\">CustomSprite</span><span class=\"p\">()</span>\n\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">events</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"p\">(</span><span class=\"n\">sprite</span><span class=\"o\">.</span><span class=\"n\">spin</span><span class=\"p\">)</span>\n</pre>\n<p>Alternatively you can add a handler that doesn't interract with a sprite in any way.</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">random</span>\n\n<span class=\"kn\">import</span> <span class=\"nn\">arcade</span>\n<span class=\"kn\">from</span> <span class=\"nn\">arcade_curtains</span> <span class=\"kn\">import</span> <span class=\"n\">BaseScene</span>\n\n<span class=\"n\">COLORS</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"nb\">getattr</span><span class=\"p\">(</span><span class=\"n\">arcade</span><span class=\"o\">.</span><span class=\"n\">color</span><span class=\"p\">,</span> <span class=\"n\">color</span><span class=\"p\">)</span> <span class=\"k\">for</span> <span class=\"n\">color</span> <span class=\"ow\">in</span> <span class=\"nb\">dir</span><span class=\"p\">(</span><span class=\"n\">arcade</span><span class=\"o\">.</span><span class=\"n\">color</span><span class=\"p\">)]</span>\n\n\n<span class=\"k\">def</span> <span class=\"nf\">trip_balls</span><span class=\"p\">(</span><span class=\"n\">delta</span><span class=\"p\">):</span>\n    <span class=\"n\">arcade</span><span class=\"o\">.</span><span class=\"n\">set_background_color</span><span class=\"p\">(</span><span class=\"n\">random</span><span class=\"o\">.</span><span class=\"n\">choice</span><span class=\"p\">(</span><span class=\"n\">COLORS</span><span class=\"p\">))</span>\n\n\n<span class=\"k\">class</span> <span class=\"nc\">MyOpeningScene</span><span class=\"p\">(</span><span class=\"n\">BaseScene</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"nf\">setup</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">events</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"p\">(</span><span class=\"n\">trip_balls</span><span class=\"p\">)</span>\n</pre>\n<p>Adding keyboard events is equally easy, and uses the arcade keymap to define handlers</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">sys</span>\n\n<span class=\"kn\">import</span> <span class=\"nn\">arcade</span>\n\n<span class=\"kn\">from</span> <span class=\"nn\">arcade_curtains</span> <span class=\"kn\">import</span> <span class=\"n\">BaseScene</span>\n\n\n<span class=\"k\">def</span> <span class=\"nf\">exit</span><span class=\"p\">(</span><span class=\"n\">key</span><span class=\"p\">):</span>\n    <span class=\"n\">sys</span><span class=\"o\">.</span><span class=\"n\">exit</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">)</span>\n\n\n<span class=\"k\">class</span> <span class=\"nc\">MyOpeningScene</span><span class=\"p\">(</span><span class=\"n\">BaseScene</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"nf\">setup</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">events</span><span class=\"o\">.</span><span class=\"n\">key</span><span class=\"p\">(</span><span class=\"n\">arcade</span><span class=\"o\">.</span><span class=\"n\">key</span><span class=\"o\">.</span><span class=\"n\">ESCAPE</span><span class=\"p\">,</span> <span class=\"n\">exit</span><span class=\"p\">)</span>\n</pre>\n<h2>Animations</h2>\n<p>Animations in Arcade-Curtains should be easy to achieve. For this reason, the arcade <code>Sprite</code> class has been outfitted with an additional method, deftly named <code>animate()</code>.\nDon't worry, you won't lose this method if you subclass <code>arcade.Sprite</code>.</p>\n<p>Using the <code>animate</code> method will allow you to make an animation between the start and end states of your sprite. If you'd like more control, and intermediate states, the library provides additional objects to build more complex animations</p>\n<h3>Sprite.animate()</h3>\n<p>The easiest and fastest way to get started is the <code>animate</code> method that is newly exposed on any Sprite instance.</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">arcade</span>\n<span class=\"kn\">from</span> <span class=\"nn\">arcade_curtains</span> <span class=\"kn\">import</span> <span class=\"n\">BaseScene</span>\n\n\n<span class=\"k\">class</span> <span class=\"nc\">MyOpeningScene</span><span class=\"p\">(</span><span class=\"n\">BaseScene</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"nf\">setup</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">actors</span> <span class=\"o\">=</span> <span class=\"n\">arcade</span><span class=\"o\">.</span><span class=\"n\">SpriteList</span><span class=\"p\">()</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">actor</span> <span class=\"o\">=</span> <span class=\"n\">arcade</span><span class=\"o\">.</span><span class=\"n\">Sprite</span><span class=\"p\">()</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">actors</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">actor</span><span class=\"p\">)</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">enter_scene</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">previous_scene</span><span class=\"p\">):</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">actor</span><span class=\"o\">.</span><span class=\"n\">animate</span><span class=\"p\">(</span>\n            <span class=\"n\">duration</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"c1\"># duration of the animation in seconds</span>\n            <span class=\"n\">position</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mi\">100</span><span class=\"p\">,</span> <span class=\"mi\">100</span><span class=\"p\">),</span> <span class=\"c1\"># will move the sprite from its current position to (100, 100) in 1 second</span>\n        <span class=\"p\">)</span>\n</pre>\n<p>When this method is called, it will use the <code>AnimationManager</code> of the current active scene. If needed, it can be given a manager explicitly.</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">arcade</span>\n<span class=\"kn\">from</span> <span class=\"nn\">arcade_curtains</span> <span class=\"kn\">import</span> <span class=\"n\">BaseScene</span>\n\n\n<span class=\"k\">class</span> <span class=\"nc\">MyOpeningScene</span><span class=\"p\">(</span><span class=\"n\">BaseScene</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"nf\">leave_scene</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">next_scene</span><span class=\"p\">):</span>\n        <span class=\"n\">next_scene</span><span class=\"o\">.</span><span class=\"n\">actor</span><span class=\"o\">.</span><span class=\"n\">animate</span><span class=\"p\">(</span>\n            <span class=\"n\">duration</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"c1\"># duration of the animation in seconds</span>\n            <span class=\"n\">position</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mi\">100</span><span class=\"p\">,</span> <span class=\"mi\">100</span><span class=\"p\">),</span>\n            <span class=\"n\">manager</span><span class=\"o\">=</span><span class=\"n\">next_scene</span><span class=\"o\">.</span><span class=\"n\">animations</span>\n        <span class=\"p\">)</span>\n</pre>\n<h3>KeyFrames</h3>\n<p>If you'd like some more control over your animation, you can make use of <code>KeyFrame</code>s to define the states you'd like to visit during your animation, and wrap them up in a <code>Sequence</code>.</p>\n<p><code>KeyFrames</code> allow you to define a state in which you want your sprite to be in at a certain point in time. The <code>KeyFrame</code> class allows you to set any of the attributes you would a sprite to set it's state.</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">arcade_curtains</span> <span class=\"kn\">import</span> <span class=\"n\">KeyFrame</span>\n\n<span class=\"n\">frame</span> <span class=\"o\">=</span> <span class=\"n\">KeyFrame</span><span class=\"p\">(</span>\n    <span class=\"n\">center_x</span><span class=\"o\">=</span><span class=\"mi\">10</span><span class=\"p\">,</span>\n    <span class=\"n\">center_y</span><span class=\"o\">=</span><span class=\"mi\">10</span><span class=\"p\">,</span>\n    <span class=\"n\">position</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mi\">10</span><span class=\"p\">,</span> <span class=\"mi\">10</span><span class=\"p\">),</span> <span class=\"c1\"># position will be considered if both center_x/center_y and position are set</span>\n    <span class=\"n\">angle</span><span class=\"o\">=</span><span class=\"mi\">50</span><span class=\"p\">,</span>\n    <span class=\"n\">scale</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">,</span>\n    <span class=\"n\">width</span><span class=\"o\">=</span><span class=\"mi\">100</span><span class=\"p\">,</span>\n    <span class=\"n\">height</span><span class=\"o\">=</span><span class=\"mi\">100</span><span class=\"p\">,</span> <span class=\"c1\"># width/height will be considered if both widht/height and scale are set</span>\n    <span class=\"n\">alpha</span><span class=\"o\">=</span><span class=\"mi\">255</span><span class=\"p\">,</span>\n    <span class=\"c1\"># left = 100,</span>\n    <span class=\"c1\"># right = 100,</span>\n    <span class=\"c1\"># top = 100,</span>\n    <span class=\"c1\"># bottom = 100,</span>\n<span class=\"p\">)</span>\n</pre>\n<h3>Sequences</h3>\n<p><code>Sequence</code>s are used to glue together the <code>KeyFrame</code>s you've defined. Because you might want to set the state of your sprite with the same <code>KeyFrame</code> at different times of your animation, the <code>Sequence</code> class is where we define at which states in time we want to reach the state.</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">arcade_curtains</span> <span class=\"kn\">import</span> <span class=\"n\">KeyFrame</span><span class=\"p\">,</span> <span class=\"n\">Sequence</span>\n\n<span class=\"n\">frame1</span> <span class=\"o\">=</span> <span class=\"n\">KeyFrame</span><span class=\"p\">(</span><span class=\"n\">position</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mi\">10</span><span class=\"p\">,</span> <span class=\"mi\">10</span><span class=\"p\">))</span>\n<span class=\"n\">frame2</span> <span class=\"o\">=</span> <span class=\"n\">KeyFrame</span><span class=\"p\">(</span><span class=\"n\">position</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mi\">100</span><span class=\"p\">,</span> <span class=\"mi\">100</span><span class=\"p\">))</span>\n\n<span class=\"n\">seq</span> <span class=\"o\">=</span> <span class=\"n\">Sequence</span><span class=\"p\">()</span>\n<span class=\"n\">seq</span><span class=\"o\">.</span><span class=\"n\">add_keyframe</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">frame1</span><span class=\"p\">)</span> <span class=\"c1\"># We want the sprite to reach the state of frame 1 after 0 seconds</span>\n<span class=\"n\">seq</span><span class=\"o\">.</span><span class=\"n\">add_keyframe</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">frame2</span><span class=\"p\">)</span> <span class=\"c1\"># We want the sprite to reach the state of frame 2 after 1 second</span>\n<span class=\"n\">seq</span><span class=\"o\">.</span><span class=\"n\">add_keyframe</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"n\">frame1</span><span class=\"p\">)</span> <span class=\"c1\"># We want the sprite to reach the state of frame 1 again after 2 seconds</span>\n\n<span class=\"c1\"># The animation duration of this sequence is 2 seconds.</span>\n</pre>\n<p>Once you have a <code>Sequence</code>, you can then fire it explicitly by using the scene's animation manager, or pass it to the <code>animate</code> method of your sprite.</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">arcade</span>\n<span class=\"kn\">from</span> <span class=\"nn\">arcade_curtains</span> <span class=\"kn\">import</span> <span class=\"n\">BaseScene</span><span class=\"p\">,</span> <span class=\"n\">KeyFrame</span><span class=\"p\">,</span> <span class=\"n\">Sequence</span>\n\n\n<span class=\"k\">class</span> <span class=\"nc\">MyOpeningScene</span><span class=\"p\">(</span><span class=\"n\">BaseScene</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"nf\">setup</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">actors</span> <span class=\"o\">=</span> <span class=\"n\">arcade</span><span class=\"o\">.</span><span class=\"n\">SpriteList</span><span class=\"p\">()</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">actor</span> <span class=\"o\">=</span> <span class=\"n\">arcade</span><span class=\"o\">.</span><span class=\"n\">Sprite</span><span class=\"p\">()</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">actors</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">actor</span><span class=\"p\">)</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">enter_scene</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">previous_scene</span><span class=\"p\">):</span>\n        <span class=\"n\">seq</span> <span class=\"o\">=</span> <span class=\"n\">Sequence</span><span class=\"p\">()</span>\n        <span class=\"n\">seq</span><span class=\"o\">.</span><span class=\"n\">add_keyframes</span><span class=\"p\">(</span>\n            <span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">KeyFrame</span><span class=\"p\">(</span><span class=\"n\">angle</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">)),</span>\n            <span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">KeyFrame</span><span class=\"p\">(</span><span class=\"n\">angle</span><span class=\"o\">=</span><span class=\"mi\">180</span><span class=\"p\">))</span>\n        <span class=\"p\">)</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">actor</span><span class=\"o\">.</span><span class=\"n\">animate</span><span class=\"p\">(</span><span class=\"n\">seq</span><span class=\"p\">)</span>\n        <span class=\"c1\"># Alternatively use self.animations.fire(self.actor, seq)</span>\n</pre>\n<p>Alternatively, you are able to interact with a Sequence in the following way</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">arcade</span>\n<span class=\"kn\">from</span> <span class=\"nn\">arcade_curtains</span> <span class=\"kn\">import</span> <span class=\"n\">BaseScene</span><span class=\"p\">,</span> <span class=\"n\">KeyFrame</span><span class=\"p\">,</span> <span class=\"n\">Sequence</span>\n\n\n<span class=\"k\">class</span> <span class=\"nc\">MyOpeningScene</span><span class=\"p\">(</span><span class=\"n\">BaseScene</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"nf\">setup</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">actors</span> <span class=\"o\">=</span> <span class=\"n\">arcade</span><span class=\"o\">.</span><span class=\"n\">SpriteList</span><span class=\"p\">()</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">actor</span> <span class=\"o\">=</span> <span class=\"n\">arcade</span><span class=\"o\">.</span><span class=\"n\">Sprite</span><span class=\"p\">()</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">actors</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">actor</span><span class=\"p\">)</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">enter_scene</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">previous_scene</span><span class=\"p\">):</span>\n        <span class=\"n\">seq</span> <span class=\"o\">=</span> <span class=\"n\">Sequence</span><span class=\"p\">()</span>\n        <span class=\"n\">seq</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">frame</span> <span class=\"o\">=</span> <span class=\"n\">KeyFrame</span><span class=\"p\">(</span><span class=\"n\">angle</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">)</span>\n        <span class=\"n\">seq</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">frame</span> <span class=\"o\">=</span> <span class=\"n\">KeyFrame</span><span class=\"p\">(</span><span class=\"n\">angle</span><span class=\"o\">=</span><span class=\"mi\">180</span><span class=\"p\">)</span>\n        <span class=\"n\">seq</span><span class=\"p\">[</span><span class=\"o\">.</span><span class=\"mi\">5</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">callback</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">actor</span><span class=\"o\">.</span><span class=\"n\">do_something</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">actor</span><span class=\"o\">.</span><span class=\"n\">animate</span><span class=\"p\">(</span><span class=\"n\">seq</span><span class=\"p\">)</span>\n</pre>\n<h3>Looping Sequences</h3>\n<p>You can choose to have your sequence loop indefinitely. Once it had reached the final keyframe, it will restart its animation at the first keyframe.</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">arcade_curtains</span> <span class=\"kn\">import</span> <span class=\"n\">Sequence</span>\n\n<span class=\"n\">seq</span> <span class=\"o\">=</span> <span class=\"n\">Sequence</span><span class=\"p\">(</span><span class=\"n\">loop</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n</pre>\n<h3>Reversing Sequences</h3>\n<p>You can reverse a sequence, causing the last keyframe to be animated first.</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">arcade_curtains</span> <span class=\"kn\">import</span> <span class=\"n\">Sequence</span>\n\n<span class=\"n\">seq</span> <span class=\"o\">=</span> <span class=\"n\">Sequence</span><span class=\"p\">(</span><span class=\"n\">is_reversed</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n</pre>\n<h3>Callbacks</h3>\n<p>Both the Sprite method <code>animate</code>, and <code>Sequence.add_keyframe</code> allow you to execute a callback when a certain keyframe is reached. When defining a callback using <code>sprite.animate</code>, the callback defaults to the last <code>KeyFrame</code>.</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">arcade_curtains</span> <span class=\"kn\">import</span> <span class=\"n\">KeyFrame</span><span class=\"p\">,</span> <span class=\"n\">Sequence</span>\n<span class=\"kn\">from</span> <span class=\"nn\">my_game.triggers</span> <span class=\"kn\">import</span> <span class=\"n\">trigger_end_animation_handler</span>\n\n<span class=\"n\">seq</span> <span class=\"o\">=</span> <span class=\"n\">Sequence</span><span class=\"p\">()</span>\n<span class=\"n\">seq</span><span class=\"o\">.</span><span class=\"n\">add_keyframe</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">KeyFrame</span><span class=\"p\">(</span><span class=\"n\">position</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mi\">10</span><span class=\"p\">,</span> <span class=\"mi\">10</span><span class=\"p\">)))</span>\n<span class=\"n\">seq</span><span class=\"o\">.</span><span class=\"n\">add_keyframe</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">KeyFrame</span><span class=\"p\">(</span><span class=\"n\">position</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mi\">100</span><span class=\"p\">,</span> <span class=\"mi\">100</span><span class=\"p\">)),</span> <span class=\"n\">callback</span><span class=\"o\">=</span><span class=\"n\">trigger_end_animation_handler</span><span class=\"p\">)</span>\n</pre>\n<p>You can also define callbacks independently from keyframes, to be executed when a certain point in time is reached within your animation.</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">arcade_curtains</span> <span class=\"kn\">import</span> <span class=\"n\">KeyFrame</span><span class=\"p\">,</span> <span class=\"n\">Sequence</span>\n<span class=\"kn\">from</span> <span class=\"nn\">my_game.triggers</span> <span class=\"kn\">import</span> <span class=\"n\">set_sprite_attack_intent_animation</span>\n\n<span class=\"n\">seq</span> <span class=\"o\">=</span> <span class=\"n\">Sequence</span><span class=\"p\">()</span>\n<span class=\"n\">seq</span><span class=\"o\">.</span><span class=\"n\">add_keyframe</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">KeyFrame</span><span class=\"p\">(</span><span class=\"n\">position</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mi\">10</span><span class=\"p\">,</span> <span class=\"mi\">10</span><span class=\"p\">)))</span>\n<span class=\"n\">seq</span><span class=\"o\">.</span><span class=\"n\">add_keyframe</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">KeyFrame</span><span class=\"p\">(</span><span class=\"n\">position</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mi\">100</span><span class=\"p\">,</span> <span class=\"mi\">100</span><span class=\"p\">)))</span>\n\n<span class=\"n\">seq</span><span class=\"o\">.</span><span class=\"n\">add_callback</span><span class=\"p\">(</span><span class=\"o\">.</span><span class=\"mi\">5</span><span class=\"p\">,</span> <span class=\"n\">callback</span><span class=\"o\">=</span><span class=\"n\">set_sprite_attack_intent_animation</span><span class=\"p\">)</span>\n</pre>\n<h3>Chaining animations</h3>\n<p>Sometimes you'd only like to start an animation once another is done. Well then, I have good news for you, friend!</p>\n<p>Of course, you could just chain callbacks to achieve this, but this library provides a way to do it hastle free, and with the possibility to loop and have it's own \"end of chain\" callback.</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">arcade_curtains</span> <span class=\"kn\">import</span> <span class=\"n\">KeyFrame</span><span class=\"p\">,</span> <span class=\"n\">Sequence</span>\n<span class=\"kn\">from</span> <span class=\"nn\">my_game.triggers</span> <span class=\"kn\">import</span> <span class=\"n\">set_sprite_attack_intent_animation</span>\n<span class=\"kn\">from</span> <span class=\"nn\">my_game.scenes</span> <span class=\"kn\">import</span> <span class=\"n\">start_scene</span>\n\n<span class=\"n\">seq1</span> <span class=\"o\">=</span> <span class=\"n\">Sequence</span><span class=\"p\">()</span>\n<span class=\"n\">seq1</span><span class=\"o\">.</span><span class=\"n\">add_keyframes</span><span class=\"p\">(</span>\n    <span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">KeyFrame</span><span class=\"p\">(</span><span class=\"n\">position</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mi\">10</span><span class=\"p\">,</span> <span class=\"mi\">10</span><span class=\"p\">))),</span>\n    <span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">KeyFrame</span><span class=\"p\">(</span><span class=\"n\">position</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mi\">100</span><span class=\"p\">,</span> <span class=\"mi\">100</span><span class=\"p\">)))</span>\n<span class=\"p\">)</span>\n<span class=\"n\">seq2</span> <span class=\"o\">=</span> <span class=\"n\">Sequence</span><span class=\"p\">()</span>\n<span class=\"n\">seq2</span><span class=\"o\">.</span><span class=\"n\">add_keyframes</span><span class=\"p\">(</span>\n    <span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">KeyFrame</span><span class=\"p\">(</span><span class=\"n\">position</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mi\">100</span><span class=\"p\">,</span> <span class=\"mi\">100</span><span class=\"p\">))),</span>\n    <span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">KeyFrame</span><span class=\"p\">(</span><span class=\"n\">position</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mi\">10</span><span class=\"p\">,</span> <span class=\"mi\">10</span><span class=\"p\">))</span>\n<span class=\"p\">)</span>\n\n<span class=\"n\">chain</span> <span class=\"o\">=</span> <span class=\"n\">Chain</span><span class=\"p\">(</span><span class=\"n\">loop</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n<span class=\"n\">chain</span><span class=\"o\">.</span><span class=\"n\">add_sequences</span><span class=\"p\">(</span>\n    <span class=\"p\">(</span><span class=\"n\">my_first_sprite</span><span class=\"p\">,</span> <span class=\"n\">sequence1</span><span class=\"p\">),</span>\n    <span class=\"p\">(</span><span class=\"n\">my_second_sprite</span><span class=\"p\">,</span> <span class=\"n\">sequence2</span><span class=\"p\">)</span>\n<span class=\"p\">)</span>\n\n<span class=\"n\">start_scene</span><span class=\"o\">.</span><span class=\"n\">animations</span><span class=\"o\">.</span><span class=\"n\">fire</span><span class=\"p\">(</span><span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"n\">chain</span><span class=\"p\">)</span>\n</pre>\n<h3>Animation utility functions</h3>\n<h4>KeyFrame from sprite</h4>\n<p>Create a keyframe from the current state of a sprite</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">arcade_curtains</span> <span class=\"kn\">import</span> <span class=\"n\">KeyFrame</span>\n\n<span class=\"n\">frame</span> <span class=\"o\">=</span> <span class=\"n\">KeyFrame</span><span class=\"o\">.</span><span class=\"n\">from_sprite</span><span class=\"p\">(</span><span class=\"n\">my_sprite</span><span class=\"p\">)</span>\n<span class=\"n\">frame</span> <span class=\"o\">=</span> <span class=\"n\">KeyFrame</span><span class=\"o\">.</span><span class=\"n\">from_sprite</span><span class=\"p\">(</span><span class=\"n\">my_sprite</span><span class=\"p\">,</span> <span class=\"n\">only_keys</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"s1\">'angle'</span><span class=\"p\">,</span> <span class=\"s1\">'scale'</span><span class=\"p\">])</span>\n</pre>\n<h4>Sequence from sprite</h4>\n<p>Create a sequence with one keyframe at the 0 point in time, from the current state of a sprite</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">arcade_curtains</span> <span class=\"kn\">import</span> <span class=\"n\">Sequence</span>\n\n<span class=\"n\">seq</span> <span class=\"o\">=</span> <span class=\"n\">Sequence</span><span class=\"o\">.</span><span class=\"n\">from_sprite</span><span class=\"p\">(</span><span class=\"n\">my_sprite</span><span class=\"p\">)</span>\n</pre>\n<h2>Helpers</h2>\n<p>This module provides a number of interesting things to allow you to write your game faster and more smoothly.</p>\n<h3>General utilities</h3>\n<h4>delay_set_attribute</h4>\n<p>This is a small helper function that allows you to set an attribute on an object as a callback.</p>\n<pre><span class=\"c1\"># Will set the health attribute to 10 when clicked</span>\n<span class=\"n\">events</span><span class=\"o\">.</span><span class=\"n\">click</span><span class=\"p\">(</span><span class=\"n\">sprite</span><span class=\"p\">,</span> <span class=\"n\">delay_set_attribute</span><span class=\"p\">(</span><span class=\"n\">sprite</span><span class=\"p\">,</span> <span class=\"s1\">'health'</span><span class=\"p\">,</span> <span class=\"mi\">10</span><span class=\"p\">))</span>\n</pre>\n<h4>Position helper</h4>\n<p><code>arcade.Sprite</code>s and everything that subclasses it are outfitted with <code>topleft</code>, <code>topright</code>, <code>bottomleft</code>, <code>bottomright</code> coordinates. It functions the same as position, meaning it returns an x and a y coordinate.</p>\n<p>A small disclaimer, to be conform with position, the return values of these properties are (x, y) which is the inverse of the naming, but \"lefttop\" doesn't really roll off the tongue.</p>\n<h3>ObservableSprite</h3>\n<p>An <code>ObservableSprite</code> is a subclass from <code>arcade.Sprite</code> that allows you to attach handlers to attribute modifications.</p>\n<h4>before_change/after_change events</h4>\n<p>You can define a callback and have it be called whenever the targetted attribute changes</p>\n<pre><span class=\"n\">sprite</span><span class=\"o\">.</span><span class=\"n\">before_change</span><span class=\"p\">(</span><span class=\"s1\">'health'</span><span class=\"p\">,</span> <span class=\"n\">controller</span><span class=\"o\">.</span><span class=\"n\">validate_health_change</span><span class=\"p\">)</span>\n<span class=\"n\">sprite</span><span class=\"o\">.</span><span class=\"n\">after_change</span><span class=\"p\">(</span><span class=\"s1\">'health'</span><span class=\"p\">,</span> <span class=\"n\">controller</span><span class=\"o\">.</span><span class=\"n\">notify_health_change</span><span class=\"p\">)</span>\n</pre>\n<p>In the example below, the bottom circle is being moved every frame and has an <code>after_change</code> handler defined, to set the second sprite, as followed</p>\n<pre><span class=\"n\">mod</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>\n<span class=\"k\">def</span> <span class=\"nf\">keep_pace</span><span class=\"p\">(</span><span class=\"n\">sprite</span><span class=\"p\">,</span> <span class=\"n\">attribute</span><span class=\"p\">,</span> <span class=\"n\">old</span><span class=\"p\">,</span> <span class=\"n\">new</span><span class=\"p\">):</span>\n    <span class=\"nb\">setattr</span><span class=\"p\">(</span><span class=\"n\">sprite2</span><span class=\"p\">,</span> <span class=\"n\">attribute</span><span class=\"p\">,</span> <span class=\"n\">new</span><span class=\"p\">)</span>\n\n<span class=\"n\">sprite1</span><span class=\"o\">.</span><span class=\"n\">after_change</span><span class=\"p\">(</span><span class=\"s1\">'center_x'</span><span class=\"p\">,</span> <span class=\"n\">keep_pace</span><span class=\"p\">)</span>\n</pre>\n<p><img alt=\"Showcasing Anchor\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/795f2f6599496a618278942eabd86a9038d691ee/68747470733a2f2f7261772e67697468756275736572636f6e74656e742e636f6d2f6d61617274656e2d64702f6172636164652d6375727461696e732f6d61737465722f6173736574732f6f6273657276652e676966\"></p>\n<h4>triggers</h4>\n<p>An <code>ObservableSprite</code> allows you to define a trigger that is run whenever a certain condition is met. For instance, you want your handler to run if health is equal or below 0.</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">arcade_curtains</span> <span class=\"kn\">import</span> <span class=\"n\">TriggerAttr</span>\n<span class=\"c1\"># Build a triggerable attribute definition</span>\n<span class=\"n\">health</span> <span class=\"o\">=</span> <span class=\"n\">TriggerAttr</span><span class=\"p\">(</span><span class=\"s1\">'health'</span><span class=\"p\">)</span>\n<span class=\"n\">sprite</span><span class=\"o\">.</span><span class=\"n\">trigger</span><span class=\"p\">(</span><span class=\"n\">health</span> <span class=\"o\">&lt;</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">sprite</span><span class=\"o\">.</span><span class=\"n\">die</span><span class=\"p\">)</span>\n</pre>\n<h3>Widgets</h3>\n<p>A <code>Widget</code> is a baseclass for grouping <code>Sprite</code>s into a widget. It allows a number of sprites to work together, while still maintaining the fine grained control over each sprite. <code>Widget</code>s use <code>AnchorPoint</code>s underneath to work as a group.</p>\n<h4>AnchorPoint</h4>\n<p>An <code>AnchorPoint</code> is an object that is just an <code>x, y</code> coordinate, but you can affix sprites to this anchor. Whenever you move the anchor, all affixed sprites move with it.</p>\n<pre><span class=\"n\">sprite1</span><span class=\"o\">.</span><span class=\"n\">position</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"mi\">100</span><span class=\"p\">,</span> <span class=\"mi\">100</span><span class=\"p\">)</span>\n<span class=\"n\">sprite2</span><span class=\"o\">.</span><span class=\"n\">position</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"mi\">200</span><span class=\"p\">,</span> <span class=\"mi\">200</span><span class=\"p\">)</span>\n<span class=\"n\">anchor</span> <span class=\"o\">=</span> <span class=\"n\">AnchorPoint</span><span class=\"o\">.</span><span class=\"n\">from_sprite</span><span class=\"p\">(</span><span class=\"n\">sprite1</span><span class=\"p\">,</span> <span class=\"s1\">'position'</span><span class=\"p\">)</span>\n<span class=\"n\">anchor</span><span class=\"o\">.</span><span class=\"n\">dock</span><span class=\"p\">(</span><span class=\"n\">sprite2</span><span class=\"p\">)</span>\n<span class=\"c1\"># Will move sprite1 and sprite2 relative to the anchor</span>\n<span class=\"n\">anchor</span><span class=\"o\">.</span><span class=\"n\">position</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"mi\">300</span><span class=\"p\">,</span> <span class=\"mi\">300</span><span class=\"p\">)</span>\n<span class=\"k\">assert</span> <span class=\"n\">sprite1</span><span class=\"o\">.</span><span class=\"n\">position</span> <span class=\"o\">==</span> <span class=\"p\">(</span><span class=\"mi\">300</span><span class=\"p\">,</span> <span class=\"mi\">300</span><span class=\"p\">)</span>\n<span class=\"k\">assert</span> <span class=\"n\">sprite2</span><span class=\"o\">.</span><span class=\"n\">position</span> <span class=\"o\">==</span> <span class=\"p\">(</span><span class=\"mi\">400</span><span class=\"p\">,</span> <span class=\"mi\">400</span><span class=\"p\">)</span>\n</pre>\n<p>This example shows all orbs are being anchored on an anchorpoint that is defined on the largest orb's position. When moving the large orb, the smaller, orbing orbs are moved as well</p>\n<p><img alt=\"Showcasing Anchor\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/c55f386a8d440cae39cde66535054e1fc4b5f603/68747470733a2f2f7261772e67697468756275736572636f6e74656e742e636f6d2f6d61617274656e2d64702f6172636164652d6375727461696e732f6d61737465722f6173736574732f616e63686f722e676966\"></p>\n<h4>Widget</h4>\n<p>You can consider a <code>Widget</code> to be a \"view\" where you can define your sprites relative to the (0, 0) coordinate. <code>Widget</code> starting coordinates will be inferred from the defined sprites within the widget. After initialisation you are able to manipulate these, to move your widget to the desired location.</p>\n<p>The baseclass is outfitted with a <code>self.sprites</code> where you can add the sprites defined in your widget. After initializing your widget, you will have to register a spritelist to have your sprites drawn on screen.</p>\n<pre><span class=\"k\">class</span> <span class=\"nc\">MyWidget</span><span class=\"p\">(</span><span class=\"n\">Widget</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"nf\">setup_widget</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"n\">sprite1</span> <span class=\"o\">=</span> <span class=\"n\">arcade</span><span class=\"o\">.</span><span class=\"n\">Sprite</span><span class=\"p\">(</span><span class=\"n\">TEXTURE1</span><span class=\"p\">)</span>\n        <span class=\"n\">sprite1</span><span class=\"o\">.</span><span class=\"n\">bottomleft</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">)</span>\n        <span class=\"n\">sprite2</span> <span class=\"o\">=</span> <span class=\"n\">arcade</span><span class=\"o\">.</span><span class=\"n\">Sprite</span><span class=\"p\">(</span><span class=\"n\">TEXTURE2</span><span class=\"p\">)</span>\n        <span class=\"n\">sprite2</span><span class=\"o\">.</span><span class=\"n\">bottomleft</span> <span class=\"o\">=</span> <span class=\"n\">sprite1</span><span class=\"o\">.</span><span class=\"n\">topleft</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">sprites</span><span class=\"o\">.</span><span class=\"n\">extend</span><span class=\"p\">([</span><span class=\"n\">sprite1</span><span class=\"p\">,</span> <span class=\"n\">sprite2</span><span class=\"p\">])</span>\n\n<span class=\"n\">spritelist</span> <span class=\"o\">=</span> <span class=\"n\">arcade</span><span class=\"o\">.</span><span class=\"n\">SpriteList</span><span class=\"p\">()</span>\n<span class=\"n\">widget</span> <span class=\"o\">=</span> <span class=\"n\">MyWidget</span><span class=\"p\">()</span>\n<span class=\"n\">widget</span><span class=\"o\">.</span><span class=\"n\">position</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">SCREEN_WIDTH</span> <span class=\"o\">/</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"n\">SCREEN_HEIGHT</span> <span class=\"o\">/</span> <span class=\"mi\">2</span><span class=\"p\">)</span>\n<span class=\"c1\"># register the sprites to an arcade spritelist</span>\n<span class=\"n\">widget</span><span class=\"o\">.</span><span class=\"n\">register</span><span class=\"p\">(</span><span class=\"n\">spritelist</span><span class=\"p\">)</span>\n</pre>\n\n          </div>"}, "last_serial": 6631885, "releases": {"0.0.1": [{"comment_text": "", "digests": {"md5": "815f0d2ab3bc2dee12f991b95b8ac782", "sha256": "5cd69a98c463594e98293726fbc7f1cdca790e5e8355b5f72426f93039750838"}, "downloads": -1, "filename": "arcade_curtains-0.0.1-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "815f0d2ab3bc2dee12f991b95b8ac782", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 8310, "upload_time": "2019-11-04T13:34:18", "upload_time_iso_8601": "2019-11-04T13:34:18.499796Z", "url": "https://files.pythonhosted.org/packages/ab/d4/e2a5d94a07d8a17d2dfe522789de2014efeccda820d79111f561c147f05a/arcade_curtains-0.0.1-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "9465477debb159030960c040e4f1e668", "sha256": "fe4567a5459562d0bc2eba13c5d3b5e8fb9c13ab16f8459804ae90eb40117720"}, "downloads": -1, "filename": "arcade-curtains-0.0.1.tar.gz", "has_sig": false, "md5_digest": "9465477debb159030960c040e4f1e668", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 13265, "upload_time": "2019-11-04T13:34:20", "upload_time_iso_8601": "2019-11-04T13:34:20.740611Z", "url": "https://files.pythonhosted.org/packages/da/ff/fac3c4c0c8216dfb677d65b4f76a46cebad829d93ece49ec22fb0d2c70a2/arcade-curtains-0.0.1.tar.gz", "yanked": false}], "0.1.0": [{"comment_text": "", "digests": {"md5": "523e4519d85c2249b58922e1f09784bd", "sha256": "f9d054e0097e3ae8063c8e4f6515a692a46bb0a04e0f564c76b48825139cb7eb"}, "downloads": -1, "filename": "arcade_curtains-0.1.0-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "523e4519d85c2249b58922e1f09784bd", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 12946, "upload_time": "2020-01-08T23:12:27", "upload_time_iso_8601": "2020-01-08T23:12:27.810269Z", "url": "https://files.pythonhosted.org/packages/c6/7c/58c9d3d2e85c0cdfa165b48e3d33607368e2f7b57615adb1f61c0568fdf1/arcade_curtains-0.1.0-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "71927a40e9dfcf22f8b147a7303873b5", "sha256": "c853e7a80f5be04e3e5a3d5f026e192d71e4b3f4a047c1c39b57137d0ed48f9f"}, "downloads": -1, "filename": "arcade-curtains-0.1.0.tar.gz", "has_sig": false, "md5_digest": "71927a40e9dfcf22f8b147a7303873b5", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 1036873, "upload_time": "2020-01-08T23:12:29", "upload_time_iso_8601": "2020-01-08T23:12:29.900230Z", "url": "https://files.pythonhosted.org/packages/6d/e5/7475d32cb54d54eceb7474e390aab90dc934c066c9bfe805830c689df925/arcade-curtains-0.1.0.tar.gz", "yanked": false}], "0.2.0": [{"comment_text": "", "digests": {"md5": "a4d04ca7ffb9fdc2a167b93c2c5eab20", "sha256": "d9dbfddbc9a3c9cf261b22de2802fb3378297b277e98d3afec356b8099e24ac8"}, "downloads": -1, "filename": "arcade_curtains-0.2.0-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "a4d04ca7ffb9fdc2a167b93c2c5eab20", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 17051, "upload_time": "2020-02-14T15:12:20", "upload_time_iso_8601": "2020-02-14T15:12:20.319155Z", "url": "https://files.pythonhosted.org/packages/e7/d4/cde63677c5fd307565fd654e5ca821a1414ff192d657207729d0a6590e86/arcade_curtains-0.2.0-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "ca03e51211fb57e1edecad75febf8820", "sha256": "fddaac93d8a87d43901389943a288114ecf2aa5154fe191250f7a90dd26690fc"}, "downloads": -1, "filename": "arcade-curtains-0.2.0.tar.gz", "has_sig": false, "md5_digest": "ca03e51211fb57e1edecad75febf8820", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 13827984, "upload_time": "2020-02-14T15:12:22", "upload_time_iso_8601": "2020-02-14T15:12:22.946778Z", "url": "https://files.pythonhosted.org/packages/7e/f3/21e103f9929e426ffe908e75a2fdb570d8702caa1fc939200b91ccd71b96/arcade-curtains-0.2.0.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "a4d04ca7ffb9fdc2a167b93c2c5eab20", "sha256": "d9dbfddbc9a3c9cf261b22de2802fb3378297b277e98d3afec356b8099e24ac8"}, "downloads": -1, "filename": "arcade_curtains-0.2.0-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "a4d04ca7ffb9fdc2a167b93c2c5eab20", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 17051, "upload_time": "2020-02-14T15:12:20", "upload_time_iso_8601": "2020-02-14T15:12:20.319155Z", "url": "https://files.pythonhosted.org/packages/e7/d4/cde63677c5fd307565fd654e5ca821a1414ff192d657207729d0a6590e86/arcade_curtains-0.2.0-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "ca03e51211fb57e1edecad75febf8820", "sha256": "fddaac93d8a87d43901389943a288114ecf2aa5154fe191250f7a90dd26690fc"}, "downloads": -1, "filename": "arcade-curtains-0.2.0.tar.gz", "has_sig": false, "md5_digest": "ca03e51211fb57e1edecad75febf8820", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 13827984, "upload_time": "2020-02-14T15:12:22", "upload_time_iso_8601": "2020-02-14T15:12:22.946778Z", "url": "https://files.pythonhosted.org/packages/7e/f3/21e103f9929e426ffe908e75a2fdb570d8702caa1fc939200b91ccd71b96/arcade-curtains-0.2.0.tar.gz", "yanked": false}], "timestamp": "Thu May  7 18:17:26 2020"}