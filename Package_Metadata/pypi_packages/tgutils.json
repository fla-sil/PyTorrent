{"info": {"author": "Oren Ben-Kiki", "author_email": "oren@ben-kiki.org", "bugtrack_url": null, "classifiers": ["Development Status :: 3 - Alpha", "Intended Audience :: Developers", "License :: OSI Approved :: MIT License", "Programming Language :: Python :: 3.6", "Programming Language :: Python :: 3.7", "Topic :: Scientific/Engineering :: Bio-Informatics"], "description": "TGUtils - Utilities for Tanay Group lab code\n============================================\n\n.. image:: https://travis-ci.org/tanaylab/tgutils.svg?branch=master\n    :target: https://travis-ci.org/tanaylab/tgutils\n\n.. image:: https://readthedocs.org/projects/tgutils/badge/?version=latest\n    :target: https://tgutils.readthedocs.io/en/latest/?badge=latest\n    :alt: Documentation Status\n\nThis package contains common utilities used by the Tanay Group Python lab code (for example,\n``metacell``). These utilities are generally useful and not associated with any specific project.\n\nPhantom Types\n-------------\n\nThe vanilla ``np.ndarray``, ``pd.Series`` and ``pd.DataFrame`` types are very generic. They are the\nsame regardless of the element data type used, and in the case of ``np.ndarray``, the number of\ndimensions (array vs. matrix).\n\nTo understand the code, it is helpful to keep track of a more detailed data type - whether the\nvariable is an array or a matrix, and what the element data type is. To facilitate this, ``tgutils``\nprovides what is known as \"Phantom Types\". These types can be used in ``mypy`` type declarations,\neven though the actual data type of the variables remains the vanilla Numpy/Pandas data type.\n\nSee ``tgutils.numpy`` and ``tgutils.pandas`` for the list of provided phantom types. To\nuse them, instead of the vanilla:\n\n.. code-block:: python\n\n    import numpy as np\n    import pandas as pd\n\nWrite the modified:\n\n.. code-block:: python\n\n    import tgutils.numpy as np\n    import tgutils.pandas as pd\n\nThis this will provide access to the vanilla symbols using the ``np.`` and/or ``pd.`` prefixes, and\nwill also provide access to the enhanced functionality described below.\n\nFor example, instead of writing:\n\n.. code-block:: python\n\n    def compute_some_integers() -> np.ndarray:\n        ...\n\n    def compute_some_floats() -> np.ndarray:\n        ...\n\n    def compute_stuff(foo: np.ndarray, bar: np.ndarray) -> ...:\n        ...\n\n    def workflow() -> ...:\n        foo = compute_some_integers()\n        bar = compute_some_floats()\n        compute_stuff(foo, bar)\n\nYou should write:\n\n.. code-block:: python\n\n    def compute_some_integers() -> np.ArrayInt32:\n        ...\n\n    def compute_some_floats() -> np.MatrixFloat64:\n        ...\n\n    def compute_stuff(foo: np.ArrayInt32, bar: np.MatrixFloat64) -> ...:\n        ...\n\n    def workflow() -> ...:\n        foo = compute_some_integers()\n        bar = compute_some_floats()\n        compute_stuff(foo, bar)\n\nThis will allow the reader to understand the exact data types involved. Even better, it will allow\n``mypy`` to verify that you actually pass the correct data type to each function invocation.\nFor example, if you by mistake write ``compute_stuff(bar, foo)`` then ``mypy`` will complain that\nthe data types do not match - even though, under the covers, both ``foo`` and ``bar`` have exactly\nthe same data type at run-time: ``np.ndarray``.\n\nTo further help with ``mypy`` type checking, the ``tgutils`` package includes a ``stubs`` directory\ncontaining very partial quick-and-dirty type stubs for ``numpy`` and ``pandas`` (ideally, some brave\nsoul(s) would tackle the very difficult issue of providing proper stubs for these libraries,\nallowing for the removal of the ``tgutils`` stubs). Importing ``tgutils.setup_mypy`` module\nset ``MYPYPATH`` to this stubs directory, which is also a hack (see the ``metacell`` package for an\nexample of using this in your ``setup.py`` file).\n\nType Operations\n...............\n\nControl over the data types is also important when performing computations. It affects performance,\nmemory consumption and even the semantics of some operations. For example, integer elements can\nnever be ``NaN`` while floating point elements can, boolean elements have their own logic, and\nstring elements are different from numeric elements.\n\nTo help with this, ``tgutils`` provides two functions, ``am`` and ``be``. Both these functions\nreturn the requested data type, but ``am`` is just an assertion while ``be`` is a cast operation.\nThat is, writing ``ArrayInt32.am(foo)`` will return ``foo`` as an ``ArrayInt32``, or will raise an\nerror if ``foo`` is not an array of ``int32``; while writing ``ArrayInt32.be(foo)`` will always\nreturn an ``ArrayInt32``, which is either ``foo`` if it is an array of ``int32``, or a copy of\n``foo`` whose elements are the conversion of the elements of ``foo`` to ``int32``.\n\nDe/serialization\n................\n\nThe phantom types also provide read and write operations for efficiently storing data on the disk.\nThat is, writing ``ArrayInt32.read(path)`` will read an array of ``int32`` elements from the\nspecified path, and ``ArrayInt32.write(foo, path)`` will write an array of ``int32`` elements\ninto the specified path.\n\nDynaMake\n--------\n\nImport ``tgutils.make`` instead of ``dynamake.make``. This will achieve the following:\n\nUsing Qsub\n..........\n\nThe ``tgutils.tg_qsub`` script deals with submitting jobs to run on the SunGrid cluster in the\nTanay Group lab.\n\nA ``tgutils.make.tg_require`` function allows for collecting context for optimizing the slot\nallocation of ``tg_qsub`` for maximizing the cluster utilization and minimizing wait times. This has\nno effect unless the collected context values are explicitly used in the ``run_prefix`` and/or\n``run_suffix`` action wrapper of some step.\n\nThis is a convoluted and sub-optimal mechanism but has significant performance benefits in the\nspecific environment it was designed for.\n\nApplications\n------------\n\nImport ``tgutils.application`` instead of ``dynamake.application``. This will achieve the following:\n\nResources\n.........\n\nBy default, the Python process is restricted in the number of simultaneous open files. This\nis raised by ``tgutils`` to the maximum allowed by the operating system.\n\nNumpy Errors\n............\n\nBy default, ``numpy`` ignores several kinds of numeric errors. This is modified by ``tgutils``\nto raise an appropriate exception. This increases the robustness of the results.\n\nNumpy Random Number Generation\n..............................\n\nBy default, ``dynamake`` only handles the Python random number generator. This is extended by\n``tgutils`` so that the ``numpy`` random number generator is seeded with the same seeds as the\nPython random number generator, even in parallel calls. This seeding ensures results are replicable\n(when using the same non-zero seed).\n\nLogging\n.......\n\nThe default Python logging that prints to ``stderr`` works well for a single application. However,\nwhen running multiple applications in parallel, log messages may get interleaved resulting in\ngarbled output.\n\nThis is solved by ``tgutils`` using the ``tgutils.application.tg_qsub_logger``, which wraps\nthe default logger with a ``tgutils.application.FileLockLoggerAdapter``. This uses a file\nlock operation around each emitted log message to ensure it is atomic. The lock file is chosen\nto be compatible with the one used by the ``tgutils.tg_qsub`` script, so that log messages\nfrom this script will also be protected.\n\nParallel\n........\n\nWhen running a large number of very small tasks, it possible to let ``multiprocessing.Pool`` run\neach task on the much smaller number of available threads. However, this is less efficient. An\nalternative is to use ``tgutils.application.indexed_range`` which will partition the large\nrange of task indices into equal-sized sub-ranges, one per process. Reporting progress can be\ndone using the ``tgutils.application.ParallelCounter`` class.\n\nOther Utilities\n---------------\n\nTests\n.....\n\nThe provided ``tgutils.tests`` module provides ``TestWithReset`` which properly\nresets all the global state for each test, and ``TestWithFiles`` which also creates\na fresh temporary directory for each test. You can create new files using\n``tgutils.tests.write_file`` and verify file contents using\n``tgutils.tests.TestWithFiles.expect_file``.\n\nCaching\n.......\n\nYou can use the ``tgutils.cache.Cache`` class for a lightweight generic cache mechanism.\nIt uses weak references to hold onto expensive-to-compute data.\n\nYAML\n....\n\nYou can use ``tgutils.load_yaml.load_dictionary`` for a lightweight verification of loaded\nYAML data.", "description_content_type": "text/x-rst", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/tanaylab/tgutils.git", "keywords": "pandas numpy bioinformatics", "license": "MIT", "maintainer": "", "maintainer_email": "", "name": "tgutils", "package_url": "https://pypi.org/project/tgutils/", "platform": "", "project_url": "https://pypi.org/project/tgutils/", "project_urls": {"Homepage": "https://github.com/tanaylab/tgutils.git"}, "release_url": "https://pypi.org/project/tgutils/0.2.29/", "requires_dist": null, "requires_python": "", "summary": "Common utilities used by the Tanay Group Python lab code.", "version": "0.2.29", "yanked": false, "html_description": "<div class=\"project-description\">\n            <a href=\"https://travis-ci.org/tanaylab/tgutils\" rel=\"nofollow\"><img alt=\"https://travis-ci.org/tanaylab/tgutils.svg?branch=master\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/4e2e64979c3a3a1a8982b07288dc598f008d9754/68747470733a2f2f7472617669732d63692e6f72672f74616e61796c61622f74677574696c732e7376673f6272616e63683d6d6173746572\"></a>\n<a href=\"https://tgutils.readthedocs.io/en/latest/?badge=latest\" rel=\"nofollow\"><img alt=\"Documentation Status\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/f3f03c9d3c8826c3ed1e0214b7f8dd2ee1298585/68747470733a2f2f72656164746865646f63732e6f72672f70726f6a656374732f74677574696c732f62616467652f3f76657273696f6e3d6c6174657374\"></a>\n<p>This package contains common utilities used by the Tanay Group Python lab code (for example,\n<tt>metacell</tt>). These utilities are generally useful and not associated with any specific project.</p>\n<div id=\"phantom-types\">\n<h2>Phantom Types</h2>\n<p>The vanilla <tt>np.ndarray</tt>, <tt>pd.Series</tt> and <tt>pd.DataFrame</tt> types are very generic. They are the\nsame regardless of the element data type used, and in the case of <tt>np.ndarray</tt>, the number of\ndimensions (array vs. matrix).</p>\n<p>To understand the code, it is helpful to keep track of a more detailed data type - whether the\nvariable is an array or a matrix, and what the element data type is. To facilitate this, <tt>tgutils</tt>\nprovides what is known as \u201cPhantom Types\u201d. These types can be used in <tt>mypy</tt> type declarations,\neven though the actual data type of the variables remains the vanilla Numpy/Pandas data type.</p>\n<p>See <tt>tgutils.numpy</tt> and <tt>tgutils.pandas</tt> for the list of provided phantom types. To\nuse them, instead of the vanilla:</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">numpy</span> <span class=\"k\">as</span> <span class=\"nn\">np</span>\n<span class=\"kn\">import</span> <span class=\"nn\">pandas</span> <span class=\"k\">as</span> <span class=\"nn\">pd</span>\n</pre>\n<p>Write the modified:</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">tgutils.numpy</span> <span class=\"k\">as</span> <span class=\"nn\">np</span>\n<span class=\"kn\">import</span> <span class=\"nn\">tgutils.pandas</span> <span class=\"k\">as</span> <span class=\"nn\">pd</span>\n</pre>\n<p>This this will provide access to the vanilla symbols using the <tt>np.</tt> and/or <tt>pd.</tt> prefixes, and\nwill also provide access to the enhanced functionality described below.</p>\n<p>For example, instead of writing:</p>\n<pre><span class=\"k\">def</span> <span class=\"nf\">compute_some_integers</span><span class=\"p\">()</span> <span class=\"o\">-&gt;</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">:</span>\n    <span class=\"o\">...</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">compute_some_floats</span><span class=\"p\">()</span> <span class=\"o\">-&gt;</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">:</span>\n    <span class=\"o\">...</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">compute_stuff</span><span class=\"p\">(</span><span class=\"n\">foo</span><span class=\"p\">:</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"n\">bar</span><span class=\"p\">:</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"o\">...</span><span class=\"p\">:</span>\n    <span class=\"o\">...</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">workflow</span><span class=\"p\">()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">...</span><span class=\"p\">:</span>\n    <span class=\"n\">foo</span> <span class=\"o\">=</span> <span class=\"n\">compute_some_integers</span><span class=\"p\">()</span>\n    <span class=\"n\">bar</span> <span class=\"o\">=</span> <span class=\"n\">compute_some_floats</span><span class=\"p\">()</span>\n    <span class=\"n\">compute_stuff</span><span class=\"p\">(</span><span class=\"n\">foo</span><span class=\"p\">,</span> <span class=\"n\">bar</span><span class=\"p\">)</span>\n</pre>\n<p>You should write:</p>\n<pre><span class=\"k\">def</span> <span class=\"nf\">compute_some_integers</span><span class=\"p\">()</span> <span class=\"o\">-&gt;</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">ArrayInt32</span><span class=\"p\">:</span>\n    <span class=\"o\">...</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">compute_some_floats</span><span class=\"p\">()</span> <span class=\"o\">-&gt;</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">MatrixFloat64</span><span class=\"p\">:</span>\n    <span class=\"o\">...</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">compute_stuff</span><span class=\"p\">(</span><span class=\"n\">foo</span><span class=\"p\">:</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">ArrayInt32</span><span class=\"p\">,</span> <span class=\"n\">bar</span><span class=\"p\">:</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">MatrixFloat64</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"o\">...</span><span class=\"p\">:</span>\n    <span class=\"o\">...</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">workflow</span><span class=\"p\">()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">...</span><span class=\"p\">:</span>\n    <span class=\"n\">foo</span> <span class=\"o\">=</span> <span class=\"n\">compute_some_integers</span><span class=\"p\">()</span>\n    <span class=\"n\">bar</span> <span class=\"o\">=</span> <span class=\"n\">compute_some_floats</span><span class=\"p\">()</span>\n    <span class=\"n\">compute_stuff</span><span class=\"p\">(</span><span class=\"n\">foo</span><span class=\"p\">,</span> <span class=\"n\">bar</span><span class=\"p\">)</span>\n</pre>\n<p>This will allow the reader to understand the exact data types involved. Even better, it will allow\n<tt>mypy</tt> to verify that you actually pass the correct data type to each function invocation.\nFor example, if you by mistake write <tt>compute_stuff(bar, foo)</tt> then <tt>mypy</tt> will complain that\nthe data types do not match - even though, under the covers, both <tt>foo</tt> and <tt>bar</tt> have exactly\nthe same data type at run-time: <tt>np.ndarray</tt>.</p>\n<p>To further help with <tt>mypy</tt> type checking, the <tt>tgutils</tt> package includes a <tt>stubs</tt> directory\ncontaining very partial quick-and-dirty type stubs for <tt>numpy</tt> and <tt>pandas</tt> (ideally, some brave\nsoul(s) would tackle the very difficult issue of providing proper stubs for these libraries,\nallowing for the removal of the <tt>tgutils</tt> stubs). Importing <tt>tgutils.setup_mypy</tt> module\nset <tt>MYPYPATH</tt> to this stubs directory, which is also a hack (see the <tt>metacell</tt> package for an\nexample of using this in your <tt>setup.py</tt> file).</p>\n<div id=\"type-operations\">\n<h3>Type Operations</h3>\n<p>Control over the data types is also important when performing computations. It affects performance,\nmemory consumption and even the semantics of some operations. For example, integer elements can\nnever be <tt>NaN</tt> while floating point elements can, boolean elements have their own logic, and\nstring elements are different from numeric elements.</p>\n<p>To help with this, <tt>tgutils</tt> provides two functions, <tt>am</tt> and <tt>be</tt>. Both these functions\nreturn the requested data type, but <tt>am</tt> is just an assertion while <tt>be</tt> is a cast operation.\nThat is, writing <tt>ArrayInt32.am(foo)</tt> will return <tt>foo</tt> as an <tt>ArrayInt32</tt>, or will raise an\nerror if <tt>foo</tt> is not an array of <tt>int32</tt>; while writing <tt>ArrayInt32.be(foo)</tt> will always\nreturn an <tt>ArrayInt32</tt>, which is either <tt>foo</tt> if it is an array of <tt>int32</tt>, or a copy of\n<tt>foo</tt> whose elements are the conversion of the elements of <tt>foo</tt> to <tt>int32</tt>.</p>\n</div>\n<div id=\"de-serialization\">\n<h3>De/serialization</h3>\n<p>The phantom types also provide read and write operations for efficiently storing data on the disk.\nThat is, writing <tt>ArrayInt32.read(path)</tt> will read an array of <tt>int32</tt> elements from the\nspecified path, and <tt>ArrayInt32.write(foo, path)</tt> will write an array of <tt>int32</tt> elements\ninto the specified path.</p>\n</div>\n</div>\n<div id=\"dynamake\">\n<h2>DynaMake</h2>\n<p>Import <tt>tgutils.make</tt> instead of <tt>dynamake.make</tt>. This will achieve the following:</p>\n<div id=\"using-qsub\">\n<h3>Using Qsub</h3>\n<p>The <tt>tgutils.tg_qsub</tt> script deals with submitting jobs to run on the SunGrid cluster in the\nTanay Group lab.</p>\n<p>A <tt>tgutils.make.tg_require</tt> function allows for collecting context for optimizing the slot\nallocation of <tt>tg_qsub</tt> for maximizing the cluster utilization and minimizing wait times. This has\nno effect unless the collected context values are explicitly used in the <tt>run_prefix</tt> and/or\n<tt>run_suffix</tt> action wrapper of some step.</p>\n<p>This is a convoluted and sub-optimal mechanism but has significant performance benefits in the\nspecific environment it was designed for.</p>\n</div>\n</div>\n<div id=\"applications\">\n<h2>Applications</h2>\n<p>Import <tt>tgutils.application</tt> instead of <tt>dynamake.application</tt>. This will achieve the following:</p>\n<div id=\"resources\">\n<h3>Resources</h3>\n<p>By default, the Python process is restricted in the number of simultaneous open files. This\nis raised by <tt>tgutils</tt> to the maximum allowed by the operating system.</p>\n</div>\n<div id=\"numpy-errors\">\n<h3>Numpy Errors</h3>\n<p>By default, <tt>numpy</tt> ignores several kinds of numeric errors. This is modified by <tt>tgutils</tt>\nto raise an appropriate exception. This increases the robustness of the results.</p>\n</div>\n<div id=\"numpy-random-number-generation\">\n<h3>Numpy Random Number Generation</h3>\n<p>By default, <tt>dynamake</tt> only handles the Python random number generator. This is extended by\n<tt>tgutils</tt> so that the <tt>numpy</tt> random number generator is seeded with the same seeds as the\nPython random number generator, even in parallel calls. This seeding ensures results are replicable\n(when using the same non-zero seed).</p>\n</div>\n<div id=\"logging\">\n<h3>Logging</h3>\n<p>The default Python logging that prints to <tt>stderr</tt> works well for a single application. However,\nwhen running multiple applications in parallel, log messages may get interleaved resulting in\ngarbled output.</p>\n<p>This is solved by <tt>tgutils</tt> using the <tt>tgutils.application.tg_qsub_logger</tt>, which wraps\nthe default logger with a <tt>tgutils.application.FileLockLoggerAdapter</tt>. This uses a file\nlock operation around each emitted log message to ensure it is atomic. The lock file is chosen\nto be compatible with the one used by the <tt>tgutils.tg_qsub</tt> script, so that log messages\nfrom this script will also be protected.</p>\n</div>\n<div id=\"parallel\">\n<h3>Parallel</h3>\n<p>When running a large number of very small tasks, it possible to let <tt>multiprocessing.Pool</tt> run\neach task on the much smaller number of available threads. However, this is less efficient. An\nalternative is to use <tt>tgutils.application.indexed_range</tt> which will partition the large\nrange of task indices into equal-sized sub-ranges, one per process. Reporting progress can be\ndone using the <tt>tgutils.application.ParallelCounter</tt> class.</p>\n</div>\n</div>\n<div id=\"other-utilities\">\n<h2>Other Utilities</h2>\n<div id=\"tests\">\n<h3>Tests</h3>\n<p>The provided <tt>tgutils.tests</tt> module provides <tt>TestWithReset</tt> which properly\nresets all the global state for each test, and <tt>TestWithFiles</tt> which also creates\na fresh temporary directory for each test. You can create new files using\n<tt>tgutils.tests.write_file</tt> and verify file contents using\n<tt>tgutils.tests.TestWithFiles.expect_file</tt>.</p>\n</div>\n<div id=\"caching\">\n<h3>Caching</h3>\n<p>You can use the <tt>tgutils.cache.Cache</tt> class for a lightweight generic cache mechanism.\nIt uses weak references to hold onto expensive-to-compute data.</p>\n</div>\n<div id=\"yaml\">\n<h3>YAML</h3>\n<p>You can use <tt>tgutils.load_yaml.load_dictionary</tt> for a lightweight verification of loaded\nYAML data.</p>\n</div>\n</div>\n\n          </div>"}, "last_serial": 6561708, "releases": {"0.2.29": [{"comment_text": "", "digests": {"md5": "ec33790a229b1bd712adde72fb2fdd44", "sha256": "8e69ba05940dd3551cc01347933e6b5583f246efb0bf30289eb5b1b6a427b5f0"}, "downloads": -1, "filename": "tgutils-0.2.29.tar.gz", "has_sig": false, "md5_digest": "ec33790a229b1bd712adde72fb2fdd44", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 27542, "upload_time": "2020-02-03T09:33:54", "upload_time_iso_8601": "2020-02-03T09:33:54.266011Z", "url": "https://files.pythonhosted.org/packages/c4/f1/2149965d1a562369cc68d03332037d73d0ac5d3101757ea39e2d04b3933e/tgutils-0.2.29.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "ec33790a229b1bd712adde72fb2fdd44", "sha256": "8e69ba05940dd3551cc01347933e6b5583f246efb0bf30289eb5b1b6a427b5f0"}, "downloads": -1, "filename": "tgutils-0.2.29.tar.gz", "has_sig": false, "md5_digest": "ec33790a229b1bd712adde72fb2fdd44", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 27542, "upload_time": "2020-02-03T09:33:54", "upload_time_iso_8601": "2020-02-03T09:33:54.266011Z", "url": "https://files.pythonhosted.org/packages/c4/f1/2149965d1a562369cc68d03332037d73d0ac5d3101757ea39e2d04b3933e/tgutils-0.2.29.tar.gz", "yanked": false}], "timestamp": "Fri May  8 02:54:11 2020"}