{"info": {"author": "Zope Corporation and Contributors", "author_email": "zope-dev@zope.org", "bugtrack_url": null, "classifiers": ["Development Status :: 5 - Production/Stable", "Framework :: Zope :: 3", "Framework :: Zope :: 4", "Intended Audience :: Developers", "License :: OSI Approved :: Zope Public License", "Natural Language :: English", "Operating System :: OS Independent", "Programming Language :: Python", "Programming Language :: Python :: 2", "Programming Language :: Python :: 2.7", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.5", "Programming Language :: Python :: 3.6", "Programming Language :: Python :: 3.7", "Programming Language :: Python :: Implementation :: CPython", "Topic :: Software Development"], "description": "================\nSource Factories\n================\n\nSource factories are used to simplify the creation of sources for certain\nstandard cases.\n\nSources split up the process of providing input fields with choices for users\ninto several components: a context binder, a source class, a terms class, and a\nterm class.\n\nThis is the correct abstraction and will fit many complex cases very well. To\nreduce the amount of work to do for some standard cases, the source factories\nallow users to define only the business relevant code for getting a list of\nvalues, getting a token and a title to display.\n\n\n\n\n.. contents::\n\nSimple case\n===========\n\nIn the most simple case, you only have to provide a method that returns a list\nof values and derive from `BasicSourceFactory`:\n\n  >>> import zc.sourcefactory.basic\n  >>> class MyStaticSource(zc.sourcefactory.basic.BasicSourceFactory):\n  ...     def getValues(self):\n  ...         return ['a', 'b', 'c']\n\nWhen calling the source factory, we get a source:\n\n  >>> source = MyStaticSource()\n  >>> import zope.schema.interfaces\n  >>> zope.schema.interfaces.ISource.providedBy(source)\n  True\n\nThe values match our `getValues`-method of the factory:\n\n  >>> list(source)\n  ['a', 'b', 'c']\n  >>> 'a' in source\n  True\n  >>> len(source)\n  3\n\n\nContextual sources\n==================\n\nSometimes we need context to determine the values. In this case, the\n`getValues`-method gets a parameter `context`.\n\nLet's assume we have a small object containing data to be used by the source:\n\n  >>> class Context(object):\n  ...      values = []\n\n  >>> import zc.sourcefactory.contextual\n  >>> class MyDynamicSource(\n  ...     zc.sourcefactory.contextual.BasicContextualSourceFactory):\n  ...     def getValues(self, context):\n  ...         return context.values\n\nWhen instanciating, we get a ContextSourceBinder:\n\n  >>> binder = MyDynamicSource()\n  >>> zope.schema.interfaces.IContextSourceBinder.providedBy(binder)\n  True\n\nBinding it to a context, we get a source:\n\n  >>> context = Context()\n  >>> source = binder(context)\n  >>> zope.schema.interfaces.ISource.providedBy(source)\n  True\n\n  >>> list(source)\n  []\n\nModifying the context also modifies the data in the source:\n\n  >>> context.values = [1,2,3,4]\n  >>> list(source)\n  [1, 2, 3, 4]\n  >>> 1 in source\n  True\n  >>> len(source)\n  4\n\nIt's possible to have the default machinery return different sources, by\nproviding a source_class argument when calling the binder.  One can also\nprovide arguments to the source.\n\n  >>> class MultiplierSource(zc.sourcefactory.source.FactoredContextualSource):\n  ...     def __init__(self, factory, context, multiplier):\n  ...         super(MultiplierSource, self).__init__(factory, context)\n  ...         self.multiplier = multiplier\n  ...\n  ...     def _get_filtered_values(self):\n  ...         for value in self.factory.getValues(self.context):\n  ...             yield self.multiplier * value\n  >>> class MultiplierSourceFactory(MyDynamicSource):\n  ...     source_class = MultiplierSource\n  >>> binder = MultiplierSourceFactory()\n  >>> source = binder(context, multiplier=5)\n  >>> list(source)\n  [5, 10, 15, 20]\n  >>> 5 in source\n  True\n  >>> len(source)\n  4\n\nFiltering\n=========\n\nAdditional to providing the `getValues`-method you can also provide a\n`filterValue`-method that will allow you to reduce the items from the list,\npiece by piece.\n\nThis is useful if you want to have more specific sources (by subclassing) that\nshare the same basic origin of the data but have different filters applied to\nit:\n\n  >>> class FilteringSource(zc.sourcefactory.basic.BasicSourceFactory):\n  ...     def getValues(self):\n  ...         return iter(range(1,20))\n  ...     def filterValue(self, value):\n  ...         return value % 2\n  >>> source = FilteringSource()\n  >>> list(source)\n  [1, 3, 5, 7, 9, 11, 13, 15, 17, 19]\n\nSubclassing modifies the filter, not the original data:\n\n  >>> class OtherFilteringSource(FilteringSource):\n  ...     def filterValue(self, value):\n  ...         return not value % 2\n  >>> source = OtherFilteringSource()\n  >>> list(source)\n  [2, 4, 6, 8, 10, 12, 14, 16, 18]\n\nThe \"in\" operator gets applied also to filtered values:\n\n  >>> 2 in source\n  True\n  >>> 3 in source\n  False\n\nThe \"len\" also gets applied to filtered values:\n\n  >>> len(source)\n  9\n\n\nScaling\n=======\n\nSometimes the number of items available through a source is very large.  So\nlarge that you only want to access them if absolutely neccesary.  One such\noccasion is with truth-testing a source.  By default Python will call\n__nonzero__ to get the boolean value of an object, but if that isn't available\n__len__ is called to see what it returns.  That might be very expensive, so we\nwant to make sure it isn't called.\n\n  >>> class MyExpensiveSource(zc.sourcefactory.basic.BasicSourceFactory):\n  ...     def getValues(self):\n  ...         yield 'a'\n  ...         raise RuntimeError('oops, iterated too far')\n\n  >>> source = MyExpensiveSource()\n\n  >>> bool(source)\n  True\n\n\nSimple case\n===========\n\nIn the most simple case, you only have to provide a method that returns a list\nof values and derive from `BasicSourceFactory`:\n\n  >>> import zc.sourcefactory.basic\n  >>> class MyStaticSource(zc.sourcefactory.basic.BasicSourceFactory):\n  ...     def getValues(self):\n  ...         return ['a', 'b', 'c']\n\nWhen calling the source factory, we get a source:\n\n  >>> source = MyStaticSource()\n  >>> import zope.schema.interfaces\n  >>> zope.schema.interfaces.ISource.providedBy(source)\n  True\n\nThe values match our `getValues`-method of the factory:\n\n  >>> list(source)\n  ['a', 'b', 'c']\n  >>> 'a' in source\n  True\n  >>> len(source)\n  3\n\n\nWARNING about the standard adapters for ITerms\n==============================================\n\nThe standard adapters for ITerms are only suitable if the value types returned\nby your `getValues` function are homogenous. Mixing integers, persistent\nobjects, strings, and unicode within one source may create non-unique tokens.\nIn this case, you have to provide a custom `getToken`-method to provide unique\nand unambigous tokens.\n\n\nMapping source values\n=====================\n\nSometimes a source provides the right choice of objects, but the actual values\nwe want to talk about are properties or computed views on those objects. The\n`mapping proxy source` helps us to map a source to a different value space.\n\nWe start out with a source:\n\n  >>> source = [1,2,3,4,5]\n\nand we provide a method that maps the values of the original source to the\nvalues we want to see (we map the numbers to the characters in the english\nalphabet):\n\n  >>> map = lambda x: chr(x+96)\n\nNow we can create a mapped source:\n\n  >>> from zc.sourcefactory.mapping import ValueMappingSource\n  >>> mapped_source = ValueMappingSource(source, map)\n  >>> list(mapped_source)\n  ['a', 'b', 'c', 'd', 'e']\n  >>> len(mapped_source)\n  5\n  >>> 'a' in mapped_source\n  True\n  >>> 1 in mapped_source\n  False\n\nYou can also use context-dependent sources:\n\n  >>> def bindSource(context):\n  ...     return [1,2,3,4,5]\n  >>> from zc.sourcefactory.mapping import ValueMappingSourceContextBinder\n  >>> binder = ValueMappingSourceContextBinder(bindSource, map)\n  >>> bound_source = binder(object())\n  >>> list(bound_source)\n  ['a', 'b', 'c', 'd', 'e']\n  >>> len(bound_source)\n  5\n  >>> 'a' in bound_source\n  True\n  >>> 1 in bound_source\n  False\n\n\nScaling\n-------\n\nSometimes the number of items available through a source is very large.  So\nlarge that you only want to access them if absolutely neccesary.  One such\noccasion is with truth-testing a source.  By default Python will call\n__nonzero__ to get the boolean value of an object, but if that isn't available\n__len__ is called to see what it returns.  That might be very expensive, so we\nwant to make sure it isn't called.\n\n  >>> class ExpensiveSource(object):\n  ...     def __len__(self):\n  ...         raise RuntimeError(\"oops, don't want to call __len__\")\n  ...\n  ...     def __iter__(self):\n  ...         return iter(range(999999))\n\n  >>> expensive_source = ExpensiveSource()\n  >>> mapped_source = ValueMappingSource(expensive_source, map)\n  >>> bool(mapped_source)\n  True\n\n\n===================\nCustom constructors\n===================\n\nSource factories are intended to behave as natural as possible. A side-effect\nof using a custom factory method (__new__) on the base class is that\nsub-classes may have a hard time if their constructor (__init__) has a\ndifferent signature.\n\nzc.sourcefactory takes extra measures to allow using a custom constructor with\na different signature.\n\n>>> import zc.sourcefactory.basic\n\n>>> class Source(zc.sourcefactory.basic.BasicSourceFactory):\n...\n...     def __init__(self, values):\n...         super(Source, self).__init__()\n...         self.values = values\n...\n...     def getValues(self):\n...         return self.values\n\n>>> source = Source([1, 2, 3])\n>>> list(source)\n[1, 2, 3]\n\nThis is also true for contextual sources. The example is a bit silly\nbut it shows that it works in principal:\n\n>>> import zc.sourcefactory.contextual\n>>> default_values = (4, 5, 6)\n>>> context_values = (6, 7, 8)\n>>> class ContextualSource(\n...     zc.sourcefactory.contextual.BasicContextualSourceFactory):\n...\n...     def __init__(self, defaults):\n...         super(ContextualSource, self).__init__()\n...         self.defaults = defaults\n...\n...     def getValues(self, context):\n...         return self.defaults + context\n\n>>> contextual_source = ContextualSource(default_values)(context_values)\n>>> list(contextual_source)\n[4, 5, 6, 6, 7, 8]\n\n\n===========================\nCommon adapters for sources\n===========================\n\nTo allow adapting factored sources specific to the factory, a couple of\nstandard interfaces that can be adapters are re-adapted as using a\nmulti-adapter for (FactoredSource, SourceFactory).\n\nISourceQueriables\n=================\n\n  >>> from zc.sourcefactory.basic import BasicSourceFactory\n  >>> class Factory(BasicSourceFactory):\n  ...     def getValues(self):\n  ...         return [1,2,3]\n  >>> source = Factory()\n\n  >>> from zope.schema.interfaces import ISourceQueriables\n  >>> import zope.interface\n  >>> @zope.interface.implementer(ISourceQueriables)\n  ... class SourceQueriables(object):\n  ...     def __init__(self, source, factory):\n  ...         self.source = source\n  ...         self.factory = factory\n  ...     def getQueriables(self):\n  ...         return [('test', None)]\n\n  >>> from zc.sourcefactory.source import FactoredSource\n  >>> zope.component.provideAdapter(factory=SourceQueriables,\n  ...                               provides=ISourceQueriables,\n  ...                               adapts=(FactoredSource, Factory))\n\n  >>> queriables = ISourceQueriables(source)\n  >>> queriables.factory\n  <Factory object at 0x...>\n  >>> queriables.source\n  <zc.sourcefactory.source.FactoredSource object at 0x...>\n  >>> queriables.getQueriables()\n  [('test', None)]\n\nCleanup\n-------\n\n  >>> zope.component.getSiteManager().unregisterAdapter(factory=SourceQueriables,\n  ...     provided=ISourceQueriables, required=(FactoredSource, Factory))\n  True\n\n\n=====================================================\nBrowser views for sources created by source factories\n=====================================================\n\nSources that were created using source factories already come with ready-made\nterms and term objects.\n\n\nSimple use\n==========\n\nLet's start with a simple source factory:\n\n  >>> import zc.sourcefactory.basic\n  >>> class DemoSource(zc.sourcefactory.basic.BasicSourceFactory):\n  ...     def getValues(self):\n  ...         return [b'a', b'b', b'c', b'd']\n  >>> source = DemoSource()\n  >>> list(source)\n  [b'a', b'b', b'c', b'd']\n\nWe need a request first, then we can adapt the source to ITerms:\n\n  >>> from zope.publisher.browser import TestRequest\n  >>> import zope.browser.interfaces\n  >>> import zope.component\n  >>> request = TestRequest()\n  >>> terms = zope.component.getMultiAdapter(\n  ...     (source, request), zope.browser.interfaces.ITerms)\n  >>> terms\n  <zc.sourcefactory.browser.source.FactoredTerms object at 0x...>\n\nFor each value we get a factored term:\n\n  >>> terms.getTerm(b'a')\n  <zc.sourcefactory.browser.source.FactoredTerm object at 0x...>\n  >>> terms.getTerm(b'b')\n  <zc.sourcefactory.browser.source.FactoredTerm object at 0x...>\n  >>> terms.getTerm(b'c')\n  <zc.sourcefactory.browser.source.FactoredTerm object at 0x...>\n  >>> terms.getTerm(b'd')\n  <zc.sourcefactory.browser.source.FactoredTerm object at 0x...>\n\nUnicode values are allowed as well:\n\n  >>> terms.getTerm(u'\\xd3')\n  <zc.sourcefactory.browser.source.FactoredTerm object at 0x...>\n\nOur terms are ITitledTokenizedTerm-compatible:\n\n  >>> import zope.schema.interfaces\n  >>> zope.schema.interfaces.ITitledTokenizedTerm.providedBy(\n  ...     terms.getTerm('a'))\n  True\n\nIn the most simple case, the title of a term is the string representation of\nthe object:\n\n  >>> terms.getTerm('a').title\n  u'a'\n\nIf an adapter from the value to IDCDescriptiveProperties exists, the title\nwill be retrieved from this adapter:\n\n  >>> import persistent\n  >>> class MyObject(persistent.Persistent):\n  ...    custom_title = u'My custom title'\n  ...    _p_oid = 12\n  >>> class DCDescriptivePropertiesAdapter(object):\n  ...    def __init__(self, context):\n  ...        self.title = context.custom_title\n  ...        self.description = u\"\"\n  >>> from zope.component import provideAdapter\n  >>> from zope.dublincore.interfaces import IDCDescriptiveProperties\n  >>> provideAdapter(DCDescriptivePropertiesAdapter, [MyObject],\n  ...     IDCDescriptiveProperties)\n  >>> terms.getTerm(MyObject()).title\n  u'My custom title'\n\nExtended use: provide your own titles\n=====================================\n\nInstead of relying on string representation or IDCDescriptiveProperties\nadapters you can specify the `getTitle` method on the source factory to\ndetermine the title for a value:\n\n  >>> class DemoSourceWithTitles(DemoSource):\n  ...     def getTitle(self, value):\n  ...         return 'Custom title ' + value.custom_title\n  >>> source2 = DemoSourceWithTitles()\n  >>> terms2 = zope.component.getMultiAdapter(\n  ...     (source2, request), zope.browser.interfaces.ITerms)\n  >>> o1 = MyObject()\n  >>> o1.custom_title = u\"Object one\"\n  >>> o2 = MyObject()\n  >>> o2.custom_title = u\"Object two\"\n  >>> terms2.getTerm(o1).title\n  u'Custom title Object one'\n  >>> terms2.getTerm(o2).title\n  u'Custom title Object two'\n\n\nExtended use: provide your own tokens\n=====================================\n\nInstead of relying on default adapters to generate tokens for your values, you\ncan override the `getToken` method on the source factory to determine the\ntoken for a value:\n\n  >>> class DemoObjectWithToken(object):\n  ...     token = None\n  >>> o1 = DemoObjectWithToken()\n  >>> o1.token = \"one\"\n  >>> o2 = DemoObjectWithToken()\n  >>> o2.token = \"two\"\n\n  >>> class DemoSourceWithTokens(DemoSource):\n  ...     values = [o1, o2]\n  ...     def getValues(self):\n  ...         return self.values\n  ...     def getToken(self, value):\n  ...         return value.token\n\n  >>> source3 = DemoSourceWithTokens()\n  >>> terms3 = zope.component.getMultiAdapter(\n  ...     (source3, request), zope.browser.interfaces.ITerms)\n\n  >>> terms3.getTerm(o1).token\n  'one'\n  >>> terms3.getTerm(o2).token\n  'two'\n\nLooking up by the custom tokens works as well:\n\n  >>> terms3.getValue(\"one\") is o1\n  True\n  >>> terms3.getValue(\"two\") is o2\n  True\n  >>> terms3.getValue(\"three\")\n  Traceback (most recent call last):\n  KeyError: \"No value with token 'three'\"\n\n\nValue mapping sources\n=====================\n\n  XXX to come\n\n\nContextual sources\n==================\n\nLet's start with an object that we can use as the context:\n\n  >>> zip_to_city = {'06112': 'Halle',\n  ...                '06844': 'Dessau'}\n  >>> import zc.sourcefactory.contextual\n  >>> class DemoContextualSource(\n  ...     zc.sourcefactory.contextual.BasicContextualSourceFactory):\n  ...     def getValues(self, context):\n  ...         return context.keys()\n  ...     def getTitle(self, context, value):\n  ...         return context[value]\n  ...     def getToken(self, context, value):\n  ...         return 'token-%s' % value\n  >>> source = DemoContextualSource()(zip_to_city)\n  >>> sorted(list(source))\n  ['06112', '06844']\n\nLet's look at the terms:\n\n  >>> terms = zope.component.getMultiAdapter(\n  ...     (source, request), zope.browser.interfaces.ITerms)\n  >>> terms\n  <zc.sourcefactory.browser.source.FactoredContextualTerms object at 0x...>\n\nFor each value we get a factored term with the right title from the context:\n\n  >>> terms.getTerm('06112')\n  <zc.sourcefactory.browser.source.FactoredTerm object at 0x...>\n  >>> terms.getTerm('06112').title\n  'Halle'\n  >>> terms.getTerm('06844')\n  <zc.sourcefactory.browser.source.FactoredTerm object at 0x...>\n  >>> terms.getTerm('06844').title\n  'Dessau'\n  >>> terms.getTerm('06844').token\n  'token-06844'\n\nAnd in reverse we can get the value for a given token as well:\n\n  >>> terms.getValue('token-06844')\n  '06844'\n\nInterfaces\n==========\n\nBoth the FactoredSource and FactoredContextualSource have associated\ninterfaces.\n\n  >>> from zc.sourcefactory import interfaces\n  >>> from zc.sourcefactory import source\n  >>> from zope import interface\n  >>> interface.classImplements(\n  ...     source.FactoredSource, interfaces.IFactoredSource)\n  >>> interface.classImplements(\n  ...     source.FactoredContextualSource, interfaces.IContextualSource)\n\n\n======\nTokens\n======\n\nTokens are an identifying representation of an object, suitable for\ntransmission amongs URL-encoded data.\n\nThe sourcefactory package provides a few standard generators for tokens:\n\n  >>> import zc.sourcefactory.browser.token\n\nWe have generators for strings:\n\n  >>> zc.sourcefactory.browser.token.fromString('somestring')\n  '1f129c42de5e4f043cbd88ff6360486f'\n\nUnicode\n=======\n\n  Argh, I have to write the umlauts as unicode escapes otherwise\n  distutils will have a encoding error in preparing upload to pypi:\n\n  >>> zc.sourcefactory.browser.token.fromUnicode(\n  ...     u'somestring with umlauts \\u00F6\\u00E4\\u00FC')\n  '45dadc304e0d6ae7f4864368bad74951'\n\nInteger\n=======\n\n  >>> zc.sourcefactory.browser.token.fromInteger(12)\n  '12'\n\nPersistent\n==========\n\n  >>> import persistent\n  >>> class PersistentDummy(persistent.Persistent):\n  ...     pass\n  >>> p = PersistentDummy()\n  >>> p._p_oid = 1234\n  >>> zc.sourcefactory.browser.token.fromPersistent(p)\n  '1234'\n\nIf an object is persistent but has not been added to a database yet, it will\nbe added to the database of it's __parent__:\n\n  >>> root = rootFolder\n  >>> p1 = PersistentDummy()\n  >>> p1.__parent__ = root\n  >>> zc.sourcefactory.browser.token.fromPersistent(p1)\n  u'0x01'\n\nIf an object has no parent, we fail:\n\n  >>> p2 = PersistentDummy()\n  >>> zc.sourcefactory.browser.token.fromPersistent(p2)\n  Traceback (most recent call last):\n  ...\n  ValueError: Can not determine OID for <builtins.PersistentDummy object at 0x...>\n\nSecurity proxied objects are unwrapped to get to their oid or connection\nattribute:\n\n  >>> from zope.security.proxy import ProxyFactory\n  >>> p3 = PersistentDummy()\n  >>> root['p3'] = p3\n  >>> p3.__parent__ = root\n  >>> p3p = ProxyFactory(p3)\n  >>> p3p._p_jar\n  Traceback (most recent call last):\n    ...\n  ForbiddenAttribute: ('_p_jar', <builtins.PersistentDummy object at 0x...>)\n\n  >>> zc.sourcefactory.browser.token.fromPersistent(p3p)\n  u'0x02'\n\n\nAs a side-effect `p3` now has an _p_oid assigned.  When an object already has\nan OID the connection is not queried, so a __parent__ would not be necessary:\n\n  >>> del p3.__parent__\n  >>> zc.sourcefactory.browser.token.fromPersistent(p3p)\n  u'0x02'\n\n\nInterfaces\n==========\n\n  >>> from zope.interface import Interface\n  >>> class I(Interface):\n  ...     pass\n  >>> zc.sourcefactory.browser.token.fromInterface(I)\n  '__builtin__.I'\n\n\n=======\nChanges\n=======\n\n1.1 (2018-11-07)\n================\n\n- Add support for Python 3.6 and 3.7.\n\n- Drop support for Python 3.3 and 3.4.\n\n\n1.0.0 (2016-08-02)\n==================\n\n- Claim support for Python 3.4 and 3.5.\n\n- Drop support for Python 2.6.\n\n\n1.0.0a1 (2013-02-23)\n====================\n\n- Added support for Python 3.3.\n\n- Drastically reduce testing dependencies to make porting easier.\n\n- Replaced deprecated ``zope.interface.implements`` usage with equivalent\n  ``zope.interface.implementer`` decorator.\n\n- Dropped support for Python 2.4 and 2.5.\n\n\n0.8.0 (2013-10-04)\n==================\n\n- ``BasicSourceFactory`` now uses a class variable to tell what kind of\n  source to make. (Same mechanism as it was added for\n  ``ContextualSourceFactory`` in version 0.5.0).\n\n\n0.7.0 (2010-09-17)\n==================\n\n- Using Python's ``doctest`` instead of deprecated\n  ``zope.testing.doctest``.\n\n- Using ``zope.keyreference`` as test dependency instead of\n  ``zope.app.keyreference``.\n\n\n0.6.0 (2009-08-15)\n==================\n\n- Change package homepage to PyPI instead of Subversion.\n\n- Dropped Support for Zope 3.2 by removing a conditional import.\n\n- Use hashlib for Python 2.5 and later to avoid deprecation warnings.\n\n\n0.5.0 (2009-02-03)\n==================\n\n- FactoredContextualSourceBinder.__call__ now accepts arguments giving the\n  args to pass to source class.  ContextualSourceFactory now uses a class\n  variable to tell what kind of Source to make.\n\n- Use zope.intid instead of zope.app.intid.\n\n- Corrected e-mail address as zope3-dev@zope.org has been retired.\n\n\n0.4.0 (2008-12-11)\n==================\n\n- Removed zope.app.form dependency. Changed ITerms import from\n  zope.app.form.browser.interfaces to\n  zope.browser.interfaces. [projekt01]\n\n\n0.3.5 (2008-12-08)\n==================\n\n- Fixed bug in __new__ of contexual factories that would disallow\n  subclasses to use constructors that expect a different\n  signature. [icemac]\n\n\n0.3.4 (2008-08-27)\n==================\n\n- Added all documents in package to long description, so they are\n  readable in pypi. [icemac]\n\n0.3.3 (2008-06-10)\n==================\n\n- Fixed bug in __new__ of factories that would disallow subclasses to use\n  constructors that expect a different signature. (Thanks to Sebastian\n  Wehrmann for the patch.)\n\n0.3.2 (2008-04-09)\n==================\n\n- Fixed scalability bug caused by missing __nonzero__ on ValueMappingSource\n\n\n0.3.1 (2008-02-12)\n==================\n\n- Fixed scalability bug caused by missing __nonzero__ on BasicSourceFactory\n\n\n0.3.0 (??????????)\n==================\n\n- Added class-level defaults for attributes that are declared in the\n  interfaces to not have the Zope 2 security machinery complain about\n  them.\n\n\n0.2.1 (2007-07-10)\n==================\n\n- Fixed a bug in the contextual token policy that was handling the\n  resolution of values for a given token incorrectly.\n\n\n0.2.0 (2007-07-10)\n==================\n\n- Added a contextual token policy interface that allows getToken and\n  getValue to access the cotext for contextual sources.\n\n- Added a contextual term policy interface that allows createTerm and\n  getTitle to access the context for contextual sources.\n\n- Added compatibility for Zope 3.2 and Zope 2.9 (via Five 1.3)", "description_content_type": "", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/zopefoundation/zc.sourcefactory", "keywords": "zope vocabulary source factory", "license": "ZPL 2.1", "maintainer": "", "maintainer_email": "", "name": "zc.sourcefactory", "package_url": "https://pypi.org/project/zc.sourcefactory/", "platform": "", "project_url": "https://pypi.org/project/zc.sourcefactory/", "project_urls": {"Homepage": "https://github.com/zopefoundation/zc.sourcefactory"}, "release_url": "https://pypi.org/project/zc.sourcefactory/1.1/", "requires_dist": null, "requires_python": "", "summary": "An easy way to create custom Zope sources.", "version": "1.1", "yanked": false, "html_description": "<div class=\"project-description\">\n            <div id=\"source-factories\">\n<h2><a href=\"#id20\" rel=\"nofollow\">Source Factories</a></h2>\n<p>Source factories are used to simplify the creation of sources for certain\nstandard cases.</p>\n<p>Sources split up the process of providing input fields with choices for users\ninto several components: a context binder, a source class, a terms class, and a\nterm class.</p>\n<p>This is the correct abstraction and will fit many complex cases very well. To\nreduce the amount of work to do for some standard cases, the source factories\nallow users to define only the business relevant code for getting a list of\nvalues, getting a token and a title to display.</p>\n<div id=\"contents\">\n<p>Contents</p>\n<ul>\n<li><a href=\"#source-factories\" id=\"id20\" rel=\"nofollow\">Source Factories</a><ul>\n<li><a href=\"#simple-case\" id=\"id21\" rel=\"nofollow\">Simple case</a></li>\n<li><a href=\"#contextual-sources\" id=\"id22\" rel=\"nofollow\">Contextual sources</a></li>\n<li><a href=\"#filtering\" id=\"id23\" rel=\"nofollow\">Filtering</a></li>\n<li><a href=\"#scaling\" id=\"id24\" rel=\"nofollow\">Scaling</a></li>\n<li><a href=\"#id1\" id=\"id25\" rel=\"nofollow\">Simple case</a></li>\n<li><a href=\"#warning-about-the-standard-adapters-for-iterms\" id=\"id26\" rel=\"nofollow\">WARNING about the standard adapters for ITerms</a></li>\n<li><a href=\"#mapping-source-values\" id=\"id27\" rel=\"nofollow\">Mapping source values</a><ul>\n<li><a href=\"#id2\" id=\"id28\" rel=\"nofollow\">Scaling</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#custom-constructors\" id=\"id29\" rel=\"nofollow\">Custom constructors</a></li>\n<li><a href=\"#common-adapters-for-sources\" id=\"id30\" rel=\"nofollow\">Common adapters for sources</a><ul>\n<li><a href=\"#isourcequeriables\" id=\"id31\" rel=\"nofollow\">ISourceQueriables</a><ul>\n<li><a href=\"#cleanup\" id=\"id32\" rel=\"nofollow\">Cleanup</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#browser-views-for-sources-created-by-source-factories\" id=\"id33\" rel=\"nofollow\">Browser views for sources created by source factories</a><ul>\n<li><a href=\"#simple-use\" id=\"id34\" rel=\"nofollow\">Simple use</a></li>\n<li><a href=\"#extended-use-provide-your-own-titles\" id=\"id35\" rel=\"nofollow\">Extended use: provide your own titles</a></li>\n<li><a href=\"#extended-use-provide-your-own-tokens\" id=\"id36\" rel=\"nofollow\">Extended use: provide your own tokens</a></li>\n<li><a href=\"#value-mapping-sources\" id=\"id37\" rel=\"nofollow\">Value mapping sources</a></li>\n<li><a href=\"#id3\" id=\"id38\" rel=\"nofollow\">Contextual sources</a></li>\n<li><a href=\"#interfaces\" id=\"id39\" rel=\"nofollow\">Interfaces</a></li>\n</ul>\n</li>\n<li><a href=\"#tokens\" id=\"id40\" rel=\"nofollow\">Tokens</a><ul>\n<li><a href=\"#unicode\" id=\"id41\" rel=\"nofollow\">Unicode</a></li>\n<li><a href=\"#integer\" id=\"id42\" rel=\"nofollow\">Integer</a></li>\n<li><a href=\"#persistent\" id=\"id43\" rel=\"nofollow\">Persistent</a></li>\n<li><a href=\"#id4\" id=\"id44\" rel=\"nofollow\">Interfaces</a></li>\n</ul>\n</li>\n<li><a href=\"#changes\" id=\"id45\" rel=\"nofollow\">Changes</a><ul>\n<li><a href=\"#id5\" id=\"id46\" rel=\"nofollow\">1.1 (2018-11-07)</a></li>\n<li><a href=\"#id6\" id=\"id47\" rel=\"nofollow\">1.0.0 (2016-08-02)</a></li>\n<li><a href=\"#a1-2013-02-23\" id=\"id48\" rel=\"nofollow\">1.0.0a1 (2013-02-23)</a></li>\n<li><a href=\"#id7\" id=\"id49\" rel=\"nofollow\">0.8.0 (2013-10-04)</a></li>\n<li><a href=\"#id8\" id=\"id50\" rel=\"nofollow\">0.7.0 (2010-09-17)</a></li>\n<li><a href=\"#id9\" id=\"id51\" rel=\"nofollow\">0.6.0 (2009-08-15)</a></li>\n<li><a href=\"#id10\" id=\"id52\" rel=\"nofollow\">0.5.0 (2009-02-03)</a></li>\n<li><a href=\"#id11\" id=\"id53\" rel=\"nofollow\">0.4.0 (2008-12-11)</a></li>\n<li><a href=\"#id12\" id=\"id54\" rel=\"nofollow\">0.3.5 (2008-12-08)</a></li>\n<li><a href=\"#id13\" id=\"id55\" rel=\"nofollow\">0.3.4 (2008-08-27)</a></li>\n<li><a href=\"#id14\" id=\"id56\" rel=\"nofollow\">0.3.3 (2008-06-10)</a></li>\n<li><a href=\"#id15\" id=\"id57\" rel=\"nofollow\">0.3.2 (2008-04-09)</a></li>\n<li><a href=\"#id16\" id=\"id58\" rel=\"nofollow\">0.3.1 (2008-02-12)</a></li>\n<li><a href=\"#id17\" id=\"id59\" rel=\"nofollow\">0.3.0 (??????????)</a></li>\n<li><a href=\"#id18\" id=\"id60\" rel=\"nofollow\">0.2.1 (2007-07-10)</a></li>\n<li><a href=\"#id19\" id=\"id61\" rel=\"nofollow\">0.2.0 (2007-07-10)</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<div id=\"simple-case\">\n<h3><a href=\"#id21\" rel=\"nofollow\">Simple case</a></h3>\n<p>In the most simple case, you only have to provide a method that returns a list\nof values and derive from <cite>BasicSourceFactory</cite>:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; import zc.sourcefactory.basic\n&gt;&gt;&gt; class MyStaticSource(zc.sourcefactory.basic.BasicSourceFactory):\n...     def getValues(self):\n...         return ['a', 'b', 'c']\n</pre>\n</blockquote>\n<p>When calling the source factory, we get a source:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; source = MyStaticSource()\n&gt;&gt;&gt; import zope.schema.interfaces\n&gt;&gt;&gt; zope.schema.interfaces.ISource.providedBy(source)\nTrue\n</pre>\n</blockquote>\n<p>The values match our <cite>getValues</cite>-method of the factory:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; list(source)\n['a', 'b', 'c']\n&gt;&gt;&gt; 'a' in source\nTrue\n&gt;&gt;&gt; len(source)\n3\n</pre>\n</blockquote>\n</div>\n<div id=\"contextual-sources\">\n<h3><a href=\"#id22\" rel=\"nofollow\">Contextual sources</a></h3>\n<p>Sometimes we need context to determine the values. In this case, the\n<cite>getValues</cite>-method gets a parameter <cite>context</cite>.</p>\n<p>Let\u2019s assume we have a small object containing data to be used by the source:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; class Context(object):\n...      values = []\n</pre>\n<pre>&gt;&gt;&gt; import zc.sourcefactory.contextual\n&gt;&gt;&gt; class MyDynamicSource(\n...     zc.sourcefactory.contextual.BasicContextualSourceFactory):\n...     def getValues(self, context):\n...         return context.values\n</pre>\n</blockquote>\n<p>When instanciating, we get a ContextSourceBinder:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; binder = MyDynamicSource()\n&gt;&gt;&gt; zope.schema.interfaces.IContextSourceBinder.providedBy(binder)\nTrue\n</pre>\n</blockquote>\n<p>Binding it to a context, we get a source:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; context = Context()\n&gt;&gt;&gt; source = binder(context)\n&gt;&gt;&gt; zope.schema.interfaces.ISource.providedBy(source)\nTrue\n</pre>\n<pre>&gt;&gt;&gt; list(source)\n[]\n</pre>\n</blockquote>\n<p>Modifying the context also modifies the data in the source:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; context.values = [1,2,3,4]\n&gt;&gt;&gt; list(source)\n[1, 2, 3, 4]\n&gt;&gt;&gt; 1 in source\nTrue\n&gt;&gt;&gt; len(source)\n4\n</pre>\n</blockquote>\n<p>It\u2019s possible to have the default machinery return different sources, by\nproviding a source_class argument when calling the binder.  One can also\nprovide arguments to the source.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; class MultiplierSource(zc.sourcefactory.source.FactoredContextualSource):\n...     def __init__(self, factory, context, multiplier):\n...         super(MultiplierSource, self).__init__(factory, context)\n...         self.multiplier = multiplier\n...\n...     def _get_filtered_values(self):\n...         for value in self.factory.getValues(self.context):\n...             yield self.multiplier * value\n&gt;&gt;&gt; class MultiplierSourceFactory(MyDynamicSource):\n...     source_class = MultiplierSource\n&gt;&gt;&gt; binder = MultiplierSourceFactory()\n&gt;&gt;&gt; source = binder(context, multiplier=5)\n&gt;&gt;&gt; list(source)\n[5, 10, 15, 20]\n&gt;&gt;&gt; 5 in source\nTrue\n&gt;&gt;&gt; len(source)\n4\n</pre>\n</blockquote>\n</div>\n<div id=\"filtering\">\n<h3><a href=\"#id23\" rel=\"nofollow\">Filtering</a></h3>\n<p>Additional to providing the <cite>getValues</cite>-method you can also provide a\n<cite>filterValue</cite>-method that will allow you to reduce the items from the list,\npiece by piece.</p>\n<p>This is useful if you want to have more specific sources (by subclassing) that\nshare the same basic origin of the data but have different filters applied to\nit:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; class FilteringSource(zc.sourcefactory.basic.BasicSourceFactory):\n...     def getValues(self):\n...         return iter(range(1,20))\n...     def filterValue(self, value):\n...         return value % 2\n&gt;&gt;&gt; source = FilteringSource()\n&gt;&gt;&gt; list(source)\n[1, 3, 5, 7, 9, 11, 13, 15, 17, 19]\n</pre>\n</blockquote>\n<p>Subclassing modifies the filter, not the original data:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; class OtherFilteringSource(FilteringSource):\n...     def filterValue(self, value):\n...         return not value % 2\n&gt;&gt;&gt; source = OtherFilteringSource()\n&gt;&gt;&gt; list(source)\n[2, 4, 6, 8, 10, 12, 14, 16, 18]\n</pre>\n</blockquote>\n<p>The \u201cin\u201d operator gets applied also to filtered values:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; 2 in source\nTrue\n&gt;&gt;&gt; 3 in source\nFalse\n</pre>\n</blockquote>\n<p>The \u201clen\u201d also gets applied to filtered values:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; len(source)\n9\n</pre>\n</blockquote>\n</div>\n<div id=\"scaling\">\n<h3><a href=\"#id24\" rel=\"nofollow\">Scaling</a></h3>\n<p>Sometimes the number of items available through a source is very large.  So\nlarge that you only want to access them if absolutely neccesary.  One such\noccasion is with truth-testing a source.  By default Python will call\n__nonzero__ to get the boolean value of an object, but if that isn\u2019t available\n__len__ is called to see what it returns.  That might be very expensive, so we\nwant to make sure it isn\u2019t called.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; class MyExpensiveSource(zc.sourcefactory.basic.BasicSourceFactory):\n...     def getValues(self):\n...         yield 'a'\n...         raise RuntimeError('oops, iterated too far')\n</pre>\n<pre>&gt;&gt;&gt; source = MyExpensiveSource()\n</pre>\n<pre>&gt;&gt;&gt; bool(source)\nTrue\n</pre>\n</blockquote>\n</div>\n<div id=\"id1\">\n<h3><a href=\"#id25\" rel=\"nofollow\">Simple case</a></h3>\n<p>In the most simple case, you only have to provide a method that returns a list\nof values and derive from <cite>BasicSourceFactory</cite>:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; import zc.sourcefactory.basic\n&gt;&gt;&gt; class MyStaticSource(zc.sourcefactory.basic.BasicSourceFactory):\n...     def getValues(self):\n...         return ['a', 'b', 'c']\n</pre>\n</blockquote>\n<p>When calling the source factory, we get a source:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; source = MyStaticSource()\n&gt;&gt;&gt; import zope.schema.interfaces\n&gt;&gt;&gt; zope.schema.interfaces.ISource.providedBy(source)\nTrue\n</pre>\n</blockquote>\n<p>The values match our <cite>getValues</cite>-method of the factory:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; list(source)\n['a', 'b', 'c']\n&gt;&gt;&gt; 'a' in source\nTrue\n&gt;&gt;&gt; len(source)\n3\n</pre>\n</blockquote>\n</div>\n<div id=\"warning-about-the-standard-adapters-for-iterms\">\n<h3><a href=\"#id26\" rel=\"nofollow\">WARNING about the standard adapters for ITerms</a></h3>\n<p>The standard adapters for ITerms are only suitable if the value types returned\nby your <cite>getValues</cite> function are homogenous. Mixing integers, persistent\nobjects, strings, and unicode within one source may create non-unique tokens.\nIn this case, you have to provide a custom <cite>getToken</cite>-method to provide unique\nand unambigous tokens.</p>\n</div>\n<div id=\"mapping-source-values\">\n<h3><a href=\"#id27\" rel=\"nofollow\">Mapping source values</a></h3>\n<p>Sometimes a source provides the right choice of objects, but the actual values\nwe want to talk about are properties or computed views on those objects. The\n<cite>mapping proxy source</cite> helps us to map a source to a different value space.</p>\n<p>We start out with a source:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; source = [1,2,3,4,5]\n</pre>\n</blockquote>\n<p>and we provide a method that maps the values of the original source to the\nvalues we want to see (we map the numbers to the characters in the english\nalphabet):</p>\n<blockquote>\n<pre>&gt;&gt;&gt; map = lambda x: chr(x+96)\n</pre>\n</blockquote>\n<p>Now we can create a mapped source:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from zc.sourcefactory.mapping import ValueMappingSource\n&gt;&gt;&gt; mapped_source = ValueMappingSource(source, map)\n&gt;&gt;&gt; list(mapped_source)\n['a', 'b', 'c', 'd', 'e']\n&gt;&gt;&gt; len(mapped_source)\n5\n&gt;&gt;&gt; 'a' in mapped_source\nTrue\n&gt;&gt;&gt; 1 in mapped_source\nFalse\n</pre>\n</blockquote>\n<p>You can also use context-dependent sources:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; def bindSource(context):\n...     return [1,2,3,4,5]\n&gt;&gt;&gt; from zc.sourcefactory.mapping import ValueMappingSourceContextBinder\n&gt;&gt;&gt; binder = ValueMappingSourceContextBinder(bindSource, map)\n&gt;&gt;&gt; bound_source = binder(object())\n&gt;&gt;&gt; list(bound_source)\n['a', 'b', 'c', 'd', 'e']\n&gt;&gt;&gt; len(bound_source)\n5\n&gt;&gt;&gt; 'a' in bound_source\nTrue\n&gt;&gt;&gt; 1 in bound_source\nFalse\n</pre>\n</blockquote>\n<div id=\"id2\">\n<h4><a href=\"#id28\" rel=\"nofollow\">Scaling</a></h4>\n<p>Sometimes the number of items available through a source is very large.  So\nlarge that you only want to access them if absolutely neccesary.  One such\noccasion is with truth-testing a source.  By default Python will call\n__nonzero__ to get the boolean value of an object, but if that isn\u2019t available\n__len__ is called to see what it returns.  That might be very expensive, so we\nwant to make sure it isn\u2019t called.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; class ExpensiveSource(object):\n...     def __len__(self):\n...         raise RuntimeError(\"oops, don't want to call __len__\")\n...\n...     def __iter__(self):\n...         return iter(range(999999))\n</pre>\n<pre>&gt;&gt;&gt; expensive_source = ExpensiveSource()\n&gt;&gt;&gt; mapped_source = ValueMappingSource(expensive_source, map)\n&gt;&gt;&gt; bool(mapped_source)\nTrue\n</pre>\n</blockquote>\n</div>\n</div>\n</div>\n<div id=\"custom-constructors\">\n<h2><a href=\"#id29\" rel=\"nofollow\">Custom constructors</a></h2>\n<p>Source factories are intended to behave as natural as possible. A side-effect\nof using a custom factory method (__new__) on the base class is that\nsub-classes may have a hard time if their constructor (__init__) has a\ndifferent signature.</p>\n<p>zc.sourcefactory takes extra measures to allow using a custom constructor with\na different signature.</p>\n<pre>&gt;&gt;&gt; import zc.sourcefactory.basic\n</pre>\n<pre>&gt;&gt;&gt; class Source(zc.sourcefactory.basic.BasicSourceFactory):\n...\n...     def __init__(self, values):\n...         super(Source, self).__init__()\n...         self.values = values\n...\n...     def getValues(self):\n...         return self.values\n</pre>\n<pre>&gt;&gt;&gt; source = Source([1, 2, 3])\n&gt;&gt;&gt; list(source)\n[1, 2, 3]\n</pre>\n<p>This is also true for contextual sources. The example is a bit silly\nbut it shows that it works in principal:</p>\n<pre>&gt;&gt;&gt; import zc.sourcefactory.contextual\n&gt;&gt;&gt; default_values = (4, 5, 6)\n&gt;&gt;&gt; context_values = (6, 7, 8)\n&gt;&gt;&gt; class ContextualSource(\n...     zc.sourcefactory.contextual.BasicContextualSourceFactory):\n...\n...     def __init__(self, defaults):\n...         super(ContextualSource, self).__init__()\n...         self.defaults = defaults\n...\n...     def getValues(self, context):\n...         return self.defaults + context\n</pre>\n<pre>&gt;&gt;&gt; contextual_source = ContextualSource(default_values)(context_values)\n&gt;&gt;&gt; list(contextual_source)\n[4, 5, 6, 6, 7, 8]\n</pre>\n</div>\n<div id=\"common-adapters-for-sources\">\n<h2><a href=\"#id30\" rel=\"nofollow\">Common adapters for sources</a></h2>\n<p>To allow adapting factored sources specific to the factory, a couple of\nstandard interfaces that can be adapters are re-adapted as using a\nmulti-adapter for (FactoredSource, SourceFactory).</p>\n<div id=\"isourcequeriables\">\n<h3><a href=\"#id31\" rel=\"nofollow\">ISourceQueriables</a></h3>\n<blockquote>\n<pre>&gt;&gt;&gt; from zc.sourcefactory.basic import BasicSourceFactory\n&gt;&gt;&gt; class Factory(BasicSourceFactory):\n...     def getValues(self):\n...         return [1,2,3]\n&gt;&gt;&gt; source = Factory()\n</pre>\n<pre>&gt;&gt;&gt; from zope.schema.interfaces import ISourceQueriables\n&gt;&gt;&gt; import zope.interface\n&gt;&gt;&gt; @zope.interface.implementer(ISourceQueriables)\n... class SourceQueriables(object):\n...     def __init__(self, source, factory):\n...         self.source = source\n...         self.factory = factory\n...     def getQueriables(self):\n...         return [('test', None)]\n</pre>\n<pre>&gt;&gt;&gt; from zc.sourcefactory.source import FactoredSource\n&gt;&gt;&gt; zope.component.provideAdapter(factory=SourceQueriables,\n...                               provides=ISourceQueriables,\n...                               adapts=(FactoredSource, Factory))\n</pre>\n<pre>&gt;&gt;&gt; queriables = ISourceQueriables(source)\n&gt;&gt;&gt; queriables.factory\n&lt;Factory object at 0x...&gt;\n&gt;&gt;&gt; queriables.source\n&lt;zc.sourcefactory.source.FactoredSource object at 0x...&gt;\n&gt;&gt;&gt; queriables.getQueriables()\n[('test', None)]\n</pre>\n</blockquote>\n<div id=\"cleanup\">\n<h4><a href=\"#id32\" rel=\"nofollow\">Cleanup</a></h4>\n<blockquote>\n<pre>&gt;&gt;&gt; zope.component.getSiteManager().unregisterAdapter(factory=SourceQueriables,\n...     provided=ISourceQueriables, required=(FactoredSource, Factory))\nTrue\n</pre>\n</blockquote>\n</div>\n</div>\n</div>\n<div id=\"browser-views-for-sources-created-by-source-factories\">\n<h2><a href=\"#id33\" rel=\"nofollow\">Browser views for sources created by source factories</a></h2>\n<p>Sources that were created using source factories already come with ready-made\nterms and term objects.</p>\n<div id=\"simple-use\">\n<h3><a href=\"#id34\" rel=\"nofollow\">Simple use</a></h3>\n<p>Let\u2019s start with a simple source factory:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; import zc.sourcefactory.basic\n&gt;&gt;&gt; class DemoSource(zc.sourcefactory.basic.BasicSourceFactory):\n...     def getValues(self):\n...         return [b'a', b'b', b'c', b'd']\n&gt;&gt;&gt; source = DemoSource()\n&gt;&gt;&gt; list(source)\n[b'a', b'b', b'c', b'd']\n</pre>\n</blockquote>\n<p>We need a request first, then we can adapt the source to ITerms:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from zope.publisher.browser import TestRequest\n&gt;&gt;&gt; import zope.browser.interfaces\n&gt;&gt;&gt; import zope.component\n&gt;&gt;&gt; request = TestRequest()\n&gt;&gt;&gt; terms = zope.component.getMultiAdapter(\n...     (source, request), zope.browser.interfaces.ITerms)\n&gt;&gt;&gt; terms\n&lt;zc.sourcefactory.browser.source.FactoredTerms object at 0x...&gt;\n</pre>\n</blockquote>\n<p>For each value we get a factored term:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; terms.getTerm(b'a')\n&lt;zc.sourcefactory.browser.source.FactoredTerm object at 0x...&gt;\n&gt;&gt;&gt; terms.getTerm(b'b')\n&lt;zc.sourcefactory.browser.source.FactoredTerm object at 0x...&gt;\n&gt;&gt;&gt; terms.getTerm(b'c')\n&lt;zc.sourcefactory.browser.source.FactoredTerm object at 0x...&gt;\n&gt;&gt;&gt; terms.getTerm(b'd')\n&lt;zc.sourcefactory.browser.source.FactoredTerm object at 0x...&gt;\n</pre>\n</blockquote>\n<p>Unicode values are allowed as well:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; terms.getTerm(u'\\xd3')\n&lt;zc.sourcefactory.browser.source.FactoredTerm object at 0x...&gt;\n</pre>\n</blockquote>\n<p>Our terms are ITitledTokenizedTerm-compatible:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; import zope.schema.interfaces\n&gt;&gt;&gt; zope.schema.interfaces.ITitledTokenizedTerm.providedBy(\n...     terms.getTerm('a'))\nTrue\n</pre>\n</blockquote>\n<p>In the most simple case, the title of a term is the string representation of\nthe object:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; terms.getTerm('a').title\nu'a'\n</pre>\n</blockquote>\n<p>If an adapter from the value to IDCDescriptiveProperties exists, the title\nwill be retrieved from this adapter:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; import persistent\n&gt;&gt;&gt; class MyObject(persistent.Persistent):\n...    custom_title = u'My custom title'\n...    _p_oid = 12\n&gt;&gt;&gt; class DCDescriptivePropertiesAdapter(object):\n...    def __init__(self, context):\n...        self.title = context.custom_title\n...        self.description = u\"\"\n&gt;&gt;&gt; from zope.component import provideAdapter\n&gt;&gt;&gt; from zope.dublincore.interfaces import IDCDescriptiveProperties\n&gt;&gt;&gt; provideAdapter(DCDescriptivePropertiesAdapter, [MyObject],\n...     IDCDescriptiveProperties)\n&gt;&gt;&gt; terms.getTerm(MyObject()).title\nu'My custom title'\n</pre>\n</blockquote>\n</div>\n<div id=\"extended-use-provide-your-own-titles\">\n<h3><a href=\"#id35\" rel=\"nofollow\">Extended use: provide your own titles</a></h3>\n<p>Instead of relying on string representation or IDCDescriptiveProperties\nadapters you can specify the <cite>getTitle</cite> method on the source factory to\ndetermine the title for a value:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; class DemoSourceWithTitles(DemoSource):\n...     def getTitle(self, value):\n...         return 'Custom title ' + value.custom_title\n&gt;&gt;&gt; source2 = DemoSourceWithTitles()\n&gt;&gt;&gt; terms2 = zope.component.getMultiAdapter(\n...     (source2, request), zope.browser.interfaces.ITerms)\n&gt;&gt;&gt; o1 = MyObject()\n&gt;&gt;&gt; o1.custom_title = u\"Object one\"\n&gt;&gt;&gt; o2 = MyObject()\n&gt;&gt;&gt; o2.custom_title = u\"Object two\"\n&gt;&gt;&gt; terms2.getTerm(o1).title\nu'Custom title Object one'\n&gt;&gt;&gt; terms2.getTerm(o2).title\nu'Custom title Object two'\n</pre>\n</blockquote>\n</div>\n<div id=\"extended-use-provide-your-own-tokens\">\n<h3><a href=\"#id36\" rel=\"nofollow\">Extended use: provide your own tokens</a></h3>\n<p>Instead of relying on default adapters to generate tokens for your values, you\ncan override the <cite>getToken</cite> method on the source factory to determine the\ntoken for a value:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; class DemoObjectWithToken(object):\n...     token = None\n&gt;&gt;&gt; o1 = DemoObjectWithToken()\n&gt;&gt;&gt; o1.token = \"one\"\n&gt;&gt;&gt; o2 = DemoObjectWithToken()\n&gt;&gt;&gt; o2.token = \"two\"\n</pre>\n<pre>&gt;&gt;&gt; class DemoSourceWithTokens(DemoSource):\n...     values = [o1, o2]\n...     def getValues(self):\n...         return self.values\n...     def getToken(self, value):\n...         return value.token\n</pre>\n<pre>&gt;&gt;&gt; source3 = DemoSourceWithTokens()\n&gt;&gt;&gt; terms3 = zope.component.getMultiAdapter(\n...     (source3, request), zope.browser.interfaces.ITerms)\n</pre>\n<pre>&gt;&gt;&gt; terms3.getTerm(o1).token\n'one'\n&gt;&gt;&gt; terms3.getTerm(o2).token\n'two'\n</pre>\n</blockquote>\n<p>Looking up by the custom tokens works as well:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; terms3.getValue(\"one\") is o1\nTrue\n&gt;&gt;&gt; terms3.getValue(\"two\") is o2\nTrue\n&gt;&gt;&gt; terms3.getValue(\"three\")\nTraceback (most recent call last):\nKeyError: \"No value with token 'three'\"\n</pre>\n</blockquote>\n</div>\n<div id=\"value-mapping-sources\">\n<h3><a href=\"#id37\" rel=\"nofollow\">Value mapping sources</a></h3>\n<blockquote>\nXXX to come</blockquote>\n</div>\n<div id=\"id3\">\n<h3><a href=\"#id38\" rel=\"nofollow\">Contextual sources</a></h3>\n<p>Let\u2019s start with an object that we can use as the context:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; zip_to_city = {'06112': 'Halle',\n...                '06844': 'Dessau'}\n&gt;&gt;&gt; import zc.sourcefactory.contextual\n&gt;&gt;&gt; class DemoContextualSource(\n...     zc.sourcefactory.contextual.BasicContextualSourceFactory):\n...     def getValues(self, context):\n...         return context.keys()\n...     def getTitle(self, context, value):\n...         return context[value]\n...     def getToken(self, context, value):\n...         return 'token-%s' % value\n&gt;&gt;&gt; source = DemoContextualSource()(zip_to_city)\n&gt;&gt;&gt; sorted(list(source))\n['06112', '06844']\n</pre>\n</blockquote>\n<p>Let\u2019s look at the terms:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; terms = zope.component.getMultiAdapter(\n...     (source, request), zope.browser.interfaces.ITerms)\n&gt;&gt;&gt; terms\n&lt;zc.sourcefactory.browser.source.FactoredContextualTerms object at 0x...&gt;\n</pre>\n</blockquote>\n<p>For each value we get a factored term with the right title from the context:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; terms.getTerm('06112')\n&lt;zc.sourcefactory.browser.source.FactoredTerm object at 0x...&gt;\n&gt;&gt;&gt; terms.getTerm('06112').title\n'Halle'\n&gt;&gt;&gt; terms.getTerm('06844')\n&lt;zc.sourcefactory.browser.source.FactoredTerm object at 0x...&gt;\n&gt;&gt;&gt; terms.getTerm('06844').title\n'Dessau'\n&gt;&gt;&gt; terms.getTerm('06844').token\n'token-06844'\n</pre>\n</blockquote>\n<p>And in reverse we can get the value for a given token as well:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; terms.getValue('token-06844')\n'06844'\n</pre>\n</blockquote>\n</div>\n<div id=\"interfaces\">\n<h3><a href=\"#id39\" rel=\"nofollow\">Interfaces</a></h3>\n<p>Both the FactoredSource and FactoredContextualSource have associated\ninterfaces.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from zc.sourcefactory import interfaces\n&gt;&gt;&gt; from zc.sourcefactory import source\n&gt;&gt;&gt; from zope import interface\n&gt;&gt;&gt; interface.classImplements(\n...     source.FactoredSource, interfaces.IFactoredSource)\n&gt;&gt;&gt; interface.classImplements(\n...     source.FactoredContextualSource, interfaces.IContextualSource)\n</pre>\n</blockquote>\n</div>\n</div>\n<div id=\"tokens\">\n<h2><a href=\"#id40\" rel=\"nofollow\">Tokens</a></h2>\n<p>Tokens are an identifying representation of an object, suitable for\ntransmission amongs URL-encoded data.</p>\n<p>The sourcefactory package provides a few standard generators for tokens:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; import zc.sourcefactory.browser.token\n</pre>\n</blockquote>\n<p>We have generators for strings:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; zc.sourcefactory.browser.token.fromString('somestring')\n'1f129c42de5e4f043cbd88ff6360486f'\n</pre>\n</blockquote>\n<div id=\"unicode\">\n<h3><a href=\"#id41\" rel=\"nofollow\">Unicode</a></h3>\n<blockquote>\n<p>Argh, I have to write the umlauts as unicode escapes otherwise\ndistutils will have a encoding error in preparing upload to pypi:</p>\n<pre>&gt;&gt;&gt; zc.sourcefactory.browser.token.fromUnicode(\n...     u'somestring with umlauts \\u00F6\\u00E4\\u00FC')\n'45dadc304e0d6ae7f4864368bad74951'\n</pre>\n</blockquote>\n</div>\n<div id=\"integer\">\n<h3><a href=\"#id42\" rel=\"nofollow\">Integer</a></h3>\n<blockquote>\n<pre>&gt;&gt;&gt; zc.sourcefactory.browser.token.fromInteger(12)\n'12'\n</pre>\n</blockquote>\n</div>\n<div id=\"persistent\">\n<h3><a href=\"#id43\" rel=\"nofollow\">Persistent</a></h3>\n<blockquote>\n<pre>&gt;&gt;&gt; import persistent\n&gt;&gt;&gt; class PersistentDummy(persistent.Persistent):\n...     pass\n&gt;&gt;&gt; p = PersistentDummy()\n&gt;&gt;&gt; p._p_oid = 1234\n&gt;&gt;&gt; zc.sourcefactory.browser.token.fromPersistent(p)\n'1234'\n</pre>\n</blockquote>\n<p>If an object is persistent but has not been added to a database yet, it will\nbe added to the database of it\u2019s __parent__:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; root = rootFolder\n&gt;&gt;&gt; p1 = PersistentDummy()\n&gt;&gt;&gt; p1.__parent__ = root\n&gt;&gt;&gt; zc.sourcefactory.browser.token.fromPersistent(p1)\nu'0x01'\n</pre>\n</blockquote>\n<p>If an object has no parent, we fail:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; p2 = PersistentDummy()\n&gt;&gt;&gt; zc.sourcefactory.browser.token.fromPersistent(p2)\nTraceback (most recent call last):\n...\nValueError: Can not determine OID for &lt;builtins.PersistentDummy object at 0x...&gt;\n</pre>\n</blockquote>\n<p>Security proxied objects are unwrapped to get to their oid or connection\nattribute:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from zope.security.proxy import ProxyFactory\n&gt;&gt;&gt; p3 = PersistentDummy()\n&gt;&gt;&gt; root['p3'] = p3\n&gt;&gt;&gt; p3.__parent__ = root\n&gt;&gt;&gt; p3p = ProxyFactory(p3)\n&gt;&gt;&gt; p3p._p_jar\nTraceback (most recent call last):\n  ...\nForbiddenAttribute: ('_p_jar', &lt;builtins.PersistentDummy object at 0x...&gt;)\n</pre>\n<pre>&gt;&gt;&gt; zc.sourcefactory.browser.token.fromPersistent(p3p)\nu'0x02'\n</pre>\n</blockquote>\n<p>As a side-effect <cite>p3</cite> now has an _p_oid assigned.  When an object already has\nan OID the connection is not queried, so a __parent__ would not be necessary:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; del p3.__parent__\n&gt;&gt;&gt; zc.sourcefactory.browser.token.fromPersistent(p3p)\nu'0x02'\n</pre>\n</blockquote>\n</div>\n<div id=\"id4\">\n<h3><a href=\"#id44\" rel=\"nofollow\">Interfaces</a></h3>\n<blockquote>\n<pre>&gt;&gt;&gt; from zope.interface import Interface\n&gt;&gt;&gt; class I(Interface):\n...     pass\n&gt;&gt;&gt; zc.sourcefactory.browser.token.fromInterface(I)\n'__builtin__.I'\n</pre>\n</blockquote>\n</div>\n</div>\n<div id=\"changes\">\n<h2><a href=\"#id45\" rel=\"nofollow\">Changes</a></h2>\n<div id=\"id5\">\n<h3><a href=\"#id46\" rel=\"nofollow\">1.1 (2018-11-07)</a></h3>\n<ul>\n<li>Add support for Python 3.6 and 3.7.</li>\n<li>Drop support for Python 3.3 and 3.4.</li>\n</ul>\n</div>\n<div id=\"id6\">\n<h3><a href=\"#id47\" rel=\"nofollow\">1.0.0 (2016-08-02)</a></h3>\n<ul>\n<li>Claim support for Python 3.4 and 3.5.</li>\n<li>Drop support for Python 2.6.</li>\n</ul>\n</div>\n<div id=\"a1-2013-02-23\">\n<h3><a href=\"#id48\" rel=\"nofollow\">1.0.0a1 (2013-02-23)</a></h3>\n<ul>\n<li>Added support for Python 3.3.</li>\n<li>Drastically reduce testing dependencies to make porting easier.</li>\n<li>Replaced deprecated <tt>zope.interface.implements</tt> usage with equivalent\n<tt>zope.interface.implementer</tt> decorator.</li>\n<li>Dropped support for Python 2.4 and 2.5.</li>\n</ul>\n</div>\n<div id=\"id7\">\n<h3><a href=\"#id49\" rel=\"nofollow\">0.8.0 (2013-10-04)</a></h3>\n<ul>\n<li><tt>BasicSourceFactory</tt> now uses a class variable to tell what kind of\nsource to make. (Same mechanism as it was added for\n<tt>ContextualSourceFactory</tt> in version 0.5.0).</li>\n</ul>\n</div>\n<div id=\"id8\">\n<h3><a href=\"#id50\" rel=\"nofollow\">0.7.0 (2010-09-17)</a></h3>\n<ul>\n<li>Using Python\u2019s <tt>doctest</tt> instead of deprecated\n<tt>zope.testing.doctest</tt>.</li>\n<li>Using <tt>zope.keyreference</tt> as test dependency instead of\n<tt>zope.app.keyreference</tt>.</li>\n</ul>\n</div>\n<div id=\"id9\">\n<h3><a href=\"#id51\" rel=\"nofollow\">0.6.0 (2009-08-15)</a></h3>\n<ul>\n<li>Change package homepage to PyPI instead of Subversion.</li>\n<li>Dropped Support for Zope 3.2 by removing a conditional import.</li>\n<li>Use hashlib for Python 2.5 and later to avoid deprecation warnings.</li>\n</ul>\n</div>\n<div id=\"id10\">\n<h3><a href=\"#id52\" rel=\"nofollow\">0.5.0 (2009-02-03)</a></h3>\n<ul>\n<li>FactoredContextualSourceBinder.__call__ now accepts arguments giving the\nargs to pass to source class.  ContextualSourceFactory now uses a class\nvariable to tell what kind of Source to make.</li>\n<li>Use zope.intid instead of zope.app.intid.</li>\n<li>Corrected e-mail address as <a href=\"mailto:zope3-dev%40zope.org\">zope3-dev<span>@</span>zope<span>.</span>org</a> has been retired.</li>\n</ul>\n</div>\n<div id=\"id11\">\n<h3><a href=\"#id53\" rel=\"nofollow\">0.4.0 (2008-12-11)</a></h3>\n<ul>\n<li>Removed zope.app.form dependency. Changed ITerms import from\nzope.app.form.browser.interfaces to\nzope.browser.interfaces. [projekt01]</li>\n</ul>\n</div>\n<div id=\"id12\">\n<h3><a href=\"#id54\" rel=\"nofollow\">0.3.5 (2008-12-08)</a></h3>\n<ul>\n<li>Fixed bug in __new__ of contexual factories that would disallow\nsubclasses to use constructors that expect a different\nsignature. [icemac]</li>\n</ul>\n</div>\n<div id=\"id13\">\n<h3><a href=\"#id55\" rel=\"nofollow\">0.3.4 (2008-08-27)</a></h3>\n<ul>\n<li>Added all documents in package to long description, so they are\nreadable in pypi. [icemac]</li>\n</ul>\n</div>\n<div id=\"id14\">\n<h3><a href=\"#id56\" rel=\"nofollow\">0.3.3 (2008-06-10)</a></h3>\n<ul>\n<li>Fixed bug in __new__ of factories that would disallow subclasses to use\nconstructors that expect a different signature. (Thanks to Sebastian\nWehrmann for the patch.)</li>\n</ul>\n</div>\n<div id=\"id15\">\n<h3><a href=\"#id57\" rel=\"nofollow\">0.3.2 (2008-04-09)</a></h3>\n<ul>\n<li>Fixed scalability bug caused by missing __nonzero__ on ValueMappingSource</li>\n</ul>\n</div>\n<div id=\"id16\">\n<h3><a href=\"#id58\" rel=\"nofollow\">0.3.1 (2008-02-12)</a></h3>\n<ul>\n<li>Fixed scalability bug caused by missing __nonzero__ on BasicSourceFactory</li>\n</ul>\n</div>\n<div id=\"id17\">\n<h3><a href=\"#id59\" rel=\"nofollow\">0.3.0 (??????????)</a></h3>\n<ul>\n<li>Added class-level defaults for attributes that are declared in the\ninterfaces to not have the Zope 2 security machinery complain about\nthem.</li>\n</ul>\n</div>\n<div id=\"id18\">\n<h3><a href=\"#id60\" rel=\"nofollow\">0.2.1 (2007-07-10)</a></h3>\n<ul>\n<li>Fixed a bug in the contextual token policy that was handling the\nresolution of values for a given token incorrectly.</li>\n</ul>\n</div>\n<div id=\"id19\">\n<h3><a href=\"#id61\" rel=\"nofollow\">0.2.0 (2007-07-10)</a></h3>\n<ul>\n<li>Added a contextual token policy interface that allows getToken and\ngetValue to access the cotext for contextual sources.</li>\n<li>Added a contextual term policy interface that allows createTerm and\ngetTitle to access the context for contextual sources.</li>\n<li>Added compatibility for Zope 3.2 and Zope 2.9 (via Five 1.3)</li>\n</ul>\n</div>\n</div>\n\n          </div>"}, "last_serial": 4460501, "releases": {"0.1": [], "0.1DEV-r73411": [{"comment_text": "", "digests": {"md5": "dece1e1afe38d53b7fad42edbe58b762", "sha256": "85a10c1b26eae8982cf4af8bbe7fdd66bb398bc53f62732553718b55d76e82c1"}, "downloads": -1, "filename": "zc.sourcefactory-0.1DEV-r73411.tar.gz", "has_sig": false, "md5_digest": "dece1e1afe38d53b7fad42edbe58b762", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 11574, "upload_time": "2007-03-21T08:38:08", "upload_time_iso_8601": "2007-03-21T08:38:08Z", "url": "https://files.pythonhosted.org/packages/64/d3/a88628924278d673af39f6dbe584dd8e86e4282bd7efcbbefa7a61fa366d/zc.sourcefactory-0.1DEV-r73411.tar.gz", "yanked": false}], "0.1dev": [], "0.2": [{"comment_text": "", "digests": {"md5": "ea7eac2ca6bcf84bbbd43814abef2d51", "sha256": "7c24f9e7914bd68799e6c8d9dcea94a6386c8800931f750698fd1ca63e796433"}, "downloads": -1, "filename": "zc.sourcefactory-0.2.tar.gz", "has_sig": false, "md5_digest": "ea7eac2ca6bcf84bbbd43814abef2d51", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 13296, "upload_time": "2007-06-10T12:22:56", "upload_time_iso_8601": "2007-06-10T12:22:56Z", "url": "https://files.pythonhosted.org/packages/07/94/abc40398f4c591e8d41a290e61198bc7fa3ebda2e05d87f8f20dbe45809d/zc.sourcefactory-0.2.tar.gz", "yanked": false}], "0.2.1": [{"comment_text": "", "digests": {"md5": "0f72e6d3a5e4285d93e6cbb6be9d9e6e", "sha256": "4653d6c6eb8eb37333ecbf0de279ee49a7822a6128e4d599a3dc76189f5487f5"}, "downloads": -1, "filename": "zc.sourcefactory-0.2.1.tar.gz", "has_sig": false, "md5_digest": "0f72e6d3a5e4285d93e6cbb6be9d9e6e", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 14762, "upload_time": "2007-06-10T12:44:38", "upload_time_iso_8601": "2007-06-10T12:44:38Z", "url": "https://files.pythonhosted.org/packages/d5/4c/ff1cae41e4d7bff798c05528eb40da5e79016594478097a7ca526ef64ab4/zc.sourcefactory-0.2.1.tar.gz", "yanked": false}], "0.2dev-r75607": [{"comment_text": "", "digests": {"md5": "e983a89dfe6d1e7b495b40dd2241be2a", "sha256": "61b10eaa8d83109f48cd200fc54949093447301d5457731e7e6e5614b77212eb"}, "downloads": -1, "filename": "zc.sourcefactory-0.2dev-r75607.tar.gz", "has_sig": false, "md5_digest": "e983a89dfe6d1e7b495b40dd2241be2a", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 13145, "upload_time": "2007-05-07T10:46:03", "upload_time_iso_8601": "2007-05-07T10:46:03Z", "url": "https://files.pythonhosted.org/packages/0c/c0/052693b804e68a90e4ef58f83c76de09965e15baf49f1705230a7572b02f/zc.sourcefactory-0.2dev-r75607.tar.gz", "yanked": false}], "0.2dev-r75608": [{"comment_text": "", "digests": {"md5": "d23077acc9c2d92764093ce5da0fd570", "sha256": "6c338c70d810de7d7818af47bf807bd18c98f7c2acacbb5cbab394d31798a790"}, "downloads": -1, "filename": "zc.sourcefactory-0.2dev-r75608.tar.gz", "has_sig": false, "md5_digest": "d23077acc9c2d92764093ce5da0fd570", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 13157, "upload_time": "2007-05-07T10:52:49", "upload_time_iso_8601": "2007-05-07T10:52:49Z", "url": "https://files.pythonhosted.org/packages/33/e1/ef11972d3f12e239ef18de2c76d348077b570699ada27a40f8f2da2e9e01/zc.sourcefactory-0.2dev-r75608.tar.gz", "yanked": false}], "0.3": [{"comment_text": "", "digests": {"md5": "9258d8ae8c928a6ecd9c9758060d2a48", "sha256": "d79e470a48461592299c9f137b9d8256bbac667b8cae854e21b4b9407bb0b05c"}, "downloads": -1, "filename": "zc.sourcefactory-0.3.tar.gz", "has_sig": false, "md5_digest": "9258d8ae8c928a6ecd9c9758060d2a48", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 15284, "upload_time": "2007-09-12T12:53:53", "upload_time_iso_8601": "2007-09-12T12:53:53Z", "url": "https://files.pythonhosted.org/packages/16/ac/f6ffeeb392c2c6b053b9665711c46172e451b861fd15e7f376d7dc237446/zc.sourcefactory-0.3.tar.gz", "yanked": false}], "0.3.1": [{"comment_text": "", "digests": {"md5": "a12520a3c3ae25bbc5e08d89ab307d83", "sha256": "afd53b71d7e16abed63734449b26fc825d6bf6cf82dcdce0bf107e8ecc42482c"}, "downloads": -1, "filename": "zc.sourcefactory-0.3.1.tar.gz", "has_sig": false, "md5_digest": "a12520a3c3ae25bbc5e08d89ab307d83", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 16095, "upload_time": "2008-02-13T03:47:16", "upload_time_iso_8601": "2008-02-13T03:47:16Z", "url": "https://files.pythonhosted.org/packages/e4/1c/eee5bba135fd78b9959e4d4d50b0f17257fa00b18c4513a7725e0b5c1471/zc.sourcefactory-0.3.1.tar.gz", "yanked": false}], "0.3.2": [{"comment_text": "", "digests": {"md5": "2cf5ab9315ab742c227a008ea868b4c1", "sha256": "df6bbb4f4b0cec81cf72fd7cdb2f3bae6a9a0660c76e7527aeb9477cda5ad135"}, "downloads": -1, "filename": "zc.sourcefactory-0.3.2.tar.gz", "has_sig": false, "md5_digest": "2cf5ab9315ab742c227a008ea868b4c1", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 16087, "upload_time": "2008-04-09T15:30:43", "upload_time_iso_8601": "2008-04-09T15:30:43Z", "url": "https://files.pythonhosted.org/packages/33/a1/68bd4f2e70be03d2ffec4420eb1c9950aac52b97398542fd789e963f876c/zc.sourcefactory-0.3.2.tar.gz", "yanked": false}], "0.3.3": [{"comment_text": "", "digests": {"md5": "0e20bd693126362252d4f276a002f6a8", "sha256": "d805620e82c599393c1e1ff451069fa37ac4f9f049b03bf763228dc686c94722"}, "downloads": -1, "filename": "zc.sourcefactory-0.3.3.tar.gz", "has_sig": false, "md5_digest": "0e20bd693126362252d4f276a002f6a8", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 17078, "upload_time": "2008-06-10T15:07:27", "upload_time_iso_8601": "2008-06-10T15:07:27Z", "url": "https://files.pythonhosted.org/packages/1b/cd/dd43525e2d92626c12def5413e3a5a28f27ae9dcfd7d8fc29fa9321dec39/zc.sourcefactory-0.3.3.tar.gz", "yanked": false}], "0.3.4": [{"comment_text": "", "digests": {"md5": "3bfdf59ceab4282c12872edac2ca3a50", "sha256": "2602f71a06b1e63c8b3d1a719c8087c04c5eda6c205ef92113a7ecc06468f603"}, "downloads": -1, "filename": "zc.sourcefactory-0.3.4.tar.gz", "has_sig": false, "md5_digest": "3bfdf59ceab4282c12872edac2ca3a50", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 23876, "upload_time": "2008-08-27T11:44:07", "upload_time_iso_8601": "2008-08-27T11:44:07Z", "url": "https://files.pythonhosted.org/packages/54/42/56aa2eed52a74fbd4339c689410dc01ff322898616df5f8ad982fea79851/zc.sourcefactory-0.3.4.tar.gz", "yanked": false}], "0.3.5": [{"comment_text": "", "digests": {"md5": "50df5a838b2df85144a623d8ecb6ad60", "sha256": "921027df6a336811e791f8823841b212f0ba7507e8b6b5363e9606957e8442ec"}, "downloads": -1, "filename": "zc.sourcefactory-0.3.5.tar.gz", "has_sig": false, "md5_digest": "50df5a838b2df85144a623d8ecb6ad60", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 24910, "upload_time": "2008-12-08T07:36:33", "upload_time_iso_8601": "2008-12-08T07:36:33Z", "url": "https://files.pythonhosted.org/packages/00/af/5978a18a554585e26ce20ba6c8daf64e635480bfcffbf7c7a55fe6a9c630/zc.sourcefactory-0.3.5.tar.gz", "yanked": false}], "0.4.0": [{"comment_text": "", "digests": {"md5": "8d37c2c82e34c1d3c2678e72d3ffa566", "sha256": "71e6ffa3f1855f352b21a1e6f5237f49f721d2aee4c2fa7f2d01e2bcc666a9bd"}, "downloads": -1, "filename": "zc.sourcefactory-0.4.0.tar.gz", "has_sig": false, "md5_digest": "8d37c2c82e34c1d3c2678e72d3ffa566", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 25017, "upload_time": "2008-12-11T08:45:55", "upload_time_iso_8601": "2008-12-11T08:45:55Z", "url": "https://files.pythonhosted.org/packages/b6/6f/11d29e2ef2098cca2e07cd40e3d984811b4d73451c00d132abc810c6100d/zc.sourcefactory-0.4.0.tar.gz", "yanked": false}], "0.5.0": [{"comment_text": "", "digests": {"md5": "c7caa542f2e8564efb6ce877f6091628", "sha256": "ed2f7d76c5f9c3011525be49cf01c318e8d8c68b00ad3be93168704575c1956d"}, "downloads": -1, "filename": "zc.sourcefactory-0.5.0.tar.gz", "has_sig": false, "md5_digest": "c7caa542f2e8564efb6ce877f6091628", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 26320, "upload_time": "2009-02-03T17:43:07", "upload_time_iso_8601": "2009-02-03T17:43:07Z", "url": "https://files.pythonhosted.org/packages/f2/28/43f3a29f18a0a66bf9354f153c43df2eb1b52fc190698737a7f806d37fbc/zc.sourcefactory-0.5.0.tar.gz", "yanked": false}], "0.6.0": [{"comment_text": "", "digests": {"md5": "518cd17ed2101e1755de32a2f0f0f4b2", "sha256": "100d6c26370997c3714dc1f2a26e67f2c29f61c6d9d8c47f974326e3d8b5e49d"}, "downloads": -1, "filename": "zc.sourcefactory-0.6.0.tar.gz", "has_sig": false, "md5_digest": "518cd17ed2101e1755de32a2f0f0f4b2", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 27161, "upload_time": "2009-08-15T23:06:12", "upload_time_iso_8601": "2009-08-15T23:06:12.421194Z", "url": "https://files.pythonhosted.org/packages/11/fe/0a3eed373e31a641f09435ff512da0d88ba2c7cdae37d356c6318c13443f/zc.sourcefactory-0.6.0.tar.gz", "yanked": false}], "0.7.0": [{"comment_text": "", "digests": {"md5": "532dfd0a72489023268c19e3788b105d", "sha256": "faee06fb83e33701f56e0d60ba0be0b7d4b05bc2617a11b02c07404c75757d3c"}, "downloads": -1, "filename": "zc.sourcefactory-0.7.0.tar.gz", "has_sig": false, "md5_digest": "532dfd0a72489023268c19e3788b105d", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 27333, "upload_time": "2010-09-17T13:25:08", "upload_time_iso_8601": "2010-09-17T13:25:08.003537Z", "url": "https://files.pythonhosted.org/packages/fd/67/de3714ba407610578c1d7b606ebd5a83dd9d6780d8e4882eb59c9ea658f9/zc.sourcefactory-0.7.0.tar.gz", "yanked": false}], "0.8.0": [{"comment_text": "", "digests": {"md5": "b0e106d44467e8df4f730246e52fb4d1", "sha256": "b56eb7847106778f8db2af707b1ef77ba9f995aa96cf1abed85beeb21f310a39"}, "downloads": -1, "filename": "zc.sourcefactory-0.8.0.zip", "has_sig": false, "md5_digest": "b0e106d44467e8df4f730246e52fb4d1", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 45385, "upload_time": "2013-10-04T06:19:56", "upload_time_iso_8601": "2013-10-04T06:19:56.182421Z", "url": "https://files.pythonhosted.org/packages/ab/45/74e37331be38a714abde428c5200e5605052bb49368ea66b58b29f12ef7b/zc.sourcefactory-0.8.0.zip", "yanked": false}], "1.0.0": [{"comment_text": "", "digests": {"md5": "a2975b1d60f76f48b9de40536d2df7bf", "sha256": "83bc2a1f630d880479e5eed6081741286f09c8ba18a639568116b48b41535b13"}, "downloads": -1, "filename": "zc.sourcefactory-1.0.0.tar.gz", "has_sig": false, "md5_digest": "a2975b1d60f76f48b9de40536d2df7bf", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 30329, "upload_time": "2016-08-02T10:54:29", "upload_time_iso_8601": "2016-08-02T10:54:29.383041Z", "url": "https://files.pythonhosted.org/packages/4f/77/4b222ca6ea613ef41ceb1582eb3a9c20b2d1cc7f5ba9d79525f5b72c8101/zc.sourcefactory-1.0.0.tar.gz", "yanked": false}], "1.0.0a1": [{"comment_text": "", "digests": {"md5": "d67e9e47d00417715b52b9978ef3e338", "sha256": "e0d9dbe0717715f7e9e710fb6c6b353908ad4f7c5a8abff00549163c509b416d"}, "downloads": -1, "filename": "zc.sourcefactory-1.0.0a1.zip", "has_sig": false, "md5_digest": "d67e9e47d00417715b52b9978ef3e338", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 48608, "upload_time": "2013-02-23T05:13:57", "upload_time_iso_8601": "2013-02-23T05:13:57.755945Z", "url": "https://files.pythonhosted.org/packages/f6/52/5ba70bedf9f8238e3cdb94cdb3fd7cfc40727a2d009db7ffe2c8a26af76b/zc.sourcefactory-1.0.0a1.zip", "yanked": false}], "1.1": [{"comment_text": "", "digests": {"md5": "a0cf0c152037db1083454f432655f49b", "sha256": "444eec8a9bbfc8d36459e0149184c75a00d2a438a0da4fa2c11fbda02b71a3ad"}, "downloads": -1, "filename": "zc.sourcefactory-1.1.tar.gz", "has_sig": false, "md5_digest": "a0cf0c152037db1083454f432655f49b", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 27674, "upload_time": "2018-11-07T08:24:19", "upload_time_iso_8601": "2018-11-07T08:24:19.589594Z", "url": "https://files.pythonhosted.org/packages/db/62/122fccf6d514118c3f76afc9606197bf11d0cfbfc8cd0eb2a0f7e9fece05/zc.sourcefactory-1.1.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "a0cf0c152037db1083454f432655f49b", "sha256": "444eec8a9bbfc8d36459e0149184c75a00d2a438a0da4fa2c11fbda02b71a3ad"}, "downloads": -1, "filename": "zc.sourcefactory-1.1.tar.gz", "has_sig": false, "md5_digest": "a0cf0c152037db1083454f432655f49b", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 27674, "upload_time": "2018-11-07T08:24:19", "upload_time_iso_8601": "2018-11-07T08:24:19.589594Z", "url": "https://files.pythonhosted.org/packages/db/62/122fccf6d514118c3f76afc9606197bf11d0cfbfc8cd0eb2a0f7e9fece05/zc.sourcefactory-1.1.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:18:55 2020"}