{"info": {"author": "Dave Abrahams", "author_email": "dave@boostpro.com", "bugtrack_url": null, "classifiers": ["Intended Audience :: Developers", "License :: OSI Approved :: MIT License", "Operating System :: OS Independent", "Programming Language :: Python"], "description": "The Lazy Python Reloader\n========================\n\nThis is one way to control what happens when you reload.  Modules are\nreloaded in the same order they would be if they were being loaded for\nthe first time, and for the same reasons, thus eliminating some of the\nunpredictability associated with circular module references.\n\nUsage\n-----\n\n::\n\n  from lazy_reload import lazy_reload\n  import foo.bar.baz\n  lazy_reload(foo)\n  from foo.bar import baz # <= foo, bar, and baz reloaded here\n\nMotivation\n----------\n\nThe problems with reloading modules in Python are legion and\nwell-known.  During the course of ordinary execution, references to\nobjects in the modules and to the modules themselves end up\ndistributed around the object graph in ways that can be hard to manage\nand hard to predict.  As a result, it's very common to have old code\nhanging around long after the reload, possibly referencing things you\nexpect to have reloaded.  This is not necessarily Python's fault: it's\njust a hard problem to solve well.\n\nAs a result, most applications that need to update their code\ndynamically find a way to start up a new python process for that\npurpose. **I strongly recommend you do that if it's an option for\nyou**; you'll save yourself lots of debugging headaches in the long\nrun.  For the rest of us, there's ``lazy_reload``.\n\nWhat Python's ``__builtin__.reload`` Does\n-----------------------------------------\n\nThe ``reload()`` function supplied by Python is very simple-minded: it\ncauses the module's source file to be interpreted in the context of\nthe existing module object.  Any attributes of the module that aren't\noverwritten by that interpretation remain in place.  So for example, a\nmodule can detect that it's being reloaded as follows::\n\n    if 'already_loaded' in globals():\n        print 'I am being reloaded'\n    already_loaded = True\n\nAlso, Python makes no attempt to update references to that module\nelsewhere in your program.  Because the identity of the module object\ndoesn't change, direct module references will still work.  However,\nany existing references to functions or classes defined within that\nmodule will still point to the old definitions.  Objects created\nbefore the reload still refer to outdated classes via their\n``__class__`` attribute, and any local names that have been imported\ninto other modules still reference their old definitions.\n\nWhat ``lazy_reload`` Does\n-------------------------\n\n``lazy_reload(foo)`` (or ``lazy_reload('foo')``) removes ``foo`` and\nall of its submodules from ``sys.modules``, and arranges that the next\ntime any of them are imported, they will be reloaded.  \n\nWhat ``lazy_reload`` Doesn't Do\n-------------------------------\n\n* It doesn't eliminate references to the reloaded module from other\n  modules.  In particular, having loaded this::\n\n        # bar.py\n        import foo\n        def f():\n            return foo.x\n        \n  the reference to ``foo`` is already present in ``bar``, so after\n  ``lazy_unload(foo)``, a call to ``bar.f()`` will not cause ``foo``\n  to be reloaded even though it is used there.  Thus, you are safest\n  using ``lazy_unload`` on top-level modules that are not known to\n  other parts of your program by name.\n  \n* It doesn't immediately cause anything to be reloaded.  Remember that\n  the reload operation is *lazy*, and only happens when the module is\n  being imported.\n\n* It also doesn't cause anything to be \"unloaded,\" nor does it do\n  anything explicit to reclaim memory.  If the program is holding\n  references to functions and classes, don't expect them to be\n  garbage-collected.  (Watch out for backtraces; information from the\n  last exception raised can keep things alive longer than you'd like).\n\n* It doesn't fold your laundry or wash your cats.  If you don't enjoy\n  these activities yourself, consider the many affordable alternatives\n  to pets and clothes.", "description_content_type": null, "docs_url": null, "download_url": "UNKNOWN", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "http://github.com/boostpro/lazy_reload", "keywords": null, "license": "Boost License 1.0", "maintainer": null, "maintainer_email": null, "name": "lazy-reload", "package_url": "https://pypi.org/project/lazy-reload/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/lazy-reload/", "project_urls": {"Download": "UNKNOWN", "Homepage": "http://github.com/boostpro/lazy_reload"}, "release_url": "https://pypi.org/project/lazy-reload/1.1/", "requires_dist": null, "requires_python": null, "summary": "The Lazy Python Reloader", "version": "1.1", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p>This is one way to control what happens when you reload.  Modules are\nreloaded in the same order they would be if they were being loaded for\nthe first time, and for the same reasons, thus eliminating some of the\nunpredictability associated with circular module references.</p>\n<div id=\"usage\">\n<h2>Usage</h2>\n<pre>from lazy_reload import lazy_reload\nimport foo.bar.baz\nlazy_reload(foo)\nfrom foo.bar import baz # &lt;= foo, bar, and baz reloaded here\n</pre>\n</div>\n<div id=\"motivation\">\n<h2>Motivation</h2>\n<p>The problems with reloading modules in Python are legion and\nwell-known.  During the course of ordinary execution, references to\nobjects in the modules and to the modules themselves end up\ndistributed around the object graph in ways that can be hard to manage\nand hard to predict.  As a result, it\u2019s very common to have old code\nhanging around long after the reload, possibly referencing things you\nexpect to have reloaded.  This is not necessarily Python\u2019s fault: it\u2019s\njust a hard problem to solve well.</p>\n<p>As a result, most applications that need to update their code\ndynamically find a way to start up a new python process for that\npurpose. <strong>I strongly recommend you do that if it\u2019s an option for\nyou</strong>; you\u2019ll save yourself lots of debugging headaches in the long\nrun.  For the rest of us, there\u2019s <tt>lazy_reload</tt>.</p>\n</div>\n<div id=\"what-python-s-builtin-reload-does\">\n<h2>What Python\u2019s <tt>__builtin__.reload</tt> Does</h2>\n<p>The <tt>reload()</tt> function supplied by Python is very simple-minded: it\ncauses the module\u2019s source file to be interpreted in the context of\nthe existing module object.  Any attributes of the module that aren\u2019t\noverwritten by that interpretation remain in place.  So for example, a\nmodule can detect that it\u2019s being reloaded as follows:</p>\n<pre>if 'already_loaded' in globals():\n    print 'I am being reloaded'\nalready_loaded = True\n</pre>\n<p>Also, Python makes no attempt to update references to that module\nelsewhere in your program.  Because the identity of the module object\ndoesn\u2019t change, direct module references will still work.  However,\nany existing references to functions or classes defined within that\nmodule will still point to the old definitions.  Objects created\nbefore the reload still refer to outdated classes via their\n<tt>__class__</tt> attribute, and any local names that have been imported\ninto other modules still reference their old definitions.</p>\n</div>\n<div id=\"what-lazy-reload-does\">\n<h2>What <tt>lazy_reload</tt> Does</h2>\n<p><tt>lazy_reload(foo)</tt> (or <tt><span class=\"pre\">lazy_reload('foo')</span></tt>) removes <tt>foo</tt> and\nall of its submodules from <tt>sys.modules</tt>, and arranges that the next\ntime any of them are imported, they will be reloaded.</p>\n</div>\n<div id=\"what-lazy-reload-doesn-t-do\">\n<h2>What <tt>lazy_reload</tt> Doesn\u2019t Do</h2>\n<ul>\n<li><p>It doesn\u2019t eliminate references to the reloaded module from other\nmodules.  In particular, having loaded this:</p>\n<pre># bar.py\nimport foo\ndef f():\n    return foo.x\n</pre>\n<p>the reference to <tt>foo</tt> is already present in <tt>bar</tt>, so after\n<tt>lazy_unload(foo)</tt>, a call to <tt>bar.f()</tt> will not cause <tt>foo</tt>\nto be reloaded even though it is used there.  Thus, you are safest\nusing <tt>lazy_unload</tt> on top-level modules that are not known to\nother parts of your program by name.</p>\n</li>\n<li><p>It doesn\u2019t immediately cause anything to be reloaded.  Remember that\nthe reload operation is <em>lazy</em>, and only happens when the module is\nbeing imported.</p>\n</li>\n<li><p>It also doesn\u2019t cause anything to be \u201cunloaded,\u201d nor does it do\nanything explicit to reclaim memory.  If the program is holding\nreferences to functions and classes, don\u2019t expect them to be\ngarbage-collected.  (Watch out for backtraces; information from the\nlast exception raised can keep things alive longer than you\u2019d like).</p>\n</li>\n<li><p>It doesn\u2019t fold your laundry or wash your cats.  If you don\u2019t enjoy\nthese activities yourself, consider the many affordable alternatives\nto pets and clothes.</p>\n</li>\n</ul>\n</div>\n\n          </div>"}, "last_serial": 794088, "releases": {"1.0": [{"comment_text": "", "digests": {"md5": "edf2e923ead202804e9b98448ab10602", "sha256": "5fb865af0df90e9b518300f3c5467b443cc6a7edfcf0e8aec8c1648f316c738d"}, "downloads": -1, "filename": "lazy-reload-1.0.tar.gz", "has_sig": true, "md5_digest": "edf2e923ead202804e9b98448ab10602", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 4301, "upload_time": "2011-04-21T05:35:13", "upload_time_iso_8601": "2011-04-21T05:35:13.542563Z", "url": "https://files.pythonhosted.org/packages/b3/30/bb96153fc99821e01557065d3d60eed69de85a24f44dd1b97c5d1df0454b/lazy-reload-1.0.tar.gz", "yanked": false}], "1.1": [{"comment_text": "", "digests": {"md5": "219642ba2a08aefe6ae0dfcc05b47257", "sha256": "22693ba03a9e39f19492368b18f5cf5e9251f38066075ababe01a25c8f505960"}, "downloads": -1, "filename": "lazy-reload-1.1.tar.gz", "has_sig": false, "md5_digest": "219642ba2a08aefe6ae0dfcc05b47257", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 4162, "upload_time": "2011-04-28T22:31:14", "upload_time_iso_8601": "2011-04-28T22:31:14.346532Z", "url": "https://files.pythonhosted.org/packages/ae/c6/7e9b2e54652dd4ce92c0c682d797801a6ce60e36419a925f57b03dd84324/lazy-reload-1.1.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "219642ba2a08aefe6ae0dfcc05b47257", "sha256": "22693ba03a9e39f19492368b18f5cf5e9251f38066075ababe01a25c8f505960"}, "downloads": -1, "filename": "lazy-reload-1.1.tar.gz", "has_sig": false, "md5_digest": "219642ba2a08aefe6ae0dfcc05b47257", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 4162, "upload_time": "2011-04-28T22:31:14", "upload_time_iso_8601": "2011-04-28T22:31:14.346532Z", "url": "https://files.pythonhosted.org/packages/ae/c6/7e9b2e54652dd4ce92c0c682d797801a6ce60e36419a925f57b03dd84324/lazy-reload-1.1.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:47:35 2020"}