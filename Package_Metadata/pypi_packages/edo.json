{"info": {"author": "Henry Wilde", "author_email": "henrydavidwilde@gmail.com", "bugtrack_url": null, "classifiers": [], "description": ".. image:: https://img.shields.io/pypi/v/edo.svg\n   :target: https://pypi.org/project/edo/\n\n.. image:: https://travis-ci.com/daffidwilde/edo.svg?branch=master\n    :target: https://travis-ci.com/daffidwilde/edo\n\n.. image:: https://coveralls.io/repos/github/daffidwilde/edo/badge.svg?branch=master&service=github\n   :target: https://coveralls.io/github/daffidwilde/edo?branch=master\n\n.. image:: https://img.shields.io/badge/code%20style-black-000000.svg\n   :target: https://github.com/ambv/black\n\n.. image:: https://zenodo.org/badge/139703799.svg\n   :target: https://zenodo.org/badge/latestdoi/139703799\n\nEvolutionary Dataset Optimisation\n*********************************\n\nA library for generating artificial datasets through genetic evolution.\n=======================================================================\nTypically, when faced with a problem in data science, the data is fixed and the\nresearcher must select an algorithm that suits both the problem and performs\nwell on the data. This is typically done by running multiple algorithms on the\ndataset or by justifying a choice based on the findings of the current\nliterature. But what makes that data \"good\" for the algorithm? Why is it that an\nalgorithm performs well on some datasets and not others?\n\nThe purpose of this library is to create a population of families of datasets\nfor which a specific algorithm performs well with respect to its objective\nfunction. This function is passed to a genetic algorithm (GA) where each\nindividual represents a family of datasets defined by their dimensions, and the\nstatistical shape of each of its columns. The fitness of an individual is taken\nusing some amalgamation of the fitnesses from a sample of datasets belonging to\nits family.\n\nThrough this genetic algorithm, the hope is to not only build up banks of\neffective datasets for a particular algorithm but to give the user the ability\nto determine and study the preferred characteristics of such datasets.\n\nMoreover, since this GA can take any fitness function as argument, two or more\nalgorithms can be compared at once. For example, by considering two similar\nalgorithms :math:`A` and :math:`B` with fitness functions :math:`f_A` and\n:math:`f_B` respectively. Then for a suitable dataset :math:`X` consider the\nfitness function, denoted by :math:`f`, and\ngiven by:\n\n.. math::\n    f(X) = f_A(X) - f_B(X)\n\nThis fitness function, when passed to the GA, will attempt to generate\nindividuals for which algorithm :math:`A` outperforms algorithm :math:`B`.\n\nWhat is a genetic algorithm?\n============================\nGenetic algorithms (GAs) form a branch of search and optimisation methods that\nutilise the concept of natural selection. GAs work by creating populations of\nindividuals based on their fitness. These individuals are potential solutions in\nthe search space and are typically represented by a string of \"alleles\".\nTogether, these alleles form a \"chromosome\" representation. Most GAs, regardless\nof their application, have the following operators:\n\n* **Selection:** A method for selecting a subset of individuals from the current\n  population for producing the next. Almost always based on the fitness of the\n  individuals.\n* **Crossover:** An operator on two individuals, often deemed to be \"parents\",\n  that creates one or more \"offspring\".\n* **Mutation:** Takes each new offspring in turn and changes (\"mutates\") each of\n  their alleles with some probability.\n\nA schematic of a generic GA is given below.\n\n.. image:: ./docs/_static/flowchart.svg\n    :alt: A schematic for a genetic algorithm\n    :width: 80 %\n    :align: center\n\n.. include:: INSTALLATION.rst", "description_content_type": "text/x-rst", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/daffidwilde/edo", "keywords": "genetic-algorithmdataevolution", "license": "MIT", "maintainer": "", "maintainer_email": "", "name": "edo", "package_url": "https://pypi.org/project/edo/", "platform": "", "project_url": "https://pypi.org/project/edo/", "project_urls": {"Homepage": "https://github.com/daffidwilde/edo"}, "release_url": "https://pypi.org/project/edo/0.2.1/", "requires_dist": null, "requires_python": "", "summary": "Generating artificial datasets through genetic evolution.", "version": "0.2.1", "yanked": false, "html_description": "<div class=\"project-description\">\n            .. image:: https://img.shields.io/pypi/v/edo.svg<br>   :target: https://pypi.org/project/edo/<br><br>.. image:: https://travis-ci.com/daffidwilde/edo.svg?branch=master<br>    :target: https://travis-ci.com/daffidwilde/edo<br><br>.. image:: https://coveralls.io/repos/github/daffidwilde/edo/badge.svg?branch=master&amp;service=github<br>   :target: https://coveralls.io/github/daffidwilde/edo?branch=master<br><br>.. image:: https://img.shields.io/badge/code%20style-black-000000.svg<br>   :target: https://github.com/ambv/black<br><br>.. image:: https://zenodo.org/badge/139703799.svg<br>   :target: https://zenodo.org/badge/latestdoi/139703799<br><br>Evolutionary Dataset Optimisation<br>*********************************<br><br>A library for generating artificial datasets through genetic evolution.<br>=======================================================================<br>Typically, when faced with a problem in data science, the data is fixed and the<br>researcher must select an algorithm that suits both the problem and performs<br>well on the data. This is typically done by running multiple algorithms on the<br>dataset or by justifying a choice based on the findings of the current<br>literature. But what makes that data \"good\" for the algorithm? Why is it that an<br>algorithm performs well on some datasets and not others?<br><br>The purpose of this library is to create a population of families of datasets<br>for which a specific algorithm performs well with respect to its objective<br>function. This function is passed to a genetic algorithm (GA) where each<br>individual represents a family of datasets defined by their dimensions, and the<br>statistical shape of each of its columns. The fitness of an individual is taken<br>using some amalgamation of the fitnesses from a sample of datasets belonging to<br>its family.<br><br>Through this genetic algorithm, the hope is to not only build up banks of<br>effective datasets for a particular algorithm but to give the user the ability<br>to determine and study the preferred characteristics of such datasets.<br><br>Moreover, since this GA can take any fitness function as argument, two or more<br>algorithms can be compared at once. For example, by considering two similar<br>algorithms :math:`A` and :math:`B` with fitness functions :math:`f_A` and<br>:math:`f_B` respectively. Then for a suitable dataset :math:`X` consider the<br>fitness function, denoted by :math:`f`, and<br>given by:<br><br>.. math::<br>    f(X) = f_A(X) - f_B(X)<br><br>This fitness function, when passed to the GA, will attempt to generate<br>individuals for which algorithm :math:`A` outperforms algorithm :math:`B`.<br><br>What is a genetic algorithm?<br>============================<br>Genetic algorithms (GAs) form a branch of search and optimisation methods that<br>utilise the concept of natural selection. GAs work by creating populations of<br>individuals based on their fitness. These individuals are potential solutions in<br>the search space and are typically represented by a string of \"alleles\".<br>Together, these alleles form a \"chromosome\" representation. Most GAs, regardless<br>of their application, have the following operators:<br><br>* **Selection:** A method for selecting a subset of individuals from the current<br>  population for producing the next. Almost always based on the fitness of the<br>  individuals.<br>* **Crossover:** An operator on two individuals, often deemed to be \"parents\",<br>  that creates one or more \"offspring\".<br>* **Mutation:** Takes each new offspring in turn and changes (\"mutates\") each of<br>  their alleles with some probability.<br><br>A schematic of a generic GA is given below.<br><br>.. image:: ./docs/_static/flowchart.svg<br>    :alt: A schematic for a genetic algorithm<br>    :width: 80 %<br>    :align: center<br><br>.. include:: INSTALLATION.rst\n          </div>"}, "last_serial": 5187992, "releases": {"0.0.1a0": [{"comment_text": "", "digests": {"md5": "69e83d4374bf03ce36766b4a07936ad9", "sha256": "ac5195ca6c6e5a47e738bd912ad0902c63c07f27d7d9e87e58eb88ffbd5813ee"}, "downloads": -1, "filename": "edo-0.0.1a0.tar.gz", "has_sig": false, "md5_digest": "69e83d4374bf03ce36766b4a07936ad9", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 10717, "upload_time": "2018-08-24T17:23:52", "upload_time_iso_8601": "2018-08-24T17:23:52.959007Z", "url": "https://files.pythonhosted.org/packages/0c/d0/d62b686ca551bf9943f3a85aa4666f940f6ccfd18e20a62d6b09871ae4b8/edo-0.0.1a0.tar.gz", "yanked": false}], "0.0.2": [{"comment_text": "", "digests": {"md5": "189f740d693156bc435eb36308995db7", "sha256": "fc5f3869999fd3d55a3cef7ae9bcf447924568192955b522cc0ab11c48a8ba79"}, "downloads": -1, "filename": "edo-0.0.2.tar.gz", "has_sig": false, "md5_digest": "189f740d693156bc435eb36308995db7", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 12358, "upload_time": "2019-01-30T01:06:33", "upload_time_iso_8601": "2019-01-30T01:06:33.091368Z", "url": "https://files.pythonhosted.org/packages/b4/e0/e8c9b1fcd83ed1eed817c94801166be699a4f4ced682402d7125aedaa246/edo-0.0.2.tar.gz", "yanked": false}], "0.0.3": [{"comment_text": "", "digests": {"md5": "55ce8d56f8dd99d93baeb4e1984191f6", "sha256": "8fe1f4fa5c19ef6cfec9da36de78d33f4bb9d4d615d98d0d4c7d514276c56b98"}, "downloads": -1, "filename": "edo-0.0.3.tar.gz", "has_sig": false, "md5_digest": "55ce8d56f8dd99d93baeb4e1984191f6", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 12960, "upload_time": "2019-01-30T22:45:56", "upload_time_iso_8601": "2019-01-30T22:45:56.951350Z", "url": "https://files.pythonhosted.org/packages/b4/48/2d10007db99b2f2a1508ff14cde4c78286ac25bed475e6c64a6b96295a11/edo-0.0.3.tar.gz", "yanked": false}], "0.0.4": [{"comment_text": "", "digests": {"md5": "d7abdfeeaa5eb13abb6f96ef595fd3d4", "sha256": "36561adfd1c2cd56ab463e36e7b6b2b30860c276dff2710265b94a4a8a8af5a1"}, "downloads": -1, "filename": "edo-0.0.4.tar.gz", "has_sig": false, "md5_digest": "d7abdfeeaa5eb13abb6f96ef595fd3d4", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 12994, "upload_time": "2019-01-30T23:18:10", "upload_time_iso_8601": "2019-01-30T23:18:10.195530Z", "url": "https://files.pythonhosted.org/packages/98/c4/542ffba36b0f7dc05ef0215474e89b92d50432d14d132d1f03914fe17cc7/edo-0.0.4.tar.gz", "yanked": false}], "0.0.4a0": [{"comment_text": "", "digests": {"md5": "7fdcfbe9520483c52494657b7018ebd3", "sha256": "248cc62855b5e9aa3bf58fe157b6874c374e63dd74b015818f8ebee959c53cc1"}, "downloads": -1, "filename": "edo-0.0.4a0.tar.gz", "has_sig": false, "md5_digest": "7fdcfbe9520483c52494657b7018ebd3", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 13045, "upload_time": "2019-01-31T14:12:39", "upload_time_iso_8601": "2019-01-31T14:12:39.752641Z", "url": "https://files.pythonhosted.org/packages/2a/8f/7ab407bd12f4d4fd7654713798dee189f6fbbdb6ae8510e2432bc6aa0ee0/edo-0.0.4a0.tar.gz", "yanked": false}], "0.1": [{"comment_text": "", "digests": {"md5": "ad5ebbf4bb396092b1d769b8214bf6bd", "sha256": "7782d1bdb9174819d2374df823488c7b518afa3772518f7ff33ebda9ad924782"}, "downloads": -1, "filename": "edo-0.1.tar.gz", "has_sig": false, "md5_digest": "ad5ebbf4bb396092b1d769b8214bf6bd", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 13156, "upload_time": "2019-02-05T13:46:47", "upload_time_iso_8601": "2019-02-05T13:46:47.433361Z", "url": "https://files.pythonhosted.org/packages/49/02/fb005b27410227dfbfd4640adfb4e4c49eebea21acb8fee54c650e43fcc3/edo-0.1.tar.gz", "yanked": false}], "0.2": [{"comment_text": "", "digests": {"md5": "7b51b34c91ea0b279a30050c7262352d", "sha256": "f0214fe60b0abf6256ff6f13b1a118699619bb6a1051449cb94641421d9a820a"}, "downloads": -1, "filename": "edo-0.2.tar.gz", "has_sig": false, "md5_digest": "7b51b34c91ea0b279a30050c7262352d", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 15723, "upload_time": "2019-04-15T14:25:00", "upload_time_iso_8601": "2019-04-15T14:25:00.506562Z", "url": "https://files.pythonhosted.org/packages/29/bb/c297b8d9ad194d9a496b080137cafceca580988ba82590aa5fbad222ec11/edo-0.2.tar.gz", "yanked": false}], "0.2.1": [{"comment_text": "", "digests": {"md5": "c7a658db259f2a29377ddfb8e66cb2fa", "sha256": "b92e50150d6bec9f7d35f32e6f4f2df271b83d665a2af93e35457970e4f4ea21"}, "downloads": -1, "filename": "edo-0.2.1.tar.gz", "has_sig": false, "md5_digest": "c7a658db259f2a29377ddfb8e66cb2fa", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 15758, "upload_time": "2019-04-25T13:14:43", "upload_time_iso_8601": "2019-04-25T13:14:43.802783Z", "url": "https://files.pythonhosted.org/packages/53/f5/98a9e98c810bccf425821ea74650c4b72ac21cff35d51a58fffb4376643c/edo-0.2.1.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "c7a658db259f2a29377ddfb8e66cb2fa", "sha256": "b92e50150d6bec9f7d35f32e6f4f2df271b83d665a2af93e35457970e4f4ea21"}, "downloads": -1, "filename": "edo-0.2.1.tar.gz", "has_sig": false, "md5_digest": "c7a658db259f2a29377ddfb8e66cb2fa", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 15758, "upload_time": "2019-04-25T13:14:43", "upload_time_iso_8601": "2019-04-25T13:14:43.802783Z", "url": "https://files.pythonhosted.org/packages/53/f5/98a9e98c810bccf425821ea74650c4b72ac21cff35d51a58fffb4376643c/edo-0.2.1.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:47:42 2020"}