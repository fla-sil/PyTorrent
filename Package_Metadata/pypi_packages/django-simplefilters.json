{"info": {"author": "Lukasz Balcerzak", "author_email": "lukaszbalcerzak@gmail.com", "bugtrack_url": null, "classifiers": [], "description": "# django-simplefilters\n\nThis is a drop-in replacement for built-in Django Rest Framework filters package. It provides an easy way to retrieve params from the URL and use them to narrow results of the queryset.\n\nThe main difference with other solutions, i.e. [django-filter](https://pypi.python.org/pypi/django-filter), is that we do not try to handle each case and actual filtering is left for the user to implement. This might sound counterintuitive for a filtering library but we believe that in many cases it's much easier to write something like\n\n    class EntryFilterSet(filters.FilterSet):\n\n        @filters.CharFilter(many=True)\n        def filter_status(self, queryset, values):\n            return queryset.filter(status__in=values)\n\nthan try to lookup this special case (multiple values) in your filtering library documentation.\n\n\n\n## Installation\n\n    $ pip install django-simplefilters\n\n\n## Usage\n\nLet's imagine we have an `Entry` model with following attributes:\n\n    status_choices = ((c, c) for c in ['draft', 'published', 'archived'])\n\n    class Entry(models.Model):\n        title = models.CharField(max_length=64)\n        status = models.CharField(max_length=16, choices=status_choices)\n        modified_at = models.DateTimeField(auto_now=True)\n\n\nand we want to allow owner to filter entries by their status and modification date.\n\nWe need to define our filterset first:\n\n\n    # entries/filtersets.py\n    import simplefilters as filters\n\n\n    class Entry(filters.FilterSet):\n\n        @filters.CharFilter()\n        def filter_status(self, queryset, value):\n            return queryset.filter(status=value)\n\n        @filters.DateTimeFilter()\n        def filter_modified_at_min(self, queryset, ts):\n            return queryset.filter(modified_at__gte=ts)\n\n        @filters.DateTimeFilter()\n        def filter_modified_at_max(self, queryset, ts):\n            return queryset.filter(modified_at__lte=ts)\n\n\nMostly this should be self-explanatory, however important bit is how we indicate url param. This is achieved similarly to validation in serializers: name of the parameter is prefixed with `filter_` string. So, code above defines filters for following URL parameters: `status`, `modified_at_min` and `modified_at_max`.\n\nThen hook it at corresponding ViewSet class:\n\n    # entries/views.py\n    from . import filtersets\n    from . import models\n    import simplefilters as filters\n\n\n    class EntryViewSet(ModelViewSet):\n        serializer_class = ...\n        filter_backends = [filters.DjangoFilterBackend]\n        filter_class = filtersets.Entry\n\n        class Meta:\n            model = models.Entry\n\n\nnow user would be able to perform queries like:\n\n    GET /entries?status=draft\n    GET /entries?modified_at_min=2018-03-30T14:00Z\n    etc.\n\n\n\n\n## Supported filters\n\nBy definition, whatever user puts as query param is simply a string. Thus, `CharFiled` is simplest and most basic filter. But sometimes we would need to accept other types, i.e. numbers, timestamps or flags.\n\nHere is a full list of available filters:\n\n### `CharFilter`\n\nMost basic filter. Nothing fancy is done here.\n\n### `IntegerFilter`\n\nParam is casted to integer.\n\n### `FlagFilter`\n\nParam is casted to bool. Strings that would be treated as `True` indicator (case insensitive): `yes`, `y`, `true`, `t` and `1`. Similarly, those would be treated as `False`: `no`, `n`, `false`, `f` and `0`.\n\n### `DateTimeFilter`\n\nParam is casted to `datetime` object.\n\n\n## Multiple params\n\nSometimes we want to pass multiple params from the url. In example, we might want to allow users to filter by multiple status values and perform something like:\n\n    GET /entries?status=draft&status=archived\n\n\nFor this to work, simply indicate that we want to use `many` values at the filter method definition:\n\n      @filters.CharFilter(many)\n      def filter_status(self, queryset, values):\n          return queryset.filter(status__in=values)", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/lukaszb/django-simplefilters", "keywords": "", "license": "MIT", "maintainer": "", "maintainer_email": "", "name": "django-simplefilters", "package_url": "https://pypi.org/project/django-simplefilters/", "platform": "", "project_url": "https://pypi.org/project/django-simplefilters/", "project_urls": {"Homepage": "https://github.com/lukaszb/django-simplefilters"}, "release_url": "https://pypi.org/project/django-simplefilters/0.1.3/", "requires_dist": null, "requires_python": "", "summary": "Simple drop-in replacement for rest_framework.filters", "version": "0.1.3", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>django-simplefilters</h1>\n<p>This is a drop-in replacement for built-in Django Rest Framework filters package. It provides an easy way to retrieve params from the URL and use them to narrow results of the queryset.</p>\n<p>The main difference with other solutions, i.e. <a href=\"https://pypi.python.org/pypi/django-filter\" rel=\"nofollow\">django-filter</a>, is that we do not try to handle each case and actual filtering is left for the user to implement. This might sound counterintuitive for a filtering library but we believe that in many cases it's much easier to write something like</p>\n<pre><code>class EntryFilterSet(filters.FilterSet):\n\n    @filters.CharFilter(many=True)\n    def filter_status(self, queryset, values):\n        return queryset.filter(status__in=values)\n</code></pre>\n<p>than try to lookup this special case (multiple values) in your filtering library documentation.</p>\n<h2>Installation</h2>\n<pre><code>$ pip install django-simplefilters\n</code></pre>\n<h2>Usage</h2>\n<p>Let's imagine we have an <code>Entry</code> model with following attributes:</p>\n<pre><code>status_choices = ((c, c) for c in ['draft', 'published', 'archived'])\n\nclass Entry(models.Model):\n    title = models.CharField(max_length=64)\n    status = models.CharField(max_length=16, choices=status_choices)\n    modified_at = models.DateTimeField(auto_now=True)\n</code></pre>\n<p>and we want to allow owner to filter entries by their status and modification date.</p>\n<p>We need to define our filterset first:</p>\n<pre><code># entries/filtersets.py\nimport simplefilters as filters\n\n\nclass Entry(filters.FilterSet):\n\n    @filters.CharFilter()\n    def filter_status(self, queryset, value):\n        return queryset.filter(status=value)\n\n    @filters.DateTimeFilter()\n    def filter_modified_at_min(self, queryset, ts):\n        return queryset.filter(modified_at__gte=ts)\n\n    @filters.DateTimeFilter()\n    def filter_modified_at_max(self, queryset, ts):\n        return queryset.filter(modified_at__lte=ts)\n</code></pre>\n<p>Mostly this should be self-explanatory, however important bit is how we indicate url param. This is achieved similarly to validation in serializers: name of the parameter is prefixed with <code>filter_</code> string. So, code above defines filters for following URL parameters: <code>status</code>, <code>modified_at_min</code> and <code>modified_at_max</code>.</p>\n<p>Then hook it at corresponding ViewSet class:</p>\n<pre><code># entries/views.py\nfrom . import filtersets\nfrom . import models\nimport simplefilters as filters\n\n\nclass EntryViewSet(ModelViewSet):\n    serializer_class = ...\n    filter_backends = [filters.DjangoFilterBackend]\n    filter_class = filtersets.Entry\n\n    class Meta:\n        model = models.Entry\n</code></pre>\n<p>now user would be able to perform queries like:</p>\n<pre><code>GET /entries?status=draft\nGET /entries?modified_at_min=2018-03-30T14:00Z\netc.\n</code></pre>\n<h2>Supported filters</h2>\n<p>By definition, whatever user puts as query param is simply a string. Thus, <code>CharFiled</code> is simplest and most basic filter. But sometimes we would need to accept other types, i.e. numbers, timestamps or flags.</p>\n<p>Here is a full list of available filters:</p>\n<h3><code>CharFilter</code></h3>\n<p>Most basic filter. Nothing fancy is done here.</p>\n<h3><code>IntegerFilter</code></h3>\n<p>Param is casted to integer.</p>\n<h3><code>FlagFilter</code></h3>\n<p>Param is casted to bool. Strings that would be treated as <code>True</code> indicator (case insensitive): <code>yes</code>, <code>y</code>, <code>true</code>, <code>t</code> and <code>1</code>. Similarly, those would be treated as <code>False</code>: <code>no</code>, <code>n</code>, <code>false</code>, <code>f</code> and <code>0</code>.</p>\n<h3><code>DateTimeFilter</code></h3>\n<p>Param is casted to <code>datetime</code> object.</p>\n<h2>Multiple params</h2>\n<p>Sometimes we want to pass multiple params from the url. In example, we might want to allow users to filter by multiple status values and perform something like:</p>\n<pre><code>GET /entries?status=draft&amp;status=archived\n</code></pre>\n<p>For this to work, simply indicate that we want to use <code>many</code> values at the filter method definition:</p>\n<pre><code>  @filters.CharFilter(many)\n  def filter_status(self, queryset, values):\n      return queryset.filter(status__in=values)\n</code></pre>\n\n          </div>"}, "last_serial": 3777614, "releases": {"0.1": [{"comment_text": "", "digests": {"md5": "447af712e1a1b4659fce6182b8d25366", "sha256": "b013c995276250c5b8a75478ee4e1d7d6977e9f60899ccf4be8717855d0fc94e"}, "downloads": -1, "filename": "django-simplefilters-0.1.tar.gz", "has_sig": false, "md5_digest": "447af712e1a1b4659fce6182b8d25366", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 3289, "upload_time": "2018-04-02T19:19:01", "upload_time_iso_8601": "2018-04-02T19:19:01.058412Z", "url": "https://files.pythonhosted.org/packages/f1/ed/9a2136df5207cc3227cb6fd28dcdd881487c409897e8c055d530ec40918f/django-simplefilters-0.1.tar.gz", "yanked": false}], "0.1.1": [{"comment_text": "", "digests": {"md5": "c4e7433f3de6d7541591b6f59939a6e7", "sha256": "a5c7453cf39873e00661c40869b6370c3496ed0c3059d62cc876dfb5b5fb0ba4"}, "downloads": -1, "filename": "django-simplefilters-0.1.1.tar.gz", "has_sig": false, "md5_digest": "c4e7433f3de6d7541591b6f59939a6e7", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 3377, "upload_time": "2018-04-03T06:35:02", "upload_time_iso_8601": "2018-04-03T06:35:02.910713Z", "url": "https://files.pythonhosted.org/packages/34/1d/e4d374816ed1948917826835b4be0105423ec6b004c87c52aa06a25e0099/django-simplefilters-0.1.1.tar.gz", "yanked": false}], "0.1.3": [{"comment_text": "", "digests": {"md5": "bcc9984beb65d99cb97aeea5a45c7bb4", "sha256": "ed14e2e159a9fd3b8905cc8901acd64571b1daaeac293f839d03c9789ac0cb02"}, "downloads": -1, "filename": "django-simplefilters-0.1.3.tar.gz", "has_sig": false, "md5_digest": "bcc9984beb65d99cb97aeea5a45c7bb4", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 3886, "upload_time": "2018-04-18T15:46:33", "upload_time_iso_8601": "2018-04-18T15:46:33.404638Z", "url": "https://files.pythonhosted.org/packages/ba/22/e80a93b06a616b03126f63e9affe005eff6782fb198b23d9a6399d9411f0/django-simplefilters-0.1.3.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "bcc9984beb65d99cb97aeea5a45c7bb4", "sha256": "ed14e2e159a9fd3b8905cc8901acd64571b1daaeac293f839d03c9789ac0cb02"}, "downloads": -1, "filename": "django-simplefilters-0.1.3.tar.gz", "has_sig": false, "md5_digest": "bcc9984beb65d99cb97aeea5a45c7bb4", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 3886, "upload_time": "2018-04-18T15:46:33", "upload_time_iso_8601": "2018-04-18T15:46:33.404638Z", "url": "https://files.pythonhosted.org/packages/ba/22/e80a93b06a616b03126f63e9affe005eff6782fb198b23d9a6399d9411f0/django-simplefilters-0.1.3.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:53:24 2020"}