{"info": {"author": "Bebop Team", "author_email": "uwe_oestermeier@iwm-kmrc.de", "bugtrack_url": null, "classifiers": ["Development Status :: 3 - Alpha", "Environment :: Web Environment", "Framework :: Zope3", "Intended Audience :: Developers", "License :: OSI Approved :: GNU General Public License (GPL)", "Natural Language :: English", "Operating System :: OS Independent", "Programming Language :: Python", "Topic :: Internet :: WWW/HTTP"], "description": "Bebop Protocol\n==============\n\nThis package contains a extension to Zope3 which simplifies the registration\nof components.\n\nZope3 has been criticized as an overly complex and difficult to learn framework.\nEspecially the ZCML configuration language and the missing Python API for \nconfiguration actions has been a topic of debate.\n\nThis package tries to combine the conciseness of Python with the explicitness, \nfine-grained configurability, and conflict management of ZCML. A protocol is a \nPython object that defines how a component is registered and configured, how \nthe component is called, and how it is unregistered. Protocols are used and \nextended by declarations, i.e. class advisors and decorators that correspond \nto existing ZCML directives. All declarations within a package can be activated \nwith a single line of ZCML. The equivalent ZCML configuration can be recorded \nfor documentary purposes and used as a basis for more selective configurations \nand overloads.\n\nSince the protocol package mimics the ZCML directives as closely as possible \nit provides no extra learning curve for the experienced Zope3 programmer. \nPredefined protocols are available for adapters, utilities, subscribers, pages,\nand menus. Since protocols are extensible, they can also be used to define \ngeneric functions and extend the component architecture with special forms \nof utilities and adapter lookup without the need to define new ZCML directives. \n\n\nDetailed Documentation\n**********************\n\n=========\nProtocols\n=========\n\nThis package defines Protocols that use Zope's component registry.\nIt was inspired by Tim Hochberg's way to register generic functions.\n\n    http://mail.python.org/pipermail/python-3000/2006-April/000394.html\n    \nBasically a Protocol says how a component is configured and how it is called.\nTherefore each Protocol has two main methods: configure and __call__.\nThe configure method triggers the configuration actions which in turn\nensure the registration/activation of the protocol elements.\nThis is typically done in production mode via a few ZCML directives\nwhich are part of the protocol package. Since you often want to\nextend a protocol with application specific behavior you can\nalso activate protocol additions via ZCML. \n\nMost protocols support an `activate` method. This method\nregisters all component declarations that have been collected \nin the protocol. A typical use case are doctests where you want to\nensure that protocol elements like adapters and utilities are registered.\n\nIn the following we describe how protocols interact with content classes, \nadapters, utilities, and subscribers. See browser.txt for view related \nprotocols and generic.txt for an implementation of generic functions.\n\n\nHello World\n===========\n\nLet's start with \"hello world\". In demo/hello you find the usual structure\nof a Zope3 application:\n\n    interfaces.py: the involved (public) interfaces which are needed\n                   to make things replaceable and extensible\n    world.py:      the content class and a basic implementation \n                   of the content related interfaces\n    greeting.py:   the view that shows the mini program to the user\n    configure.zcml the ZCML statements which feed the component registries\n\nAll this can be reduced to a single file (demo/hello/allinone.py):\n\n    from persistent import Persistent \n    from zope.publisher.browser import BrowserView \n    \n    from bebop.protocol import protocol\n    from bebop.protocol import browser\n    \n    class World(Persistent): \n        pass\n    \n    greet = protocol.GenericFunction('IGreet')\n    @greet.when(World)\n    def greet_world(world):\n        return 'world'\n    \n    class Greeting(BrowserView): \n        browser.page(World, name=\"greet\", permission='zope.Public')\n      \n        def __call__(self): \n            return \"Hello %s\" % greet(self.context) \n\n\nNote that this file contains no reference to external interfaces and no\nZCML. Even the model and the view are in the same file. That of course\nworks only in simple cases, in more complex applications it may be\nnecessary to split things up, and then the traditional Zope3 structure\nmake of course much more sense. So this example is not intended to show\nthat there is something inherently bad with Zope3's verbosity.\nTo the contrary: We strive at a simplification that integrates well \nwith existing Zope3 packages and at the same time allows to simplify \nthings without loosing the explicitness of Zope3.\n\nThe example illustrates two main ideas which are the core of this package:\n\n    1. ZCML statements integrated into the Python code as class advisors\n       and method decorators\n       \n    2. A generic function ``greet``that replaces all the IGreetable, IGreet\n       interfaces without loosing the replaceability and extensibility\n       of the Zope component architecture.\n\nThe necessary ZCML can be generated from the source code since most of\nthe class advisors and decorators are equivalent to existing ZCML\nstatements. The browser.pages directive, for instance, exactly matches\nthe following ZCML snippet:\n\n    &lt;browser:pages name=\"greet\"/&gt;\n   \nThe generic function ``greet`` however goes beyond the simple idea\nof putting configuration statements into the code. It show's that Zope3's\ncomponent architecture is rich enough to maintain extensions which\nwere not anticipated by the original design. If we look at the complete\ngenerated ZCML of this example we see that the generic function is \nregistered as an adapter for an interface that is generated by the\nGenericFunction factory:\n   \n    &gt;&gt;&gt; from bebop.protocol.directive import record\n    &gt;&gt;&gt; print record(module='bebop.protocol.demo.hello.allinone')\n    &lt;configure\n           xmlns:browser=\"http://namespaces.zope.org/browser\"\n           xmlns:zope=\"http://namespaces.zope.org/zope\"\n          &gt;\n       &lt;!-- GENERATED PROTOCOL. DO NOT MODIFY OR INCLUDE --&gt;\n       &lt;browser:page\n          class=\"bebop.protocol.demo.hello.allinone.Greeting\"\n          layer=\"zope.publisher.interfaces.browser.IDefaultBrowserLayer\"\n          for=\"bebop.protocol.demo.hello.allinone.World\"\n          permission=\"zope.Public\"\n          name=\"greet\"\n          attribute=\"__call__\"\n       /&gt;\n       &lt;zope:adapter\n          factory=\"bebop.protocol.demo.hello.allinone.greet_world\"\n          provides=\"bebop.protocol.demo.hello.allinone.IGreet\"\n          for=\"bebop.protocol.demo.hello.allinone.World\"\n       /&gt;\n    &lt;/configure&gt;\n\n\nBoth ideas are elaborated in the following. Protocols are the basic\nbuilding blocks of this approach.\n\n\nClass Protocol\n==============\n\nFor many cases it is sufficient to use the predefined protocols. The class\nprotocol may serve as an example. It closely mimics the ZCML class \ndirective since the protocol does exactly what the directive does: it\nconfigures the security machinery. There's only one important difference. \nThe protocol is completely written in Python, and the corresponding \nZCML directives are generated from the Python code.\n\n    &gt;&gt;&gt; class IPerson(zope.interface.Interface):\n    ...     name = zope.interface.Attribute(u'The name of the person')\n    ...     email = zope.interface.Attribute(u'The email address')\n\n    &gt;&gt;&gt; from bebop.protocol import protocol\n    &gt;&gt;&gt; class Person(object):\n    ...     zope.interface.implements(IPerson)\n    ...     protocol.classProtocol.require(\n    ...         permission=\"zope.View\",\n    ...         interface=IPerson)\n\nWe could have used `require` as a shorthand for `classProtocol.require`.\nThe more explict form was choosen to make clear that the a predefined protocol \ninstance is involved.\n\nThe protocol collects all declarations and allows to configure the described\nobjects according to these declarations. We can inspect the protocol by \ncalling it's report method. This method returns the corresponding configuration\nstatements which belong to a set of modules:\n\n    &gt;&gt;&gt; print protocol.classProtocol.record(modules=('bebop.protocol.readme',))\n    &lt;configure\n           xmlns:zope=\"http://namespaces.zope.org/zope\"\n          &gt;\n       &lt;!-- GENERATED PROTOCOL. DO NOT MODIFY OR INCLUDE --&gt;\n       &lt;zope:class class=\"bebop.protocol.readme.Person\"&gt;\n           &lt;zope:require\n                  permission=\"zope.View\"\n                  interface=\"bebop.protocol.readme.IPerson\"\n           /&gt;\n       &lt;/class&gt;\n    &lt;/configure&gt;\n\nSince this written record is like a contract further modifications to the \nprotocol are prohibited:\n\n    &gt;&gt;&gt; class Employee(object):\n    ...     zope.interface.implements(IPerson)\n    ...     protocol.classProtocol.require(\n    ...         permission=\"zope.View\",\n    ...         interface=IPerson)\n    Traceback (most recent call last):\n    ...\n    ProtocolError: protocol 'class' is written and must be reopened ...\n\nWe must explicitely reopen the protocol to allow further extensions:\n\n    &gt;&gt;&gt; protocol.classProtocol.reopen()\n    &gt;&gt;&gt; class Employee2(object):\n    ...     zope.interface.implements(IPerson)\n    ...     protocol.classProtocol.require(\n    ...         permission=\"zope.View\",\n    ...         interface=IPerson)\n\nDeclarations as such have no consequences (as in politics). We have \nenact the protocol in order to use the declarations. Typically this\nis done in ZCML. We need to load the metaconfiguration first:\n\n    &gt;&gt;&gt; from zope.configuration import xmlconfig\n    &gt;&gt;&gt; import bebop.protocol\n    &gt;&gt;&gt; context = xmlconfig.file('meta.zcml',  bebop.protocol)    \n\nThe most powerfull way to enact protocols is a call to the protocol \ndirective.  This directive recursively collects all used protocols in \nall modules of a package, enacts the declarations, and records the \ncorresponding ZCML directives in a singe file:\n\n    &gt;&gt;&gt; protocol_zcml = '''&lt;configure\n    ...       xmlns=\"http://iwm-kmrc.de/bebop\"\n    ...      &gt;\n    ...     &lt;protocol package=\"bebop.protocol.demo.package\"\n    ...               record=\"demo/package/protocol.zcml\"/&gt;\n    ... &lt;/configure&gt;'''\n    &gt;&gt;&gt; ignore = xmlconfig.string(protocol_zcml, context=context)\n\nIf you compare the demo code in bebop.protocol.demo.package with the \nresulting configuration, you can estimate the amount of saved typed text:\n\n    &gt;&gt;&gt; print open(context.path('demo/package/protocol.zcml')).read()\n    &lt;configure\n           xmlns:zope=\"http://namespaces.zope.org/zope\"\n          &gt;\n       &lt;!-- GENERATED PROTOCOL. DO NOT MODIFY OR INCLUDE --&gt;\n       &lt;zope:adapter\n          factory=\"bebop.protocol.demo.package.adapter.SampleAdapter\"\n          for=\"zope.interface.Interface\"\n       /&gt;\n       &lt;zope:adapter\n          factory=\"bebop.protocol.demo.package.adapter.NamedSampleAdapter\"\n          for=\"zope.interface.Interface\"\n          name=\"demo\"\n       /&gt;\n       &lt;zope:adapter\n          factory=\"bebop.protocol.demo.package.adapter.SampleMultiAdapter\"\n          for=\"str int\"\n       /&gt;\n       &lt;zope:adapter\n          factory=\"bebop.protocol.demo.package.adapter.TrustedAdapter\"\n          for=\"dict\"\n          trusted=\"True\"\n       /&gt;\n       &lt;zope:utility\n          factory=\"bebop.protocol.demo.package.utility.SampleUtility\"\n       /&gt;\n       &lt;zope:utility\n          component=\"bebop.protocol.demo.package.utility.sampleComponent\"\n       /&gt;\n       &lt;zope:utility\n          component=\"bebop.protocol.demo.package.utility.SampleComponentUtility\"\n          provides=\"zope.component.interfaces.IFactory\"\n       /&gt;\n       &lt;zope:utility\n          permission=\"zope.View\"\n          factory=\"bebop.protocol.demo.package.utility.SampleNamedUtility\"\n          name=\"demo\"\n       /&gt;\n       &lt;zope:subscriber\n          handler=\"bebop.protocol.demo.package.subscriber.sampleSubscriber\"\n          for=\"bebop.protocol.demo.package.interfaces.ISampleEvent\"\n       /&gt;\n       &lt;zope:class class=\"bebop.protocol.demo.package.security.SampleClass\"&gt;\n           &lt;zope:factory\n                  id=\"bebop.protocol.demo.package.security.SampleClass\"\n           /&gt;\n           &lt;zope:require\n                  permission=\"zope.View\"\n                  interface=\"...demo.package.interfaces.ISampleClass\"\n           /&gt;\n           &lt;zope:require\n                  permission=\"zope.MangeContent\"\n                  interface=\"...demo.package.interfaces.IProtectedMethods\"\n           /&gt;\n           &lt;zope:allow\n                  interface=\"...demo.package.interfaces.IPublicMethods\"\n           /&gt;\n           &lt;zope:require\n                  permission=\"zope.MangeContent\"\n                  set_attributes=\"protected_attribute\"\n           /&gt;\n       &lt;/class&gt;\n    &lt;/configure&gt;\n    \nLet's check whether the protocol directive registers the components correctly:\n\n    &gt;&gt;&gt; from bebop.protocol.demo.package import interfaces\n    &gt;&gt;&gt; from bebop.protocol.demo.package.utility import sampleComponent\n    &gt;&gt;&gt; utility = zope.component.getUtility(interfaces.ISampleComponentUtility)\n    &gt;&gt;&gt; utility == sampleComponent\n    True\n    \n    &gt;&gt;&gt; from bebop.protocol.demo.package.utility import SampleComponentUtility\n    &gt;&gt;&gt; factory = zope.component.getUtility(zope.component.interfaces.IFactory)\n    &gt;&gt;&gt; factory == SampleComponentUtility\n    True\n    \n    &gt;&gt;&gt; from bebop.protocol.demo.package.subscriber import SampleEvent\n    &gt;&gt;&gt; import zope.event\n    &gt;&gt;&gt; zope.event.notify(SampleEvent())\n    sampleEventSubscriber called\n    \nSometimes, mostly in tests, it might be usefull to activate the protocol \ndirectly.  Most protocols support activate and deactivate methods which \nregister and unregister the corresponding components. The classPotocol \nabove is an exception to this rule since this protocol is not able to \nrevert the security settings. All following protocols can be activated\nand deactivated at will.\n\n\nAdapter Protocol\n================\n\nThe adapter protocol mimics the ZCML adapter directive. The protocol.adapter\ndeclaration says that an object or function can be used as an adapter:\n    \n    &gt;&gt;&gt; class ISample(zope.interface.Interface):\n    ...     def foo(self):\n    ...         pass\n    \n    &gt;&gt;&gt; class Adapted(object):\n    ...     pass\n    &gt;&gt;&gt; class SampleAdapter(object):\n    ...     zope.interface.implements(ISample)\n    ...     protocol.adapter(Adapted, permission='zope.View')\n    ...     def __init__(self, context):\n    ...         self.context = context\n    ...     def foo(self):\n    ...         print 'foo'\n    \nThe protocol has to be activated before we can use the adapter:\n\n    &gt;&gt;&gt; ISample(Adapted()).foo()\n    Traceback (most recent call last):\n    ...\n    TypeError: ('Could not adapt', &lt;bebop.protocol.readme.Adapted object at ...\n\nWe need an explicit activation of the underlying protocol:\n\n    &gt;&gt;&gt; protocol.adapterProtocol.activate()\n    \nAfter the protocol has been activated the adapter works as expected:\n\n    &gt;&gt;&gt; ISample(Adapted()).foo()\n    foo\n    \nFunctions can also be declared as adapter factories. This is done by calling \nprotocol.adapter as a function decorator:\n\n    &gt;&gt;&gt; class ISampleAnnotation(zope.interface.Interface):\n    ...     pass\n    &gt;&gt;&gt; class SampleAnnotations(object):\n    ...     def __init__(self, context):\n    ...         self.context = context\n    \n    &gt;&gt;&gt; @protocol.adapter(Adapted, provides=ISampleAnnotation)\n    ... def sampleannotation(obj):\n    ...     return SampleAnnotations(obj)\n    &gt;&gt;&gt; ISampleAnnotation(Adapted())\n    &lt;bebop.protocol.readme.SampleAnnotations object at ...&gt;\n    \nLet's see what has been recorded:\n    \n    &gt;&gt;&gt; adapterProtocol = protocol.adapterProtocol\n    &gt;&gt;&gt; print adapterProtocol.record(modules=('bebop.protocol.readme',))\n    &lt;configure\n           xmlns:zope=\"http://namespaces.zope.org/zope\"\n          &gt;\n       &lt;!-- GENERATED PROTOCOL. DO NOT MODIFY OR INCLUDE --&gt;\n       &lt;zope:adapter\n          factory=\"bebop.protocol.readme.SampleAdapter\"\n          for=\"bebop.protocol.readme.Adapted\"\n          permission=\"zope.View\"\n       /&gt;\n       &lt;zope:adapter\n          factory=\"bebop.protocol.readme.sampleannotation\"\n          provides=\"bebop.protocol.readme.ISampleAnnotation\"\n          for=\"bebop.protocol.readme.Adapted\"\n       /&gt;\n    &lt;/configure&gt;\n\n    &gt;&gt;&gt; protocol.adapterProtocol.reopen()\n    \n\nUtility Protocol\n================\n\nIn ZCML you can declare a utility factory or a component. The same can be \ndone with the protocol.utility declaration:\n\n    &gt;&gt;&gt; class SampleUtility(object):\n    ...     zope.interface.implements(ISample)\n    &gt;&gt;&gt; protocol.utility(factory=SampleUtility, name='test1')\n\nIn cases were the name and module can be deduced from the object (e.g.\nclasses and functions), you can provide the object itself:\n\n    &gt;&gt;&gt; def utilityFunction(): print \"called utility function\"\n    &gt;&gt;&gt; protocol.utility(\n    ...     component=utilityFunction,\n    ...     provides=ISample,\n    ...     name='test3')\n    \nIf you assign a component to a variable for future reference you have to\nuse a syntax which deviates a little from the corresponding ZCML directive \nsince the variable name is available to the component itself (the module can\nbe taken from the internal stack frame of the utility call):\n\n    &gt;&gt;&gt; sampleUtility = SampleUtility()\n    &gt;&gt;&gt; protocol.utility(\n    ...     component=sampleUtility,\n    ...     variable='sampleUtility',\n    ...     name='test2')\n    \nLet's see how these declarations have been recorded:\n\n    &gt;&gt;&gt; utilityProtocol = protocol.utilityProtocol\n    &gt;&gt;&gt; print utilityProtocol.record(modules=('bebop.protocol.readme',))\n    &lt;configure\n           xmlns:zope=\"http://namespaces.zope.org/zope\"\n          &gt;\n       &lt;!-- GENERATED PROTOCOL. DO NOT MODIFY OR INCLUDE --&gt;\n       &lt;zope:utility\n          factory=\"bebop.protocol.readme.SampleUtility\"\n          name=\"test1\"\n       /&gt;\n       &lt;zope:utility\n          component=\"bebop.protocol.readme.utilityFunction\"\n          provides=\"bebop.protocol.readme.ISample\"\n          name=\"test3\"\n       /&gt;\n       &lt;zope:utility\n          component=\"bebop.protocol.readme.sampleUtility\"\n          name=\"test2\"\n       /&gt;\n    &lt;/configure&gt;\n\nSince the underlying protocol has not been activated yet the objects are \nnot registered:\n\n    &gt;&gt;&gt; zope.component.getUtility(ISample, name='test1')\n    Traceback (most recent call last):\n    ...\n    ComponentLookupError: (&lt;InterfaceClass ...readme.ISample&gt;, 'test1')\n\nThe utilities can be used only after an explicit activation:\n\n    &gt;&gt;&gt; protocol.utilityProtocol.activate()\n    &gt;&gt;&gt; zope.component.getUtility(ISample, name='test1')\n    &lt;bebop.protocol.readme.SampleUtility object at ...&gt;\n    \n    &gt;&gt;&gt; sampleUtility is zope.component.getUtility(ISample, name='test2')\n    True\n    \n    &gt;&gt;&gt; zope.component.getUtility(ISample, name='test3')()\n    called utility function\n\n\nSubscriber Protocol\n===================\n\nA subscriber can be declared as follows:\n\n    &gt;&gt;&gt; from zope.lifecycleevent.interfaces import IObjectCreatedEvent\n    &gt;&gt;&gt; @protocol.subscriber(IPerson, IObjectCreatedEvent)\n    ... def personCreatedHandler(obj, event):\n    ...     print \"personCreatedHandler called\"\n    \nThis corresponds to the following ZCML:\n\n    &gt;&gt;&gt; subscriberProtocol = protocol.subscriberProtocol\n    &gt;&gt;&gt; print subscriberProtocol.record(modules=('bebop.protocol.readme',))\n    &lt;configure\n           xmlns:zope=\"http://namespaces.zope.org/zope\"\n          &gt;\n       &lt;!-- GENERATED PROTOCOL. DO NOT MODIFY OR INCLUDE --&gt;\n       &lt;zope:subscriber\n          handler=\"bebop.protocol.readme.personCreatedHandler\"\n          for=\"bebop.protocol.readme.IPerson ...IObjectCreatedEvent\"\n       /&gt;\n    &lt;/configure&gt;\n    \nAgain the corresponding protocol must be activated:\n\n    &gt;&gt;&gt; subscriberProtocol.activate()\n    \n    &gt;&gt;&gt; person = Person()   \n    &gt;&gt;&gt; event = zope.lifecycleevent.ObjectCreatedEvent(person)\n    &gt;&gt;&gt; zope.component.event.objectEventNotify(event)\n    personCreatedHandler called\n\n\nDownload\n**********************", "description_content_type": null, "docs_url": null, "download_url": "UNKNOWN", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "http://svn.kmrc.de/projects/devel/bebop.protocol", "keywords": "zope3 ZCML generation configuration", "license": "GPL", "maintainer": null, "maintainer_email": null, "name": "bebop.protocol", "package_url": "https://pypi.org/project/bebop.protocol/", "platform": "any", "project_url": "https://pypi.org/project/bebop.protocol/", "project_urls": {"Download": "UNKNOWN", "Homepage": "http://svn.kmrc.de/projects/devel/bebop.protocol"}, "release_url": "https://pypi.org/project/bebop.protocol/0.1/", "requires_dist": null, "requires_python": null, "summary": "This package allows to register components from Python. It also provides a basic implementation of generic functions in Zope3", "version": "0.1", "yanked": false, "html_description": "<div class=\"project-description\">\n            Bebop Protocol<br>==============<br><br>This package contains a extension to Zope3 which simplifies the registration<br>of components.<br><br>Zope3 has been criticized as an overly complex and difficult to learn framework.<br>Especially the ZCML configuration language and the missing Python API for <br>configuration actions has been a topic of debate.<br><br>This package tries to combine the conciseness of Python with the explicitness, <br>fine-grained configurability, and conflict management of ZCML. A protocol is a <br>Python object that defines how a component is registered and configured, how <br>the component is called, and how it is unregistered. Protocols are used and <br>extended by declarations, i.e. class advisors and decorators that correspond <br>to existing ZCML directives. All declarations within a package can be activated <br>with a single line of ZCML. The equivalent ZCML configuration can be recorded <br>for documentary purposes and used as a basis for more selective configurations <br>and overloads.<br><br>Since the protocol package mimics the ZCML directives as closely as possible <br>it provides no extra learning curve for the experienced Zope3 programmer. <br>Predefined protocols are available for adapters, utilities, subscribers, pages,<br>and menus. Since protocols are extensible, they can also be used to define <br>generic functions and extend the component architecture with special forms <br>of utilities and adapter lookup without the need to define new ZCML directives. <br><br><br>Detailed Documentation<br>**********************<br><br>=========<br>Protocols<br>=========<br><br>This package defines Protocols that use Zope's component registry.<br>It was inspired by Tim Hochberg's way to register generic functions.<br><br>    http://mail.python.org/pipermail/python-3000/2006-April/000394.html<br>    <br>Basically a Protocol says how a component is configured and how it is called.<br>Therefore each Protocol has two main methods: configure and __call__.<br>The configure method triggers the configuration actions which in turn<br>ensure the registration/activation of the protocol elements.<br>This is typically done in production mode via a few ZCML directives<br>which are part of the protocol package. Since you often want to<br>extend a protocol with application specific behavior you can<br>also activate protocol additions via ZCML. <br><br>Most protocols support an `activate` method. This method<br>registers all component declarations that have been collected <br>in the protocol. A typical use case are doctests where you want to<br>ensure that protocol elements like adapters and utilities are registered.<br><br>In the following we describe how protocols interact with content classes, <br>adapters, utilities, and subscribers. See browser.txt for view related <br>protocols and generic.txt for an implementation of generic functions.<br><br><br>Hello World<br>===========<br><br>Let's start with \"hello world\". In demo/hello you find the usual structure<br>of a Zope3 application:<br><br>    interfaces.py: the involved (public) interfaces which are needed<br>                   to make things replaceable and extensible<br>    world.py:      the content class and a basic implementation <br>                   of the content related interfaces<br>    greeting.py:   the view that shows the mini program to the user<br>    configure.zcml the ZCML statements which feed the component registries<br><br>All this can be reduced to a single file (demo/hello/allinone.py):<br><br>    from persistent import Persistent <br>    from zope.publisher.browser import BrowserView <br>    <br>    from bebop.protocol import protocol<br>    from bebop.protocol import browser<br>    <br>    class World(Persistent): <br>        pass<br>    <br>    greet = protocol.GenericFunction('IGreet')<br>    @greet.when(World)<br>    def greet_world(world):<br>        return 'world'<br>    <br>    class Greeting(BrowserView): <br>        browser.page(World, name=\"greet\", permission='zope.Public')<br>      <br>        def __call__(self): <br>            return \"Hello %s\" % greet(self.context) <br><br><br>Note that this file contains no reference to external interfaces and no<br>ZCML. Even the model and the view are in the same file. That of course<br>works only in simple cases, in more complex applications it may be<br>necessary to split things up, and then the traditional Zope3 structure<br>make of course much more sense. So this example is not intended to show<br>that there is something inherently bad with Zope3's verbosity.<br>To the contrary: We strive at a simplification that integrates well <br>with existing Zope3 packages and at the same time allows to simplify <br>things without loosing the explicitness of Zope3.<br><br>The example illustrates two main ideas which are the core of this package:<br><br>    1. ZCML statements integrated into the Python code as class advisors<br>       and method decorators<br>       <br>    2. A generic function ``greet``that replaces all the IGreetable, IGreet<br>       interfaces without loosing the replaceability and extensibility<br>       of the Zope component architecture.<br><br>The necessary ZCML can be generated from the source code since most of<br>the class advisors and decorators are equivalent to existing ZCML<br>statements. The browser.pages directive, for instance, exactly matches<br>the following ZCML snippet:<br><br>    &amp;lt;browser:pages name=\"greet\"/&amp;gt;<br>   <br>The generic function ``greet`` however goes beyond the simple idea<br>of putting configuration statements into the code. It show's that Zope3's<br>component architecture is rich enough to maintain extensions which<br>were not anticipated by the original design. If we look at the complete<br>generated ZCML of this example we see that the generic function is <br>registered as an adapter for an interface that is generated by the<br>GenericFunction factory:<br>   <br>    &amp;gt;&amp;gt;&amp;gt; from bebop.protocol.directive import record<br>    &amp;gt;&amp;gt;&amp;gt; print record(module='bebop.protocol.demo.hello.allinone')<br>    &amp;lt;configure<br>           xmlns:browser=\"http://namespaces.zope.org/browser\"<br>           xmlns:zope=\"http://namespaces.zope.org/zope\"<br>          &amp;gt;<br>       &amp;lt;!-- GENERATED PROTOCOL. DO NOT MODIFY OR INCLUDE --&amp;gt;<br>       &amp;lt;browser:page<br>          class=\"bebop.protocol.demo.hello.allinone.Greeting\"<br>          layer=\"zope.publisher.interfaces.browser.IDefaultBrowserLayer\"<br>          for=\"bebop.protocol.demo.hello.allinone.World\"<br>          permission=\"zope.Public\"<br>          name=\"greet\"<br>          attribute=\"__call__\"<br>       /&amp;gt;<br>       &amp;lt;zope:adapter<br>          factory=\"bebop.protocol.demo.hello.allinone.greet_world\"<br>          provides=\"bebop.protocol.demo.hello.allinone.IGreet\"<br>          for=\"bebop.protocol.demo.hello.allinone.World\"<br>       /&amp;gt;<br>    &amp;lt;/configure&amp;gt;<br><br><br>Both ideas are elaborated in the following. Protocols are the basic<br>building blocks of this approach.<br><br><br>Class Protocol<br>==============<br><br>For many cases it is sufficient to use the predefined protocols. The class<br>protocol may serve as an example. It closely mimics the ZCML class <br>directive since the protocol does exactly what the directive does: it<br>configures the security machinery. There's only one important difference. <br>The protocol is completely written in Python, and the corresponding <br>ZCML directives are generated from the Python code.<br><br>    &amp;gt;&amp;gt;&amp;gt; class IPerson(zope.interface.Interface):<br>    ...     name = zope.interface.Attribute(u'The name of the person')<br>    ...     email = zope.interface.Attribute(u'The email address')<br><br>    &amp;gt;&amp;gt;&amp;gt; from bebop.protocol import protocol<br>    &amp;gt;&amp;gt;&amp;gt; class Person(object):<br>    ...     zope.interface.implements(IPerson)<br>    ...     protocol.classProtocol.require(<br>    ...         permission=\"zope.View\",<br>    ...         interface=IPerson)<br><br>We could have used `require` as a shorthand for `classProtocol.require`.<br>The more explict form was choosen to make clear that the a predefined protocol <br>instance is involved.<br><br>The protocol collects all declarations and allows to configure the described<br>objects according to these declarations. We can inspect the protocol by <br>calling it's report method. This method returns the corresponding configuration<br>statements which belong to a set of modules:<br><br>    &amp;gt;&amp;gt;&amp;gt; print protocol.classProtocol.record(modules=('bebop.protocol.readme',))<br>    &amp;lt;configure<br>           xmlns:zope=\"http://namespaces.zope.org/zope\"<br>          &amp;gt;<br>       &amp;lt;!-- GENERATED PROTOCOL. DO NOT MODIFY OR INCLUDE --&amp;gt;<br>       &amp;lt;zope:class class=\"bebop.protocol.readme.Person\"&amp;gt;<br>           &amp;lt;zope:require<br>                  permission=\"zope.View\"<br>                  interface=\"bebop.protocol.readme.IPerson\"<br>           /&amp;gt;<br>       &amp;lt;/class&amp;gt;<br>    &amp;lt;/configure&amp;gt;<br><br>Since this written record is like a contract further modifications to the <br>protocol are prohibited:<br><br>    &amp;gt;&amp;gt;&amp;gt; class Employee(object):<br>    ...     zope.interface.implements(IPerson)<br>    ...     protocol.classProtocol.require(<br>    ...         permission=\"zope.View\",<br>    ...         interface=IPerson)<br>    Traceback (most recent call last):<br>    ...<br>    ProtocolError: protocol 'class' is written and must be reopened ...<br><br>We must explicitely reopen the protocol to allow further extensions:<br><br>    &amp;gt;&amp;gt;&amp;gt; protocol.classProtocol.reopen()<br>    &amp;gt;&amp;gt;&amp;gt; class Employee2(object):<br>    ...     zope.interface.implements(IPerson)<br>    ...     protocol.classProtocol.require(<br>    ...         permission=\"zope.View\",<br>    ...         interface=IPerson)<br><br>Declarations as such have no consequences (as in politics). We have <br>enact the protocol in order to use the declarations. Typically this<br>is done in ZCML. We need to load the metaconfiguration first:<br><br>    &amp;gt;&amp;gt;&amp;gt; from zope.configuration import xmlconfig<br>    &amp;gt;&amp;gt;&amp;gt; import bebop.protocol<br>    &amp;gt;&amp;gt;&amp;gt; context = xmlconfig.file('meta.zcml',  bebop.protocol)    <br><br>The most powerfull way to enact protocols is a call to the protocol <br>directive.  This directive recursively collects all used protocols in <br>all modules of a package, enacts the declarations, and records the <br>corresponding ZCML directives in a singe file:<br><br>    &amp;gt;&amp;gt;&amp;gt; protocol_zcml = '''&amp;lt;configure<br>    ...       xmlns=\"http://iwm-kmrc.de/bebop\"<br>    ...      &amp;gt;<br>    ...     &amp;lt;protocol package=\"bebop.protocol.demo.package\"<br>    ...               record=\"demo/package/protocol.zcml\"/&amp;gt;<br>    ... &amp;lt;/configure&amp;gt;'''<br>    &amp;gt;&amp;gt;&amp;gt; ignore = xmlconfig.string(protocol_zcml, context=context)<br><br>If you compare the demo code in bebop.protocol.demo.package with the <br>resulting configuration, you can estimate the amount of saved typed text:<br><br>    &amp;gt;&amp;gt;&amp;gt; print open(context.path('demo/package/protocol.zcml')).read()<br>    &amp;lt;configure<br>           xmlns:zope=\"http://namespaces.zope.org/zope\"<br>          &amp;gt;<br>       &amp;lt;!-- GENERATED PROTOCOL. DO NOT MODIFY OR INCLUDE --&amp;gt;<br>       &amp;lt;zope:adapter<br>          factory=\"bebop.protocol.demo.package.adapter.SampleAdapter\"<br>          for=\"zope.interface.Interface\"<br>       /&amp;gt;<br>       &amp;lt;zope:adapter<br>          factory=\"bebop.protocol.demo.package.adapter.NamedSampleAdapter\"<br>          for=\"zope.interface.Interface\"<br>          name=\"demo\"<br>       /&amp;gt;<br>       &amp;lt;zope:adapter<br>          factory=\"bebop.protocol.demo.package.adapter.SampleMultiAdapter\"<br>          for=\"str int\"<br>       /&amp;gt;<br>       &amp;lt;zope:adapter<br>          factory=\"bebop.protocol.demo.package.adapter.TrustedAdapter\"<br>          for=\"dict\"<br>          trusted=\"True\"<br>       /&amp;gt;<br>       &amp;lt;zope:utility<br>          factory=\"bebop.protocol.demo.package.utility.SampleUtility\"<br>       /&amp;gt;<br>       &amp;lt;zope:utility<br>          component=\"bebop.protocol.demo.package.utility.sampleComponent\"<br>       /&amp;gt;<br>       &amp;lt;zope:utility<br>          component=\"bebop.protocol.demo.package.utility.SampleComponentUtility\"<br>          provides=\"zope.component.interfaces.IFactory\"<br>       /&amp;gt;<br>       &amp;lt;zope:utility<br>          permission=\"zope.View\"<br>          factory=\"bebop.protocol.demo.package.utility.SampleNamedUtility\"<br>          name=\"demo\"<br>       /&amp;gt;<br>       &amp;lt;zope:subscriber<br>          handler=\"bebop.protocol.demo.package.subscriber.sampleSubscriber\"<br>          for=\"bebop.protocol.demo.package.interfaces.ISampleEvent\"<br>       /&amp;gt;<br>       &amp;lt;zope:class class=\"bebop.protocol.demo.package.security.SampleClass\"&amp;gt;<br>           &amp;lt;zope:factory<br>                  id=\"bebop.protocol.demo.package.security.SampleClass\"<br>           /&amp;gt;<br>           &amp;lt;zope:require<br>                  permission=\"zope.View\"<br>                  interface=\"...demo.package.interfaces.ISampleClass\"<br>           /&amp;gt;<br>           &amp;lt;zope:require<br>                  permission=\"zope.MangeContent\"<br>                  interface=\"...demo.package.interfaces.IProtectedMethods\"<br>           /&amp;gt;<br>           &amp;lt;zope:allow<br>                  interface=\"...demo.package.interfaces.IPublicMethods\"<br>           /&amp;gt;<br>           &amp;lt;zope:require<br>                  permission=\"zope.MangeContent\"<br>                  set_attributes=\"protected_attribute\"<br>           /&amp;gt;<br>       &amp;lt;/class&amp;gt;<br>    &amp;lt;/configure&amp;gt;<br>    <br>Let's check whether the protocol directive registers the components correctly:<br><br>    &amp;gt;&amp;gt;&amp;gt; from bebop.protocol.demo.package import interfaces<br>    &amp;gt;&amp;gt;&amp;gt; from bebop.protocol.demo.package.utility import sampleComponent<br>    &amp;gt;&amp;gt;&amp;gt; utility = zope.component.getUtility(interfaces.ISampleComponentUtility)<br>    &amp;gt;&amp;gt;&amp;gt; utility == sampleComponent<br>    True<br>    <br>    &amp;gt;&amp;gt;&amp;gt; from bebop.protocol.demo.package.utility import SampleComponentUtility<br>    &amp;gt;&amp;gt;&amp;gt; factory = zope.component.getUtility(zope.component.interfaces.IFactory)<br>    &amp;gt;&amp;gt;&amp;gt; factory == SampleComponentUtility<br>    True<br>    <br>    &amp;gt;&amp;gt;&amp;gt; from bebop.protocol.demo.package.subscriber import SampleEvent<br>    &amp;gt;&amp;gt;&amp;gt; import zope.event<br>    &amp;gt;&amp;gt;&amp;gt; zope.event.notify(SampleEvent())<br>    sampleEventSubscriber called<br>    <br>Sometimes, mostly in tests, it might be usefull to activate the protocol <br>directly.  Most protocols support activate and deactivate methods which <br>register and unregister the corresponding components. The classPotocol <br>above is an exception to this rule since this protocol is not able to <br>revert the security settings. All following protocols can be activated<br>and deactivated at will.<br><br><br>Adapter Protocol<br>================<br><br>The adapter protocol mimics the ZCML adapter directive. The protocol.adapter<br>declaration says that an object or function can be used as an adapter:<br>    <br>    &amp;gt;&amp;gt;&amp;gt; class ISample(zope.interface.Interface):<br>    ...     def foo(self):<br>    ...         pass<br>    <br>    &amp;gt;&amp;gt;&amp;gt; class Adapted(object):<br>    ...     pass<br>    &amp;gt;&amp;gt;&amp;gt; class SampleAdapter(object):<br>    ...     zope.interface.implements(ISample)<br>    ...     protocol.adapter(Adapted, permission='zope.View')<br>    ...     def __init__(self, context):<br>    ...         self.context = context<br>    ...     def foo(self):<br>    ...         print 'foo'<br>    <br>The protocol has to be activated before we can use the adapter:<br><br>    &amp;gt;&amp;gt;&amp;gt; ISample(Adapted()).foo()<br>    Traceback (most recent call last):<br>    ...<br>    TypeError: ('Could not adapt', &amp;lt;bebop.protocol.readme.Adapted object at ...<br><br>We need an explicit activation of the underlying protocol:<br><br>    &amp;gt;&amp;gt;&amp;gt; protocol.adapterProtocol.activate()<br>    <br>After the protocol has been activated the adapter works as expected:<br><br>    &amp;gt;&amp;gt;&amp;gt; ISample(Adapted()).foo()<br>    foo<br>    <br>Functions can also be declared as adapter factories. This is done by calling <br>protocol.adapter as a function decorator:<br><br>    &amp;gt;&amp;gt;&amp;gt; class ISampleAnnotation(zope.interface.Interface):<br>    ...     pass<br>    &amp;gt;&amp;gt;&amp;gt; class SampleAnnotations(object):<br>    ...     def __init__(self, context):<br>    ...         self.context = context<br>    <br>    &amp;gt;&amp;gt;&amp;gt; @protocol.adapter(Adapted, provides=ISampleAnnotation)<br>    ... def sampleannotation(obj):<br>    ...     return SampleAnnotations(obj)<br>    &amp;gt;&amp;gt;&amp;gt; ISampleAnnotation(Adapted())<br>    &amp;lt;bebop.protocol.readme.SampleAnnotations object at ...&amp;gt;<br>    <br>Let's see what has been recorded:<br>    <br>    &amp;gt;&amp;gt;&amp;gt; adapterProtocol = protocol.adapterProtocol<br>    &amp;gt;&amp;gt;&amp;gt; print adapterProtocol.record(modules=('bebop.protocol.readme',))<br>    &amp;lt;configure<br>           xmlns:zope=\"http://namespaces.zope.org/zope\"<br>          &amp;gt;<br>       &amp;lt;!-- GENERATED PROTOCOL. DO NOT MODIFY OR INCLUDE --&amp;gt;<br>       &amp;lt;zope:adapter<br>          factory=\"bebop.protocol.readme.SampleAdapter\"<br>          for=\"bebop.protocol.readme.Adapted\"<br>          permission=\"zope.View\"<br>       /&amp;gt;<br>       &amp;lt;zope:adapter<br>          factory=\"bebop.protocol.readme.sampleannotation\"<br>          provides=\"bebop.protocol.readme.ISampleAnnotation\"<br>          for=\"bebop.protocol.readme.Adapted\"<br>       /&amp;gt;<br>    &amp;lt;/configure&amp;gt;<br><br>    &amp;gt;&amp;gt;&amp;gt; protocol.adapterProtocol.reopen()<br>    <br><br>Utility Protocol<br>================<br><br>In ZCML you can declare a utility factory or a component. The same can be <br>done with the protocol.utility declaration:<br><br>    &amp;gt;&amp;gt;&amp;gt; class SampleUtility(object):<br>    ...     zope.interface.implements(ISample)<br>    &amp;gt;&amp;gt;&amp;gt; protocol.utility(factory=SampleUtility, name='test1')<br><br>In cases were the name and module can be deduced from the object (e.g.<br>classes and functions), you can provide the object itself:<br><br>    &amp;gt;&amp;gt;&amp;gt; def utilityFunction(): print \"called utility function\"<br>    &amp;gt;&amp;gt;&amp;gt; protocol.utility(<br>    ...     component=utilityFunction,<br>    ...     provides=ISample,<br>    ...     name='test3')<br>    <br>If you assign a component to a variable for future reference you have to<br>use a syntax which deviates a little from the corresponding ZCML directive <br>since the variable name is available to the component itself (the module can<br>be taken from the internal stack frame of the utility call):<br><br>    &amp;gt;&amp;gt;&amp;gt; sampleUtility = SampleUtility()<br>    &amp;gt;&amp;gt;&amp;gt; protocol.utility(<br>    ...     component=sampleUtility,<br>    ...     variable='sampleUtility',<br>    ...     name='test2')<br>    <br>Let's see how these declarations have been recorded:<br><br>    &amp;gt;&amp;gt;&amp;gt; utilityProtocol = protocol.utilityProtocol<br>    &amp;gt;&amp;gt;&amp;gt; print utilityProtocol.record(modules=('bebop.protocol.readme',))<br>    &amp;lt;configure<br>           xmlns:zope=\"http://namespaces.zope.org/zope\"<br>          &amp;gt;<br>       &amp;lt;!-- GENERATED PROTOCOL. DO NOT MODIFY OR INCLUDE --&amp;gt;<br>       &amp;lt;zope:utility<br>          factory=\"bebop.protocol.readme.SampleUtility\"<br>          name=\"test1\"<br>       /&amp;gt;<br>       &amp;lt;zope:utility<br>          component=\"bebop.protocol.readme.utilityFunction\"<br>          provides=\"bebop.protocol.readme.ISample\"<br>          name=\"test3\"<br>       /&amp;gt;<br>       &amp;lt;zope:utility<br>          component=\"bebop.protocol.readme.sampleUtility\"<br>          name=\"test2\"<br>       /&amp;gt;<br>    &amp;lt;/configure&amp;gt;<br><br>Since the underlying protocol has not been activated yet the objects are <br>not registered:<br><br>    &amp;gt;&amp;gt;&amp;gt; zope.component.getUtility(ISample, name='test1')<br>    Traceback (most recent call last):<br>    ...<br>    ComponentLookupError: (&amp;lt;InterfaceClass ...readme.ISample&amp;gt;, 'test1')<br><br>The utilities can be used only after an explicit activation:<br><br>    &amp;gt;&amp;gt;&amp;gt; protocol.utilityProtocol.activate()<br>    &amp;gt;&amp;gt;&amp;gt; zope.component.getUtility(ISample, name='test1')<br>    &amp;lt;bebop.protocol.readme.SampleUtility object at ...&amp;gt;<br>    <br>    &amp;gt;&amp;gt;&amp;gt; sampleUtility is zope.component.getUtility(ISample, name='test2')<br>    True<br>    <br>    &amp;gt;&amp;gt;&amp;gt; zope.component.getUtility(ISample, name='test3')()<br>    called utility function<br><br><br>Subscriber Protocol<br>===================<br><br>A subscriber can be declared as follows:<br><br>    &amp;gt;&amp;gt;&amp;gt; from zope.lifecycleevent.interfaces import IObjectCreatedEvent<br>    &amp;gt;&amp;gt;&amp;gt; @protocol.subscriber(IPerson, IObjectCreatedEvent)<br>    ... def personCreatedHandler(obj, event):<br>    ...     print \"personCreatedHandler called\"<br>    <br>This corresponds to the following ZCML:<br><br>    &amp;gt;&amp;gt;&amp;gt; subscriberProtocol = protocol.subscriberProtocol<br>    &amp;gt;&amp;gt;&amp;gt; print subscriberProtocol.record(modules=('bebop.protocol.readme',))<br>    &amp;lt;configure<br>           xmlns:zope=\"http://namespaces.zope.org/zope\"<br>          &amp;gt;<br>       &amp;lt;!-- GENERATED PROTOCOL. DO NOT MODIFY OR INCLUDE --&amp;gt;<br>       &amp;lt;zope:subscriber<br>          handler=\"bebop.protocol.readme.personCreatedHandler\"<br>          for=\"bebop.protocol.readme.IPerson ...IObjectCreatedEvent\"<br>       /&amp;gt;<br>    &amp;lt;/configure&amp;gt;<br>    <br>Again the corresponding protocol must be activated:<br><br>    &amp;gt;&amp;gt;&amp;gt; subscriberProtocol.activate()<br>    <br>    &amp;gt;&amp;gt;&amp;gt; person = Person()   <br>    &amp;gt;&amp;gt;&amp;gt; event = zope.lifecycleevent.ObjectCreatedEvent(person)<br>    &amp;gt;&amp;gt;&amp;gt; zope.component.event.objectEventNotify(event)<br>    personCreatedHandler called<br><br><br>Download<br>**********************\n          </div>"}, "last_serial": 786783, "releases": {"0.1": [{"comment_text": "", "digests": {"md5": "6997b09e736a6571ac12b8efd30ef623", "sha256": "75786b58ef5255ea3231b40d84cd3bc771cdb402413da2db712f06dafba13774"}, "downloads": -1, "filename": "bebop.protocol-0.1.tar.gz", "has_sig": false, "md5_digest": "6997b09e736a6571ac12b8efd30ef623", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 30706, "upload_time": "2007-07-10T20:18:19", "upload_time_iso_8601": "2007-07-10T20:18:19Z", "url": "https://files.pythonhosted.org/packages/da/74/02dd7a4a2e19ade2d0393667cbf3720f9ca62c0430f2c0b347a68a2de4a8/bebop.protocol-0.1.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "6997b09e736a6571ac12b8efd30ef623", "sha256": "75786b58ef5255ea3231b40d84cd3bc771cdb402413da2db712f06dafba13774"}, "downloads": -1, "filename": "bebop.protocol-0.1.tar.gz", "has_sig": false, "md5_digest": "6997b09e736a6571ac12b8efd30ef623", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 30706, "upload_time": "2007-07-10T20:18:19", "upload_time_iso_8601": "2007-07-10T20:18:19Z", "url": "https://files.pythonhosted.org/packages/da/74/02dd7a4a2e19ade2d0393667cbf3720f9ca62c0430f2c0b347a68a2de4a8/bebop.protocol-0.1.tar.gz", "yanked": false}], "timestamp": "Thu May  7 22:37:54 2020"}