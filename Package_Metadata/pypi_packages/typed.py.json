{"info": {"author": "Pavel Panchekha", "author_email": "pavpanchekha@gmail.com", "bugtrack_url": null, "classifiers": ["Development Status :: 4 - Beta", "Intended Audience :: Developers", "License :: OSI Approved :: GNU General Public License (GPL)", "Programming Language :: Python :: 2.6", "Topic :: Software Development :: Libraries :: Python Modules"], "description": "Multiple Dispatch and Inquisitive Types for Python\n==================================================\n\n``typed.py`` implements multimethods (also known as multiple dispatch) for\nPython. However, instead of basing the types used for dispatch on the\nstandard Python class system, ``typed.py`` uses a method called `inquisitive\ntypes`.\n\nDiving In\n---------\n\nStart off by importing the ``typed`` module; you don't need anything besides\nthat. ::\n\n    from typed import *\n\nSome of the names in the typed module may conflict with names you yourself use:\n``typed``, ``typedef``, ``restrict``, ``fn``, ``from_pytype``, and ``eq``. If\nso, take special care to eliminate shadowing.\n\nNow then, let's write a function::\n\n    @typed(String, String)\n    def combine(a, b):\n        return a + b\n\nThis function will require both arguments to be strings::\n\n    >>> combine(\"adsf\", \"adsf\")\n    'asdfasdf'\n    >>> combine(1, 2)\n    Traceback (most recent call last):\n    File \"<stdin>\", line 1, in <module>\n    File \"typed/specialize.py\", line 108, in __call__\n        return self.match(args)[1](*args)\n    File \"typed/specialize.py\", line 103, in match\n        raise TypedError(\"No matches\", self, [x[0] for x in self.sigs])\n    typed.specialize.TypedError: No matches for function <typed function combine at 0xb733a4ec>. Alternatives:\n            (<Type String>, <Type String>)\n\nScary looking error, huh? Note that it tells you the alternative signatures.\n\nAnyway, let's define another variant to this function::\n\n    @typed(String, Integer)\n    def combine(a, n):\n        return a + str(n)\n\nAnd, we can use it normally::\n\n    >>> combine(\"asdf\", 12)\n    'asdf12'\n    >>> combine(\"asdf\", \"asdf\")\n    'asdfasdf'\n\nYay, both signatures work!\n\nThe builtin types include:\n\n    - ``Object`` (anything at all, not just things that inherit from\n      ``object``)\n    - ``Complex`` (``complex``, ``float``, or and integral type)\n    - ``Real`` (``float`` or an integral type)\n    - ``Integer`` (``int`` or ``long``; an integral type)\n    - ``Boolean`` (``bool``)\n    - ``String`` (guess!)\n    - ``Type`` (An inquisitive type)\n    - ``PyType`` (A python class or type)\n    - ``Tuple`` (A tuple of any length or type)\n    - ``List`` (A list of any type) and ``List(T)`` (A list of type ``T``\n      elements)\n    - ``Dict`` (A dict of any type to any type), ``Dict(T)`` (A list where all\n      keys have type ``T``), and ``Dict(K, V)`` (A dict with keys of type ``K``\n      and values of type ``V``)\n    - ``OneOf(*x)`` (Type of things equal to one of the elements of ``x``)\n\nWhat are Inquisitive Types?\n---------------------------\n\nAn inquisitive type is defined by two properties: `is` and `sub`. I'll skip the\nsecond for now, but `is` (which in Python is the method ``is_`` of a type) just\ntakes an object and tells you if that object is an instance of the given type.\nFor example, the `is` method for ``Object`` is simply::\n\n    def is(self, x):\n        return True\n\nBecause, after all, everything is an object. Not that `a priori`, objects have\nno type; one can only ask a type if an object is an instance. This is why they\nare called `inquisitive`: you always have to ask if you want to know if an object\nis an instance of something.\n\nNow, what about that `sub` method I mentioned? This is the analog of\n``issubclass`` for inquisitive types: it takes another type, and tells you if\nthe given type is a subclass of it. For example, the one for ``Object`` is::\n\n    def sub(self, X):\n        if X == self:\n            return True\n        else:\n            return False\n\nThese subclass relations are used to determine which method to call if a\nfunction has, for example, two implementations with signatures ``Integer,\nInteger`` and ``Real, Real``: clearly you want the one with ``Integer``\\ s to\nbe called if possible; and it is, because ``Integer.sub(Real)`` returns\n``True``.\n\nNow, the nice thing is that this allows you to construct more complex types\neasily, using `type functions`. Don't worry, the concept is easy: it's a\nfunction that takes a type and returns a type. For example, consider the\nfunction ``restrict``. ``restrict(T, f, name)`` takes a type ``T`` and returns\na type that only says things are instances if they are instances of that type,\n*and* satisfy the function ``f``. The ``name`` just names the resulting type.\nSo, for example::\n\n    >>> EvenInt = restrict(Integer, lambda x: x % 2 == 0, \"EvenInt\")\n    <type EvenInt>\n    >>> isinstance(4, EvenInt)\n    True\n    >>> isinstance(3, EvenInt)\n    False\n\nSome other type functions are built in to ``typed.py``. ``fn(f)`` is another way\nof saying ``restrict(Object, f)``. ``typedef(T, name)`` copies the type ``T``\nand renames it (sometimes useful if you use type functions to construct types).\n``eq(x)`` creates a new type whose only instance is ``x``; it's equivalent to\n``OneOf(x)``. Finally, ``from_pytype`` is a compatibility feature, taking any\nPython type and returning a new inquisitive type.\n\nFurthermore, a few useful type functions have nice operator syntax. For example::\n\n    >>> isinstance((3, 4), Integer * Integer)\n    True\n    >>> isinstance((\"foo\", \"bar\", \"baz\"), String ** 3)\n    True\n    >>> isinstance(5, Integer < 3)\n    False\n    >>> isinstance(7, Integer > -2)\n    True\n    >>> isinstance(\"a\", eq(\"a\") | eq(\"b\"))\n    True\n    >>> map(lambda x: isinstance(x, Integer | String), [1, \"a\", 17.3, \"17.3\", True])\n    [True, True, False, True, False]\n    >>> isinstance(12, (3 < Integer) < 17)\n    True\n\nNote that in the last example, you *must* place parentheses around one of the\ntwo comparisons. It doesn't matter which one; this is simply a fault of Python's\nsyntax.\n\nUse in APIs\n-----------\n\nOne can use ``typed.py`` for simple type checking::\n\n    @typed(Real)\n    def sqrt(x):\n        ...\n\nOr, you can use it to dispatch based on type::\n\n    @typed(Real)\n    def sqrt(x):\n        import math\n        return math.sqrt(x)\n\n    @typed(Complex)\n    def sqrt(x):\n        import cmath\n        return cmath.sqrt(x)\n\nYou can eliminate boring conditional checks::\n\n    @typed(Integer < 10000)\n    def is_prime(x):\n        return do_bruteforce(x)\n\n    @typed(Integer)\n    def is_prime(x):\n        return elliptic_curve_primality_test(x)\n\nYou can also dispatch, because these are inquisitive types, on specifics of the\narguments::\n\n    @typed(restrict(String, lambda x: x.startswith(\"http\")))\n    def download(x):\n        import urllib\n        return urllib.urlopen(x).read()\n\n    @typed(restrict(String, lambda x: x.startswith(\"ftp\")))\n    def download(x):\n        import ftplib\n        f = ftplib.FTP(dir)\n        return f.getwelcome()\n\nFinally, you can combine these to make those strings you ask people to pass to\nidentify things to do type-safe::\n\n    Color = typedef(OneOf(\"green\", \"yellow\", \"red\"), \"Color\")\n\n    @typed(Banana, Color)\n    def eat(b, color):\n        if color == \"green\":\n            print \"Hold on\"\n        elif color == \"yellow\":\n            print \"Go ahead\"\n        elif color == \"red\":\n            print \"Where the **** did you get that banana?\" # -- Mitch Hedburg\n\nAdmittedly, in that last example, you'd probably write three methods and use\n``eq`` to create types corresponding to each color.\n\nLastly, you can now create singletons that are easy to use: just use ``eq``\nconstructors on a string.\n\nType Types and so on\n--------------------\n\n::\n\n    >>> isinstance(Integer, Type)\n    True\n\nSee, types can have types (it's like metatypes, only it makes sense!). In fact,\nit actually gets a bit spookier, because::\n\n    >>> isinstance(Type, Type)\n    True\n\nIt's ``Type``\\ s all the way down! ::\n\n    >>> isinstance(Object, Object)\n    True\n\nUntil you hit the ``Object``\\ s, that is.\n\nA Short Note on Covariance\n--------------------------\n\n::\n\n    >>> a = [1, 2, 3]\n    >>> isinstance(a, List(Integer))\n    True\n    >>> isinstance(a, List(Complex))\n    True\n    >>> a[1] = \"asdf\"\n    >>> isinstance(a, List(Integer))\n    False\n\n``List``\\ s (and ``Dict``\\ ionaries) covary with their contained types. This\nraises the usual endless troubles. Cry me a river. Or, better yet, deal with it.", "description_content_type": null, "docs_url": null, "download_url": "UNKNOWN", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "http://pypi.python.org/pypi/typed.py/", "keywords": null, "license": "LICENSE.txt", "maintainer": null, "maintainer_email": null, "name": "typed.py", "package_url": "https://pypi.org/project/typed.py/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/typed.py/", "project_urls": {"Download": "UNKNOWN", "Homepage": "http://pypi.python.org/pypi/typed.py/"}, "release_url": "https://pypi.org/project/typed.py/1.0.0.1/", "requires_dist": null, "requires_python": null, "summary": "Inquisitive types and multiple dispatch, now for Python!", "version": "1.0.0.1", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p><tt>typed.py</tt> implements multimethods (also known as multiple dispatch) for\nPython. However, instead of basing the types used for dispatch on the\nstandard Python class system, <tt>typed.py</tt> uses a method called <cite>inquisitive\ntypes</cite>.</p>\n<div id=\"diving-in\">\n<h2>Diving In</h2>\n<p>Start off by importing the <tt>typed</tt> module; you don\u2019t need anything besides\nthat.</p>\n<pre>from typed import *\n</pre>\n<p>Some of the names in the typed module may conflict with names you yourself use:\n<tt>typed</tt>, <tt>typedef</tt>, <tt>restrict</tt>, <tt>fn</tt>, <tt>from_pytype</tt>, and <tt>eq</tt>. If\nso, take special care to eliminate shadowing.</p>\n<p>Now then, let\u2019s write a function:</p>\n<pre>@typed(String, String)\ndef combine(a, b):\n    return a + b\n</pre>\n<p>This function will require both arguments to be strings:</p>\n<pre>&gt;&gt;&gt; combine(\"adsf\", \"adsf\")\n'asdfasdf'\n&gt;&gt;&gt; combine(1, 2)\nTraceback (most recent call last):\nFile \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nFile \"typed/specialize.py\", line 108, in __call__\n    return self.match(args)[1](*args)\nFile \"typed/specialize.py\", line 103, in match\n    raise TypedError(\"No matches\", self, [x[0] for x in self.sigs])\ntyped.specialize.TypedError: No matches for function &lt;typed function combine at 0xb733a4ec&gt;. Alternatives:\n        (&lt;Type String&gt;, &lt;Type String&gt;)\n</pre>\n<p>Scary looking error, huh? Note that it tells you the alternative signatures.</p>\n<p>Anyway, let\u2019s define another variant to this function:</p>\n<pre>@typed(String, Integer)\ndef combine(a, n):\n    return a + str(n)\n</pre>\n<p>And, we can use it normally:</p>\n<pre>&gt;&gt;&gt; combine(\"asdf\", 12)\n'asdf12'\n&gt;&gt;&gt; combine(\"asdf\", \"asdf\")\n'asdfasdf'\n</pre>\n<p>Yay, both signatures work!</p>\n<p>The builtin types include:</p>\n<blockquote>\n<ul>\n<li><tt>Object</tt> (anything at all, not just things that inherit from\n<tt>object</tt>)</li>\n<li><tt>Complex</tt> (<tt>complex</tt>, <tt>float</tt>, or and integral type)</li>\n<li><tt>Real</tt> (<tt>float</tt> or an integral type)</li>\n<li><tt>Integer</tt> (<tt>int</tt> or <tt>long</tt>; an integral type)</li>\n<li><tt>Boolean</tt> (<tt>bool</tt>)</li>\n<li><tt>String</tt> (guess!)</li>\n<li><tt>Type</tt> (An inquisitive type)</li>\n<li><tt>PyType</tt> (A python class or type)</li>\n<li><tt>Tuple</tt> (A tuple of any length or type)</li>\n<li><tt>List</tt> (A list of any type) and <tt>List(T)</tt> (A list of type <tt>T</tt>\nelements)</li>\n<li><tt>Dict</tt> (A dict of any type to any type), <tt>Dict(T)</tt> (A list where all\nkeys have type <tt>T</tt>), and <tt>Dict(K, V)</tt> (A dict with keys of type <tt>K</tt>\nand values of type <tt>V</tt>)</li>\n<li><tt><span class=\"pre\">OneOf(*x)</span></tt> (Type of things equal to one of the elements of <tt>x</tt>)</li>\n</ul>\n</blockquote>\n</div>\n<div id=\"what-are-inquisitive-types\">\n<h2>What are Inquisitive Types?</h2>\n<p>An inquisitive type is defined by two properties: <cite>is</cite> and <cite>sub</cite>. I\u2019ll skip the\nsecond for now, but <cite>is</cite> (which in Python is the method <tt>is_</tt> of a type) just\ntakes an object and tells you if that object is an instance of the given type.\nFor example, the <cite>is</cite> method for <tt>Object</tt> is simply:</p>\n<pre>def is(self, x):\n    return True\n</pre>\n<p>Because, after all, everything is an object. Not that <cite>a priori</cite>, objects have\nno type; one can only ask a type if an object is an instance. This is why they\nare called <cite>inquisitive</cite>: you always have to ask if you want to know if an object\nis an instance of something.</p>\n<p>Now, what about that <cite>sub</cite> method I mentioned? This is the analog of\n<tt>issubclass</tt> for inquisitive types: it takes another type, and tells you if\nthe given type is a subclass of it. For example, the one for <tt>Object</tt> is:</p>\n<pre>def sub(self, X):\n    if X == self:\n        return True\n    else:\n        return False\n</pre>\n<p>These subclass relations are used to determine which method to call if a\nfunction has, for example, two implementations with signatures <tt>Integer,\nInteger</tt> and <tt>Real, Real</tt>: clearly you want the one with <tt>Integer</tt>s to\nbe called if possible; and it is, because <tt>Integer.sub(Real)</tt> returns\n<tt>True</tt>.</p>\n<p>Now, the nice thing is that this allows you to construct more complex types\neasily, using <cite>type functions</cite>. Don\u2019t worry, the concept is easy: it\u2019s a\nfunction that takes a type and returns a type. For example, consider the\nfunction <tt>restrict</tt>. <tt>restrict(T, f, name)</tt> takes a type <tt>T</tt> and returns\na type that only says things are instances if they are instances of that type,\n<em>and</em> satisfy the function <tt>f</tt>. The <tt>name</tt> just names the resulting type.\nSo, for example:</p>\n<pre>&gt;&gt;&gt; EvenInt = restrict(Integer, lambda x: x % 2 == 0, \"EvenInt\")\n&lt;type EvenInt&gt;\n&gt;&gt;&gt; isinstance(4, EvenInt)\nTrue\n&gt;&gt;&gt; isinstance(3, EvenInt)\nFalse\n</pre>\n<p>Some other type functions are built in to <tt>typed.py</tt>. <tt>fn(f)</tt> is another way\nof saying <tt>restrict(Object, f)</tt>. <tt>typedef(T, name)</tt> copies the type <tt>T</tt>\nand renames it (sometimes useful if you use type functions to construct types).\n<tt>eq(x)</tt> creates a new type whose only instance is <tt>x</tt>; it\u2019s equivalent to\n<tt>OneOf(x)</tt>. Finally, <tt>from_pytype</tt> is a compatibility feature, taking any\nPython type and returning a new inquisitive type.</p>\n<p>Furthermore, a few useful type functions have nice operator syntax. For example:</p>\n<pre>&gt;&gt;&gt; isinstance((3, 4), Integer * Integer)\nTrue\n&gt;&gt;&gt; isinstance((\"foo\", \"bar\", \"baz\"), String ** 3)\nTrue\n&gt;&gt;&gt; isinstance(5, Integer &lt; 3)\nFalse\n&gt;&gt;&gt; isinstance(7, Integer &gt; -2)\nTrue\n&gt;&gt;&gt; isinstance(\"a\", eq(\"a\") | eq(\"b\"))\nTrue\n&gt;&gt;&gt; map(lambda x: isinstance(x, Integer | String), [1, \"a\", 17.3, \"17.3\", True])\n[True, True, False, True, False]\n&gt;&gt;&gt; isinstance(12, (3 &lt; Integer) &lt; 17)\nTrue\n</pre>\n<p>Note that in the last example, you <em>must</em> place parentheses around one of the\ntwo comparisons. It doesn\u2019t matter which one; this is simply a fault of Python\u2019s\nsyntax.</p>\n</div>\n<div id=\"use-in-apis\">\n<h2>Use in APIs</h2>\n<p>One can use <tt>typed.py</tt> for simple type checking:</p>\n<pre>@typed(Real)\ndef sqrt(x):\n    ...\n</pre>\n<p>Or, you can use it to dispatch based on type:</p>\n<pre>@typed(Real)\ndef sqrt(x):\n    import math\n    return math.sqrt(x)\n\n@typed(Complex)\ndef sqrt(x):\n    import cmath\n    return cmath.sqrt(x)\n</pre>\n<p>You can eliminate boring conditional checks:</p>\n<pre>@typed(Integer &lt; 10000)\ndef is_prime(x):\n    return do_bruteforce(x)\n\n@typed(Integer)\ndef is_prime(x):\n    return elliptic_curve_primality_test(x)\n</pre>\n<p>You can also dispatch, because these are inquisitive types, on specifics of the\narguments:</p>\n<pre>@typed(restrict(String, lambda x: x.startswith(\"http\")))\ndef download(x):\n    import urllib\n    return urllib.urlopen(x).read()\n\n@typed(restrict(String, lambda x: x.startswith(\"ftp\")))\ndef download(x):\n    import ftplib\n    f = ftplib.FTP(dir)\n    return f.getwelcome()\n</pre>\n<p>Finally, you can combine these to make those strings you ask people to pass to\nidentify things to do type-safe:</p>\n<pre>Color = typedef(OneOf(\"green\", \"yellow\", \"red\"), \"Color\")\n\n@typed(Banana, Color)\ndef eat(b, color):\n    if color == \"green\":\n        print \"Hold on\"\n    elif color == \"yellow\":\n        print \"Go ahead\"\n    elif color == \"red\":\n        print \"Where the **** did you get that banana?\" # -- Mitch Hedburg\n</pre>\n<p>Admittedly, in that last example, you\u2019d probably write three methods and use\n<tt>eq</tt> to create types corresponding to each color.</p>\n<p>Lastly, you can now create singletons that are easy to use: just use <tt>eq</tt>\nconstructors on a string.</p>\n</div>\n<div id=\"type-types-and-so-on\">\n<h2>Type Types and so on</h2>\n<pre>&gt;&gt;&gt; isinstance(Integer, Type)\nTrue\n</pre>\n<p>See, types can have types (it\u2019s like metatypes, only it makes sense!). In fact,\nit actually gets a bit spookier, because:</p>\n<pre>&gt;&gt;&gt; isinstance(Type, Type)\nTrue\n</pre>\n<p>It\u2019s <tt>Type</tt>s all the way down!</p>\n<pre>&gt;&gt;&gt; isinstance(Object, Object)\nTrue\n</pre>\n<p>Until you hit the <tt>Object</tt>s, that is.</p>\n</div>\n<div id=\"a-short-note-on-covariance\">\n<h2>A Short Note on Covariance</h2>\n<pre>&gt;&gt;&gt; a = [1, 2, 3]\n&gt;&gt;&gt; isinstance(a, List(Integer))\nTrue\n&gt;&gt;&gt; isinstance(a, List(Complex))\nTrue\n&gt;&gt;&gt; a[1] = \"asdf\"\n&gt;&gt;&gt; isinstance(a, List(Integer))\nFalse\n</pre>\n<p><tt>List</tt>s (and <tt>Dict</tt>ionaries) covary with their contained types. This\nraises the usual endless troubles. Cry me a river. Or, better yet, deal with it.</p>\n</div>\n\n          </div>"}, "last_serial": 746263, "releases": {"1.0": [{"comment_text": "", "digests": {"md5": "c14bc8db7d21001268206ddb6cb1a353", "sha256": "b5262f7c7c2d22d520ee9cb845c543dce1b04e37fcc69b80282910f47a7bb67d"}, "downloads": -1, "filename": "typed.py-1.0.tar.gz", "has_sig": false, "md5_digest": "c14bc8db7d21001268206ddb6cb1a353", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 7402, "upload_time": "2010-06-26T06:01:01", "upload_time_iso_8601": "2010-06-26T06:01:01.624611Z", "url": "https://files.pythonhosted.org/packages/ff/06/3223689b03a5f32145dddabd6d56dcad108996688dc9412abc21fe89ac7e/typed.py-1.0.tar.gz", "yanked": false}], "1.0.0.1": [{"comment_text": "", "digests": {"md5": "ba09d0d774423c830e8b6cd3c2bc6441", "sha256": "c8a72e252de9fd9eedaacc1c20016183e5016ba9ee3d1a107dab8f56b6544ff1"}, "downloads": -1, "filename": "typed.py-1.0.0.1.tar.gz", "has_sig": false, "md5_digest": "ba09d0d774423c830e8b6cd3c2bc6441", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 7411, "upload_time": "2010-06-26T06:05:31", "upload_time_iso_8601": "2010-06-26T06:05:31.400664Z", "url": "https://files.pythonhosted.org/packages/bb/68/af886c4c05d396ca75d4a132400cc5806ada0e2eed8febe869204ff13983/typed.py-1.0.0.1.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "ba09d0d774423c830e8b6cd3c2bc6441", "sha256": "c8a72e252de9fd9eedaacc1c20016183e5016ba9ee3d1a107dab8f56b6544ff1"}, "downloads": -1, "filename": "typed.py-1.0.0.1.tar.gz", "has_sig": false, "md5_digest": "ba09d0d774423c830e8b6cd3c2bc6441", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 7411, "upload_time": "2010-06-26T06:05:31", "upload_time_iso_8601": "2010-06-26T06:05:31.400664Z", "url": "https://files.pythonhosted.org/packages/bb/68/af886c4c05d396ca75d4a132400cc5806ada0e2eed8febe869204ff13983/typed.py-1.0.0.1.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:42:51 2020"}