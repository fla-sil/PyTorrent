{"info": {"author": "Kane Blueriver", "author_email": "kxxoling@gmail.com", "bugtrack_url": null, "classifiers": ["License :: OSI Approved :: BSD License", "Programming Language :: Python", "Programming Language :: Python :: 2.4", "Programming Language :: Python :: 2.5", "Programming Language :: Python :: 2.6", "Programming Language :: Python :: 2.7", "Programming Language :: Python :: 3", "Topic :: Text Processing"], "description": "===============\nPTable Tutorial\n===============\n\nPTable is a simple Python library designed to make it quick and easy to\nrepresent tabular data in visually appealing ASCII tables, originally\nforked from `PrettyTable <https://code.google.com/p/prettytable/>`_ .\n\n.. image:: https://travis-ci.org/kxxoling/PTable.svg\n    :target: https://travis-ci.org/kxxoling/PTable\n    :alt: Build Status\n\n.. image:: https://landscape.io/github/kxxoling/PTable/master/landscape.svg?style=flat\n    :target: https://landscape.io/github/kxxoling/PTable/master\n    :alt: Code Health\n\n.. image:: https://pypip.in/download/PTable/badge.svg?period=week\n    :target: https://pypi.python.org/pypi/PTable/\n    :alt: Downloads\n\n**This tutorial is distributed with PrettyTable and is meant to serve as\na \"quick start\" guide for the lazy or impatient. It is not an exhaustive\ndescription of the whole API, and it is not guaranteed to be 100% up to\ndate. For more complete and update documentation, check the PrettyTable\nwiki at http://code.google.com/p/prettytable/w/list**\n\n\nLinks\n=====\n\n* `Source Code (GitHub) <https://github.com/kxxoling/PrettyTable>`_\n* `PyPI <https://pypi.python.org/pypi/ptabl://pypi.python.org/pypi/ptable>`_\n* `RTFD <https://ptable.readthedocs.org>`_\n\n\nGetting your data into (and out of) the table\n=============================================\n\nLet's suppose you have a shiny new PrettyTable:\n\n::\n\n    from prettytable import PrettyTable\n    x = PrettyTable()\n\nand you want to put some data into it. You have a few options.\n\nRow by row\n----------\n\nYou can add data one row at a time. To do this you can set the field\nnames first using the ``field_names`` attribute, and then add the rows\none at a time using the ``add_row`` method:\n\n::\n\n    x.field_names = [\"City name\", \"Area\", \"Population\", \"Annual Rainfall\"]\n    x.add_row([\"Adelaide\",1295, 1158259, 600.5])\n    x.add_row([\"Brisbane\",5905, 1857594, 1146.4])\n    x.add_row([\"Darwin\", 112, 120900, 1714.7])\n    x.add_row([\"Hobart\", 1357, 205556, 619.5])\n    x.add_row([\"Sydney\", 2058, 4336374, 1214.8])\n    x.add_row([\"Melbourne\", 1566, 3806092, 646.9])\n    x.add_row([\"Perth\", 5386, 1554769, 869.4])\n\nColumn by column\n----------------\n\nYou can add data one column at a time as well. To do this you use the\n``add_column`` method, which takes two arguments - a string which is the\nname for the field the column you are adding corresponds to, and a list\nor tuple which contains the column data\"\n\n::\n\n    x.add_column(\"City name\",\n    [\"Adelaide\",\"Brisbane\",\"Darwin\",\"Hobart\",\"Sydney\",\"Melbourne\",\"Perth\"])\n    x.add_column(\"Area\", [1295, 5905, 112, 1357, 2058, 1566, 5386])\n    x.add_column(\"Population\", [1158259, 1857594, 120900, 205556, 4336374, 3806092,\n    1554769])\n    x.add_column(\"Annual Rainfall\",[600.5, 1146.4, 1714.7, 619.5, 1214.8, 646.9,\n    869.4])\n\nMixing and matching\n-------------------\n\nIf you really want to, you can even mix and match ``add_row`` and\n``add_column`` and build some of your table in one way and some of it in\nthe other. There's a unit test which makes sure that doing things this\nway will always work out nicely as if you'd done it using just one of\nthe two approaches. Tables built this way are kind of confusing for\nother people to read, though, so don't do this unless you have a good\nreason.\n\nImporting data from a CSV file\n------------------------------\n\nIf you have your table data in a comma separated values file (.csv), you\ncan read this data into a PrettyTable like this:\n\n::\n\n    from prettytable import from_csv\n    fp = open(\"myfile.csv\", \"r\")\n    mytable = from_csv(fp)\n    fp.close()\n\nImporting data from a database cursor\n-------------------------------------\n\nIf you have your table data in a database which you can access using a\nlibrary which confirms to the Python DB-API (e.g. an SQLite database\naccessible using the sqlite module), then you can build a PrettyTable\nusing a cursor object, like this:\n\n::\n\n    import sqlite3\n    from prettytable import from_cursor\n\n    connection = sqlite3.connect(\"mydb.db\")\n    cursor = connection.cursor()\n    cursor.execute(\"SELECT field1, field2, field3 FROM my_table\")\n    mytable = from_cursor(cursor)\n\nGetting data out\n----------------\n\nThere are three ways to get data out of a PrettyTable, in increasing\norder of completeness:\n\n-  The ``del_row`` method takes an integer index of a single row to\n   delete.\n-  The ``clear_rows`` method takes no arguments and deletes all the rows\n   in the table - but keeps the field names as they were so you that you\n   can repopulate it with the same kind of data.\n-  The ``clear`` method takes no arguments and deletes all rows and all\n   field names. It's not quite the same as creating a fresh table\n   instance, though - style related settings, discussed later, are\n   maintained.\n\nDisplaying your table in ASCII form\n===================================\n\nPrettyTable's main goal is to let you print tables in an attractive\nASCII form, like this:\n\n::\n\n    +-----------+------+------------+-----------------+\n    | City name | Area | Population | Annual Rainfall |\n    +-----------+------+------------+-----------------+\n    | Adelaide  | 1295 |  1158259   |      600.5      |\n    | Brisbane  | 5905 |  1857594   |      1146.4     |\n    | Darwin    | 112  |   120900   |      1714.7     |\n    | Hobart    | 1357 |   205556   |      619.5      |\n    | Melbourne | 1566 |  3806092   |      646.9      |\n    | Perth     | 5386 |  1554769   |      869.4      |\n    | Sydney    | 2058 |  4336374   |      1214.8     |\n    +-----------+------+------------+-----------------+\n\nYou can print tables like this to ``stdout`` or get string\nrepresentations of them.\n\nPrinting\n--------\n\nTo print a table in ASCII form, you can just do this:\n\n::\n\n    print x\n\nin Python 2.x or:\n\n::\n\n    print(x)\n\nin Python 3.x.\n\nThe old x.printt() method from versions 0.5 and earlier has been\nremoved.\n\nTo pass options changing the look of the table, use the get\\_string()\nmethod documented below:\n\n::\n\n    print x.get_string()\n\nStringing\n---------\n\nIf you don't want to actually print your table in ASCII form but just\nget a string containing what *would* be printed if you use \"print x\",\nyou can use the ``get_string`` method:\n\n::\n\n    mystring = x.get_string()\n\nThis string is guaranteed to look exactly the same as what would be\nprinted by doing \"print x\". You can now do all the usual things you can\ndo with a string, like write your table to a file or insert it into a\nGUI.\n\nControlling which data gets displayed\n-------------------------------------\n\nIf you like, you can restrict the output of ``print x`` or\n``x.get_string`` to only the fields or rows you like.\n\nThe ``fields`` argument to these methods takes a list of field names to\nbe printed:\n\n::\n\n    print x.get_string(fields=[\"City name\", \"Population\"])\n\ngives:\n\n::\n\n    +-----------+------------+\n    | City name | Population |\n    +-----------+------------+\n    | Adelaide  |  1158259   |\n    | Brisbane  |  1857594   |\n    | Darwin    |   120900   |\n    | Hobart    |   205556   |\n    | Melbourne |  3806092   |\n    | Perth     |  1554769   |\n    | Sydney    |  4336374   |\n    +-----------+------------+\n\nThe ``start`` and ``end`` arguments take the index of the first and last\nrow to print respectively. Note that the indexing works like Python list\nslicing - to print the 2nd, 3rd and 4th rows of the table, set ``start``\nto 1 (the first row is row 0, so the second is row 1) and set ``end`` to\n4 (the index of the 4th row, plus 1):\n\n::\n\n    print x.get_string(start=1,end=4)\n\nprints:\n\n::\n\n    +-----------+------+------------+-----------------+\n    | City name | Area | Population | Annual Rainfall |\n    +-----------+------+------------+-----------------+\n    | Brisbane  | 5905 |    1857594 | 1146.4          |\n    | Darwin    | 112  |     120900 | 1714.7          |\n    | Hobart    | 1357 |     205556 | 619.5           |\n    +-----------+------+------------+-----------------+\n\nChanging the alignment of columns\n---------------------------------\n\nBy default, all columns in a table are centre aligned.\n\nAll columns at once\n~~~~~~~~~~~~~~~~~~~\n\nYou can change the alignment of all the columns in a table at once by\nassigning a one character string to the ``align`` attribute. The allowed\nstrings are \"l\", \"r\" and \"c\" for left, right and centre alignment,\nrespectively:\n\n::\n\n    x.align = \"r\"\n    print x\n\ngives:\n\n::\n\n    +-----------+------+------------+-----------------+\n    | City name | Area | Population | Annual Rainfall |\n    +-----------+------+------------+-----------------+\n    |  Adelaide | 1295 |    1158259 |           600.5 |\n    |  Brisbane | 5905 |    1857594 |          1146.4 |\n    |    Darwin |  112 |     120900 |          1714.7 |\n    |    Hobart | 1357 |     205556 |           619.5 |\n    | Melbourne | 1566 |    3806092 |           646.9 |\n    |     Perth | 5386 |    1554769 |           869.4 |\n    |    Sydney | 2058 |    4336374 |          1214.8 |\n    +-----------+------+------------+-----------------+\n\nOne column at a time\n~~~~~~~~~~~~~~~~~~~~\n\nYou can also change the alignment of individual columns based on the\ncorresponding field name by treating the ``align`` attribute as if it\nwere a dictionary.\n\n::\n\n    x.align[\"City name\"] = \"l\"\n    x.align[\"Area\"] = \"c\"\n    x.align[\"Population\"] = \"r\"\n    x.align[\"Annual Rainfall\"] = \"c\"\n    print x\n\ngives:\n\n::\n\n    +-----------+------+------------+-----------------+\n    | City name | Area | Population | Annual Rainfall |\n    +-----------+------+------------+-----------------+\n    | Adelaide  | 1295 |    1158259 |      600.5      |\n    | Brisbane  | 5905 |    1857594 |      1146.4     |\n    | Darwin    | 112  |     120900 |      1714.7     |\n    | Hobart    | 1357 |     205556 |      619.5      |\n    | Melbourne | 1566 |    3806092 |      646.9      |\n    | Perth     | 5386 |    1554769 |      869.4      |\n    | Sydney    | 2058 |    4336374 |      1214.8     |\n    +-----------+------+------------+-----------------+\n\nSorting your table by a field\n-----------------------------\n\nYou can make sure that your ASCII tables are produced with the data\nsorted by one particular field by giving ``get_string`` a ``sortby``\nkeyword argument, which > must be a string containing the name of one\nfield.\n\nFor example, to print the example table we built earlier of Australian\ncapital city data, so that the most populated city comes last, we can do\nthis:\n\n::\n\n    print x.get_string(sortby=\"Population\")\n\nto get\n\n::\n\n    +-----------+------+------------+-----------------+\n    | City name | Area | Population | Annual Rainfall |\n    +-----------+------+------------+-----------------+\n    | Darwin    | 112  |   120900   |      1714.7     |\n    | Hobart    | 1357 |   205556   |      619.5      |\n    | Adelaide  | 1295 |  1158259   |      600.5      |\n    | Perth     | 5386 |  1554769   |      869.4      |\n    | Brisbane  | 5905 |  1857594   |      1146.4     |\n    | Melbourne | 1566 |  3806092   |      646.9      |\n    | Sydney    | 2058 |  4336374   |      1214.8     |\n    +-----------+------+------------+-----------------+\n\nIf we want the most populated city to come *first*, we can also give a\n``reversesort=True`` argument.\n\nIf you *always* want your tables to be sorted in a certain way, you can\nmake the setting long term like this:\n\n::\n\n    x.sortby = \"Population\"\n    print x\n    print x\n    print x\n\nAll three tables printed by this code will be sorted by population (you\ncould do ``x.reversesort = True`` as well, if you wanted). The behaviour\nwill persist until you turn it off:\n\n::\n\n    x.sortby = None\n\nIf you want to specify a custom sorting function, you can use the\n``sort_key`` keyword argument. Pass this a function which accepts two\nlists of values and returns a negative or positive value depending on\nwhether the first list should appeare before or after the second one. If\nyour table has n columns, each list will have n+1 elements. Each list\ncorresponds to one row of the table. The first element will be whatever\ndata is in the relevant row, in the column specified by the ``sort_by``\nargument. The remaining n elements are the data in each of the table's\ncolumns, in order, including a repeated instance of the data in the\n``sort_by`` column.\n\nChanging the appearance of your table - the easy way\n====================================================\n\nBy default, PrettyTable produces ASCII tables that look like the ones\nused in SQL database shells. But if can print them in a variety of other\nformats as well. If the format you want to use is common, PrettyTable\nmakes this very easy for you to do using the ``set_style`` method. If\nyou want to produce an uncommon table, you'll have to do things slightly\nharder (see later).\n\nSetting a table style\n---------------------\n\nYou can set the style for your table using the ``set_style`` method\nbefore any calls to ``print`` or ``get_string``. Here's how to print a\ntable in a format which works nicely with Microsoft Word's \"Convert to\ntable\" feature:\n\n::\n\n    from prettytable import MSWORD_FRIENDLY\n    x.set_style(MSWORD_FRIENDLY)\n    print x\n\nIn addition to ``MSWORD_FRIENDLY`` there are currently two other\nin-built styles you can use for your tables:\n\n-  ``DEFAULT`` - The default look, used to undo any style changes you\n   may have made\n-  ``PLAIN_COLUMN`` - A borderless style that works well with command\n   line programs for columnar data\n\nOther styles are likely to appear in future releases.\n\nChanging the appearance of your table - the hard way\n====================================================\n\nIf you want to display your table in a style other than one of the\nin-built styles listed above, you'll have to set things up the hard way.\n\nDon't worry, it's not really that hard!\n\nStyle options\n-------------\n\nPrettyTable has a number of style options which control various aspects\nof how tables are displayed. You have the freedom to set each of these\noptions individually to whatever you prefer. The ``set_style`` method\njust does this automatically for you.\n\nThe options are these:\n\n-  ``border`` - A boolean option (must be ``True`` or ``False``).\n   Controls whether > > or not a border is drawn around the table.\n-  ``header`` - A boolean option (must be ``True`` or ``False``).\n   Controls whether > > or not the first row of the table is a header\n   showing the names of all the > > fields.\n-  ``hrules`` - Controls printing of horizontal rules after rows.\n   Allowed > > values: FRAME, HEADER, ALL, NONE - note that these are\n   variables defined > > inside the ``prettytable`` module so make sure\n   you import them or use > > ``prettytable.FRAME`` etc.\n-  ``vrules`` - Controls printing of vertical rules between columns.\n   Allowed > > values: FRAME, ALL, NONE.\n-  ``int_format`` - A string which controls the way integer data is\n   printed. > > This works like: ``print \"%<int_format>d\" % data``\n-  ``float_format`` - A string which controls the way floating point\n   data is > > printed. This works like:\n   ``print \"%<int_format>f\" % data``\n-  ``padding_width`` - Number of spaces on either side of column data\n   (only used > > if left and right paddings are None).\n-  ``left_padding_width`` - Number of spaces on left hand side of column\n   data.\n-  ``right_padding_width`` - Number of spaces on right hand side of\n   column data.\n-  ``vertical_char`` - Single character string used to draw vertical\n   lines. > > Default is ``|``.\n-  ``horizontal_char`` - Single character string used to draw horizontal\n   lines. > > Default is ``-``.\n-  ``junction_char`` - Single character string used to draw line\n   junctions. > > Default is ``+``.\n\nYou can set the style options to your own settings in two ways:\n\nSetting style options for the long term\n---------------------------------------\n\nIf you want to print your table with a different style several times,\nyou can set your option for the \"long term\" just by changing the\nappropriate attributes. If you never want your tables to have borders\nyou can do this:\n\n::\n\n    x.border = False\n    print x\n    print x\n    print x\n\nNeither of the 3 tables printed by this will have borders, even if you\ndo things like add extra rows inbetween them. The lack of borders will\nlast until you do:\n\n::\n\n    x.border = True\n\nto turn them on again. This sort of long term setting is exactly how\n``set_style`` works. ``set_style`` just sets a bunch of attributes to\npre-set values for you.\n\nNote that if you know what style options you want at the moment you are\ncreating your table, you can specify them using keyword arguments to the\nconstructor. For example, the following two code blocks are equivalent:\n\n::\n\n    x = PrettyTable()\n    x.border = False\n    x.header = False\n    x.padding_width = 5\n\nx = PrettyTable(border=False, header=False, padding\\_width=5)\n\nChanging style options just once\n--------------------------------\n\nIf you don't want to make long term style changes by changing an\nattribute like in the previous section, you can make changes that last\nfor just one ``get_string`` by giving those methods keyword arguments.\nTo print two \"normal\" tables with one borderless table between them, you\ncould do this:\n\n::\n\n    print x\n    print x.get_string(border=False)\n    print x\n\nDisplaying your table in HTML form\n==================================\n\nPrettyTable will also print your tables in HTML form, as ``<table>``\\ s.\nJust like in ASCII form, you can actually print your table - just use\n``print_html()`` - or get a string representation - just use\n``get_html_string()``. HTML printing supports the ``fields``, ``start``,\n``end``, ``sortby`` and ``reversesort`` arguments in exactly the same\nway as ASCII printing.\n\nStyling HTML tables\n-------------------\n\nBy default, PrettyTable outputs HTML for \"vanilla\" tables. The HTML code\nis quite simple. It looks like this:\n\n::\n\n    <table>\n        <tr>\n            <th>City name</th>\n            <th>Area</th>\n            <th>Population</th>\n            <th>Annual Rainfall</th>\n        </tr>\n        <tr>\n            <td>Adelaide</td>\n            <td>1295</td>\n            <td>1158259</td>\n            <td>600.5</td>\n        <tr>\n            <td>Brisbane</td>\n            <td>5905</td>\n            <td>1857594</td>\n            <td>1146.4</td>\n        ...\n        ...\n        ...\n    </table>\n\nIf you like, you can ask PrettyTable to do its best to mimick the style\noptions that your table has set using inline CSS. This is done by giving\na ``format=True`` keyword argument to either the ``print_html`` or\n``get_html_string`` methods. Note that if you *always* want to print\nformatted HTML you can do:\n\n::\n\n    x.format = True\n\nand the setting will persist until you turn it off.\n\nJust like with ASCII tables, if you want to change the table's style for\njust one ``print_html`` or one ``get_html_string`` you can pass those\nmethods keyword arguments - exactly like ``print`` and ``get_string``.\n\nSetting HTML attributes\n-----------------------\n\nYou can provide a dictionary of HTML attribute name/value pairs to the\n``print_html`` and ``get_html_string`` methods using the ``attributes``\nkeyword argument. This lets you specify common HTML attributes like\n``name``, ``id`` and ``class`` that can be used for linking to your\ntables or customising their appearance using CSS. For example:\n\n::\n\n    x.print_html(attributes={\"name\":\"my_table\", \"class\":\"red_table\"})\n\nwill print:\n\n::\n\n    <table name=\"my_table\" class=\"red_table\">\n        <tr>\n            <th>City name</th>\n            <th>Area</th>\n            <th>Population</th>\n            <th>Annual Rainfall</th>\n        </tr>\n        ...\n        ...\n        ...\n    </table>\n\nMiscellaneous things\n====================\n\nCopying a table\n---------------\n\nYou can call the ``copy`` method on a PrettyTable object without\narguments to return an identical independent copy of the table.\n\nIf you want a copy of a PrettyTable object with just a subset of the\nrows, you can use list slicing notation:\n\n::\n\n    new_table = old_table[0:5]", "description_content_type": null, "docs_url": null, "download_url": "UNKNOWN", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/kxxoling/PTable", "keywords": null, "license": "BSD (3 clause)", "maintainer": null, "maintainer_email": null, "name": "PTable", "package_url": "https://pypi.org/project/PTable/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/PTable/", "project_urls": {"Download": "UNKNOWN", "Homepage": "https://github.com/kxxoling/PTable"}, "release_url": "https://pypi.org/project/PTable/0.9.2/", "requires_dist": null, "requires_python": null, "summary": "A simple Python library for easily displaying tabular data in a visually appealing ASCII table format", "version": "0.9.2", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p>PTable is a simple Python library designed to make it quick and easy to\nrepresent tabular data in visually appealing ASCII tables, originally\nforked from <a href=\"https://code.google.com/p/prettytable/\" rel=\"nofollow\">PrettyTable</a> .</p>\n<a href=\"https://travis-ci.org/kxxoling/PTable\" rel=\"nofollow\"><img alt=\"Build Status\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/ecc074d3e6e2380743a278b938ff2d5a6044112b/68747470733a2f2f7472617669732d63692e6f72672f6b78786f6c696e672f505461626c652e737667\"></a>\n<a href=\"https://landscape.io/github/kxxoling/PTable/master\" rel=\"nofollow\"><img alt=\"Code Health\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/8f5d93f24c4d9bdac1fbbacb6c91394b5144abd3/68747470733a2f2f6c616e6473636170652e696f2f6769746875622f6b78786f6c696e672f505461626c652f6d61737465722f6c616e6473636170652e7376673f7374796c653d666c6174\"></a>\n<a href=\"https://pypi.python.org/pypi/PTable/\" rel=\"nofollow\"><img alt=\"Downloads\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/ce7dd0f83706a4a8896570eec0ae8788c79b633c/68747470733a2f2f70797069702e696e2f646f776e6c6f61642f505461626c652f62616467652e7376673f706572696f643d7765656b\"></a>\n<p><strong>This tutorial is distributed with PrettyTable and is meant to serve as\na \u201cquick start\u201d guide for the lazy or impatient. It is not an exhaustive\ndescription of the whole API, and it is not guaranteed to be 100% up to\ndate. For more complete and update documentation, check the PrettyTable\nwiki at http://code.google.com/p/prettytable/w/list</strong></p>\n<div id=\"links\">\n<h2>Links</h2>\n<ul>\n<li><a href=\"https://github.com/kxxoling/PrettyTable\" rel=\"nofollow\">Source Code (GitHub)</a></li>\n<li><a href=\"https://pypi.python.org/pypi/ptabl://pypi.python.org/pypi/ptable\" rel=\"nofollow\">PyPI</a></li>\n<li><a href=\"https://ptable.readthedocs.org\" rel=\"nofollow\">RTFD</a></li>\n</ul>\n</div>\n<div id=\"getting-your-data-into-and-out-of-the-table\">\n<h2>Getting your data into (and out of) the table</h2>\n<p>Let\u2019s suppose you have a shiny new PrettyTable:</p>\n<pre>from prettytable import PrettyTable\nx = PrettyTable()\n</pre>\n<p>and you want to put some data into it. You have a few options.</p>\n<div id=\"row-by-row\">\n<h3>Row by row</h3>\n<p>You can add data one row at a time. To do this you can set the field\nnames first using the <tt>field_names</tt> attribute, and then add the rows\none at a time using the <tt>add_row</tt> method:</p>\n<pre>x.field_names = [\"City name\", \"Area\", \"Population\", \"Annual Rainfall\"]\nx.add_row([\"Adelaide\",1295, 1158259, 600.5])\nx.add_row([\"Brisbane\",5905, 1857594, 1146.4])\nx.add_row([\"Darwin\", 112, 120900, 1714.7])\nx.add_row([\"Hobart\", 1357, 205556, 619.5])\nx.add_row([\"Sydney\", 2058, 4336374, 1214.8])\nx.add_row([\"Melbourne\", 1566, 3806092, 646.9])\nx.add_row([\"Perth\", 5386, 1554769, 869.4])\n</pre>\n</div>\n<div id=\"column-by-column\">\n<h3>Column by column</h3>\n<p>You can add data one column at a time as well. To do this you use the\n<tt>add_column</tt> method, which takes two arguments - a string which is the\nname for the field the column you are adding corresponds to, and a list\nor tuple which contains the column data\u201d</p>\n<pre>x.add_column(\"City name\",\n[\"Adelaide\",\"Brisbane\",\"Darwin\",\"Hobart\",\"Sydney\",\"Melbourne\",\"Perth\"])\nx.add_column(\"Area\", [1295, 5905, 112, 1357, 2058, 1566, 5386])\nx.add_column(\"Population\", [1158259, 1857594, 120900, 205556, 4336374, 3806092,\n1554769])\nx.add_column(\"Annual Rainfall\",[600.5, 1146.4, 1714.7, 619.5, 1214.8, 646.9,\n869.4])\n</pre>\n</div>\n<div id=\"mixing-and-matching\">\n<h3>Mixing and matching</h3>\n<p>If you really want to, you can even mix and match <tt>add_row</tt> and\n<tt>add_column</tt> and build some of your table in one way and some of it in\nthe other. There\u2019s a unit test which makes sure that doing things this\nway will always work out nicely as if you\u2019d done it using just one of\nthe two approaches. Tables built this way are kind of confusing for\nother people to read, though, so don\u2019t do this unless you have a good\nreason.</p>\n</div>\n<div id=\"importing-data-from-a-csv-file\">\n<h3>Importing data from a CSV file</h3>\n<p>If you have your table data in a comma separated values file (.csv), you\ncan read this data into a PrettyTable like this:</p>\n<pre>from prettytable import from_csv\nfp = open(\"myfile.csv\", \"r\")\nmytable = from_csv(fp)\nfp.close()\n</pre>\n</div>\n<div id=\"importing-data-from-a-database-cursor\">\n<h3>Importing data from a database cursor</h3>\n<p>If you have your table data in a database which you can access using a\nlibrary which confirms to the Python DB-API (e.g. an SQLite database\naccessible using the sqlite module), then you can build a PrettyTable\nusing a cursor object, like this:</p>\n<pre>import sqlite3\nfrom prettytable import from_cursor\n\nconnection = sqlite3.connect(\"mydb.db\")\ncursor = connection.cursor()\ncursor.execute(\"SELECT field1, field2, field3 FROM my_table\")\nmytable = from_cursor(cursor)\n</pre>\n</div>\n<div id=\"getting-data-out\">\n<h3>Getting data out</h3>\n<p>There are three ways to get data out of a PrettyTable, in increasing\norder of completeness:</p>\n<ul>\n<li>The <tt>del_row</tt> method takes an integer index of a single row to\ndelete.</li>\n<li>The <tt>clear_rows</tt> method takes no arguments and deletes all the rows\nin the table - but keeps the field names as they were so you that you\ncan repopulate it with the same kind of data.</li>\n<li>The <tt>clear</tt> method takes no arguments and deletes all rows and all\nfield names. It\u2019s not quite the same as creating a fresh table\ninstance, though - style related settings, discussed later, are\nmaintained.</li>\n</ul>\n</div>\n</div>\n<div id=\"displaying-your-table-in-ascii-form\">\n<h2>Displaying your table in ASCII form</h2>\n<p>PrettyTable\u2019s main goal is to let you print tables in an attractive\nASCII form, like this:</p>\n<pre>+-----------+------+------------+-----------------+\n| City name | Area | Population | Annual Rainfall |\n+-----------+------+------------+-----------------+\n| Adelaide  | 1295 |  1158259   |      600.5      |\n| Brisbane  | 5905 |  1857594   |      1146.4     |\n| Darwin    | 112  |   120900   |      1714.7     |\n| Hobart    | 1357 |   205556   |      619.5      |\n| Melbourne | 1566 |  3806092   |      646.9      |\n| Perth     | 5386 |  1554769   |      869.4      |\n| Sydney    | 2058 |  4336374   |      1214.8     |\n+-----------+------+------------+-----------------+\n</pre>\n<p>You can print tables like this to <tt>stdout</tt> or get string\nrepresentations of them.</p>\n<div id=\"printing\">\n<h3>Printing</h3>\n<p>To print a table in ASCII form, you can just do this:</p>\n<pre>print x\n</pre>\n<p>in Python 2.x or:</p>\n<pre>print(x)\n</pre>\n<p>in Python 3.x.</p>\n<p>The old x.printt() method from versions 0.5 and earlier has been\nremoved.</p>\n<p>To pass options changing the look of the table, use the get_string()\nmethod documented below:</p>\n<pre>print x.get_string()\n</pre>\n</div>\n<div id=\"stringing\">\n<h3>Stringing</h3>\n<p>If you don\u2019t want to actually print your table in ASCII form but just\nget a string containing what <em>would</em> be printed if you use \u201cprint x\u201d,\nyou can use the <tt>get_string</tt> method:</p>\n<pre>mystring = x.get_string()\n</pre>\n<p>This string is guaranteed to look exactly the same as what would be\nprinted by doing \u201cprint x\u201d. You can now do all the usual things you can\ndo with a string, like write your table to a file or insert it into a\nGUI.</p>\n</div>\n<div id=\"controlling-which-data-gets-displayed\">\n<h3>Controlling which data gets displayed</h3>\n<p>If you like, you can restrict the output of <tt>print x</tt> or\n<tt>x.get_string</tt> to only the fields or rows you like.</p>\n<p>The <tt>fields</tt> argument to these methods takes a list of field names to\nbe printed:</p>\n<pre>print x.get_string(fields=[\"City name\", \"Population\"])\n</pre>\n<p>gives:</p>\n<pre>+-----------+------------+\n| City name | Population |\n+-----------+------------+\n| Adelaide  |  1158259   |\n| Brisbane  |  1857594   |\n| Darwin    |   120900   |\n| Hobart    |   205556   |\n| Melbourne |  3806092   |\n| Perth     |  1554769   |\n| Sydney    |  4336374   |\n+-----------+------------+\n</pre>\n<p>The <tt>start</tt> and <tt>end</tt> arguments take the index of the first and last\nrow to print respectively. Note that the indexing works like Python list\nslicing - to print the 2nd, 3rd and 4th rows of the table, set <tt>start</tt>\nto 1 (the first row is row 0, so the second is row 1) and set <tt>end</tt> to\n4 (the index of the 4th row, plus 1):</p>\n<pre>print x.get_string(start=1,end=4)\n</pre>\n<p>prints:</p>\n<pre>+-----------+------+------------+-----------------+\n| City name | Area | Population | Annual Rainfall |\n+-----------+------+------------+-----------------+\n| Brisbane  | 5905 |    1857594 | 1146.4          |\n| Darwin    | 112  |     120900 | 1714.7          |\n| Hobart    | 1357 |     205556 | 619.5           |\n+-----------+------+------------+-----------------+\n</pre>\n</div>\n<div id=\"changing-the-alignment-of-columns\">\n<h3>Changing the alignment of columns</h3>\n<p>By default, all columns in a table are centre aligned.</p>\n<div id=\"all-columns-at-once\">\n<h4>All columns at once</h4>\n<p>You can change the alignment of all the columns in a table at once by\nassigning a one character string to the <tt>align</tt> attribute. The allowed\nstrings are \u201cl\u201d, \u201cr\u201d and \u201cc\u201d for left, right and centre alignment,\nrespectively:</p>\n<pre>x.align = \"r\"\nprint x\n</pre>\n<p>gives:</p>\n<pre>+-----------+------+------------+-----------------+\n| City name | Area | Population | Annual Rainfall |\n+-----------+------+------------+-----------------+\n|  Adelaide | 1295 |    1158259 |           600.5 |\n|  Brisbane | 5905 |    1857594 |          1146.4 |\n|    Darwin |  112 |     120900 |          1714.7 |\n|    Hobart | 1357 |     205556 |           619.5 |\n| Melbourne | 1566 |    3806092 |           646.9 |\n|     Perth | 5386 |    1554769 |           869.4 |\n|    Sydney | 2058 |    4336374 |          1214.8 |\n+-----------+------+------------+-----------------+\n</pre>\n</div>\n<div id=\"one-column-at-a-time\">\n<h4>One column at a time</h4>\n<p>You can also change the alignment of individual columns based on the\ncorresponding field name by treating the <tt>align</tt> attribute as if it\nwere a dictionary.</p>\n<pre>x.align[\"City name\"] = \"l\"\nx.align[\"Area\"] = \"c\"\nx.align[\"Population\"] = \"r\"\nx.align[\"Annual Rainfall\"] = \"c\"\nprint x\n</pre>\n<p>gives:</p>\n<pre>+-----------+------+------------+-----------------+\n| City name | Area | Population | Annual Rainfall |\n+-----------+------+------------+-----------------+\n| Adelaide  | 1295 |    1158259 |      600.5      |\n| Brisbane  | 5905 |    1857594 |      1146.4     |\n| Darwin    | 112  |     120900 |      1714.7     |\n| Hobart    | 1357 |     205556 |      619.5      |\n| Melbourne | 1566 |    3806092 |      646.9      |\n| Perth     | 5386 |    1554769 |      869.4      |\n| Sydney    | 2058 |    4336374 |      1214.8     |\n+-----------+------+------------+-----------------+\n</pre>\n</div>\n</div>\n<div id=\"sorting-your-table-by-a-field\">\n<h3>Sorting your table by a field</h3>\n<p>You can make sure that your ASCII tables are produced with the data\nsorted by one particular field by giving <tt>get_string</tt> a <tt>sortby</tt>\nkeyword argument, which &gt; must be a string containing the name of one\nfield.</p>\n<p>For example, to print the example table we built earlier of Australian\ncapital city data, so that the most populated city comes last, we can do\nthis:</p>\n<pre>print x.get_string(sortby=\"Population\")\n</pre>\n<p>to get</p>\n<pre>+-----------+------+------------+-----------------+\n| City name | Area | Population | Annual Rainfall |\n+-----------+------+------------+-----------------+\n| Darwin    | 112  |   120900   |      1714.7     |\n| Hobart    | 1357 |   205556   |      619.5      |\n| Adelaide  | 1295 |  1158259   |      600.5      |\n| Perth     | 5386 |  1554769   |      869.4      |\n| Brisbane  | 5905 |  1857594   |      1146.4     |\n| Melbourne | 1566 |  3806092   |      646.9      |\n| Sydney    | 2058 |  4336374   |      1214.8     |\n+-----------+------+------------+-----------------+\n</pre>\n<p>If we want the most populated city to come <em>first</em>, we can also give a\n<tt>reversesort=True</tt> argument.</p>\n<p>If you <em>always</em> want your tables to be sorted in a certain way, you can\nmake the setting long term like this:</p>\n<pre>x.sortby = \"Population\"\nprint x\nprint x\nprint x\n</pre>\n<p>All three tables printed by this code will be sorted by population (you\ncould do <tt>x.reversesort = True</tt> as well, if you wanted). The behaviour\nwill persist until you turn it off:</p>\n<pre>x.sortby = None\n</pre>\n<p>If you want to specify a custom sorting function, you can use the\n<tt>sort_key</tt> keyword argument. Pass this a function which accepts two\nlists of values and returns a negative or positive value depending on\nwhether the first list should appeare before or after the second one. If\nyour table has n columns, each list will have n+1 elements. Each list\ncorresponds to one row of the table. The first element will be whatever\ndata is in the relevant row, in the column specified by the <tt>sort_by</tt>\nargument. The remaining n elements are the data in each of the table\u2019s\ncolumns, in order, including a repeated instance of the data in the\n<tt>sort_by</tt> column.</p>\n</div>\n</div>\n<div id=\"changing-the-appearance-of-your-table-the-easy-way\">\n<h2>Changing the appearance of your table - the easy way</h2>\n<p>By default, PrettyTable produces ASCII tables that look like the ones\nused in SQL database shells. But if can print them in a variety of other\nformats as well. If the format you want to use is common, PrettyTable\nmakes this very easy for you to do using the <tt>set_style</tt> method. If\nyou want to produce an uncommon table, you\u2019ll have to do things slightly\nharder (see later).</p>\n<div id=\"setting-a-table-style\">\n<h3>Setting a table style</h3>\n<p>You can set the style for your table using the <tt>set_style</tt> method\nbefore any calls to <tt>print</tt> or <tt>get_string</tt>. Here\u2019s how to print a\ntable in a format which works nicely with Microsoft Word\u2019s \u201cConvert to\ntable\u201d feature:</p>\n<pre>from prettytable import MSWORD_FRIENDLY\nx.set_style(MSWORD_FRIENDLY)\nprint x\n</pre>\n<p>In addition to <tt>MSWORD_FRIENDLY</tt> there are currently two other\nin-built styles you can use for your tables:</p>\n<ul>\n<li><tt>DEFAULT</tt> - The default look, used to undo any style changes you\nmay have made</li>\n<li><tt>PLAIN_COLUMN</tt> - A borderless style that works well with command\nline programs for columnar data</li>\n</ul>\n<p>Other styles are likely to appear in future releases.</p>\n</div>\n</div>\n<div id=\"changing-the-appearance-of-your-table-the-hard-way\">\n<h2>Changing the appearance of your table - the hard way</h2>\n<p>If you want to display your table in a style other than one of the\nin-built styles listed above, you\u2019ll have to set things up the hard way.</p>\n<p>Don\u2019t worry, it\u2019s not really that hard!</p>\n<div id=\"style-options\">\n<h3>Style options</h3>\n<p>PrettyTable has a number of style options which control various aspects\nof how tables are displayed. You have the freedom to set each of these\noptions individually to whatever you prefer. The <tt>set_style</tt> method\njust does this automatically for you.</p>\n<p>The options are these:</p>\n<ul>\n<li><tt>border</tt> - A boolean option (must be <tt>True</tt> or <tt>False</tt>).\nControls whether &gt; &gt; or not a border is drawn around the table.</li>\n<li><tt>header</tt> - A boolean option (must be <tt>True</tt> or <tt>False</tt>).\nControls whether &gt; &gt; or not the first row of the table is a header\nshowing the names of all the &gt; &gt; fields.</li>\n<li><tt>hrules</tt> - Controls printing of horizontal rules after rows.\nAllowed &gt; &gt; values: FRAME, HEADER, ALL, NONE - note that these are\nvariables defined &gt; &gt; inside the <tt>prettytable</tt> module so make sure\nyou import them or use &gt; &gt; <tt>prettytable.FRAME</tt> etc.</li>\n<li><tt>vrules</tt> - Controls printing of vertical rules between columns.\nAllowed &gt; &gt; values: FRAME, ALL, NONE.</li>\n<li><tt>int_format</tt> - A string which controls the way integer data is\nprinted. &gt; &gt; This works like: <tt>print <span class=\"pre\">\"%&lt;int_format&gt;d\"</span> % data</tt></li>\n<li><tt>float_format</tt> - A string which controls the way floating point\ndata is &gt; &gt; printed. This works like:\n<tt>print <span class=\"pre\">\"%&lt;int_format&gt;f\"</span> % data</tt></li>\n<li><tt>padding_width</tt> - Number of spaces on either side of column data\n(only used &gt; &gt; if left and right paddings are None).</li>\n<li><tt>left_padding_width</tt> - Number of spaces on left hand side of column\ndata.</li>\n<li><tt>right_padding_width</tt> - Number of spaces on right hand side of\ncolumn data.</li>\n<li><tt>vertical_char</tt> - Single character string used to draw vertical\nlines. &gt; &gt; Default is <tt>|</tt>.</li>\n<li><tt>horizontal_char</tt> - Single character string used to draw horizontal\nlines. &gt; &gt; Default is <tt>-</tt>.</li>\n<li><tt>junction_char</tt> - Single character string used to draw line\njunctions. &gt; &gt; Default is <tt>+</tt>.</li>\n</ul>\n<p>You can set the style options to your own settings in two ways:</p>\n</div>\n<div id=\"setting-style-options-for-the-long-term\">\n<h3>Setting style options for the long term</h3>\n<p>If you want to print your table with a different style several times,\nyou can set your option for the \u201clong term\u201d just by changing the\nappropriate attributes. If you never want your tables to have borders\nyou can do this:</p>\n<pre>x.border = False\nprint x\nprint x\nprint x\n</pre>\n<p>Neither of the 3 tables printed by this will have borders, even if you\ndo things like add extra rows inbetween them. The lack of borders will\nlast until you do:</p>\n<pre>x.border = True\n</pre>\n<p>to turn them on again. This sort of long term setting is exactly how\n<tt>set_style</tt> works. <tt>set_style</tt> just sets a bunch of attributes to\npre-set values for you.</p>\n<p>Note that if you know what style options you want at the moment you are\ncreating your table, you can specify them using keyword arguments to the\nconstructor. For example, the following two code blocks are equivalent:</p>\n<pre>x = PrettyTable()\nx.border = False\nx.header = False\nx.padding_width = 5\n</pre>\n<p>x = PrettyTable(border=False, header=False, padding_width=5)</p>\n</div>\n<div id=\"changing-style-options-just-once\">\n<h3>Changing style options just once</h3>\n<p>If you don\u2019t want to make long term style changes by changing an\nattribute like in the previous section, you can make changes that last\nfor just one <tt>get_string</tt> by giving those methods keyword arguments.\nTo print two \u201cnormal\u201d tables with one borderless table between them, you\ncould do this:</p>\n<pre>print x\nprint x.get_string(border=False)\nprint x\n</pre>\n</div>\n</div>\n<div id=\"displaying-your-table-in-html-form\">\n<h2>Displaying your table in HTML form</h2>\n<p>PrettyTable will also print your tables in HTML form, as <tt>&lt;table&gt;</tt>s.\nJust like in ASCII form, you can actually print your table - just use\n<tt>print_html()</tt> - or get a string representation - just use\n<tt>get_html_string()</tt>. HTML printing supports the <tt>fields</tt>, <tt>start</tt>,\n<tt>end</tt>, <tt>sortby</tt> and <tt>reversesort</tt> arguments in exactly the same\nway as ASCII printing.</p>\n<div id=\"styling-html-tables\">\n<h3>Styling HTML tables</h3>\n<p>By default, PrettyTable outputs HTML for \u201cvanilla\u201d tables. The HTML code\nis quite simple. It looks like this:</p>\n<pre>&lt;table&gt;\n    &lt;tr&gt;\n        &lt;th&gt;City name&lt;/th&gt;\n        &lt;th&gt;Area&lt;/th&gt;\n        &lt;th&gt;Population&lt;/th&gt;\n        &lt;th&gt;Annual Rainfall&lt;/th&gt;\n    &lt;/tr&gt;\n    &lt;tr&gt;\n        &lt;td&gt;Adelaide&lt;/td&gt;\n        &lt;td&gt;1295&lt;/td&gt;\n        &lt;td&gt;1158259&lt;/td&gt;\n        &lt;td&gt;600.5&lt;/td&gt;\n    &lt;tr&gt;\n        &lt;td&gt;Brisbane&lt;/td&gt;\n        &lt;td&gt;5905&lt;/td&gt;\n        &lt;td&gt;1857594&lt;/td&gt;\n        &lt;td&gt;1146.4&lt;/td&gt;\n    ...\n    ...\n    ...\n&lt;/table&gt;\n</pre>\n<p>If you like, you can ask PrettyTable to do its best to mimick the style\noptions that your table has set using inline CSS. This is done by giving\na <tt>format=True</tt> keyword argument to either the <tt>print_html</tt> or\n<tt>get_html_string</tt> methods. Note that if you <em>always</em> want to print\nformatted HTML you can do:</p>\n<pre>x.format = True\n</pre>\n<p>and the setting will persist until you turn it off.</p>\n<p>Just like with ASCII tables, if you want to change the table\u2019s style for\njust one <tt>print_html</tt> or one <tt>get_html_string</tt> you can pass those\nmethods keyword arguments - exactly like <tt>print</tt> and <tt>get_string</tt>.</p>\n</div>\n<div id=\"setting-html-attributes\">\n<h3>Setting HTML attributes</h3>\n<p>You can provide a dictionary of HTML attribute name/value pairs to the\n<tt>print_html</tt> and <tt>get_html_string</tt> methods using the <tt>attributes</tt>\nkeyword argument. This lets you specify common HTML attributes like\n<tt>name</tt>, <tt>id</tt> and <tt>class</tt> that can be used for linking to your\ntables or customising their appearance using CSS. For example:</p>\n<pre>x.print_html(attributes={\"name\":\"my_table\", \"class\":\"red_table\"})\n</pre>\n<p>will print:</p>\n<pre>&lt;table name=\"my_table\" class=\"red_table\"&gt;\n    &lt;tr&gt;\n        &lt;th&gt;City name&lt;/th&gt;\n        &lt;th&gt;Area&lt;/th&gt;\n        &lt;th&gt;Population&lt;/th&gt;\n        &lt;th&gt;Annual Rainfall&lt;/th&gt;\n    &lt;/tr&gt;\n    ...\n    ...\n    ...\n&lt;/table&gt;\n</pre>\n</div>\n</div>\n<div id=\"miscellaneous-things\">\n<h2>Miscellaneous things</h2>\n<h2 id=\"copying-a-table\"><span class=\"section-subtitle\">Copying a table</span></h2>\n<p>You can call the <tt>copy</tt> method on a PrettyTable object without\narguments to return an identical independent copy of the table.</p>\n<p>If you want a copy of a PrettyTable object with just a subset of the\nrows, you can use list slicing notation:</p>\n<pre>new_table = old_table[0:5]\n</pre>\n</div>\n\n          </div>"}, "last_serial": 1565849, "releases": {"0.9.0": [], "0.9.1": [], "0.9.2": [{"comment_text": "", "digests": {"md5": "4a68135b1fc878d13d9df1a41cf4c5ac", "sha256": "aa7fc151cb40f2dabcd2275ba6f7fd0ff8577a86be3365cd3fb297cbe09cc292"}, "downloads": -1, "filename": "PTable-0.9.2.tar.gz", "has_sig": false, "md5_digest": "4a68135b1fc878d13d9df1a41cf4c5ac", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 31042, "upload_time": "2015-05-28T07:06:53", "upload_time_iso_8601": "2015-05-28T07:06:53.622513Z", "url": "https://files.pythonhosted.org/packages/ab/b3/b54301811173ca94119eb474634f120a49cd370f257d1aae5a4abaf12729/PTable-0.9.2.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "4a68135b1fc878d13d9df1a41cf4c5ac", "sha256": "aa7fc151cb40f2dabcd2275ba6f7fd0ff8577a86be3365cd3fb297cbe09cc292"}, "downloads": -1, "filename": "PTable-0.9.2.tar.gz", "has_sig": false, "md5_digest": "4a68135b1fc878d13d9df1a41cf4c5ac", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 31042, "upload_time": "2015-05-28T07:06:53", "upload_time_iso_8601": "2015-05-28T07:06:53.622513Z", "url": "https://files.pythonhosted.org/packages/ab/b3/b54301811173ca94119eb474634f120a49cd370f257d1aae5a4abaf12729/PTable-0.9.2.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:15:25 2020"}