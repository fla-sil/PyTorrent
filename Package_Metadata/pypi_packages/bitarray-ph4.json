{"info": {"author": "Dusan Klinec (ph4r05)", "author_email": "dusan.klinec@gmail.com", "bugtrack_url": null, "classifiers": ["Development Status :: 5 - Production/Stable", "Intended Audience :: Developers", "License :: OSI Approved :: Python Software Foundation License", "Operating System :: OS Independent", "Programming Language :: C", "Programming Language :: Python :: 2", "Programming Language :: Python :: 2.6", "Programming Language :: Python :: 2.7", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.3", "Programming Language :: Python :: 3.4", "Programming Language :: Python :: 3.5", "Programming Language :: Python :: 3.6", "Programming Language :: Python :: 3.7", "Programming Language :: Python :: 3.8", "Topic :: Utilities"], "description": "bitarray: efficient arrays of booleans\n======================================\n\nThis module provides an object type which efficiently represents an array\nof booleans.  Bitarrays are sequence types and behave very much like usual\nlists.  Eight bits are represented by one byte in a contiguous block of\nmemory.  The user can select between two representations: little-endian\nand big-endian.  All of the functionality is implemented in C.\nMethods for accessing the machine representation are provided.\nThis can be useful when bit level access to binary files is required,\nsuch as portable bitmap image files (.pbm).  Also, when dealing with\ncompressed data which uses variable bit length encoding, you may find\nthis module useful.\n\n\nKey features\n------------\n\n * All functionality implemented in C.\n * Bitarray objects behave very much like a list object, in particular\n   slicing (including slice assignment and deletion) is supported.\n * The bit endianness can be specified for each bitarray object, see below.\n * Packing and unpacking to other binary data formats, e.g. numpy.ndarray\n   is possible.\n * Fast methods for encoding and decoding variable bit length prefix codes\n * Bitwise operations: `&`, `|`, `^`, `&=`, `|=`, `^=`, `~`\n * Sequential search\n * Pickling and unpickling of bitarray objects.\n * Bitarray objects support the buffer protocol (Python 2.7 and above)\n * On 32-bit systems, a bitarray object can contain up to 2^34 elements,\n   that is 16 Gbits (on 64-bit machines up to 2^63 elements in theory).\n\n\nInstallation\n------------\n\nBitarray can be installed from source:\n\n    $ tar xzf bitarray-1.2.1.tar.gz\n    $ cd bitarray-1.2.1\n    $ python setup.py install\n\nOn Unix systems, the latter command may have to be executed with root\nprivileges.  You can also pip install bitarray.\nOnce you have installed the package, you may want to test it:\n\n    $ python -c 'import bitarray; bitarray.test()'\n    bitarray is installed in: /usr/local/lib/python2.7/site-packages/bitarray\n    bitarray version: 1.2.1\n    3.7.4 (r271:86832, Dec 29 2018) [GCC 4.2.1 (SUSE Linux)]\n    .........................................................................\n    .........................................................................\n    ..............................\n    ----------------------------------------------------------------------\n    Ran 199 tests in 1.144s\n\n    OK\n\nYou can always import the function test,\nand `test().wasSuccessful()` will return `True` when the test went well.\n\n\nUsing the module\n----------------\n\nAs mentioned above, bitarray objects behave very much like lists, so\nthere is not too much to learn.  The biggest difference from list objects\nis the ability to access the machine representation of the object.\nWhen doing so, the bit endianness is of importance; this issue is\nexplained in detail in the section below.  Here, we demonstrate the\nbasic usage of bitarray objects:\n\n    >>> from bitarray import bitarray\n    >>> a = bitarray()            # create empty bitarray\n    >>> a.append(True)\n    >>> a.extend([False, True, True])\n    >>> a\n    bitarray('1011')\n\nBitarray objects can be instantiated in different ways:\n\n    >>> a = bitarray(2**20)       # bitarray of length 1048576 (uninitialized)\n    >>> bitarray('1001011')       # from a string\n    bitarray('1001011')\n    >>> lst = [True, False, False, True, False, True, True]\n    >>> bitarray(lst)             # from list, tuple, iterable\n    bitarray('1001011')\n\nBits can be assigned from any Python object, if the value can be interpreted\nas a truth value.  You can think of this as Python's built-in function bool()\nbeing applied, whenever casting an object:\n\n    >>> a = bitarray([42, '', True, {}, 'foo', None])\n    >>> a\n    bitarray('101010')\n    >>> a.append(a)      # note that bool(a) is True\n    >>> a.count(42)      # counts occurrences of True (not 42)\n    4\n    >>> a.remove('')     # removes first occurrence of False\n    >>> a\n    bitarray('110101')\n\nLike lists, bitarray objects support slice assignment and deletion:\n\n    >>> a = bitarray(50)\n    >>> a.setall(False)\n    >>> a[11:37:3] = 9 * bitarray([True])\n    >>> a\n    bitarray('00000000000100100100100100100100100100000000000000')\n    >>> del a[12::3]\n    >>> a\n    bitarray('0000000000010101010101010101000000000')\n    >>> a[-6:] = bitarray('10011')\n    >>> a\n    bitarray('000000000001010101010101010100010011')\n    >>> a += bitarray('000111')\n    >>> a[9:]\n    bitarray('001010101010101010100010011000111')\n\nIn addition, slices can be assigned to booleans, which is easier (and\nfaster) than assigning to a bitarray in which all values are the same:\n\n    >>> a = 20 * bitarray('0')\n    >>> a[1:15:3] = True\n    >>> a\n    bitarray('01001001001001000000')\n\nThis is easier and faster than:\n\n    >>> a = 20 * bitarray('0')\n    >>> a[1:15:3] = 5 * bitarray('1')\n    >>> a\n    bitarray('01001001001001000000')\n\nNote that in the latter we have to create a temporary bitarray whose length\nmust be known or calculated.\n\n\nBit endianness\n--------------\n\nSince a bitarray allows addressing of individual bits, where the machine\nrepresents 8 bits in one byte, there are two obvious choices for this\nmapping: little- and big-endian.\nWhen creating a new bitarray object, the endianness can always be\nspecified explicitly:\n\n    >>> a = bitarray(endian='little')\n    >>> a.frombytes(b'A')\n    >>> a\n    bitarray('10000010')\n    >>> b = bitarray('11000010', endian='little')\n    >>> b.tobytes()\n    b'C'\n\nHere, the low-bit comes first because little-endian means that increasing\nnumeric significance corresponds to an increasing address (index).\nSo a[0] is the lowest and least significant bit, and a[7] is the highest\nand most significant bit.\n\n    >>> a = bitarray(endian='big')\n    >>> a.frombytes(b'A')\n    >>> a\n    bitarray('01000001')\n    >>> a[6] = 1\n    >>> a.tobytes()\n    b'C'\n\nHere, the high-bit comes first because big-endian\nmeans \"most-significant first\".\nSo a[0] is now the lowest and most significant bit, and a[7] is the highest\nand least significant bit.\n\nThe bit endianness is a property attached to each bitarray object.\nWhen comparing bitarray objects, the endianness (and hence the machine\nrepresentation) is irrelevant; what matters is the mapping from indices\nto bits:\n\n    >>> bitarray('11001', endian='big') == bitarray('11001', endian='little')\n    True\n\nBitwise operations (`&`, `|`, `^`, `&=`, `|=`, `^=`, `~`) are implemented\nefficiently using the corresponding byte operations in C, i.e. the operators\nact on the machine representation of the bitarray objects.\nTherefore, one has to be cautious when applying the operation to bitarrays\nwith different endianness.\n\nWhen converting to and from machine representation, using\nthe `tobytes`, `frombytes`, `tofile` and `fromfile` methods,\nthe endianness matters:\n\n    >>> a = bitarray(endian='little')\n    >>> a.frombytes(b'\\x01')\n    >>> a\n    bitarray('10000000')\n    >>> b = bitarray(endian='big')\n    >>> b.frombytes(b'\\x80')\n    >>> b\n    bitarray('10000000')\n    >>> a == b\n    True\n    >>> a.tobytes() == b.tobytes()\n    False\n\nThe endianness can not be changed once an object is created.\nHowever, since creating a bitarray from another bitarray just copies the\nmemory representing the data, you can create a new bitarray with different\nendianness:\n\n    >>> a = bitarray('11100000', endian='little')\n    >>> a\n    bitarray('11100000')\n    >>> b = bitarray(a, endian='big')\n    >>> b\n    bitarray('00000111')\n    >>> a == b\n    False\n    >>> a.tobytes() == b.tobytes()\n    True\n\nThe default bit endianness is currently big-endian, however this may change\nin the future, and when dealing with the machine representation of bitarray\nobjects, it is recommended to always explicitly specify the endianness.\n\nUnless explicitly converting to machine representation, using\nthe `tobytes`, `frombytes`, `tofile` and `fromfile` methods,\nthe bit endianness will have no effect on any computation, and one\ncan safely ignore setting the endianness, and other details of this section.\n\n\nBuffer protocol\n---------------\n\nPython 2.7 provides memoryview objects, which allow Python code to access\nthe internal data of an object that supports the buffer protocol without\ncopying.  Bitarray objects support this protocol, with the memory being\ninterpreted as simple bytes.\n\n    >>> a = bitarray('01000001' '01000010' '01000011', endian='big')\n    >>> v = memoryview(a)\n    >>> len(v)\n    3\n    >>> v[-1]\n    67\n    >>> v[:2].tobytes()\n    b'AB'\n    >>> v.readonly  # changing a bitarray's memory is also possible\n    False\n    >>> v[1] = 111\n    >>> a\n    bitarray('010000010110111101000011')\n\n\nVariable bit length prefix codes\n--------------------------------\n\nThe method `encode` takes a dictionary mapping symbols to bitarrays\nand an iterable, and extends the bitarray object with the encoded symbols\nfound while iterating.  For example:\n\n    >>> d = {'H':bitarray('111'), 'e':bitarray('0'),\n    ...      'l':bitarray('110'), 'o':bitarray('10')}\n    ...\n    >>> a = bitarray()\n    >>> a.encode(d, 'Hello')\n    >>> a\n    bitarray('111011011010')\n\nNote that the string `'Hello'` is an iterable, but the symbols are not\nlimited to characters, in fact any immutable Python object can be a symbol.\nTaking the same dictionary, we can apply the `decode` method which will\nreturn a list of the symbols:\n\n    >>> a.decode(d)\n    ['H', 'e', 'l', 'l', 'o']\n    >>> ''.join(a.decode(d))\n    'Hello'\n\nSince symbols are not limited to being characters, it is necessary to return\nthem as elements of a list, rather than simply returning the joined string.\n\n\nReference\n=========\n\nThe bitarray object:\n--------------------\n\n`bitarray(initial=0, /, endian='big')`\n\nReturn a new bitarray object whose items are bits initialized from\nthe optional initial object, and endianness.\nIf no initial object is provided, an empty bitarray (length zero) is created.\nThe initial object may be of the following types:\n\n`int`: Create a bitarray of given integer length.  The initial values are\narbitrary.  If you want all values to be set, use the .setall() method.\n\n`str`: Create bitarray from a string of `0` and `1`.\n\n`list`, `tuple`, `iterable`: Create bitarray from a sequence, each\nelement in the sequence is converted to a bit using its truth value.\n\n`bitarray`: Create bitarray from another bitarray.  This is done by\ncopying the memory holding the bitarray data, and is hence very fast.\n\nThe optional keyword arguments `endian` specifies the bit endianness of the\ncreated bitarray object.\nAllowed values are the strings `big` and `little` (default is `big`).\n\nNote that setting the bit endianness only has an effect when accessing the\nmachine representation of the bitarray, i.e. when using the methods: tofile,\nfromfile, tobytes, frombytes.\n\n\n**A bitarray object supports the following methods:**\n\n`all()` -> bool\n\nReturns True when all bits in the array are True.\n\n\n`any()` -> bool\n\nReturns True when any bit in the array is True.\n\n\n`append(item, /)`\n\nAppend the value `bool(item)` to the end of the bitarray.\n\n\n`buffer_info()` -> tuple\n\nReturn a tuple (address, size, endianness, unused, allocated) giving the\ncurrent memory address, the size (in bytes) used to hold the bitarray's\ncontents, the bit endianness as a string, the number of unused bits\n(e.g. a bitarray of length 11 will have a buffer size of 2 bytes and\n5 unused bits), and the size (in bytes) of the allocated memory.\n\n\n`bytereverse()`\n\nFor all bytes representing the bitarray, reverse the bit order (in-place).\nNote: This method changes the actual machine values representing the\nbitarray; it does not change the endianness of the bitarray object.\n\n\n`copy()` -> bitarray\n\nReturn a copy of the bitarray.\n\n\n`count(value=True, start=0, stop=<end of array>, /)` -> int\n\nCount the number of occurrences of bool(value) in the bitarray.\n\n\n`decode(code, /)` -> list\n\nGiven a prefix code (a dict mapping symbols to bitarrays),\ndecode the content of the bitarray and return it as a list of symbols.\n\n\n`encode(code, iterable, /)`\n\nGiven a prefix code (a dict mapping symbols to bitarrays),\niterate over the iterable object with symbols, and extend the bitarray\nwith the corresponding bitarray for each symbols.\n\n\n`endian()` -> str\n\nReturn the bit endianness as a string (either `little` or `big`).\n\n\n`extend(iterable, /)`\n\nAppend bits to the end of the bitarray.  The objects which can be passed\nto this method are the same iterable objects which can given to a bitarray\nobject upon initialization.\n\n\n`fill()` -> int\n\nAdds zeros to the end of the bitarray, such that the length of the bitarray\nwill be a multiple of 8.  Returns the number of bits added (0..7).\n\n\n`frombytes(bytes, /)`\n\nAppend from a byte string, interpreted as machine values.\n\n\n`fromfile(f, n=<till EOF>, /)`\n\nRead n bytes from the file object f and append them to the bitarray\ninterpreted as machine values.  When n is omitted, as many bytes are\nread until EOF is reached.\n\n\n`fromstring(str)`\n\nAppend from a string, interpreting the string as machine values.\nDeprecated since version 0.4.0, use `.frombytes()` instead.\n\n\n`index(value, start=0, stop=<end of array>, /)` -> int\n\nReturn index of the first occurrence of `bool(value)` in the bitarray.\nRaises `ValueError` if the value is not present.\n\n\n`insert(index, value, /)`\n\nInsert `bool(value)` into the bitarray before index.\n\n\n`invert()`\n\nInvert all bits in the array (in-place),\ni.e. convert each 1-bit into a 0-bit and vice versa.\n\n\n`iterdecode(code, /)` -> iterator\n\nGiven a prefix code (a dict mapping symbols to bitarrays),\ndecode the content of the bitarray and return an iterator over\nthe symbols.\n\n\n`itersearch(bitarray, /)` -> iterator\n\nSearches for the given a bitarray in self, and return an iterator over\nthe start positions where bitarray matches self.\n\n\n`length()` -> int\n\nReturn the length, i.e. number of bits stored in the bitarray.\nThis method is preferred over `__len__` (used when typing `len(a)`),\nsince `__len__` will fail for a bitarray object with 2^31 or more elements\non a 32bit machine, whereas this method will return the correct value,\non 32bit and 64bit machines.\n\n\n`pack(bytes, /)`\n\nExtend the bitarray from bytes, where each byte corresponds to a single\nbit.  The byte `b'\\x00'` maps to bit 0 and all other characters map to\nbit 1.\nThis method, as well as the unpack method, are meant for efficient\ntransfer of data between bitarray objects to other python objects\n(for example NumPy's ndarray object) which have a different memory view.\n\n\n`pop(index=-1, /)` -> item\n\nReturn the i-th (default last) element and delete it from the bitarray.\nRaises `IndexError` if bitarray is empty or index is out of range.\n\n\n`remove(value, /)`\n\nRemove the first occurrence of `bool(value)` in the bitarray.\nRaises `ValueError` if item is not present.\n\n\n`reverse()`\n\nReverse the order of bits in the array (in-place).\n\n\n`search(bitarray, limit=<none>, /)` -> list\n\nSearches for the given bitarray in self, and return the list of start\npositions.\nThe optional argument limits the number of search results to the integer\nspecified.  By default, all search results are returned.\n\n\n`setall(value, /)`\n\nSet all bits in the bitarray to `bool(value)`.\n\n\n`sort(reverse=False)`\n\nSort the bits in the array (in-place).\n\n\n`to01()` -> str\n\nReturn a string containing '0's and '1's, representing the bits in the\nbitarray object.\nNote: To extend a bitarray from a string containing '0's and '1's,\nuse the extend method.\n\n\n`tobytes()` -> bytes\n\nReturn the byte representation of the bitarray.\nWhen the length of the bitarray is not a multiple of 8, the few remaining\nbits (1..7) are considered to be 0.\n\n\n`tofile(f, /)`\n\nWrite all bits (as machine values) to the file object f.\nWhen the length of the bitarray is not a multiple of 8,\nthe remaining bits (1..7) are set to 0.\n\n\n`tolist()` -> list\n\nReturn an ordinary list with the items in the bitarray.\nNote that the list object being created will require 32 or 64 times more\nmemory than the bitarray object, which may cause a memory error if the\nbitarray is very large.\nAlso note that to extend a bitarray with elements from a list,\nuse the extend method.\n\n\n`tostring()` -> str\n\nReturn the string representing (machine values) of the bitarray.\nWhen the length of the bitarray is not a multiple of 8, the few remaining\nbits (1..7) are set to 0.\nDeprecated since version 0.4.0, use `.tobytes()` instead.\n\n\n`unpack(zero=b'\\x00', one=b'\\xff')` -> bytes\n\nReturn bytes containing one character for each bit in the bitarray,\nusing the specified mapping.\n\n\nThe frozenbitarray object:\n--------------------------\n\n`frozenbitarray(initial=0, /, endian='big')`\n\nReturn a frozenbitarray object, which is initialized the same way a bitarray\nobject is initialized.  A frozenbitarray is immutable and hashable.\nIts contents cannot be altered after is created; however, it can be used as\na dictionary key.\n\n\nFunctions defined in the module:\n--------------------------------\n\n`test(verbosity=1, repeat=1)` -> TextTestResult\n\nRun self-test, and return unittest.runner.TextTestResult object.\n\n\n`bitdiff(a, b, /)` -> int\n\nReturn the difference between two bitarrays a and b.\nThis is function does the same as (a ^ b).count(), but is more memory\nefficient, as no intermediate bitarray object gets created.\nDeprecated since version 1.2.0, use `bitarray.util.count_xor()` instead.\n\n\n`bits2bytes(n, /)` -> int\n\nReturn the number of bytes necessary to store n bits.\n\n\nFunctions defined in bitarray.util:\n-----------------------------------\n\n`zeros(length, /, endian='big')` -> bitarray\n\nCreate a bitarray of length, with all values 0.\n\n\n`rindex(bitarray, value=True, /)` -> int\n\nReturn the rightmost index of `bool(value)` in bitarray.\nRaises `ValueError` if the value is not present.\n\n\n`strip(bitarray, mode='right', /)` -> bitarray\n\nStrip zeros from left, right or both ends.\nAllowed values for mode are the strings: `left`, `right`, `both`\n\n\n`count_n(a, n, /)` -> int\n\nFind the smallest index `i` for which `a[:i].count() == n`.\nRaises `ValueError`, when n exceeds the `a.count()`.\n\n\n`count_and(a, b, /)` -> int\n\nReturns `(a & b).count()`, but is more memory efficient,\nas no intermediate bitarray object gets created.\n\n\n`count_or(a, b, /)` -> int\n\nReturns `(a | b).count()`, but is more memory efficient,\nas no intermediate bitarray object gets created.\n\n\n`count_xor(a, b, /)` -> int\n\nReturns `(a ^ b).count()`, but is more memory efficient,\nas no intermediate bitarray object gets created.\n\n\n`subset(a, b, /)` -> bool\n\nReturn True if bitarray `a` is a subset of bitarray `b` (False otherwise).\n`subset(a, b)` is equivalent to `(a & b).count() == a.count()` but is more\nefficient since we can stop as soon as one mismatch is found, and no\nintermediate bitarray object gets created.\n\n\n`ba2hex(bitarray, /)` -> hexstr\n\nReturn a bytes object containing with hexadecimal representation of\nthe bitarray (which has to be multiple of 4 in length).\n\n\n`hex2ba(hexstr, /)` -> bitarray\n\nBitarray of hexadecimal representation.\nhexstr may contain any number of hex digits (upper or lower case).\n\n\n`ba2int(bitarray, /)` -> int\n\nConvert the given bitarray into an integer.\nThe bit-endianness of the bitarray is respected.\n\n\n`int2ba(int, /, length=None, endian='big')` -> bitarray\n\nConvert the given integer into a bitarray (with given endianness,\nand no leading (big-endian) / trailing (little-endian) zeros).\nIf length is provided, the result will be of this length, and an\n`OverflowError` will be raised, if the integer cannot be represented\nwithin length bits.\n\n\n`huffman_code(dict, /, endian='big')` -> dict\n\nGiven a frequency map, a dictionary mapping symbols to thier frequency,\ncalculate the Huffman code, i.e. a dict mapping those symbols to\nbitarrays (with given endianness).  Note that the symbols may be any\nhashable object (including `None`).\n\n\nChange log\n----------\n\n*1.2.1* (2020-01-06):\n\n  * simplify markdown of readme so PyPI renders better\n  * make tests for bitarray.util required (instead of warning when\n    they cannot be imported)\n\n\n*1.2.0* (2019-12-06):\n\n  * add bitarray.util module which provides useful utility functions\n  * deprecate `bitarray.bitdiff` in favor of `bitarray.util.count_xor`\n  * use markdown for documentation\n  * fix bug in .count() on 32bit systems in special cases when array size\n    is 2^29 bits or larger\n  * simplified tests by using bytes syntax\n  * update smallints and sieve example to use new utility module\n  * simplified mandel example to use numba\n  * use file context managers in tests\n\n\n*1.1.0* (2019-11-07):\n\n  * add frozenbitarray object\n  * add optional start and stop parameters to .count() method\n  * add official Python 3.8 support\n  * optimize setrange() C-function by using memset\n  * fix issue #74, bitarray is hashable on Python 2\n  * fix issue #68, `unittest.TestCase.assert_` deprecated\n  * improved test suite - tests should run in about 1 second\n  * update documentation to use positional-only syntax in docstrings\n  * update readme to pass Python 3 doctest\n  * add utils module to examples\n\n\nPlease find the complete change log\n<a href=\"https://github.com/ilanschnell/bitarray/blob/master/CHANGE_LOG\">here</a>.", "description_content_type": "", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/ph4r05/bitarray", "keywords": "", "license": "PSF", "maintainer": "", "maintainer_email": "", "name": "bitarray-ph4", "package_url": "https://pypi.org/project/bitarray-ph4/", "platform": "", "project_url": "https://pypi.org/project/bitarray-ph4/", "project_urls": {"Homepage": "https://github.com/ph4r05/bitarray"}, "release_url": "https://pypi.org/project/bitarray-ph4/1.2.3/", "requires_dist": null, "requires_python": "", "summary": "efficient arrays of booleans -- C extension", "version": "1.2.3", "yanked": false, "html_description": "<div class=\"project-description\">\n            <div id=\"bitarray-efficient-arrays-of-booleans\">\n<h2>bitarray: efficient arrays of booleans</h2>\n<p>This module provides an object type which efficiently represents an array\nof booleans.  Bitarrays are sequence types and behave very much like usual\nlists.  Eight bits are represented by one byte in a contiguous block of\nmemory.  The user can select between two representations: little-endian\nand big-endian.  All of the functionality is implemented in C.\nMethods for accessing the machine representation are provided.\nThis can be useful when bit level access to binary files is required,\nsuch as portable bitmap image files (.pbm).  Also, when dealing with\ncompressed data which uses variable bit length encoding, you may find\nthis module useful.</p>\n<div id=\"key-features\">\n<h3>Key features</h3>\n<blockquote>\n<ul>\n<li>All functionality implemented in C.</li>\n<li>Bitarray objects behave very much like a list object, in particular\nslicing (including slice assignment and deletion) is supported.</li>\n<li>The bit endianness can be specified for each bitarray object, see below.</li>\n<li>Packing and unpacking to other binary data formats, e.g. numpy.ndarray\nis possible.</li>\n<li>Fast methods for encoding and decoding variable bit length prefix codes</li>\n<li>Bitwise operations: <cite>&amp;</cite>, <cite>|</cite>, <cite>^</cite>, <cite>&amp;=</cite>, <cite>|=</cite>, <cite>^=</cite>, <cite>~</cite></li>\n<li>Sequential search</li>\n<li>Pickling and unpickling of bitarray objects.</li>\n<li>Bitarray objects support the buffer protocol (Python 2.7 and above)</li>\n<li>On 32-bit systems, a bitarray object can contain up to 2^34 elements,\nthat is 16 Gbits (on 64-bit machines up to 2^63 elements in theory).</li>\n</ul>\n</blockquote>\n</div>\n<div id=\"installation\">\n<h3>Installation</h3>\n<p>Bitarray can be installed from source:</p>\n<blockquote>\n$ tar xzf bitarray-1.2.1.tar.gz\n$ cd bitarray-1.2.1\n$ python setup.py install</blockquote>\n<p>On Unix systems, the latter command may have to be executed with root\nprivileges.  You can also pip install bitarray.\nOnce you have installed the package, you may want to test it:</p>\n<blockquote>\n<p>$ python -c \u2018import bitarray; bitarray.test()\u2019\nbitarray is installed in: /usr/local/lib/python2.7/site-packages/bitarray\nbitarray version: 1.2.1\n3.7.4 (r271:86832, Dec 29 2018) [GCC 4.2.1 (SUSE Linux)]\n\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026.\n\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026.\n\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\n\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014-\nRan 199 tests in 1.144s</p>\n<p>OK</p>\n</blockquote>\n<p>You can always import the function test,\nand <cite>test().wasSuccessful()</cite> will return <cite>True</cite> when the test went well.</p>\n</div>\n<div id=\"using-the-module\">\n<h3>Using the module</h3>\n<p>As mentioned above, bitarray objects behave very much like lists, so\nthere is not too much to learn.  The biggest difference from list objects\nis the ability to access the machine representation of the object.\nWhen doing so, the bit endianness is of importance; this issue is\nexplained in detail in the section below.  Here, we demonstrate the\nbasic usage of bitarray objects:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from bitarray import bitarray\n&gt;&gt;&gt; a = bitarray()            # create empty bitarray\n&gt;&gt;&gt; a.append(True)\n&gt;&gt;&gt; a.extend([False, True, True])\n&gt;&gt;&gt; a\nbitarray('1011')\n</pre>\n</blockquote>\n<p>Bitarray objects can be instantiated in different ways:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; a = bitarray(2**20)       # bitarray of length 1048576 (uninitialized)\n&gt;&gt;&gt; bitarray('1001011')       # from a string\nbitarray('1001011')\n&gt;&gt;&gt; lst = [True, False, False, True, False, True, True]\n&gt;&gt;&gt; bitarray(lst)             # from list, tuple, iterable\nbitarray('1001011')\n</pre>\n</blockquote>\n<p>Bits can be assigned from any Python object, if the value can be interpreted\nas a truth value.  You can think of this as Python\u2019s built-in function bool()\nbeing applied, whenever casting an object:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; a = bitarray([42, '', True, {}, 'foo', None])\n&gt;&gt;&gt; a\nbitarray('101010')\n&gt;&gt;&gt; a.append(a)      # note that bool(a) is True\n&gt;&gt;&gt; a.count(42)      # counts occurrences of True (not 42)\n4\n&gt;&gt;&gt; a.remove('')     # removes first occurrence of False\n&gt;&gt;&gt; a\nbitarray('110101')\n</pre>\n</blockquote>\n<p>Like lists, bitarray objects support slice assignment and deletion:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; a = bitarray(50)\n&gt;&gt;&gt; a.setall(False)\n&gt;&gt;&gt; a[11:37:3] = 9 * bitarray([True])\n&gt;&gt;&gt; a\nbitarray('00000000000100100100100100100100100100000000000000')\n&gt;&gt;&gt; del a[12::3]\n&gt;&gt;&gt; a\nbitarray('0000000000010101010101010101000000000')\n&gt;&gt;&gt; a[-6:] = bitarray('10011')\n&gt;&gt;&gt; a\nbitarray('000000000001010101010101010100010011')\n&gt;&gt;&gt; a += bitarray('000111')\n&gt;&gt;&gt; a[9:]\nbitarray('001010101010101010100010011000111')\n</pre>\n</blockquote>\n<p>In addition, slices can be assigned to booleans, which is easier (and\nfaster) than assigning to a bitarray in which all values are the same:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; a = 20 * bitarray('0')\n&gt;&gt;&gt; a[1:15:3] = True\n&gt;&gt;&gt; a\nbitarray('01001001001001000000')\n</pre>\n</blockquote>\n<p>This is easier and faster than:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; a = 20 * bitarray('0')\n&gt;&gt;&gt; a[1:15:3] = 5 * bitarray('1')\n&gt;&gt;&gt; a\nbitarray('01001001001001000000')\n</pre>\n</blockquote>\n<p>Note that in the latter we have to create a temporary bitarray whose length\nmust be known or calculated.</p>\n</div>\n<div id=\"bit-endianness\">\n<h3>Bit endianness</h3>\n<p>Since a bitarray allows addressing of individual bits, where the machine\nrepresents 8 bits in one byte, there are two obvious choices for this\nmapping: little- and big-endian.\nWhen creating a new bitarray object, the endianness can always be\nspecified explicitly:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; a = bitarray(endian='little')\n&gt;&gt;&gt; a.frombytes(b'A')\n&gt;&gt;&gt; a\nbitarray('10000010')\n&gt;&gt;&gt; b = bitarray('11000010', endian='little')\n&gt;&gt;&gt; b.tobytes()\nb'C'\n</pre>\n</blockquote>\n<p>Here, the low-bit comes first because little-endian means that increasing\nnumeric significance corresponds to an increasing address (index).\nSo a[0] is the lowest and least significant bit, and a[7] is the highest\nand most significant bit.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; a = bitarray(endian='big')\n&gt;&gt;&gt; a.frombytes(b'A')\n&gt;&gt;&gt; a\nbitarray('01000001')\n&gt;&gt;&gt; a[6] = 1\n&gt;&gt;&gt; a.tobytes()\nb'C'\n</pre>\n</blockquote>\n<p>Here, the high-bit comes first because big-endian\nmeans \u201cmost-significant first\u201d.\nSo a[0] is now the lowest and most significant bit, and a[7] is the highest\nand least significant bit.</p>\n<p>The bit endianness is a property attached to each bitarray object.\nWhen comparing bitarray objects, the endianness (and hence the machine\nrepresentation) is irrelevant; what matters is the mapping from indices\nto bits:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; bitarray('11001', endian='big') == bitarray('11001', endian='little')\nTrue\n</pre>\n</blockquote>\n<p>Bitwise operations (<cite>&amp;</cite>, <cite>|</cite>, <cite>^</cite>, <cite>&amp;=</cite>, <cite>|=</cite>, <cite>^=</cite>, <cite>~</cite>) are implemented\nefficiently using the corresponding byte operations in C, i.e. the operators\nact on the machine representation of the bitarray objects.\nTherefore, one has to be cautious when applying the operation to bitarrays\nwith different endianness.</p>\n<p>When converting to and from machine representation, using\nthe <cite>tobytes</cite>, <cite>frombytes</cite>, <cite>tofile</cite> and <cite>fromfile</cite> methods,\nthe endianness matters:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; a = bitarray(endian='little')\n&gt;&gt;&gt; a.frombytes(b'\\x01')\n&gt;&gt;&gt; a\nbitarray('10000000')\n&gt;&gt;&gt; b = bitarray(endian='big')\n&gt;&gt;&gt; b.frombytes(b'\\x80')\n&gt;&gt;&gt; b\nbitarray('10000000')\n&gt;&gt;&gt; a == b\nTrue\n&gt;&gt;&gt; a.tobytes() == b.tobytes()\nFalse\n</pre>\n</blockquote>\n<p>The endianness can not be changed once an object is created.\nHowever, since creating a bitarray from another bitarray just copies the\nmemory representing the data, you can create a new bitarray with different\nendianness:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; a = bitarray('11100000', endian='little')\n&gt;&gt;&gt; a\nbitarray('11100000')\n&gt;&gt;&gt; b = bitarray(a, endian='big')\n&gt;&gt;&gt; b\nbitarray('00000111')\n&gt;&gt;&gt; a == b\nFalse\n&gt;&gt;&gt; a.tobytes() == b.tobytes()\nTrue\n</pre>\n</blockquote>\n<p>The default bit endianness is currently big-endian, however this may change\nin the future, and when dealing with the machine representation of bitarray\nobjects, it is recommended to always explicitly specify the endianness.</p>\n<p>Unless explicitly converting to machine representation, using\nthe <cite>tobytes</cite>, <cite>frombytes</cite>, <cite>tofile</cite> and <cite>fromfile</cite> methods,\nthe bit endianness will have no effect on any computation, and one\ncan safely ignore setting the endianness, and other details of this section.</p>\n</div>\n<div id=\"buffer-protocol\">\n<h3>Buffer protocol</h3>\n<p>Python 2.7 provides memoryview objects, which allow Python code to access\nthe internal data of an object that supports the buffer protocol without\ncopying.  Bitarray objects support this protocol, with the memory being\ninterpreted as simple bytes.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; a = bitarray('01000001' '01000010' '01000011', endian='big')\n&gt;&gt;&gt; v = memoryview(a)\n&gt;&gt;&gt; len(v)\n3\n&gt;&gt;&gt; v[-1]\n67\n&gt;&gt;&gt; v[:2].tobytes()\nb'AB'\n&gt;&gt;&gt; v.readonly  # changing a bitarray's memory is also possible\nFalse\n&gt;&gt;&gt; v[1] = 111\n&gt;&gt;&gt; a\nbitarray('010000010110111101000011')\n</pre>\n</blockquote>\n</div>\n<div id=\"variable-bit-length-prefix-codes\">\n<h3>Variable bit length prefix codes</h3>\n<p>The method <cite>encode</cite> takes a dictionary mapping symbols to bitarrays\nand an iterable, and extends the bitarray object with the encoded symbols\nfound while iterating.  For example:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; d = {'H':bitarray('111'), 'e':bitarray('0'),\n...      'l':bitarray('110'), 'o':bitarray('10')}\n...\n&gt;&gt;&gt; a = bitarray()\n&gt;&gt;&gt; a.encode(d, 'Hello')\n&gt;&gt;&gt; a\nbitarray('111011011010')\n</pre>\n</blockquote>\n<p>Note that the string <cite>\u2018Hello\u2019</cite> is an iterable, but the symbols are not\nlimited to characters, in fact any immutable Python object can be a symbol.\nTaking the same dictionary, we can apply the <cite>decode</cite> method which will\nreturn a list of the symbols:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; a.decode(d)\n['H', 'e', 'l', 'l', 'o']\n&gt;&gt;&gt; ''.join(a.decode(d))\n'Hello'\n</pre>\n</blockquote>\n<p>Since symbols are not limited to being characters, it is necessary to return\nthem as elements of a list, rather than simply returning the joined string.</p>\n</div>\n</div>\n<div id=\"reference\">\n<h2>Reference</h2>\n<div id=\"the-bitarray-object\">\n<h3>The bitarray object:</h3>\n<p><cite>bitarray(initial=0, /, endian=\u2019big\u2019)</cite></p>\n<p>Return a new bitarray object whose items are bits initialized from\nthe optional initial object, and endianness.\nIf no initial object is provided, an empty bitarray (length zero) is created.\nThe initial object may be of the following types:</p>\n<p><cite>int</cite>: Create a bitarray of given integer length.  The initial values are\narbitrary.  If you want all values to be set, use the .setall() method.</p>\n<p><cite>str</cite>: Create bitarray from a string of <cite>0</cite> and <cite>1</cite>.</p>\n<p><cite>list</cite>, <cite>tuple</cite>, <cite>iterable</cite>: Create bitarray from a sequence, each\nelement in the sequence is converted to a bit using its truth value.</p>\n<p><cite>bitarray</cite>: Create bitarray from another bitarray.  This is done by\ncopying the memory holding the bitarray data, and is hence very fast.</p>\n<p>The optional keyword arguments <cite>endian</cite> specifies the bit endianness of the\ncreated bitarray object.\nAllowed values are the strings <cite>big</cite> and <cite>little</cite> (default is <cite>big</cite>).</p>\n<p>Note that setting the bit endianness only has an effect when accessing the\nmachine representation of the bitarray, i.e. when using the methods: tofile,\nfromfile, tobytes, frombytes.</p>\n<p><strong>A bitarray object supports the following methods:</strong></p>\n<p><cite>all()</cite> -&gt; bool</p>\n<p>Returns True when all bits in the array are True.</p>\n<p><cite>any()</cite> -&gt; bool</p>\n<p>Returns True when any bit in the array is True.</p>\n<p><cite>append(item, /)</cite></p>\n<p>Append the value <cite>bool(item)</cite> to the end of the bitarray.</p>\n<p><cite>buffer_info()</cite> -&gt; tuple</p>\n<p>Return a tuple (address, size, endianness, unused, allocated) giving the\ncurrent memory address, the size (in bytes) used to hold the bitarray\u2019s\ncontents, the bit endianness as a string, the number of unused bits\n(e.g. a bitarray of length 11 will have a buffer size of 2 bytes and\n5 unused bits), and the size (in bytes) of the allocated memory.</p>\n<p><cite>bytereverse()</cite></p>\n<p>For all bytes representing the bitarray, reverse the bit order (in-place).\nNote: This method changes the actual machine values representing the\nbitarray; it does not change the endianness of the bitarray object.</p>\n<p><cite>copy()</cite> -&gt; bitarray</p>\n<p>Return a copy of the bitarray.</p>\n<p><cite>count(value=True, start=0, stop=&lt;end of array&gt;, /)</cite> -&gt; int</p>\n<p>Count the number of occurrences of bool(value) in the bitarray.</p>\n<p><cite>decode(code, /)</cite> -&gt; list</p>\n<p>Given a prefix code (a dict mapping symbols to bitarrays),\ndecode the content of the bitarray and return it as a list of symbols.</p>\n<p><cite>encode(code, iterable, /)</cite></p>\n<p>Given a prefix code (a dict mapping symbols to bitarrays),\niterate over the iterable object with symbols, and extend the bitarray\nwith the corresponding bitarray for each symbols.</p>\n<p><cite>endian()</cite> -&gt; str</p>\n<p>Return the bit endianness as a string (either <cite>little</cite> or <cite>big</cite>).</p>\n<p><cite>extend(iterable, /)</cite></p>\n<p>Append bits to the end of the bitarray.  The objects which can be passed\nto this method are the same iterable objects which can given to a bitarray\nobject upon initialization.</p>\n<p><cite>fill()</cite> -&gt; int</p>\n<p>Adds zeros to the end of the bitarray, such that the length of the bitarray\nwill be a multiple of 8.  Returns the number of bits added (0..7).</p>\n<p><cite>frombytes(bytes, /)</cite></p>\n<p>Append from a byte string, interpreted as machine values.</p>\n<p><cite>fromfile(f, n=&lt;till EOF&gt;, /)</cite></p>\n<p>Read n bytes from the file object f and append them to the bitarray\ninterpreted as machine values.  When n is omitted, as many bytes are\nread until EOF is reached.</p>\n<p><cite>fromstring(str)</cite></p>\n<p>Append from a string, interpreting the string as machine values.\nDeprecated since version 0.4.0, use <cite>.frombytes()</cite> instead.</p>\n<p><cite>index(value, start=0, stop=&lt;end of array&gt;, /)</cite> -&gt; int</p>\n<p>Return index of the first occurrence of <cite>bool(value)</cite> in the bitarray.\nRaises <cite>ValueError</cite> if the value is not present.</p>\n<p><cite>insert(index, value, /)</cite></p>\n<p>Insert <cite>bool(value)</cite> into the bitarray before index.</p>\n<p><cite>invert()</cite></p>\n<p>Invert all bits in the array (in-place),\ni.e. convert each 1-bit into a 0-bit and vice versa.</p>\n<p><cite>iterdecode(code, /)</cite> -&gt; iterator</p>\n<p>Given a prefix code (a dict mapping symbols to bitarrays),\ndecode the content of the bitarray and return an iterator over\nthe symbols.</p>\n<p><cite>itersearch(bitarray, /)</cite> -&gt; iterator</p>\n<p>Searches for the given a bitarray in self, and return an iterator over\nthe start positions where bitarray matches self.</p>\n<p><cite>length()</cite> -&gt; int</p>\n<p>Return the length, i.e. number of bits stored in the bitarray.\nThis method is preferred over <cite>__len__</cite> (used when typing <cite>len(a)</cite>),\nsince <cite>__len__</cite> will fail for a bitarray object with 2^31 or more elements\non a 32bit machine, whereas this method will return the correct value,\non 32bit and 64bit machines.</p>\n<p><cite>pack(bytes, /)</cite></p>\n<p>Extend the bitarray from bytes, where each byte corresponds to a single\nbit.  The byte <cite>b\u2019x00\u2019</cite> maps to bit 0 and all other characters map to\nbit 1.\nThis method, as well as the unpack method, are meant for efficient\ntransfer of data between bitarray objects to other python objects\n(for example NumPy\u2019s ndarray object) which have a different memory view.</p>\n<p><cite>pop(index=-1, /)</cite> -&gt; item</p>\n<p>Return the i-th (default last) element and delete it from the bitarray.\nRaises <cite>IndexError</cite> if bitarray is empty or index is out of range.</p>\n<p><cite>remove(value, /)</cite></p>\n<p>Remove the first occurrence of <cite>bool(value)</cite> in the bitarray.\nRaises <cite>ValueError</cite> if item is not present.</p>\n<p><cite>reverse()</cite></p>\n<p>Reverse the order of bits in the array (in-place).</p>\n<p><cite>search(bitarray, limit=&lt;none&gt;, /)</cite> -&gt; list</p>\n<p>Searches for the given bitarray in self, and return the list of start\npositions.\nThe optional argument limits the number of search results to the integer\nspecified.  By default, all search results are returned.</p>\n<p><cite>setall(value, /)</cite></p>\n<p>Set all bits in the bitarray to <cite>bool(value)</cite>.</p>\n<p><cite>sort(reverse=False)</cite></p>\n<p>Sort the bits in the array (in-place).</p>\n<p><cite>to01()</cite> -&gt; str</p>\n<p>Return a string containing \u20180\u2019s and \u20181\u2019s, representing the bits in the\nbitarray object.\nNote: To extend a bitarray from a string containing \u20180\u2019s and \u20181\u2019s,\nuse the extend method.</p>\n<p><cite>tobytes()</cite> -&gt; bytes</p>\n<p>Return the byte representation of the bitarray.\nWhen the length of the bitarray is not a multiple of 8, the few remaining\nbits (1..7) are considered to be 0.</p>\n<p><cite>tofile(f, /)</cite></p>\n<p>Write all bits (as machine values) to the file object f.\nWhen the length of the bitarray is not a multiple of 8,\nthe remaining bits (1..7) are set to 0.</p>\n<p><cite>tolist()</cite> -&gt; list</p>\n<p>Return an ordinary list with the items in the bitarray.\nNote that the list object being created will require 32 or 64 times more\nmemory than the bitarray object, which may cause a memory error if the\nbitarray is very large.\nAlso note that to extend a bitarray with elements from a list,\nuse the extend method.</p>\n<p><cite>tostring()</cite> -&gt; str</p>\n<p>Return the string representing (machine values) of the bitarray.\nWhen the length of the bitarray is not a multiple of 8, the few remaining\nbits (1..7) are set to 0.\nDeprecated since version 0.4.0, use <cite>.tobytes()</cite> instead.</p>\n<p><cite>unpack(zero=b\u2019x00\u2019, one=b\u2019xff\u2019)</cite> -&gt; bytes</p>\n<p>Return bytes containing one character for each bit in the bitarray,\nusing the specified mapping.</p>\n</div>\n<div id=\"the-frozenbitarray-object\">\n<h3>The frozenbitarray object:</h3>\n<p><cite>frozenbitarray(initial=0, /, endian=\u2019big\u2019)</cite></p>\n<p>Return a frozenbitarray object, which is initialized the same way a bitarray\nobject is initialized.  A frozenbitarray is immutable and hashable.\nIts contents cannot be altered after is created; however, it can be used as\na dictionary key.</p>\n</div>\n<div id=\"functions-defined-in-the-module\">\n<h3>Functions defined in the module:</h3>\n<p><cite>test(verbosity=1, repeat=1)</cite> -&gt; TextTestResult</p>\n<p>Run self-test, and return unittest.runner.TextTestResult object.</p>\n<p><cite>bitdiff(a, b, /)</cite> -&gt; int</p>\n<p>Return the difference between two bitarrays a and b.\nThis is function does the same as (a ^ b).count(), but is more memory\nefficient, as no intermediate bitarray object gets created.\nDeprecated since version 1.2.0, use <cite>bitarray.util.count_xor()</cite> instead.</p>\n<p><cite>bits2bytes(n, /)</cite> -&gt; int</p>\n<p>Return the number of bytes necessary to store n bits.</p>\n</div>\n<div id=\"functions-defined-in-bitarray-util\">\n<h3>Functions defined in bitarray.util:</h3>\n<p><cite>zeros(length, /, endian=\u2019big\u2019)</cite> -&gt; bitarray</p>\n<p>Create a bitarray of length, with all values 0.</p>\n<p><cite>rindex(bitarray, value=True, /)</cite> -&gt; int</p>\n<p>Return the rightmost index of <cite>bool(value)</cite> in bitarray.\nRaises <cite>ValueError</cite> if the value is not present.</p>\n<p><cite>strip(bitarray, mode=\u2019right\u2019, /)</cite> -&gt; bitarray</p>\n<p>Strip zeros from left, right or both ends.\nAllowed values for mode are the strings: <cite>left</cite>, <cite>right</cite>, <cite>both</cite></p>\n<p><cite>count_n(a, n, /)</cite> -&gt; int</p>\n<p>Find the smallest index <cite>i</cite> for which <cite>a[:i].count() == n</cite>.\nRaises <cite>ValueError</cite>, when n exceeds the <cite>a.count()</cite>.</p>\n<p><cite>count_and(a, b, /)</cite> -&gt; int</p>\n<p>Returns <cite>(a &amp; b).count()</cite>, but is more memory efficient,\nas no intermediate bitarray object gets created.</p>\n<p><cite>count_or(a, b, /)</cite> -&gt; int</p>\n<p>Returns <cite>(a | b).count()</cite>, but is more memory efficient,\nas no intermediate bitarray object gets created.</p>\n<p><cite>count_xor(a, b, /)</cite> -&gt; int</p>\n<p>Returns <cite>(a ^ b).count()</cite>, but is more memory efficient,\nas no intermediate bitarray object gets created.</p>\n<p><cite>subset(a, b, /)</cite> -&gt; bool</p>\n<p>Return True if bitarray <cite>a</cite> is a subset of bitarray <cite>b</cite> (False otherwise).\n<cite>subset(a, b)</cite> is equivalent to <cite>(a &amp; b).count() == a.count()</cite> but is more\nefficient since we can stop as soon as one mismatch is found, and no\nintermediate bitarray object gets created.</p>\n<p><cite>ba2hex(bitarray, /)</cite> -&gt; hexstr</p>\n<p>Return a bytes object containing with hexadecimal representation of\nthe bitarray (which has to be multiple of 4 in length).</p>\n<p><cite>hex2ba(hexstr, /)</cite> -&gt; bitarray</p>\n<p>Bitarray of hexadecimal representation.\nhexstr may contain any number of hex digits (upper or lower case).</p>\n<p><cite>ba2int(bitarray, /)</cite> -&gt; int</p>\n<p>Convert the given bitarray into an integer.\nThe bit-endianness of the bitarray is respected.</p>\n<p><cite>int2ba(int, /, length=None, endian=\u2019big\u2019)</cite> -&gt; bitarray</p>\n<p>Convert the given integer into a bitarray (with given endianness,\nand no leading (big-endian) / trailing (little-endian) zeros).\nIf length is provided, the result will be of this length, and an\n<cite>OverflowError</cite> will be raised, if the integer cannot be represented\nwithin length bits.</p>\n<p><cite>huffman_code(dict, /, endian=\u2019big\u2019)</cite> -&gt; dict</p>\n<p>Given a frequency map, a dictionary mapping symbols to thier frequency,\ncalculate the Huffman code, i.e. a dict mapping those symbols to\nbitarrays (with given endianness).  Note that the symbols may be any\nhashable object (including <cite>None</cite>).</p>\n</div>\n<div id=\"change-log\">\n<h3>Change log</h3>\n<p><em>1.2.1</em> (2020-01-06):</p>\n<blockquote>\n<ul>\n<li>simplify markdown of readme so PyPI renders better</li>\n<li>make tests for bitarray.util required (instead of warning when\nthey cannot be imported)</li>\n</ul>\n</blockquote>\n<p><em>1.2.0</em> (2019-12-06):</p>\n<blockquote>\n<ul>\n<li>add bitarray.util module which provides useful utility functions</li>\n<li>deprecate <cite>bitarray.bitdiff</cite> in favor of <cite>bitarray.util.count_xor</cite></li>\n<li>use markdown for documentation</li>\n<li>fix bug in .count() on 32bit systems in special cases when array size\nis 2^29 bits or larger</li>\n<li>simplified tests by using bytes syntax</li>\n<li>update smallints and sieve example to use new utility module</li>\n<li>simplified mandel example to use numba</li>\n<li>use file context managers in tests</li>\n</ul>\n</blockquote>\n<p><em>1.1.0</em> (2019-11-07):</p>\n<blockquote>\n<ul>\n<li>add frozenbitarray object</li>\n<li>add optional start and stop parameters to .count() method</li>\n<li>add official Python 3.8 support</li>\n<li>optimize setrange() C-function by using memset</li>\n<li>fix issue #74, bitarray is hashable on Python 2</li>\n<li>fix issue #68, <cite>unittest.TestCase.assert_</cite> deprecated</li>\n<li>improved test suite - tests should run in about 1 second</li>\n<li>update documentation to use positional-only syntax in docstrings</li>\n<li>update readme to pass Python 3 doctest</li>\n<li>add utils module to examples</li>\n</ul>\n</blockquote>\n<p>Please find the complete change log\n&lt;a href=\u201d<a href=\"https://github.com/ilanschnell/bitarray/blob/master/CHANGE_LOG\" rel=\"nofollow\">https://github.com/ilanschnell/bitarray/blob/master/CHANGE_LOG</a>\u201d&gt;here&lt;/a&gt;.</p>\n</div>\n</div>\n\n          </div>"}, "last_serial": 6502931, "releases": {"0.8.10": [{"comment_text": "", "digests": {"md5": "03d9e73616e095bbf8617ec2a4ae267d", "sha256": "c0b43f397d95f73770c12ea636d8dd11a63bd6a9edbc6ea167867ac34a04fa75"}, "downloads": -1, "filename": "bitarray_ph4-0.8.10.tar.gz", "has_sig": false, "md5_digest": "03d9e73616e095bbf8617ec2a4ae267d", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 49913, "upload_time": "2017-03-14T22:50:47", "upload_time_iso_8601": "2017-03-14T22:50:47.093590Z", "url": "https://files.pythonhosted.org/packages/e7/81/6355fe58e711742c0e736a93f869676bd2602d04749b53f07a6da3865849/bitarray_ph4-0.8.10.tar.gz", "yanked": false}], "0.8.11": [{"comment_text": "", "digests": {"md5": "a2708f3cfab1241b332ed670dc9bb9b4", "sha256": "2e0acd76655978b91d8dc7bd69a959b37c065311d0f498f177b6142b90f7b75e"}, "downloads": -1, "filename": "bitarray_ph4-0.8.11.tar.gz", "has_sig": false, "md5_digest": "a2708f3cfab1241b332ed670dc9bb9b4", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 49945, "upload_time": "2017-03-14T22:58:46", "upload_time_iso_8601": "2017-03-14T22:58:46.347766Z", "url": "https://files.pythonhosted.org/packages/b9/6a/aab98a2cfbec402dff1610aa392552a2742b25903428c1a57534e70c8d41/bitarray_ph4-0.8.11.tar.gz", "yanked": false}], "0.8.12": [{"comment_text": "", "digests": {"md5": "fbb9229eee84b707ef85527914fcaac7", "sha256": "8b44e3bd79566aa554f901dedfc31e94ad1f1923e200900647468b84f09f4284"}, "downloads": -1, "filename": "bitarray_ph4-0.8.12.tar.gz", "has_sig": true, "md5_digest": "fbb9229eee84b707ef85527914fcaac7", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 49380, "upload_time": "2019-11-26T09:41:37", "upload_time_iso_8601": "2019-11-26T09:41:37.948466Z", "url": "https://files.pythonhosted.org/packages/be/67/c85beff2094ca8d64899e25cc73381000f4965f6af4445dfb61b768106db/bitarray_ph4-0.8.12.tar.gz", "yanked": false}], "0.8.13": [{"comment_text": "", "digests": {"md5": "ae7829283eae78d763e7c4e7d8d4fa76", "sha256": "5f1ae9160e487674e2322bf075e84a0b1d9d808c343f6a4e17e1a459b6986d41"}, "downloads": -1, "filename": "bitarray_ph4-0.8.13.tar.gz", "has_sig": true, "md5_digest": "ae7829283eae78d763e7c4e7d8d4fa76", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 49361, "upload_time": "2019-11-26T09:47:05", "upload_time_iso_8601": "2019-11-26T09:47:05.937036Z", "url": "https://files.pythonhosted.org/packages/67/20/2b19f9275f6fa5b470062d614c0b1f7180d0edf091b26a260c02340da5f2/bitarray_ph4-0.8.13.tar.gz", "yanked": false}], "0.8.3": [{"comment_text": "", "digests": {"md5": "85191965a3a61c295697119c85161960", "sha256": "f1f4dbc63fe3b329bb194a2ada23993d5217452fbcf73ee5ce24cc9b56acd130"}, "downloads": -1, "filename": "bitarray_ph4-0.8.3.tar.gz", "has_sig": false, "md5_digest": "85191965a3a61c295697119c85161960", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 36927, "upload_time": "2017-01-16T23:14:00", "upload_time_iso_8601": "2017-01-16T23:14:00.313435Z", "url": "https://files.pythonhosted.org/packages/1f/67/8cbd6624574d5683a6f7899175028b24d9068f8ec893216356d7d582a104/bitarray_ph4-0.8.3.tar.gz", "yanked": false}], "0.8.4": [{"comment_text": "", "digests": {"md5": "2c97e0b4f12d912507a9065bf7856220", "sha256": "61833f5306f28e3bfe4601b9c6bd4f1d5ce70000d88800f3446e90eae279b42f"}, "downloads": -1, "filename": "bitarray_ph4-0.8.4.tar.gz", "has_sig": false, "md5_digest": "2c97e0b4f12d912507a9065bf7856220", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 38314, "upload_time": "2017-01-17T14:03:33", "upload_time_iso_8601": "2017-01-17T14:03:33.353292Z", "url": "https://files.pythonhosted.org/packages/79/b3/4d2a4631f92e96b35028e979f49bdef5ef0de49909df607399970ad97f45/bitarray_ph4-0.8.4.tar.gz", "yanked": false}], "0.8.5": [{"comment_text": "", "digests": {"md5": "5a018a5cb0a98a04c1a222d409586794", "sha256": "3042dd0706a8878766778b3b222c0c6a3fbdc36393b4ba65f9bf1d13146077c8"}, "downloads": -1, "filename": "bitarray_ph4-0.8.5.tar.gz", "has_sig": false, "md5_digest": "5a018a5cb0a98a04c1a222d409586794", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 40548, "upload_time": "2017-01-22T15:32:34", "upload_time_iso_8601": "2017-01-22T15:32:34.488729Z", "url": "https://files.pythonhosted.org/packages/6b/be/8f73ea5d34f1b1da7e52ddb1086703489f76cbf12c81098243c64f8f2d36/bitarray_ph4-0.8.5.tar.gz", "yanked": false}], "0.8.6": [{"comment_text": "", "digests": {"md5": "89c331533483eb0c5904b230ede64e7b", "sha256": "1b4e1374f6a9ec3d1df0b9da3579f43565be70770e512d42e78cb6ce02eb85c2"}, "downloads": -1, "filename": "bitarray_ph4-0.8.6.tar.gz", "has_sig": false, "md5_digest": "89c331533483eb0c5904b230ede64e7b", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 40971, "upload_time": "2017-01-22T16:19:24", "upload_time_iso_8601": "2017-01-22T16:19:24.239259Z", "url": "https://files.pythonhosted.org/packages/ab/90/9b3e9a7900d327d1e9da03f0b3f542aa6e13ed7da2b629f485eeca7e90af/bitarray_ph4-0.8.6.tar.gz", "yanked": false}], "0.8.7": [{"comment_text": "", "digests": {"md5": "19b4e473405fe88f165e3fa5c7f7dcb5", "sha256": "ba0b6b910bce30ceb3de56b1c8f419b8d50fe91024530d4624651d9b1cd359a2"}, "downloads": -1, "filename": "bitarray_ph4-0.8.7.tar.gz", "has_sig": false, "md5_digest": "19b4e473405fe88f165e3fa5c7f7dcb5", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 47069, "upload_time": "2017-02-21T21:10:25", "upload_time_iso_8601": "2017-02-21T21:10:25.176952Z", "url": "https://files.pythonhosted.org/packages/08/2e/18470481f87f6d280f912c30bb272e440e2ea87c14bfc49d9a8205c878d4/bitarray_ph4-0.8.7.tar.gz", "yanked": false}], "1.2.2": [{"comment_text": "", "digests": {"md5": "4b70971e212bc5f6a505145fa80f6f88", "sha256": "782cfe014c1b458b82880da77c36008d6541225cf55280b3d5683226353e29af"}, "downloads": -1, "filename": "bitarray_ph4-1.2.2.tar.gz", "has_sig": true, "md5_digest": "4b70971e212bc5f6a505145fa80f6f88", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 59554, "upload_time": "2020-01-15T09:11:39", "upload_time_iso_8601": "2020-01-15T09:11:39.087160Z", "url": "https://files.pythonhosted.org/packages/37/0e/385a37d6c58d47b6ee4be5ec68f05964d8a901901a789b00f996a8b04b6d/bitarray_ph4-1.2.2.tar.gz", "yanked": false}], "1.2.3": [{"comment_text": "", "digests": {"md5": "59a15ec9850d8fd099f8200e95f5852f", "sha256": "3fe256b0abfcaa58a0dc3171eba923db438dfc6152d691e2355f3220cd0cde5e"}, "downloads": -1, "filename": "bitarray_ph4-1.2.3.tar.gz", "has_sig": true, "md5_digest": "59a15ec9850d8fd099f8200e95f5852f", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 63644, "upload_time": "2020-01-22T22:41:32", "upload_time_iso_8601": "2020-01-22T22:41:32.790178Z", "url": "https://files.pythonhosted.org/packages/79/b0/cd29b14210d620a5665bbfc1782067a5335fd8c70f235754c7654990c637/bitarray_ph4-1.2.3.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "59a15ec9850d8fd099f8200e95f5852f", "sha256": "3fe256b0abfcaa58a0dc3171eba923db438dfc6152d691e2355f3220cd0cde5e"}, "downloads": -1, "filename": "bitarray_ph4-1.2.3.tar.gz", "has_sig": true, "md5_digest": "59a15ec9850d8fd099f8200e95f5852f", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 63644, "upload_time": "2020-01-22T22:41:32", "upload_time_iso_8601": "2020-01-22T22:41:32.790178Z", "url": "https://files.pythonhosted.org/packages/79/b0/cd29b14210d620a5665bbfc1782067a5335fd8c70f235754c7654990c637/bitarray_ph4-1.2.3.tar.gz", "yanked": false}], "timestamp": "Thu May  7 22:37:19 2020"}