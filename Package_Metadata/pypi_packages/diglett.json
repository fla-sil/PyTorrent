{"info": {"author": "Geoff Ruddock", "author_email": "", "bugtrack_url": null, "classifiers": ["License :: OSI Approved :: MIT License", "Programming Language :: Python", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.7"], "description": "# Diglett\n\n![Image of Diglett pokemon](https://raw.githubusercontent.com/asdfgeoff/diglett/master/diglett.png)\n\n\n## What it does\n\nDiglett is a collection of my most frequently used and reusable functions for data analysis, data wrangling, and machine learning. I have largely packaged them together for my own benefit, but I hope you will find something useful in here for yourself.\n\n\n## Installing\n\nYou can install this package via pip:\n\n```\npip install diglett\n```\n\n## API documentation\n\n### diglett.decorate module\n\nUseful decorators for troubleshooting data transformation pipelines and asserting assumptions.\n\nInspired by Tom Augspurger\u2019s package engarde: [https://github.com/engarde-dev/engarde](https://github.com/engarde-dev/engarde)\n\n\n#### diglett.decorate.describe_io(func)\nDescribe the shape of the input shape, output shape, and time of a pandas pipe function.\n\n\n* **Return type**\n\n    `Callable`\n\n\n\n#### diglett.decorate.timeit(func)\nDisplay the time taken to complete a pandas operation and the relative time by input size.\n\n\n* **Return type**\n\n    `Callable`\n\n\n\n#### diglett.decorate.columns_exist(columns)\nVerify that a list of columns exist in the input DataFrame.\n\nThe function being decorated should accept a pandas.DataFrame object as first argument\nand also return a DataFrame object, making it a valid function for the DataFrame.pipe() method.\n\n\n* **Return type**\n\n    `Callable`\n\n\n\n#### diglett.decorate.no_object_dtypes(func)\nVerify that all columns of the output DataFrame have a dtype other than \u2018Object\u2019.\n\nThe function being decorated should accept a pandas.DataFrame object as first argument\nand also return a DataFrame object, making it a valid function for the DataFrame.pipe() method.\n\n\n* **Return type**\n\n    `Callable`\n\n\n\n#### diglett.decorate.no_additional_nulls(func)\nWarn if the number of nulls in a DataFrame has increased during transformation.\n\nThe function being decorated should accept a pandas.DataFrame object as first argument\nand also return a DataFrame object, making it a valid function for the DataFrame.pipe() method.\n\n\n* **Return type**\n\n    `Callable`\n\n\n\n#### diglett.decorate.same_num_rows(func)\nEnsure that a DataFrame transformation function returns the same number of rows as its input.\n\nThe function being decorated should accept a pandas.DataFrame object as first argument\nand also return a DataFrame object, making it a valid function for the DataFrame.pipe() method.\n\n### diglett.display module\n\nSome utility functions related to displaying data nicely in Jupyter Notebooks.\n\n\n#### diglett.display.n_largest_coefs(coefs, n=10)\nReturn the n largest absolute values from a pandas Series\n\n\n* **Return type**\n\n    `Series`\n\n\n\n#### diglett.display.display_side_by_side(\\*args)\nOutput an array of pandas DataFrames side-by-side in a Jupyter notebook to conserve vertical space.\n\n\n* **Return type**\n\n    `None`\n\n\n\n#### diglett.display.print_header_with_lines(text, line_char='-')\nSandwich a given string with an equal length line of separate characters above and below it.\n\n\n* **Return type**\n\n    `None`\n\n\n\n#### diglett.display.display_header(size, text)\nDisplay an HTML header representation of a given string in a given size\n\n\n* **Return type**\n\n    `None`\n\n\n\n### diglett.join module\n\nFunctions for performing joins more easily in pandas.\n\n\n#### diglett.join.verbose_merge(left, right, left_on=None, right_on=None, left_index=False, right_index=False, \\*args, \\*\\*kwargs)\nWraps pd.merge function to provide a visual overview of cardinality between datasets.\n\n\n* **Return type**\n\n    `DataFrame`\n\n\n### diglett.transform module\n\nFunctions related to generating new predictive features on a dataset before fitting an ML model.\n\n\n#### diglett.transform.make_comparison_bools(df, comparisons)\nAssigns a float bool column to DataFrame reflecting whether a value equals another value.\n\nValue is NaN when previous value does not exist.\n\n\n* **Parameters**\n\n    **comparisons** (*dict*) \u2013 Tuples of column names to compare, e.g.: output_column_name: (col_a, col_b)\n\n\n\n* **Return type**\n\n    `DataFrame`\n\n\n\n#### diglett.transform.ordinal_encode_categoricals(X_train, X_test)\nFit an OrdinalEncoder on a combined test/train dataset and return transforms on each individual dataset.\n\n\n* **Return type**\n\n    `Tuple`[`DataFrame`, `DataFrame`]\n\n\n### diglett.visualize module\n\nFunctions for performing visualizations with matplotlib and seaborn.\n\n\n#### diglett.visualize.mpl_boilerplate(shape=(6, 4), left_title=False, y_axis=True, grid=False, legend=True)\nDecorator to perform boilerplate matplotlib formatting.\nTarget plot function must accept fig, ax as first args and also return them.\n\n\n* **Parameters**\n\n\n    * **shape** (`Tuple`[`int`, `int`]) \u2013 size of matplotlib figure (width, height)\n\n\n    * **left_title** (`bool`) \u2013 whether to left-align the title\n\n\n    * **y_axis** (`bool`) \u2013 whether to show the y-axis\n\n\n    * **grid** (`bool`) \u2013 whether to display grid lines\n\n\n    * **legend** (`bool`) \u2013 whether to display legend\n\n\n\n* **Return type**\n\n    `None`\n\n\n#### diglett.visualize.sorted_external_legend(func)\nDisplay a legend on the outer right edge of the figure which is sorted by final value.\n\n\n#### diglett.visualize.display_insight(df, fmt=None, title='', subtitle='', assertion=None)\nDisplay a pandas DataFrame as a presentable display_insight.\n\n\n* **Parameters**\n\n\n    * **df** (`DataFrame`) \u2013 The table to be displayed\n\n\n    * **fmt** (`Optional`[`str`]) \u2013 String representation of formatting to apply to dataframe output (e.g. {:.0%} for percentages )\n\n\n    * **title** (`str`) \u2013 The key takeaway or display_insight from the table\n\n\n    * **subtitle** (`str`) \u2013 A more objective description of the table contents\n\n\n    * **assertion** (`Optional`[`Callable`]) \u2013 A lambda statement to check the validity of the display_insight against the contents of the dataframe\n\n\n\n* **Return type**\n\n    `None`\n\n\n### diglett.wrangle module\n\nFunctions for wrangling a dataset into a tidy format with correct dtypes.\n\n### Examples\n\nYou can infer dtypes for imported data, then apply a bunch of transformations, and finally describe them:\n\n```\ndf = (pd\n      .read_csv('data.csv')\n      .pipe(infer_dtypes, categorical_threshold=0.10)\n      .pipe(fillnas, subset=['category', 'type'])\n      .pipe(drop_nulls, subset=['id', 'ts'])\n      .pipe(drop_infinite)\n      .pipe(bucket_long_tail_categories)\n      .pipe(one_hot_encode_categoricals)\n\ndescribe_dtypes(df)\n```\n\n\n#### diglett.wrangle.infer_dtypes(input_df, categorical_threshold=0.01)\nAttempt to coerce dtypes to be numerical, datetime, or categorical rather than object.\n\n\n* **Parameters**\n\n\n    * **input_df** (`DataFrame`) \u2013 The DataFrame object whose dtypes are being inferred.\n\n\n    * **categorical_threshold** (`float`) \u2013 The level of normalized cardinality below which to consider a field catagorical.\n\n\n\n* **Return type**\n\n    `DataFrame`\n\n\n\n* **Returns**\n\n    DataFrame of same dimensions as input, but with modified column dtypes.\n\n\n\n#### diglett.wrangle.describe_dtypes(input_df, top_n_cats=10)\nA more comprehensive overview of your data, inspired by pd.DataFrame.describe()\n\nSplits output by dtype to provide a more relevant summary of each, including number and pct of null values.\n\n\n* **Parameters**\n\n\n    * **input_df** (`DataFrame`) \u2013 The dataframe to be desribed.\n\n\n    * **top_n_cats** (`int`) \u2013 The number of most frequent values to include in summary of categorical columns.\n\n\n\n* **Return type**\n\n    `None`\n\n\n\n#### diglett.wrangle.fillnas(input_df, subset=None)\nFills nulls in selected columns from a DataFrame then returns input in a DataFrame.pipe() compatible way.\n\n\n* **Return type**\n\n    `DataFrame`\n\n\n\n#### diglett.wrangle.drop_nulls(input_df, subset=None)\nDrops nulls in selected columns from a DataFrame then returns input in a DataFrame.pipe() compatible way.\n\n\n* **Return type**\n\n    `DataFrame`\n\n\n\n#### diglett.wrangle.drop_infinite(input_df, subset=None)\nDrops infinite values in selected columns then returns df in a DataFrame.pipe() compatible way.\n\n\n* **Return type**\n\n    `DataFrame`\n\n\n\n#### diglett.wrangle.categorical_fillna(df)\nHard-codes null values as strings, necessary for CatBoost.\n\n\n* **Return type**\n\n    `DataFrame`\n\n\n\n#### diglett.wrangle.bucket_long_tail_categories(input_df, other_after=100)\nReplace long-tail values in each column with \u2018Other\u2019 to reduce cardinality.\n\n\n* **Parameters**\n\n\n    * **input_df** (`DataFrame`) \u2013 The entire DataFrame to operate on.\n\n\n    * **other_after** (`int`) \u2013 The index after which to bucket long-tail values into \u2018other\u2019\n\n\n\n* **Return type**\n\n    `DataFrame`\n\n\n\n#### diglett.wrangle.one_hot_encode_categoricals(input_df)\nAutomatically split any categorical columns into boolean columns for each value.\n\n\n* **Parameters**\n\n    **input_df** (`DataFrame`) \u2013 The entire DataFrame to operate on.\n\n\n\n* **Returns**\n\n    Output dataframe\n    dict: Categorical mappings (useful for inverse transform during feature importance measurement)\n\n\n\n* **Return type**\n\n    pd.DataFrame\n\n\n\n#### diglett.wrangle.cast_bools_to_float(df)\nHard-codes booleans as floats, necessary for CatBoost.\n\n\n* **Return type**\n\n    `DataFrame`\n\n\n## Running the tests\n\nTODO\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/asdfgeoff/diglett", "keywords": "", "license": "MIT", "maintainer": "", "maintainer_email": "", "name": "diglett", "package_url": "https://pypi.org/project/diglett/", "platform": "", "project_url": "https://pypi.org/project/diglett/", "project_urls": {"Homepage": "https://github.com/asdfgeoff/diglett"}, "release_url": "https://pypi.org/project/diglett/0.1.0/", "requires_dist": ["pandas", "numpy", "matplotlib", "seaborn", "scikit-learn", "IPython"], "requires_python": ">=3.6.0", "summary": "Useful python functions for digging through new datasets", "version": "0.1.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>Diglett</h1>\n<p><img alt=\"Image of Diglett pokemon\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/1883c14458eda1ab5c65a3c4efc8ff80172e1390/68747470733a2f2f7261772e67697468756275736572636f6e74656e742e636f6d2f6173646667656f66662f6469676c6574742f6d61737465722f6469676c6574742e706e67\"></p>\n<h2>What it does</h2>\n<p>Diglett is a collection of my most frequently used and reusable functions for data analysis, data wrangling, and machine learning. I have largely packaged them together for my own benefit, but I hope you will find something useful in here for yourself.</p>\n<h2>Installing</h2>\n<p>You can install this package via pip:</p>\n<pre><code>pip install diglett\n</code></pre>\n<h2>API documentation</h2>\n<h3>diglett.decorate module</h3>\n<p>Useful decorators for troubleshooting data transformation pipelines and asserting assumptions.</p>\n<p>Inspired by Tom Augspurger\u2019s package engarde: <a href=\"https://github.com/engarde-dev/engarde\" rel=\"nofollow\">https://github.com/engarde-dev/engarde</a></p>\n<h4>diglett.decorate.describe_io(func)</h4>\n<p>Describe the shape of the input shape, output shape, and time of a pandas pipe function.</p>\n<ul>\n<li>\n<p><strong>Return type</strong></p>\n<p><code>Callable</code></p>\n</li>\n</ul>\n<h4>diglett.decorate.timeit(func)</h4>\n<p>Display the time taken to complete a pandas operation and the relative time by input size.</p>\n<ul>\n<li>\n<p><strong>Return type</strong></p>\n<p><code>Callable</code></p>\n</li>\n</ul>\n<h4>diglett.decorate.columns_exist(columns)</h4>\n<p>Verify that a list of columns exist in the input DataFrame.</p>\n<p>The function being decorated should accept a pandas.DataFrame object as first argument\nand also return a DataFrame object, making it a valid function for the DataFrame.pipe() method.</p>\n<ul>\n<li>\n<p><strong>Return type</strong></p>\n<p><code>Callable</code></p>\n</li>\n</ul>\n<h4>diglett.decorate.no_object_dtypes(func)</h4>\n<p>Verify that all columns of the output DataFrame have a dtype other than \u2018Object\u2019.</p>\n<p>The function being decorated should accept a pandas.DataFrame object as first argument\nand also return a DataFrame object, making it a valid function for the DataFrame.pipe() method.</p>\n<ul>\n<li>\n<p><strong>Return type</strong></p>\n<p><code>Callable</code></p>\n</li>\n</ul>\n<h4>diglett.decorate.no_additional_nulls(func)</h4>\n<p>Warn if the number of nulls in a DataFrame has increased during transformation.</p>\n<p>The function being decorated should accept a pandas.DataFrame object as first argument\nand also return a DataFrame object, making it a valid function for the DataFrame.pipe() method.</p>\n<ul>\n<li>\n<p><strong>Return type</strong></p>\n<p><code>Callable</code></p>\n</li>\n</ul>\n<h4>diglett.decorate.same_num_rows(func)</h4>\n<p>Ensure that a DataFrame transformation function returns the same number of rows as its input.</p>\n<p>The function being decorated should accept a pandas.DataFrame object as first argument\nand also return a DataFrame object, making it a valid function for the DataFrame.pipe() method.</p>\n<h3>diglett.display module</h3>\n<p>Some utility functions related to displaying data nicely in Jupyter Notebooks.</p>\n<h4>diglett.display.n_largest_coefs(coefs, n=10)</h4>\n<p>Return the n largest absolute values from a pandas Series</p>\n<ul>\n<li>\n<p><strong>Return type</strong></p>\n<p><code>Series</code></p>\n</li>\n</ul>\n<h4>diglett.display.display_side_by_side(*args)</h4>\n<p>Output an array of pandas DataFrames side-by-side in a Jupyter notebook to conserve vertical space.</p>\n<ul>\n<li>\n<p><strong>Return type</strong></p>\n<p><code>None</code></p>\n</li>\n</ul>\n<h4>diglett.display.print_header_with_lines(text, line_char='-')</h4>\n<p>Sandwich a given string with an equal length line of separate characters above and below it.</p>\n<ul>\n<li>\n<p><strong>Return type</strong></p>\n<p><code>None</code></p>\n</li>\n</ul>\n<h4>diglett.display.display_header(size, text)</h4>\n<p>Display an HTML header representation of a given string in a given size</p>\n<ul>\n<li>\n<p><strong>Return type</strong></p>\n<p><code>None</code></p>\n</li>\n</ul>\n<h3>diglett.join module</h3>\n<p>Functions for performing joins more easily in pandas.</p>\n<h4>diglett.join.verbose_merge(left, right, left_on=None, right_on=None, left_index=False, right_index=False, *args, **kwargs)</h4>\n<p>Wraps pd.merge function to provide a visual overview of cardinality between datasets.</p>\n<ul>\n<li>\n<p><strong>Return type</strong></p>\n<p><code>DataFrame</code></p>\n</li>\n</ul>\n<h3>diglett.transform module</h3>\n<p>Functions related to generating new predictive features on a dataset before fitting an ML model.</p>\n<h4>diglett.transform.make_comparison_bools(df, comparisons)</h4>\n<p>Assigns a float bool column to DataFrame reflecting whether a value equals another value.</p>\n<p>Value is NaN when previous value does not exist.</p>\n<ul>\n<li>\n<p><strong>Parameters</strong></p>\n<p><strong>comparisons</strong> (<em>dict</em>) \u2013 Tuples of column names to compare, e.g.: output_column_name: (col_a, col_b)</p>\n</li>\n<li>\n<p><strong>Return type</strong></p>\n<p><code>DataFrame</code></p>\n</li>\n</ul>\n<h4>diglett.transform.ordinal_encode_categoricals(X_train, X_test)</h4>\n<p>Fit an OrdinalEncoder on a combined test/train dataset and return transforms on each individual dataset.</p>\n<ul>\n<li>\n<p><strong>Return type</strong></p>\n<p><code>Tuple</code>[<code>DataFrame</code>, <code>DataFrame</code>]</p>\n</li>\n</ul>\n<h3>diglett.visualize module</h3>\n<p>Functions for performing visualizations with matplotlib and seaborn.</p>\n<h4>diglett.visualize.mpl_boilerplate(shape=(6, 4), left_title=False, y_axis=True, grid=False, legend=True)</h4>\n<p>Decorator to perform boilerplate matplotlib formatting.\nTarget plot function must accept fig, ax as first args and also return them.</p>\n<ul>\n<li>\n<p><strong>Parameters</strong></p>\n<ul>\n<li>\n<p><strong>shape</strong> (<code>Tuple</code>[<code>int</code>, <code>int</code>]) \u2013 size of matplotlib figure (width, height)</p>\n</li>\n<li>\n<p><strong>left_title</strong> (<code>bool</code>) \u2013 whether to left-align the title</p>\n</li>\n<li>\n<p><strong>y_axis</strong> (<code>bool</code>) \u2013 whether to show the y-axis</p>\n</li>\n<li>\n<p><strong>grid</strong> (<code>bool</code>) \u2013 whether to display grid lines</p>\n</li>\n<li>\n<p><strong>legend</strong> (<code>bool</code>) \u2013 whether to display legend</p>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>Return type</strong></p>\n<p><code>None</code></p>\n</li>\n</ul>\n<h4>diglett.visualize.sorted_external_legend(func)</h4>\n<p>Display a legend on the outer right edge of the figure which is sorted by final value.</p>\n<h4>diglett.visualize.display_insight(df, fmt=None, title='', subtitle='', assertion=None)</h4>\n<p>Display a pandas DataFrame as a presentable display_insight.</p>\n<ul>\n<li>\n<p><strong>Parameters</strong></p>\n<ul>\n<li>\n<p><strong>df</strong> (<code>DataFrame</code>) \u2013 The table to be displayed</p>\n</li>\n<li>\n<p><strong>fmt</strong> (<code>Optional</code>[<code>str</code>]) \u2013 String representation of formatting to apply to dataframe output (e.g. {:.0%} for percentages )</p>\n</li>\n<li>\n<p><strong>title</strong> (<code>str</code>) \u2013 The key takeaway or display_insight from the table</p>\n</li>\n<li>\n<p><strong>subtitle</strong> (<code>str</code>) \u2013 A more objective description of the table contents</p>\n</li>\n<li>\n<p><strong>assertion</strong> (<code>Optional</code>[<code>Callable</code>]) \u2013 A lambda statement to check the validity of the display_insight against the contents of the dataframe</p>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>Return type</strong></p>\n<p><code>None</code></p>\n</li>\n</ul>\n<h3>diglett.wrangle module</h3>\n<p>Functions for wrangling a dataset into a tidy format with correct dtypes.</p>\n<h3>Examples</h3>\n<p>You can infer dtypes for imported data, then apply a bunch of transformations, and finally describe them:</p>\n<pre><code>df = (pd\n      .read_csv('data.csv')\n      .pipe(infer_dtypes, categorical_threshold=0.10)\n      .pipe(fillnas, subset=['category', 'type'])\n      .pipe(drop_nulls, subset=['id', 'ts'])\n      .pipe(drop_infinite)\n      .pipe(bucket_long_tail_categories)\n      .pipe(one_hot_encode_categoricals)\n\ndescribe_dtypes(df)\n</code></pre>\n<h4>diglett.wrangle.infer_dtypes(input_df, categorical_threshold=0.01)</h4>\n<p>Attempt to coerce dtypes to be numerical, datetime, or categorical rather than object.</p>\n<ul>\n<li>\n<p><strong>Parameters</strong></p>\n<ul>\n<li>\n<p><strong>input_df</strong> (<code>DataFrame</code>) \u2013 The DataFrame object whose dtypes are being inferred.</p>\n</li>\n<li>\n<p><strong>categorical_threshold</strong> (<code>float</code>) \u2013 The level of normalized cardinality below which to consider a field catagorical.</p>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>Return type</strong></p>\n<p><code>DataFrame</code></p>\n</li>\n<li>\n<p><strong>Returns</strong></p>\n<p>DataFrame of same dimensions as input, but with modified column dtypes.</p>\n</li>\n</ul>\n<h4>diglett.wrangle.describe_dtypes(input_df, top_n_cats=10)</h4>\n<p>A more comprehensive overview of your data, inspired by pd.DataFrame.describe()</p>\n<p>Splits output by dtype to provide a more relevant summary of each, including number and pct of null values.</p>\n<ul>\n<li>\n<p><strong>Parameters</strong></p>\n<ul>\n<li>\n<p><strong>input_df</strong> (<code>DataFrame</code>) \u2013 The dataframe to be desribed.</p>\n</li>\n<li>\n<p><strong>top_n_cats</strong> (<code>int</code>) \u2013 The number of most frequent values to include in summary of categorical columns.</p>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>Return type</strong></p>\n<p><code>None</code></p>\n</li>\n</ul>\n<h4>diglett.wrangle.fillnas(input_df, subset=None)</h4>\n<p>Fills nulls in selected columns from a DataFrame then returns input in a DataFrame.pipe() compatible way.</p>\n<ul>\n<li>\n<p><strong>Return type</strong></p>\n<p><code>DataFrame</code></p>\n</li>\n</ul>\n<h4>diglett.wrangle.drop_nulls(input_df, subset=None)</h4>\n<p>Drops nulls in selected columns from a DataFrame then returns input in a DataFrame.pipe() compatible way.</p>\n<ul>\n<li>\n<p><strong>Return type</strong></p>\n<p><code>DataFrame</code></p>\n</li>\n</ul>\n<h4>diglett.wrangle.drop_infinite(input_df, subset=None)</h4>\n<p>Drops infinite values in selected columns then returns df in a DataFrame.pipe() compatible way.</p>\n<ul>\n<li>\n<p><strong>Return type</strong></p>\n<p><code>DataFrame</code></p>\n</li>\n</ul>\n<h4>diglett.wrangle.categorical_fillna(df)</h4>\n<p>Hard-codes null values as strings, necessary for CatBoost.</p>\n<ul>\n<li>\n<p><strong>Return type</strong></p>\n<p><code>DataFrame</code></p>\n</li>\n</ul>\n<h4>diglett.wrangle.bucket_long_tail_categories(input_df, other_after=100)</h4>\n<p>Replace long-tail values in each column with \u2018Other\u2019 to reduce cardinality.</p>\n<ul>\n<li>\n<p><strong>Parameters</strong></p>\n<ul>\n<li>\n<p><strong>input_df</strong> (<code>DataFrame</code>) \u2013 The entire DataFrame to operate on.</p>\n</li>\n<li>\n<p><strong>other_after</strong> (<code>int</code>) \u2013 The index after which to bucket long-tail values into \u2018other\u2019</p>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>Return type</strong></p>\n<p><code>DataFrame</code></p>\n</li>\n</ul>\n<h4>diglett.wrangle.one_hot_encode_categoricals(input_df)</h4>\n<p>Automatically split any categorical columns into boolean columns for each value.</p>\n<ul>\n<li>\n<p><strong>Parameters</strong></p>\n<p><strong>input_df</strong> (<code>DataFrame</code>) \u2013 The entire DataFrame to operate on.</p>\n</li>\n<li>\n<p><strong>Returns</strong></p>\n<p>Output dataframe\ndict: Categorical mappings (useful for inverse transform during feature importance measurement)</p>\n</li>\n<li>\n<p><strong>Return type</strong></p>\n<p>pd.DataFrame</p>\n</li>\n</ul>\n<h4>diglett.wrangle.cast_bools_to_float(df)</h4>\n<p>Hard-codes booleans as floats, necessary for CatBoost.</p>\n<ul>\n<li>\n<p><strong>Return type</strong></p>\n<p><code>DataFrame</code></p>\n</li>\n</ul>\n<h2>Running the tests</h2>\n<p>TODO</p>\n\n          </div>"}, "last_serial": 6340272, "releases": {"0.1.0": [{"comment_text": "", "digests": {"md5": "d2d0af7bce37ebbf8f7ec68fc0d1165e", "sha256": "cd5ea0b80798f1d4bbb7c3bc37b8f3a1bb4c19a7b0c90510f31e563f5ab46702"}, "downloads": -1, "filename": "diglett-0.1.0-py3-none-any.whl", "has_sig": false, "md5_digest": "d2d0af7bce37ebbf8f7ec68fc0d1165e", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6.0", "size": 14007, "upload_time": "2019-12-20T17:16:18", "upload_time_iso_8601": "2019-12-20T17:16:18.628867Z", "url": "https://files.pythonhosted.org/packages/63/2f/d836968021b24580ebc714fa53c6834b8b3880f07734dc48c21a7639fbcb/diglett-0.1.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "7e58d943e99f503b9401d5b1e154cc1d", "sha256": "1678afe0fe90937c99aa8ebc3d953a554a7468056c832691ecc4628c80a3d5ea"}, "downloads": -1, "filename": "diglett-0.1.0.tar.gz", "has_sig": false, "md5_digest": "7e58d943e99f503b9401d5b1e154cc1d", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6.0", "size": 10194, "upload_time": "2019-12-20T17:16:51", "upload_time_iso_8601": "2019-12-20T17:16:51.899490Z", "url": "https://files.pythonhosted.org/packages/c6/41/3452f9d05dab9d5347c6cc6ad6a6d35509133ff9ebafe9da8f6861e400d2/diglett-0.1.0.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "d2d0af7bce37ebbf8f7ec68fc0d1165e", "sha256": "cd5ea0b80798f1d4bbb7c3bc37b8f3a1bb4c19a7b0c90510f31e563f5ab46702"}, "downloads": -1, "filename": "diglett-0.1.0-py3-none-any.whl", "has_sig": false, "md5_digest": "d2d0af7bce37ebbf8f7ec68fc0d1165e", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6.0", "size": 14007, "upload_time": "2019-12-20T17:16:18", "upload_time_iso_8601": "2019-12-20T17:16:18.628867Z", "url": "https://files.pythonhosted.org/packages/63/2f/d836968021b24580ebc714fa53c6834b8b3880f07734dc48c21a7639fbcb/diglett-0.1.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "7e58d943e99f503b9401d5b1e154cc1d", "sha256": "1678afe0fe90937c99aa8ebc3d953a554a7468056c832691ecc4628c80a3d5ea"}, "downloads": -1, "filename": "diglett-0.1.0.tar.gz", "has_sig": false, "md5_digest": "7e58d943e99f503b9401d5b1e154cc1d", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6.0", "size": 10194, "upload_time": "2019-12-20T17:16:51", "upload_time_iso_8601": "2019-12-20T17:16:51.899490Z", "url": "https://files.pythonhosted.org/packages/c6/41/3452f9d05dab9d5347c6cc6ad6a6d35509133ff9ebafe9da8f6861e400d2/diglett-0.1.0.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:38:24 2020"}