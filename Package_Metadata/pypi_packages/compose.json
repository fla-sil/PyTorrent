{"info": {"author": "Alexander Kozhevnikov", "author_email": "mentalisttraceur@gmail.com", "bugtrack_url": null, "classifiers": ["Development Status :: 5 - Production/Stable", "Operating System :: OS Independent", "Programming Language :: Python :: 2", "Programming Language :: Python :: 2.3", "Programming Language :: Python :: 2.4", "Programming Language :: Python :: 2.5", "Programming Language :: Python :: 2.6", "Programming Language :: Python :: 2.7", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.2", "Programming Language :: Python :: 3.3", "Programming Language :: Python :: 3.4", "Programming Language :: Python :: 3.5", "Programming Language :: Python :: 3.6", "Programming Language :: Python :: 3.7", "Programming Language :: Python :: 3.8", "Programming Language :: Python :: Implementation :: CPython", "Programming Language :: Python :: Implementation :: IronPython", "Programming Language :: Python :: Implementation :: Jython", "Programming Language :: Python :: Implementation :: PyPy", "Programming Language :: Python :: Implementation :: Stackless"], "description": "compose\n=======\n\nThe classic ``compose``, with all the Pythonic features.\n\nThis ``compose`` follows the lead of ``functools.partial``\nand returns callable ``compose`` objects which:\n\n* have a regular and unambiguous ``repr``,\n* retain correct signature introspection,\n* allow introspection of the composed callables,\n* can be type-checked,\n* can be weakly referenced,\n* can have attributes,\n* will merge when nested, and\n* can be pickled (if all composed callables can be pickled).\n\nThis ``compose`` also fails fast with a ``TypeError`` if any\nargument is not callable, or when called with no arguments.\n\n\nVersioning\n----------\n\nThis library's version numbers follow the `SemVer 2.0.0 specification\n<https://semver.org/spec/v2.0.0.html>`_.\n\nThe current version number is available in the variable ``__version__``,\nas is normal for Python modules.\n\n\nInstallation\n------------\n\n::\n\n    pip install compose\n\n\nUsage\n-----\n\nImport ``compose``:\n\n.. code:: python\n\n    from compose import compose\n\nAll the usual function composition you know and love:\n\n.. code:: python\n\n    >>> def double(x):\n    ...     return x * 2\n    ...\n    >>> def increment(x):\n    ...     return x + 1\n    ...\n    >>> double_then_increment = compose(increment, double)\n    >>> double_then_increment(1)\n    3\n\nOf course any number of functions can be composed:\n\n.. code:: python\n\n    >>> def double(x):\n    ...     return x * 2\n    ...\n    >>> times_eight = compose(douple, double, double)\n    >>> times_16 = compose(douple, double, double, double)\n\nWe still get the correct signature introspection:\n\n.. code:: python\n\n    >>> def f(a, b, c=0, **kwargs):\n    ...     pass\n    ...\n    >>> def g(x):\n    ...     pass\n    ...\n    >>> g_of_f = compose(g, f)\n    >>> import inspect\n    >>> inspect.signature(g_of_f)\n    <Signature (a, b, c=0, **kwargs)>\n\nAnd we can inspect all the composed callables:\n\n.. code:: python\n\n    >>> g_of_f.functions  # in order of execution:\n    (<function f at 0x4048e6f0>, <function g at 0x405228e8>)\n\nWhen programmatically inspecting arbitrary callables, we\ncan check if we are looking at a ``compose`` instance:\n\n.. code:: python\n\n    >>> isinstance(g_of_f, compose)\n    True\n\n\nDesign Decisions\n----------------\n\n* The result of ``compose`` should be a drop-in replacement to\n  functions in as many code paths as possible. Therefore:\n\n  * The proper signature of the composed function is exposed\n    in the standard Python way (by exposing the \"inner-most\"\n    function as the attribute ``__wrapped__``).\n\n  * Arbitrary attribute assignment (``__dict__``) should work,\n    because Python allows people to do that to functions.\n\n  * Weak references (``__weakref__``) are supported,\n    because Python allows weakly referencing functions.\n\n* Failing-fast as much as possible because that is important\n  to help debugging by keeping errors local to their causes.\n\n* Treating ``compose()`` with no arguments as an error, instead\n  of as implicitly composing with an identity function, because:\n\n  * It avoids turning mistakes into silent misbehavior by default.\n\n  * People who want the other behavior can more trivially build\n    it on top of this behavior than the other way around:\n\n    .. code:: python\n\n        compose = partial(compose, identity)\n\n* Doing ``__init__(self, *functions)`` instead of\n  ``__init__(self, function, *functions)`` because:\n\n  * It makes the signature and docstring more correctly hint that the\n    first function argument is not special or different from the rest.\n\n  * It allows manually raising an error with a clearer and more\n    helpful message if ``compose()`` is called with no arguments.\n\n* Using ``functools.recursive_repr`` if available because if recursion\n  happens, having a working and recursion-safe ``__repr__`` would\n  likely be extremely helpful for debugging and code robustness.\n\n  Not going beyond that because the code involved would be complex and\n  not portable across Python implementations, and the right place to\n  solve that is a separate polyfil if at all possible.\n\n* ``self`` has to be a positional-only argument of ``__call__``\n  to make ``__call__`` properly transparent in all cases.\n\n  If the user makes a typo, ``**``-splats arguments, or otherwise\n  ends up passing ``self`` in ``kwargs``, maybe even intentionally,\n  function composition should still work correctly - in this case,\n  silent seemingly-successful unintended misbehavior would be awful.\n\n  If the user uses ``compose`` to implement methods, the ``self``\n  argument to that method going through ``compose`` will normally\n  be a positional argument, but ideally should be passed through\n  transparently even if not, to match how normal methods work.\n\n* Manually getting ``self`` from ``*args`` in ``__call__``\n  **portably** makes ``self`` a positional-only argument.\n\n* Optimization priorities are:\n\n  1. \"Optimize for optimization\": implementing the essential logic\n     of the intended behavior in as clearly and simply as possible,\n     because that helps optimizers.\n\n  2. ``__call__``, because that is the code path which can only be\n     extracted from hot loops or other spots where performance\n     matters by not using ``compose`` at all.\n\n  3. ``__init__``, because composing callables together is also\n     essential to actually using this, and in some cases cannot\n     be pulled out of performance-sensitive code paths.\n\n  4. Not storing data redundantly, because memory-constrained\n     systems are a thing, and it is much easier to add redundant\n     data on top of an implementation than it is to remove it.\n\n* Flattening nested instances of ``compose`` because\n\n  * It makes the repr much more helpful for debugging and\n    interactive usage. It is more common to want to know\n    what the actual composed callable does, than to know\n    the tree of nested ``compose`` calls that created it.\n\n  * ``__call__`` performance is more important in typical cases\n    than runspace efficiency (see above performance priorities).\n\n  * Intermediate composed functions that are never used\n    after composing them with something else can just\n    be deleted so that they don't take up memory.\n\n  * It is more trivial to prevent the flattening by using a\n    simple wrapper function or class on this implementation\n    than flattening on top of a not-flattening one.\n\n* Using tuples and a read-only ``@property`` for storing\n  and exposing the composed functions because:\n\n  * Immutability helps reasoning about and validating code.\n\n  * Immutable types provide more optimisation opportunities\n    that a Python implementation could take advantage of.\n\n  * Discouraging mutations encourages optimizer-friendly code.\n\n  * Mutability is normally not needed for composed functions.\n\n  * ``functools.partial`` also only exposes read-only attributes.\n\n  * Immutability now is forward-compatible with mutability later;\n    changing mutability into immutability is a breaking change.\n\n  * A simple mutable variant can be implemented trivially\n    on top of the current immutable ``compose``:\n\n    .. code:: python\n\n        class compose(compose):\n            def __init__(self, *functions):\n                super().__init__(*functions)\n                self._wrappers = list(self._wrappers)\n\n* Generating the ``functions`` attribute tuple every time instead\n  of caching it, because:\n\n  * This implementation prevents *accidental* inconsistencies\n    if someone intentionally bypasses the immutability.\n\n    (Intentional inconsistencies that can only be introduced *by\n    deliberately modifying the implementation* are fine. What's\n    important is minimizing the surface area for errors and\n    debugging difficulty being introduced by merely *forgetting*\n    or *not realizing* the need to keep things consistent.)\n\n  * The performance priority of not storing data redundantly as\n    part of composing and calling is usually more important\n    than introspection performance, *especially* because the\n    caching can be implemented much more trivially on top of\n    this implementation than preventing caching would be if\n    it was implemented in ``compose``.\n\n  * A caching variant can be implemented fairly easily\n    on top of the current non-caching ``compose``:\n\n    .. code:: python\n\n        import functools\n\n        class compose(compose):\n            @property\n            @functools.lru_cache(maxsize=1)\n            def functions(self):\n                return super().functions\n\n* Storing the first function separately from the rest allows\n  ``__call__`` to be more efficient, simpler, and clearer.\n\n* ``__wrapped__`` cannot be a ``@property`` because several\n  functions in the standard library cannot handle that.\n\n  As a minor point, \"portability conservatism\": it is safer\n  to bet on the most conservative feature-set possible.\n\n* Not using ``__slots__`` because of many reasons adding up:\n\n  * ``__call__`` performance is basically the same, at best\n    only marginally better, when using ``__slots__``.\n\n    (``__init__`` sees a better but still small improvement.)\n\n    On PyPy, ``__call__`` ends up getting optimized to the\n    same blazingly performant code with or without\n    ``__slots__`` - makes no difference. On CPython, the\n    no-``__slots__`` variant actually performs better once\n    ``__wrapped__`` is supported (see below).\n\n  * ``__slots__`` forces more code to support older\n    pickle protocols for those who might need that.\n\n    (But one-liner ``__getstate__`` and ``__setstate__`` that\n    just handle the 3-tuple of ``_wrapped``, ``_wrappers``,\n    and ``__dict__`` would work, and are probably optimal.)\n\n  * ``__wrapped__`` cannot be in ``__slots__`` because that has\n    the same problem as making it a ``@property`` (see above).\n\n  * ``__wrapped__`` can be implemented with ``__getattribute__``\n    redirecting to a slotted ``_wrapped``, but implementing the\n    ``__getattribute__`` function is much slower than just not\n    using ``__slots__`` at all, since it proxies all attribute\n    access.\n\n  * ``__wrapped__`` can be implemented with ``__getattr__``\n    redirecting to a slotted ``_wrapped``, although once\n    upon a type Transcrypt didn't support ``__getattr__``,\n    which is a great example for portability conservatism.\n\n    Moreover, testing shows that adding ``__getattr__`` to\n    a class still makes the whole slotted implementation\n    slower somehow (merely removing ``__getattr__`` from\n    the class definition makes tests which never use\n    ``__getattr__`` go faster, although there is no\n    reason at the level of Python semantics for why this\n    should be the case). Once PyPy warms up, this is\n    negligible, and on CPython it is relatively minor,\n    but it is still strictly worse on most systems tested.\n\n  * ``__wrapped__`` can be just a *copy* of a slotted attribute,\n    but the same reasons apply against this as against making\n    ``functions`` a cached copy.\n\n  * If ``__wrapped__`` is stored in ``__dict__`` and is always\n    set in ``__init__``, a lot of the memory savings from\n    using ``__slots__`` are negated too.\n\n* When flattening composed ``compose`` instances in ``__init__``,\n  ``__wrapped__`` and ``_wrapped`` attributes are used instead\n  of the ``functions`` attribute, because:\n\n  * Speed of composition significantly increases, given\n    that ``functions`` is generated every time.\n\n  * The loss of symmetry between this and the public interface\n    of the ``functions`` attribute is unfortunate, because it\n    forces any subclasses to use ``_wrappers`` consistently\n    with ``compose`` instead of just ``functions``, but the\n    advantage seems to be worthwhile.\n\n* The ``functions`` generation uses ``tuple(self._wrappers)``\n  instead of just ``self._wrappers`` to enable subclasses\n  that make ``_wrappers`` something other than a tuple to\n  still work properly.\n\n  A subclass which wants ``functions`` itself to be something\n  other than a tuple would need to provide that themselves,\n  but this should cover at least some cases.\n\n  Importantly, because tuples are immutable, calling ``tuple``\n  on a tuple just returns the same tuple instead of copying in\n  CPython, and other Pythons can do that optimization too.\n\n* Not providing a separate ``rcompose`` (which would compose\n  its arguments in reverse order) for now, because it is\n  trivial to implement on top of ``compose`` if needed:\n\n  .. code:: python\n\n      def rcompose(*functions):\n          return compose(*reversed(functions))\n\n* Not providing a separate \"just a normal function\" variant for now,\n  because it is trivial to implement on top of ``compose`` if needed:\n\n  .. code:: python\n\n      def fcompose(*functions):\n          composed = compose(*functions)\n          return lambda *args, **kwargs: composed(*args, **kwargs)\n\n* Not providing descriptor support like ``functools.partialmethod``\n  for now, until a need for it becomes apparent which a \"normal\n  function\" variant (see last point) does not satisfy well enough.\n\n* Not providing an ``async``/``await`` variant for now, because\n  it is not yet clear if it is useful enough or if the best\n  place for it is this package, and in the meantime it can be\n  implemented on top of ``compose`` if needed:\n\n  .. code:: python\n\n      import inspect\n\n      class acompose(compose):\n          async def __call__(self, /, *args, **kwargs):\n              result = self.__wrapped__(*args, **kwargs)\n              if inspect.isawaitable(result):\n                  result = await result\n              for function in self._wrappers:\n                  result = function(result)\n                  if inspect.isawaitable(result):\n                      result = await result\n              return result\n\n\n", "description_content_type": "", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/mentalisttraceur/python-compose", "keywords": "", "license": "0BSD (BSD Zero Clause License)", "maintainer": "", "maintainer_email": "", "name": "compose", "package_url": "https://pypi.org/project/compose/", "platform": "", "project_url": "https://pypi.org/project/compose/", "project_urls": {"Homepage": "https://github.com/mentalisttraceur/python-compose"}, "release_url": "https://pypi.org/project/compose/1.1.1/", "requires_dist": null, "requires_python": "", "summary": "The classic ``compose``, with all the Pythonic features.", "version": "1.1.1", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p>The classic <tt>compose</tt>, with all the Pythonic features.</p>\n<p>This <tt>compose</tt> follows the lead of <tt>functools.partial</tt>\nand returns callable <tt>compose</tt> objects which:</p>\n<ul>\n<li>have a regular and unambiguous <tt>repr</tt>,</li>\n<li>retain correct signature introspection,</li>\n<li>allow introspection of the composed callables,</li>\n<li>can be type-checked,</li>\n<li>can be weakly referenced,</li>\n<li>can have attributes,</li>\n<li>will merge when nested, and</li>\n<li>can be pickled (if all composed callables can be pickled).</li>\n</ul>\n<p>This <tt>compose</tt> also fails fast with a <tt>TypeError</tt> if any\nargument is not callable, or when called with no arguments.</p>\n<div id=\"versioning\">\n<h2>Versioning</h2>\n<p>This library\u2019s version numbers follow the <a href=\"https://semver.org/spec/v2.0.0.html\" rel=\"nofollow\">SemVer 2.0.0 specification</a>.</p>\n<p>The current version number is available in the variable <tt>__version__</tt>,\nas is normal for Python modules.</p>\n</div>\n<div id=\"installation\">\n<h2>Installation</h2>\n<pre>pip install compose\n</pre>\n</div>\n<div id=\"usage\">\n<h2>Usage</h2>\n<p>Import <tt>compose</tt>:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">compose</span> <span class=\"kn\">import</span> <span class=\"n\">compose</span>\n</pre>\n<p>All the usual function composition you know and love:</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"k\">def</span> <span class=\"nf\">double</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">):</span>\n<span class=\"o\">...</span>     <span class=\"k\">return</span> <span class=\"n\">x</span> <span class=\"o\">*</span> <span class=\"mi\">2</span>\n<span class=\"o\">...</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"k\">def</span> <span class=\"nf\">increment</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">):</span>\n<span class=\"o\">...</span>     <span class=\"k\">return</span> <span class=\"n\">x</span> <span class=\"o\">+</span> <span class=\"mi\">1</span>\n<span class=\"o\">...</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">double_then_increment</span> <span class=\"o\">=</span> <span class=\"n\">compose</span><span class=\"p\">(</span><span class=\"n\">increment</span><span class=\"p\">,</span> <span class=\"n\">double</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">double_then_increment</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n<span class=\"mi\">3</span>\n</pre>\n<p>Of course any number of functions can be composed:</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"k\">def</span> <span class=\"nf\">double</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">):</span>\n<span class=\"o\">...</span>     <span class=\"k\">return</span> <span class=\"n\">x</span> <span class=\"o\">*</span> <span class=\"mi\">2</span>\n<span class=\"o\">...</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">times_eight</span> <span class=\"o\">=</span> <span class=\"n\">compose</span><span class=\"p\">(</span><span class=\"n\">douple</span><span class=\"p\">,</span> <span class=\"n\">double</span><span class=\"p\">,</span> <span class=\"n\">double</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">times_16</span> <span class=\"o\">=</span> <span class=\"n\">compose</span><span class=\"p\">(</span><span class=\"n\">douple</span><span class=\"p\">,</span> <span class=\"n\">double</span><span class=\"p\">,</span> <span class=\"n\">double</span><span class=\"p\">,</span> <span class=\"n\">double</span><span class=\"p\">)</span>\n</pre>\n<p>We still get the correct signature introspection:</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"k\">def</span> <span class=\"nf\">f</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">b</span><span class=\"p\">,</span> <span class=\"n\">c</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">):</span>\n<span class=\"o\">...</span>     <span class=\"k\">pass</span>\n<span class=\"o\">...</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"k\">def</span> <span class=\"nf\">g</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">):</span>\n<span class=\"o\">...</span>     <span class=\"k\">pass</span>\n<span class=\"o\">...</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">g_of_f</span> <span class=\"o\">=</span> <span class=\"n\">compose</span><span class=\"p\">(</span><span class=\"n\">g</span><span class=\"p\">,</span> <span class=\"n\">f</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">import</span> <span class=\"nn\">inspect</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">inspect</span><span class=\"o\">.</span><span class=\"n\">signature</span><span class=\"p\">(</span><span class=\"n\">g_of_f</span><span class=\"p\">)</span>\n<span class=\"o\">&lt;</span><span class=\"n\">Signature</span> <span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">b</span><span class=\"p\">,</span> <span class=\"n\">c</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">)</span><span class=\"o\">&gt;</span>\n</pre>\n<p>And we can inspect all the composed callables:</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">g_of_f</span><span class=\"o\">.</span><span class=\"n\">functions</span>  <span class=\"c1\"># in order of execution:</span>\n<span class=\"p\">(</span><span class=\"o\">&lt;</span><span class=\"n\">function</span> <span class=\"n\">f</span> <span class=\"n\">at</span> <span class=\"mh\">0x4048e6f0</span><span class=\"o\">&gt;</span><span class=\"p\">,</span> <span class=\"o\">&lt;</span><span class=\"n\">function</span> <span class=\"n\">g</span> <span class=\"n\">at</span> <span class=\"mh\">0x405228e8</span><span class=\"o\">&gt;</span><span class=\"p\">)</span>\n</pre>\n<p>When programmatically inspecting arbitrary callables, we\ncan check if we are looking at a <tt>compose</tt> instance:</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">g_of_f</span><span class=\"p\">,</span> <span class=\"n\">compose</span><span class=\"p\">)</span>\n<span class=\"kc\">True</span>\n</pre>\n</div>\n<div id=\"design-decisions\">\n<h2>Design Decisions</h2>\n<ul>\n<li><p>The result of <tt>compose</tt> should be a drop-in replacement to\nfunctions in as many code paths as possible. Therefore:</p>\n<ul>\n<li>The proper signature of the composed function is exposed\nin the standard Python way (by exposing the \u201cinner-most\u201d\nfunction as the attribute <tt>__wrapped__</tt>).</li>\n<li>Arbitrary attribute assignment (<tt>__dict__</tt>) should work,\nbecause Python allows people to do that to functions.</li>\n<li>Weak references (<tt>__weakref__</tt>) are supported,\nbecause Python allows weakly referencing functions.</li>\n</ul>\n</li>\n<li><p>Failing-fast as much as possible because that is important\nto help debugging by keeping errors local to their causes.</p>\n</li>\n<li><p>Treating <tt>compose()</tt> with no arguments as an error, instead\nof as implicitly composing with an identity function, because:</p>\n<ul>\n<li><p>It avoids turning mistakes into silent misbehavior by default.</p>\n</li>\n<li><p>People who want the other behavior can more trivially build\nit on top of this behavior than the other way around:</p>\n<pre><span class=\"n\">compose</span> <span class=\"o\">=</span> <span class=\"n\">partial</span><span class=\"p\">(</span><span class=\"n\">compose</span><span class=\"p\">,</span> <span class=\"n\">identity</span><span class=\"p\">)</span>\n</pre>\n</li>\n</ul>\n</li>\n<li><p>Doing <tt>__init__(self, *functions)</tt> instead of\n<tt>__init__(self, function, *functions)</tt> because:</p>\n<ul>\n<li>It makes the signature and docstring more correctly hint that the\nfirst function argument is not special or different from the rest.</li>\n<li>It allows manually raising an error with a clearer and more\nhelpful message if <tt>compose()</tt> is called with no arguments.</li>\n</ul>\n</li>\n<li><p>Using <tt>functools.recursive_repr</tt> if available because if recursion\nhappens, having a working and recursion-safe <tt>__repr__</tt> would\nlikely be extremely helpful for debugging and code robustness.</p>\n<p>Not going beyond that because the code involved would be complex and\nnot portable across Python implementations, and the right place to\nsolve that is a separate polyfil if at all possible.</p>\n</li>\n<li><p><tt>self</tt> has to be a positional-only argument of <tt>__call__</tt>\nto make <tt>__call__</tt> properly transparent in all cases.</p>\n<p>If the user makes a typo, <tt>**</tt>-splats arguments, or otherwise\nends up passing <tt>self</tt> in <tt>kwargs</tt>, maybe even intentionally,\nfunction composition should still work correctly - in this case,\nsilent seemingly-successful unintended misbehavior would be awful.</p>\n<p>If the user uses <tt>compose</tt> to implement methods, the <tt>self</tt>\nargument to that method going through <tt>compose</tt> will normally\nbe a positional argument, but ideally should be passed through\ntransparently even if not, to match how normal methods work.</p>\n</li>\n<li><p>Manually getting <tt>self</tt> from <tt>*args</tt> in <tt>__call__</tt>\n<strong>portably</strong> makes <tt>self</tt> a positional-only argument.</p>\n</li>\n<li><p>Optimization priorities are:</p>\n<ol>\n<li>\u201cOptimize for optimization\u201d: implementing the essential logic\nof the intended behavior in as clearly and simply as possible,\nbecause that helps optimizers.</li>\n<li><tt>__call__</tt>, because that is the code path which can only be\nextracted from hot loops or other spots where performance\nmatters by not using <tt>compose</tt> at all.</li>\n<li><tt>__init__</tt>, because composing callables together is also\nessential to actually using this, and in some cases cannot\nbe pulled out of performance-sensitive code paths.</li>\n<li>Not storing data redundantly, because memory-constrained\nsystems are a thing, and it is much easier to add redundant\ndata on top of an implementation than it is to remove it.</li>\n</ol>\n</li>\n<li><p>Flattening nested instances of <tt>compose</tt> because</p>\n<ul>\n<li>It makes the repr much more helpful for debugging and\ninteractive usage. It is more common to want to know\nwhat the actual composed callable does, than to know\nthe tree of nested <tt>compose</tt> calls that created it.</li>\n<li><tt>__call__</tt> performance is more important in typical cases\nthan runspace efficiency (see above performance priorities).</li>\n<li>Intermediate composed functions that are never used\nafter composing them with something else can just\nbe deleted so that they don\u2019t take up memory.</li>\n<li>It is more trivial to prevent the flattening by using a\nsimple wrapper function or class on this implementation\nthan flattening on top of a not-flattening one.</li>\n</ul>\n</li>\n<li><p>Using tuples and a read-only <tt>@property</tt> for storing\nand exposing the composed functions because:</p>\n<ul>\n<li><p>Immutability helps reasoning about and validating code.</p>\n</li>\n<li><p>Immutable types provide more optimisation opportunities\nthat a Python implementation could take advantage of.</p>\n</li>\n<li><p>Discouraging mutations encourages optimizer-friendly code.</p>\n</li>\n<li><p>Mutability is normally not needed for composed functions.</p>\n</li>\n<li><p><tt>functools.partial</tt> also only exposes read-only attributes.</p>\n</li>\n<li><p>Immutability now is forward-compatible with mutability later;\nchanging mutability into immutability is a breaking change.</p>\n</li>\n<li><p>A simple mutable variant can be implemented trivially\non top of the current immutable <tt>compose</tt>:</p>\n<pre><span class=\"k\">class</span> <span class=\"nc\">compose</span><span class=\"p\">(</span><span class=\"n\">compose</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"o\">*</span><span class=\"n\">functions</span><span class=\"p\">):</span>\n        <span class=\"nb\">super</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">functions</span><span class=\"p\">)</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_wrappers</span> <span class=\"o\">=</span> <span class=\"nb\">list</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_wrappers</span><span class=\"p\">)</span>\n</pre>\n</li>\n</ul>\n</li>\n<li><p>Generating the <tt>functions</tt> attribute tuple every time instead\nof caching it, because:</p>\n<ul>\n<li><p>This implementation prevents <em>accidental</em> inconsistencies\nif someone intentionally bypasses the immutability.</p>\n<p>(Intentional inconsistencies that can only be introduced <em>by\ndeliberately modifying the implementation</em> are fine. What\u2019s\nimportant is minimizing the surface area for errors and\ndebugging difficulty being introduced by merely <em>forgetting</em>\nor <em>not realizing</em> the need to keep things consistent.)</p>\n</li>\n<li><p>The performance priority of not storing data redundantly as\npart of composing and calling is usually more important\nthan introspection performance, <em>especially</em> because the\ncaching can be implemented much more trivially on top of\nthis implementation than preventing caching would be if\nit was implemented in <tt>compose</tt>.</p>\n</li>\n<li><p>A caching variant can be implemented fairly easily\non top of the current non-caching <tt>compose</tt>:</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">functools</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">compose</span><span class=\"p\">(</span><span class=\"n\">compose</span><span class=\"p\">):</span>\n    <span class=\"nd\">@property</span>\n    <span class=\"nd\">@functools</span><span class=\"o\">.</span><span class=\"n\">lru_cache</span><span class=\"p\">(</span><span class=\"n\">maxsize</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n    <span class=\"k\">def</span> <span class=\"nf\">functions</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"k\">return</span> <span class=\"nb\">super</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">functions</span>\n</pre>\n</li>\n</ul>\n</li>\n<li><p>Storing the first function separately from the rest allows\n<tt>__call__</tt> to be more efficient, simpler, and clearer.</p>\n</li>\n<li><p><tt>__wrapped__</tt> cannot be a <tt>@property</tt> because several\nfunctions in the standard library cannot handle that.</p>\n<p>As a minor point, \u201cportability conservatism\u201d: it is safer\nto bet on the most conservative feature-set possible.</p>\n</li>\n<li><p>Not using <tt>__slots__</tt> because of many reasons adding up:</p>\n<ul>\n<li><p><tt>__call__</tt> performance is basically the same, at best\nonly marginally better, when using <tt>__slots__</tt>.</p>\n<p>(<tt>__init__</tt> sees a better but still small improvement.)</p>\n<p>On PyPy, <tt>__call__</tt> ends up getting optimized to the\nsame blazingly performant code with or without\n<tt>__slots__</tt> - makes no difference. On CPython, the\nno-<tt>__slots__</tt> variant actually performs better once\n<tt>__wrapped__</tt> is supported (see below).</p>\n</li>\n<li><p><tt>__slots__</tt> forces more code to support older\npickle protocols for those who might need that.</p>\n<p>(But one-liner <tt>__getstate__</tt> and <tt>__setstate__</tt> that\njust handle the 3-tuple of <tt>_wrapped</tt>, <tt>_wrappers</tt>,\nand <tt>__dict__</tt> would work, and are probably optimal.)</p>\n</li>\n<li><p><tt>__wrapped__</tt> cannot be in <tt>__slots__</tt> because that has\nthe same problem as making it a <tt>@property</tt> (see above).</p>\n</li>\n<li><p><tt>__wrapped__</tt> can be implemented with <tt>__getattribute__</tt>\nredirecting to a slotted <tt>_wrapped</tt>, but implementing the\n<tt>__getattribute__</tt> function is much slower than just not\nusing <tt>__slots__</tt> at all, since it proxies all attribute\naccess.</p>\n</li>\n<li><p><tt>__wrapped__</tt> can be implemented with <tt>__getattr__</tt>\nredirecting to a slotted <tt>_wrapped</tt>, although once\nupon a type Transcrypt didn\u2019t support <tt>__getattr__</tt>,\nwhich is a great example for portability conservatism.</p>\n<p>Moreover, testing shows that adding <tt>__getattr__</tt> to\na class still makes the whole slotted implementation\nslower somehow (merely removing <tt>__getattr__</tt> from\nthe class definition makes tests which never use\n<tt>__getattr__</tt> go faster, although there is no\nreason at the level of Python semantics for why this\nshould be the case). Once PyPy warms up, this is\nnegligible, and on CPython it is relatively minor,\nbut it is still strictly worse on most systems tested.</p>\n</li>\n<li><p><tt>__wrapped__</tt> can be just a <em>copy</em> of a slotted attribute,\nbut the same reasons apply against this as against making\n<tt>functions</tt> a cached copy.</p>\n</li>\n<li><p>If <tt>__wrapped__</tt> is stored in <tt>__dict__</tt> and is always\nset in <tt>__init__</tt>, a lot of the memory savings from\nusing <tt>__slots__</tt> are negated too.</p>\n</li>\n</ul>\n</li>\n<li><p>When flattening composed <tt>compose</tt> instances in <tt>__init__</tt>,\n<tt>__wrapped__</tt> and <tt>_wrapped</tt> attributes are used instead\nof the <tt>functions</tt> attribute, because:</p>\n<ul>\n<li>Speed of composition significantly increases, given\nthat <tt>functions</tt> is generated every time.</li>\n<li>The loss of symmetry between this and the public interface\nof the <tt>functions</tt> attribute is unfortunate, because it\nforces any subclasses to use <tt>_wrappers</tt> consistently\nwith <tt>compose</tt> instead of just <tt>functions</tt>, but the\nadvantage seems to be worthwhile.</li>\n</ul>\n</li>\n<li><p>The <tt>functions</tt> generation uses <tt>tuple(self._wrappers)</tt>\ninstead of just <tt>self._wrappers</tt> to enable subclasses\nthat make <tt>_wrappers</tt> something other than a tuple to\nstill work properly.</p>\n<p>A subclass which wants <tt>functions</tt> itself to be something\nother than a tuple would need to provide that themselves,\nbut this should cover at least some cases.</p>\n<p>Importantly, because tuples are immutable, calling <tt>tuple</tt>\non a tuple just returns the same tuple instead of copying in\nCPython, and other Pythons can do that optimization too.</p>\n</li>\n<li><p>Not providing a separate <tt>rcompose</tt> (which would compose\nits arguments in reverse order) for now, because it is\ntrivial to implement on top of <tt>compose</tt> if needed:</p>\n<pre><span class=\"k\">def</span> <span class=\"nf\">rcompose</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">functions</span><span class=\"p\">):</span>\n    <span class=\"k\">return</span> <span class=\"n\">compose</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"nb\">reversed</span><span class=\"p\">(</span><span class=\"n\">functions</span><span class=\"p\">))</span>\n</pre>\n</li>\n<li><p>Not providing a separate \u201cjust a normal function\u201d variant for now,\nbecause it is trivial to implement on top of <tt>compose</tt> if needed:</p>\n<pre><span class=\"k\">def</span> <span class=\"nf\">fcompose</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">functions</span><span class=\"p\">):</span>\n    <span class=\"n\">composed</span> <span class=\"o\">=</span> <span class=\"n\">compose</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">functions</span><span class=\"p\">)</span>\n    <span class=\"k\">return</span> <span class=\"k\">lambda</span> <span class=\"o\">*</span><span class=\"n\">args</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">:</span> <span class=\"n\">composed</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">args</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">)</span>\n</pre>\n</li>\n<li><p>Not providing descriptor support like <tt>functools.partialmethod</tt>\nfor now, until a need for it becomes apparent which a \u201cnormal\nfunction\u201d variant (see last point) does not satisfy well enough.</p>\n</li>\n<li><p>Not providing an <tt>async</tt>/<tt>await</tt> variant for now, because\nit is not yet clear if it is useful enough or if the best\nplace for it is this package, and in the meantime it can be\nimplemented on top of <tt>compose</tt> if needed:</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">inspect</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">acompose</span><span class=\"p\">(</span><span class=\"n\">compose</span><span class=\"p\">):</span>\n    <span class=\"k\">async</span> <span class=\"k\">def</span> <span class=\"fm\">__call__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"o\">/</span><span class=\"p\">,</span> <span class=\"o\">*</span><span class=\"n\">args</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">):</span>\n        <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__wrapped__</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">args</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">)</span>\n        <span class=\"k\">if</span> <span class=\"n\">inspect</span><span class=\"o\">.</span><span class=\"n\">isawaitable</span><span class=\"p\">(</span><span class=\"n\">result</span><span class=\"p\">):</span>\n            <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"k\">await</span> <span class=\"n\">result</span>\n        <span class=\"k\">for</span> <span class=\"n\">function</span> <span class=\"ow\">in</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_wrappers</span><span class=\"p\">:</span>\n            <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">function</span><span class=\"p\">(</span><span class=\"n\">result</span><span class=\"p\">)</span>\n            <span class=\"k\">if</span> <span class=\"n\">inspect</span><span class=\"o\">.</span><span class=\"n\">isawaitable</span><span class=\"p\">(</span><span class=\"n\">result</span><span class=\"p\">):</span>\n                <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"k\">await</span> <span class=\"n\">result</span>\n        <span class=\"k\">return</span> <span class=\"n\">result</span>\n</pre>\n</li>\n</ul>\n</div>\n\n          </div>"}, "last_serial": 7065485, "releases": {"1.0.0": [{"comment_text": "", "digests": {"md5": "d68d92ca2f9fca6ef34881ae3c1c4289", "sha256": "6c63ce9800e600e0e810dd04fff53f02846db15a38a5153997241b0b3df697c0"}, "downloads": -1, "filename": "compose-1.0.0-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "d68d92ca2f9fca6ef34881ae3c1c4289", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 5515, "upload_time": "2020-02-25T18:06:13", "upload_time_iso_8601": "2020-02-25T18:06:13.584361Z", "url": "https://files.pythonhosted.org/packages/fc/ee/0d2592931f0195ca2ef9b062ce98aff87b8eb229be894baab7982b0c5a89/compose-1.0.0-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "0c210c3348a5d9af43c4ae70005cf748", "sha256": "048a8f23b5127a83c99fe9f2e4de638dfc0d2cb76c9db3f39babe8d831fdcf7c"}, "downloads": -1, "filename": "compose-1.0.0.tar.gz", "has_sig": false, "md5_digest": "0c210c3348a5d9af43c4ae70005cf748", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 5319, "upload_time": "2020-02-25T18:06:16", "upload_time_iso_8601": "2020-02-25T18:06:16.026782Z", "url": "https://files.pythonhosted.org/packages/0c/9d/27df8f871de0183b8b829411fcb8db16caa1b093002168c5bf0b94fe96a5/compose-1.0.0.tar.gz", "yanked": false}], "1.1.0": [{"comment_text": "", "digests": {"md5": "459d7058768cd72189405845b9b7dde1", "sha256": "e65098dd190dc16d71e751e4687ddacbbc20fb82e00e940411d077990749150f"}, "downloads": -1, "filename": "compose-1.1.0-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "459d7058768cd72189405845b9b7dde1", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 8136, "upload_time": "2020-04-13T09:01:40", "upload_time_iso_8601": "2020-04-13T09:01:40.260138Z", "url": "https://files.pythonhosted.org/packages/db/2d/aa8257e46e094bb94b3793fa3ba1a2ad1205d3a617820c2834bd4e10d0db/compose-1.1.0-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "3924c7b4fcad8ba2aa6f8c8164464416", "sha256": "4a3d5ee8ed42b9bc10e08ddd29c348037742218396caffe1880e9976d63adf57"}, "downloads": -1, "filename": "compose-1.1.0.tar.gz", "has_sig": false, "md5_digest": "3924c7b4fcad8ba2aa6f8c8164464416", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 8891, "upload_time": "2020-04-13T09:01:42", "upload_time_iso_8601": "2020-04-13T09:01:42.769302Z", "url": "https://files.pythonhosted.org/packages/8f/ee/9cef14c3499115d3b23a95a81b73d5d9b190ed3a7181b41c728aaac55aa7/compose-1.1.0.tar.gz", "yanked": false}], "1.1.1": [{"comment_text": "", "digests": {"md5": "4a9cbe75f6b64cce580ec4159baae653", "sha256": "1d362f5bae5098dfe419a1c4f9a481e5c49b89e70da20a2b02aea8d18a825467"}, "downloads": -1, "filename": "compose-1.1.1-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "4a9cbe75f6b64cce580ec4159baae653", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 8237, "upload_time": "2020-04-21T05:23:08", "upload_time_iso_8601": "2020-04-21T05:23:08.966582Z", "url": "https://files.pythonhosted.org/packages/79/61/667d1d348e07dac92e04f30659e7b43d41dbf7cefe2efc9c1bb3b4ceed5b/compose-1.1.1-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "875eca792c2e9532a8089ec35b478dfb", "sha256": "3710b652cc9fccc36102f4eeccd1c4ff6bc9559b1c405e7884cb2de20e82003a"}, "downloads": -1, "filename": "compose-1.1.1.tar.gz", "has_sig": false, "md5_digest": "875eca792c2e9532a8089ec35b478dfb", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 8967, "upload_time": "2020-04-21T05:23:11", "upload_time_iso_8601": "2020-04-21T05:23:11.130628Z", "url": "https://files.pythonhosted.org/packages/b9/73/32a40c87df77474d8c9b329d7f530b2034e5406f2ad1607dd3f16212a483/compose-1.1.1.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "4a9cbe75f6b64cce580ec4159baae653", "sha256": "1d362f5bae5098dfe419a1c4f9a481e5c49b89e70da20a2b02aea8d18a825467"}, "downloads": -1, "filename": "compose-1.1.1-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "4a9cbe75f6b64cce580ec4159baae653", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 8237, "upload_time": "2020-04-21T05:23:08", "upload_time_iso_8601": "2020-04-21T05:23:08.966582Z", "url": "https://files.pythonhosted.org/packages/79/61/667d1d348e07dac92e04f30659e7b43d41dbf7cefe2efc9c1bb3b4ceed5b/compose-1.1.1-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "875eca792c2e9532a8089ec35b478dfb", "sha256": "3710b652cc9fccc36102f4eeccd1c4ff6bc9559b1c405e7884cb2de20e82003a"}, "downloads": -1, "filename": "compose-1.1.1.tar.gz", "has_sig": false, "md5_digest": "875eca792c2e9532a8089ec35b478dfb", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 8967, "upload_time": "2020-04-21T05:23:11", "upload_time_iso_8601": "2020-04-21T05:23:11.130628Z", "url": "https://files.pythonhosted.org/packages/b9/73/32a40c87df77474d8c9b329d7f530b2034e5406f2ad1607dd3f16212a483/compose-1.1.1.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:44:12 2020"}