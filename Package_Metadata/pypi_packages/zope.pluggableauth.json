{"info": {"author": "Zope Foundation and Contributors", "author_email": "zope-dev@zope.org", "bugtrack_url": null, "classifiers": ["Development Status :: 5 - Production/Stable", "Environment :: Web Environment", "Framework :: Zope3", "Intended Audience :: Developers", "License :: OSI Approved :: Zope Public License", "Natural Language :: English", "Operating System :: OS Independent", "Programming Language :: Python", "Programming Language :: Python :: 2", "Programming Language :: Python :: 2.7", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.4", "Programming Language :: Python :: 3.5", "Programming Language :: Python :: 3.6", "Programming Language :: Python :: Implementation :: CPython", "Programming Language :: Python :: Implementation :: PyPy", "Topic :: Internet :: WWW/HTTP"], "description": "========================\n ``zope.pluggableauth``\n========================\n\n.. image:: https://travis-ci.org/zopefoundation/zope.pluggableauth.svg?branch=master\n        :target: https://travis-ci.org/zopefoundation/zope.pluggableauth\n\nBased on ``zope.authentication``, this package provides a flexible and\npluggable authentication utility, and provides a number of common plugins.\n\n\n==================================\n Pluggable-Authentication Utility\n==================================\n\nThe Pluggable-Authentication Utility (PAU) provides a framework for\nauthenticating principals and associating information with them. It uses\nplugins and subscribers to get its work done.\n\nFor a pluggable-authentication utility to be used, it should be\nregistered as a utility providing the\n`zope.authentication.interfaces.IAuthentication` interface.\n\nAuthentication\n==============\n\nThe primary job of PAU is to authenticate principals. It uses two types of\nplug-ins in its work:\n\n- Credentials Plugins\n\n- Authenticator Plugins\n\nCredentials plugins are responsible for extracting user credentials from a\nrequest. A credentials plugin may in some cases issue a 'challenge' to obtain\ncredentials. For example, a 'session' credentials plugin reads credentials\nfrom a session (the \"extraction\"). If it cannot find credentials, it will\nredirect the user to a login form in order to provide them (the \"challenge\").\n\nAuthenticator plugins are responsible for authenticating the credentials\nextracted by a credentials plugin. They are also typically able to create\nprincipal objects for credentials they successfully authenticate.\n\nGiven a request object, the PAU returns a principal object, if it can. The PAU\ndoes this by first iterating through its credentials plugins to obtain a\nset of credentials. If it gets credentials, it iterates through its\nauthenticator plugins to authenticate them.\n\nIf an authenticator succeeds in authenticating a set of credentials, the PAU\nuses the authenticator to create a principal corresponding to the credentials.\nThe authenticator notifies subscribers if an authenticated principal is\ncreated. Subscribers are responsible for adding data, especially groups, to\nthe principal. Typically, if a subscriber adds data, it should also add\ncorresponding interface declarations.\n\nSimple Credentials Plugin\n-------------------------\n\nTo illustrate, we'll create a simple credentials plugin:\n\n  >>> from zope import interface\n  >>> from zope.pluggableauth.authentication import interfaces\n\n  >>> @interface.implementer(interfaces.ICredentialsPlugin)\n  ... class MyCredentialsPlugin(object):\n  ...\n  ...     def extractCredentials(self, request):\n  ...         return request.get('credentials')\n  ...\n  ...     def challenge(self, request):\n  ...         pass # challenge is a no-op for this plugin\n  ...\n  ...     def logout(self, request):\n  ...         pass # logout is a no-op for this plugin\n\nAs a plugin, MyCredentialsPlugin needs to be registered as a named utility:\n\n  >>> myCredentialsPlugin = MyCredentialsPlugin()\n  >>> provideUtility(myCredentialsPlugin, name='My Credentials Plugin')\n\nSimple Authenticator Plugin\n---------------------------\n\nNext we'll create a simple authenticator plugin. For our plugin, we'll need\nan implementation of IPrincipalInfo:\n\n  >>> @interface.implementer(interfaces.IPrincipalInfo)\n  ... class PrincipalInfo(object):\n  ...\n  ...     def __init__(self, id, title, description):\n  ...         self.id = id\n  ...         self.title = title\n  ...         self.description = description\n  ...\n  ...     def __repr__(self):\n  ...         return 'PrincipalInfo(%r)' % self.id\n\nOur authenticator uses this type when it creates a principal info:\n\n  >>> @interface.implementer(interfaces.IAuthenticatorPlugin)\n  ... class MyAuthenticatorPlugin(object):\n  ...\n  ...     def authenticateCredentials(self, credentials):\n  ...         if credentials == 'secretcode':\n  ...             return PrincipalInfo('bob', 'Bob', '')\n  ...\n  ...     def principalInfo(self, id):\n  ...         pass # plugin not currently supporting search\n\nAs with the credentials plugin, the authenticator plugin must be registered\nas a named utility:\n\n  >>> myAuthenticatorPlugin = MyAuthenticatorPlugin()\n  >>> provideUtility(myAuthenticatorPlugin, name='My Authenticator Plugin')\n\nConfiguring a PAU\n-----------------\n\nFinally, we'll create the PAU itself:\n\n  >>> from zope.pluggableauth import authentication\n  >>> pau = authentication.PluggableAuthentication('xyz_')\n\nand configure it with the two plugins:\n\n  >>> pau.credentialsPlugins = ('My Credentials Plugin', )\n  >>> pau.authenticatorPlugins = ('My Authenticator Plugin', )\n\nUsing the PAU to Authenticate\n-----------------------------\n\n  >>> from zope.pluggableauth.factories import AuthenticatedPrincipalFactory\n  >>> provideAdapter(AuthenticatedPrincipalFactory)\n\nWe can now use the PAU to authenticate a sample request:\n\n  >>> from zope.publisher.browser import TestRequest\n  >>> print(pau.authenticate(TestRequest()))\n  None\n\nIn this case, we cannot authenticate an empty request. In the same way, we\nwill not be able to authenticate a request with the wrong credentials:\n\n  >>> print(pau.authenticate(TestRequest(credentials='let me in!')))\n  None\n\nHowever, if we provide the proper credentials:\n\n  >>> request = TestRequest(credentials='secretcode')\n  >>> principal = pau.authenticate(request)\n  >>> principal\n  Principal('xyz_bob')\n\nwe get an authenticated principal.\n\nMultiple Authenticator Plugins\n------------------------------\n\nThe PAU works with multiple authenticator plugins. It uses each plugin, in the\norder specified in the PAU's authenticatorPlugins attribute, to authenticate\na set of credentials.\n\nTo illustrate, we'll create another authenticator:\n\n  >>> class MyAuthenticatorPlugin2(MyAuthenticatorPlugin):\n  ...\n  ...     def authenticateCredentials(self, credentials):\n  ...         if credentials == 'secretcode':\n  ...             return PrincipalInfo('black', 'Black Spy', '')\n  ...         elif credentials == 'hiddenkey':\n  ...             return PrincipalInfo('white', 'White Spy', '')\n\n  >>> provideUtility(MyAuthenticatorPlugin2(), name='My Authenticator Plugin 2')\n\nIf we put it before the original authenticator:\n\n  >>> pau.authenticatorPlugins = (\n  ...     'My Authenticator Plugin 2',\n  ...     'My Authenticator Plugin')\n\nThen it will be given the first opportunity to authenticate a request:\n\n  >>> pau.authenticate(TestRequest(credentials='secretcode'))\n  Principal('xyz_black')\n\nIf neither plugins can authenticate, pau returns None:\n\n  >>> print(pau.authenticate(TestRequest(credentials='let me in!!')))\n  None\n\nWhen we change the order of the authenticator plugins:\n\n  >>> pau.authenticatorPlugins = (\n  ...     'My Authenticator Plugin',\n  ...     'My Authenticator Plugin 2')\n\nwe see that our original plugin is now acting first:\n\n  >>> pau.authenticate(TestRequest(credentials='secretcode'))\n  Principal('xyz_bob')\n\nThe second plugin, however, gets a chance to authenticate if first does not:\n\n  >>> pau.authenticate(TestRequest(credentials='hiddenkey'))\n  Principal('xyz_white')\n\nMultiple Credentials Plugins\n----------------------------\n\nAs with with authenticators, we can specify multiple credentials plugins. To\nillustrate, we'll create a credentials plugin that extracts credentials from\na request form:\n\n  >>> @interface.implementer(interfaces.ICredentialsPlugin)\n  ... class FormCredentialsPlugin:\n  ...\n  ...     def extractCredentials(self, request):\n  ...         return request.form.get('my_credentials')\n  ...\n  ...     def challenge(self, request):\n  ...         pass\n  ...\n  ...     def logout(request):\n  ...         pass\n\n  >>> provideUtility(FormCredentialsPlugin(),\n  ...                name='Form Credentials Plugin')\n\nand insert the new credentials plugin before the existing plugin:\n\n  >>> pau.credentialsPlugins = (\n  ...     'Form Credentials Plugin',\n  ...     'My Credentials Plugin')\n\nThe PAU will use each plugin in order to try and obtain credentials from a\nrequest:\n\n  >>> pau.authenticate(TestRequest(credentials='secretcode',\n  ...                              form={'my_credentials': 'hiddenkey'}))\n  Principal('xyz_white')\n\nIn this case, the first credentials plugin succeeded in getting credentials\nfrom the form and the second authenticator was able to authenticate the\ncredentials. Specifically, the PAU went through these steps:\n\n- Get credentials using 'Form Credentials Plugin'\n\n- Got 'hiddenkey' credentials using 'Form Credentials Plugin', try to\n  authenticate using 'My Authenticator Plugin'\n\n- Failed to authenticate 'hiddenkey' with 'My Authenticator Plugin', try\n  'My Authenticator Plugin 2'\n\n- Succeeded in authenticating with 'My Authenticator Plugin 2'\n\nLet's try a different scenario:\n\n  >>> pau.authenticate(TestRequest(credentials='secretcode'))\n  Principal('xyz_bob')\n\nIn this case, the PAU went through these steps::\n\n- Get credentials using 'Form Credentials Plugin'\n\n- Failed to get credentials using 'Form Credentials Plugin', try\n  'My Credentials Plugin'\n\n- Got 'scecretcode' credentials using 'My Credentials Plugin', try to\n  authenticate using 'My Authenticator Plugin'\n\n- Succeeded in authenticating with 'My Authenticator Plugin'\n\nLet's try a slightly more complex scenario:\n\n  >>> pau.authenticate(TestRequest(credentials='hiddenkey',\n  ...                              form={'my_credentials': 'bogusvalue'}))\n  Principal('xyz_white')\n\nThis highlights PAU's ability to use multiple plugins for authentication:\n\n- Get credentials using 'Form Credentials Plugin'\n\n- Got 'bogusvalue' credentials using 'Form Credentials Plugin', try to\n  authenticate using 'My Authenticator Plugin'\n\n- Failed to authenticate 'boguskey' with 'My Authenticator Plugin', try\n  'My Authenticator Plugin 2'\n\n- Failed to authenticate 'boguskey' with 'My Authenticator Plugin 2' --\n  there are no more authenticators to try, so lets try the next credentials\n  plugin for some new credentials\n\n- Get credentials using 'My Credentials Plugin'\n\n- Got 'hiddenkey' credentials using 'My Credentials Plugin', try to\n  authenticate using 'My Authenticator Plugin'\n\n- Failed to authenticate 'hiddenkey' using 'My Authenticator Plugin', try\n  'My Authenticator Plugin 2'\n\n- Succeeded in authenticating with 'My Authenticator Plugin 2' (shouts and\n  cheers!)\n\nMultiple Authenticator Plugins\n------------------------------\n\nAs with the other operations we've seen, the PAU uses multiple plugins to\nfind a principal. If the first authenticator plugin can't find the requested\nprincipal, the next plugin is used, and so on.\n\n  >>> @interface.implementer(interfaces.IAuthenticatorPlugin)\n  ... class AnotherAuthenticatorPlugin:\n  ...\n  ...     def __init__(self):\n  ...         self.infos = {}\n  ...         self.ids = {}\n  ...\n  ...     def principalInfo(self, id):\n  ...         return self.infos.get(id)\n  ...\n  ...     def authenticateCredentials(self, credentials):\n  ...         id = self.ids.get(credentials)\n  ...         if id is not None:\n  ...             return self.infos[id]\n  ...\n  ...     def add(self, id, title, description, credentials):\n  ...         self.infos[id] = PrincipalInfo(id, title, description)\n  ...         self.ids[credentials] = id\n\n\nTo illustrate, we'll create and register two authenticators:\n\n  >>> authenticator1 = AnotherAuthenticatorPlugin()\n  >>> provideUtility(authenticator1, name='Authentication Plugin 1')\n\n  >>> authenticator2 = AnotherAuthenticatorPlugin()\n  >>> provideUtility(authenticator2, name='Authentication Plugin 2')\n\nand add a principal to them:\n\n  >>> authenticator1.add('bob', 'Bob', 'A nice guy', 'b0b')\n  >>> authenticator1.add('white', 'White Spy', 'Sneaky', 'deathtoblack')\n  >>> authenticator2.add('black', 'Black Spy', 'Also sneaky', 'deathtowhite')\n\nWhen we configure the PAU to use both searchable authenticators (note the\norder):\n\n  >>> pau.authenticatorPlugins = (\n  ...     'Authentication Plugin 2',\n  ...     'Authentication Plugin 1')\n\nwe register the factories for our principals:\n\n  >>> from zope.pluggableauth.factories import FoundPrincipalFactory\n  >>> provideAdapter(FoundPrincipalFactory)\n\nwe see how the PAU uses both plugins:\n\n  >>> pau.getPrincipal('xyz_white')\n  Principal('xyz_white')\n\n  >>> pau.getPrincipal('xyz_black')\n  Principal('xyz_black')\n\nIf more than one plugin know about the same principal ID, the first plugin is\nused and the remaining are not delegated to. To illustrate, we'll add\nanother principal with the same ID as an existing principal:\n\n  >>> authenticator2.add('white', 'White Rider', '', 'r1der')\n  >>> pau.getPrincipal('xyz_white').title\n  'White Rider'\n\nIf we change the order of the plugins:\n\n  >>> pau.authenticatorPlugins = (\n  ...     'Authentication Plugin 1',\n  ...     'Authentication Plugin 2')\n\nwe get a different principal for ID 'white':\n\n  >>> pau.getPrincipal('xyz_white').title\n  'White Spy'\n\n\nIssuing a Challenge\n===================\n\nPart of PAU's IAuthentication contract is to challenge the user for\ncredentials when its 'unauthorized' method is called. The need for this\nfunctionality is driven by the following use case:\n\n- A user attempts to perform an operation he is not authorized to perform.\n\n- A handler responds to the unauthorized error by calling IAuthentication\n  'unauthorized'.\n\n- The authentication component (in our case, a PAU) issues a challenge to\n  the user to collect new credentials (typically in the form of logging in\n  as a new user).\n\nThe PAU handles the credentials challenge by delegating to its credentials\nplugins.\n\nCurrently, the PAU is configured with the credentials plugins that don't\nperform any action when asked to challenge (see above the 'challenge' methods).\n\nTo illustrate challenges, we'll subclass an existing credentials plugin and\ndo something in its 'challenge':\n\n  >>> class LoginFormCredentialsPlugin(FormCredentialsPlugin):\n  ...\n  ...     def __init__(self, loginForm):\n  ...         self.loginForm = loginForm\n  ...\n  ...     def challenge(self, request):\n  ...         request.response.redirect(self.loginForm)\n  ...         return True\n\nThis plugin handles a challenge by redirecting the response to a login form.\nIt returns True to signal to the PAU that it handled the challenge.\n\nWe will now create and register a couple of these plugins:\n\n  >>> provideUtility(LoginFormCredentialsPlugin('simplelogin.html'),\n  ...                name='Simple Login Form Plugin')\n\n  >>> provideUtility(LoginFormCredentialsPlugin('advancedlogin.html'),\n  ...                name='Advanced Login Form Plugin')\n\nand configure the PAU to use them:\n\n  >>> pau.credentialsPlugins = (\n  ...     'Simple Login Form Plugin',\n  ...     'Advanced Login Form Plugin')\n\nNow when we call 'unauthorized' on the PAU:\n\n  >>> request = TestRequest()\n  >>> pau.unauthorized(id=None, request=request)\n\nwe see that the user is redirected to the simple login form:\n\n  >>> request.response.getStatus()\n  302\n  >>> request.response.getHeader('location')\n  'simplelogin.html'\n\nWe can change the challenge policy by reordering the plugins:\n\n  >>> pau.credentialsPlugins = (\n  ...     'Advanced Login Form Plugin',\n  ...     'Simple Login Form Plugin')\n\nNow when we call 'unauthorized':\n\n  >>> request = TestRequest()\n  >>> pau.unauthorized(id=None, request=request)\n\nthe advanced plugin is used because it's first:\n\n  >>> request.response.getStatus()\n  302\n  >>> request.response.getHeader('location')\n  'advancedlogin.html'\n\nChallenge Protocols\n-------------------\n\nSometimes, we want multiple challengers to work together. For example, the\nHTTP specification allows multiple challenges to be issued in a response. A\nchallenge plugin can provide a `challengeProtocol` attribute that effectively\ngroups related plugins together for challenging. If a plugin returns `True`\nfrom its challenge and provides a non-None challengeProtocol, subsequent\nplugins in the credentialsPlugins list that have the same challenge protocol\nwill also be used to challenge.\n\nWithout a challengeProtocol, only the first plugin to succeed in a challenge\nwill be used.\n\nLet's look at an example. We'll define a new plugin that specifies an\n'X-Challenge' protocol:\n\n  >>> class XChallengeCredentialsPlugin(FormCredentialsPlugin):\n  ...\n  ...     challengeProtocol = 'X-Challenge'\n  ...\n  ...     def __init__(self, challengeValue):\n  ...         self.challengeValue = challengeValue\n  ...\n  ...     def challenge(self, request):\n  ...         value = self.challengeValue\n  ...         existing = request.response.getHeader('X-Challenge', '')\n  ...         if existing:\n  ...             value += ' ' + existing\n  ...         request.response.setHeader('X-Challenge', value)\n  ...         return True\n\nand register a couple instances as utilities:\n\n  >>> provideUtility(XChallengeCredentialsPlugin('basic'),\n  ...                name='Basic X-Challenge Plugin')\n\n  >>> provideUtility(XChallengeCredentialsPlugin('advanced'),\n  ...                name='Advanced X-Challenge Plugin')\n\nWhen we use both plugins with the PAU:\n\n  >>> pau.credentialsPlugins = (\n  ...     'Basic X-Challenge Plugin',\n  ...     'Advanced X-Challenge Plugin')\n\nand call 'unauthorized':\n\n  >>> request = TestRequest()\n  >>> pau.unauthorized(None, request)\n\nwe see that both plugins participate in the challenge, rather than just the\nfirst plugin:\n\n  >>> request.response.getHeader('X-Challenge')\n  'advanced basic'\n\n\nPluggable-Authentication Prefixes\n=================================\n\nPrincipal ids are required to be unique system wide. Plugins will often provide\noptions for providing id prefixes, so that different sets of plugins provide\nunique ids within a PAU. If there are multiple pluggable-authentication\nutilities in a system, it's a good idea to give each PAU a unique prefix, so\nthat principal ids from different PAUs don't conflict. We can provide a prefix\nwhen a PAU is created:\n\n  >>> pau = authentication.PluggableAuthentication('mypau_')\n  >>> pau.credentialsPlugins = ('My Credentials Plugin', )\n  >>> pau.authenticatorPlugins = ('My Authenticator Plugin', )\n\nWhen we create a request and try to authenticate:\n\n  >>> pau.authenticate(TestRequest(credentials='secretcode'))\n  Principal('mypau_bob')\n\nNote that now, our principal's id has the pluggable-authentication\nutility prefix.\n\nWe can still lookup a principal, as long as we supply the prefix::\n\n  >> pau.getPrincipal('mypas_42')\n  Principal('mypas_42', \"{'domain': 42}\")\n\n  >> pau.getPrincipal('mypas_41')\n  OddPrincipal('mypas_41', \"{'int': 41}\")\n\n\n==================\n Principal Folder\n==================\n\nPrincipal folders contain principal-information objects that contain principal\ninformation. We create an internal principal using the `InternalPrincipal`\nclass:\n\n  >>> from zope.pluggableauth.plugins.principalfolder import InternalPrincipal\n  >>> p1 = InternalPrincipal('login1', '123', \"Principal 1\",\n  ...     passwordManagerName=\"SHA1\")\n  >>> p2 = InternalPrincipal('login2', '456', \"The Other One\")\n\nand add them to a principal folder:\n\n  >>> from zope.pluggableauth.plugins.principalfolder import PrincipalFolder\n  >>> principals = PrincipalFolder(u'principal.')\n  >>> principals['p1'] = p1\n  >>> principals['p2'] = p2\n\nAuthentication\n==============\n\nPrincipal folders provide the `IAuthenticatorPlugin` interface. When we\nprovide suitable credentials:\n\n  >>> from pprint import pprint\n  >>> principals.authenticateCredentials({'login': 'login1', 'password': '123'})\n  PrincipalInfo(u'principal.p1')\n\nWe get back a principal id and supplementary information, including the\nprincipal title and description.  Note that the principal id is a concatenation\nof the principal-folder prefix and the name of the principal-information object\nwithin the folder.\n\nNone is returned if the credentials are invalid:\n\n  >>> principals.authenticateCredentials({'login': 'login1',\n  ...                                     'password': '1234'})\n  >>> principals.authenticateCredentials(42)\n\nSearch\n======\n\nPrincipal folders also provide the IQuerySchemaSearch interface.  This\nsupports both finding principal information based on their ids:\n\n  >>> principals.principalInfo('principal.p1')\n  PrincipalInfo('principal.p1')\n\n  >>> principals.principalInfo('p1')\n\nand searching for principals based on a search string:\n\n  >>> list(principals.search({'search': 'other'}))\n  [u'principal.p2']\n\n  >>> list(principals.search({'search': 'OTHER'}))\n  [u'principal.p2']\n\n  >>> list(principals.search({'search': ''}))\n  [u'principal.p1', u'principal.p2']\n\n  >>> list(principals.search({'search': 'eek'}))\n  []\n\n  >>> list(principals.search({}))\n  []\n\nIf there are a large number of matches:\n\n  >>> for i in range(20):\n  ...     i = str(i)\n  ...     p = InternalPrincipal('l'+i, i, \"Dude \"+i)\n  ...     principals[i] = p\n\n  >>> pprint(list(principals.search({'search': 'D'})), width=25)\n  [u'principal.0',\n   u'principal.1',\n   u'principal.10',\n   u'principal.11',\n   u'principal.12',\n   u'principal.13',\n   u'principal.14',\n   u'principal.15',\n   u'principal.16',\n   u'principal.17',\n   u'principal.18',\n   u'principal.19',\n   u'principal.2',\n   u'principal.3',\n   u'principal.4',\n   u'principal.5',\n   u'principal.6',\n   u'principal.7',\n   u'principal.8',\n   u'principal.9']\n\nWe can use batching parameters to specify a subset of results:\n\n  >>> pprint(list(principals.search({'search': 'D'}, start=17)))\n  [u'principal.7', u'principal.8', u'principal.9']\n\n  >>> pprint(list(principals.search({'search': 'D'}, batch_size=5)), width=60)\n  [u'principal.0',\n   u'principal.1',\n   u'principal.10',\n   u'principal.11',\n   u'principal.12']\n\n  >>> pprint(list(principals.search({'search': 'D'}, start=5, batch_size=5)),\n  ...        width=25)\n  [u'principal.13',\n   u'principal.14',\n   u'principal.15',\n   u'principal.16',\n   u'principal.17']\n\nThere is an additional method that allows requesting the principal id\nassociated with a login id.  The method raises KeyError when there is\nno associated principal:\n\n  >>> principals.getIdByLogin(\"not-there\")\n  Traceback (most recent call last):\n  KeyError: 'not-there'\n\nIf there is a matching principal, the id is returned:\n\n  >>> principals.getIdByLogin(\"login1\")\n  u'principal.p1'\n\nChanging credentials\n====================\n\nCredentials can be changed by modifying principal-information objects:\n\n  >>> p1.login = 'bob'\n  >>> p1.password = 'eek'\n\n  >>> principals.authenticateCredentials({'login': 'bob', 'password': 'eek'})\n  PrincipalInfo(u'principal.p1')\n\n  >>> principals.authenticateCredentials({'login': 'login1',\n  ...                                     'password': 'eek'})\n\n  >>> principals.authenticateCredentials({'login': 'bob',\n  ...                                     'password': '123'})\n\n\nIt is an error to try to pick a login name that is already taken:\n\n  >>> p1.login = 'login2'\n  Traceback (most recent call last):\n  ...\n  ValueError: Principal Login already taken!\n\nIf such an attempt is made, the data are unchanged:\n\n  >>> principals.authenticateCredentials({'login': 'bob', 'password': 'eek'})\n  PrincipalInfo(u'principal.p1')\n\nRemoving principals\n===================\n\nOf course, if a principal is removed, we can no-longer authenticate it:\n\n  >>> del principals['p1']\n  >>> principals.authenticateCredentials({'login': 'bob',\n  ...                                     'password': 'eek'})\n\n\n===============\n Group Folders\n===============\n\nGroup folders provide support for groups information stored in the ZODB.  They\nare persistent, and must be contained within the PAUs that use them.\n\nLike other principals, groups are created when they are needed.\n\nGroup folders contain group-information objects that contain group information.\nWe create group information using the `GroupInformation` class:\n\n  >>> import zope.pluggableauth.plugins.groupfolder\n  >>> g1 = zope.pluggableauth.plugins.groupfolder.GroupInformation(\"Group 1\")\n\n  >>> groups = zope.pluggableauth.plugins.groupfolder.GroupFolder('group.')\n  >>> groups['g1'] = g1\n\nNote that when group-info is added, a GroupAdded event is generated:\n\n  >>> from zope.pluggableauth import interfaces\n  >>> from zope.component.eventtesting import getEvents\n  >>> getEvents(interfaces.IGroupAdded)\n  [<GroupAdded 'group.g1'>]\n\nGroups are defined with respect to an authentication service.  Groups\nmust be accessible via an authentication service and can contain\nprincipals accessible via an authentication service.\n\nTo illustrate the group interaction with the authentication service,\nwe'll create a sample authentication service:\n\n  >>> from zope import interface\n  >>> from zope.authentication.interfaces import IAuthentication\n  >>> from zope.authentication.interfaces import PrincipalLookupError\n  >>> from zope.security.interfaces import IGroupAwarePrincipal\n  >>> from zope.pluggableauth.plugins.groupfolder import setGroupsForPrincipal\n\n  >>> @interface.implementer(IGroupAwarePrincipal)\n  ... class Principal:\n  ...     def __init__(self, id, title='', description=''):\n  ...         self.id, self.title, self.description = id, title, description\n  ...         self.groups = []\n\n  >>> class PrincipalCreatedEvent:\n  ...     def __init__(self, authentication, principal):\n  ...         self.authentication = authentication\n  ...         self.principal = principal\n\n  >>> from zope.pluggableauth.plugins import principalfolder\n\n  >>> @interface.implementer(IAuthentication)\n  ... class Principals:\n  ...     def __init__(self, groups, prefix='auth.'):\n  ...         self.prefix = prefix\n  ...         self.principals = {\n  ...            'p1': principalfolder.PrincipalInfo('p1', '', '', ''),\n  ...            'p2': principalfolder.PrincipalInfo('p2', '', '', ''),\n  ...            'p3': principalfolder.PrincipalInfo('p3', '', '', ''),\n  ...            'p4': principalfolder.PrincipalInfo('p4', '', '', ''),\n  ...            }\n  ...         self.groups = groups\n  ...         groups.__parent__ = self\n  ...\n  ...     def getAuthenticatorPlugins(self):\n  ...         return [('principals', self.principals), ('groups', self.groups)]\n  ...\n  ...     def getPrincipal(self, id):\n  ...         if not id.startswith(self.prefix):\n  ...             raise PrincipalLookupError(id)\n  ...         id = id[len(self.prefix):]\n  ...         info = self.principals.get(id)\n  ...         if info is None:\n  ...             info = self.groups.principalInfo(id)\n  ...             if info is None:\n  ...                raise PrincipalLookupError(id)\n  ...         principal = Principal(self.prefix+info.id,\n  ...                               info.title, info.description)\n  ...         setGroupsForPrincipal(PrincipalCreatedEvent(self, principal))\n  ...         return principal\n\nThis class doesn't really implement the full `IAuthentication` interface, but\nit implements the `getPrincipal` method used by groups. It works very much\nlike the pluggable authentication utility.  It creates principals on demand. It\ncalls `setGroupsForPrincipal`, which is normally called as an event subscriber,\nwhen principals are created. In order for `setGroupsForPrincipal` to find out\ngroup folder, we have to register it as a utility:\n\n  >>> from zope.pluggableauth.interfaces import IAuthenticatorPlugin\n  >>> from zope.component import provideUtility\n  >>> provideUtility(groups, IAuthenticatorPlugin)\n\nWe will create and register a new principals utility:\n\n  >>> principals = Principals(groups)\n  >>> provideUtility(principals, IAuthentication)\n\nNow we can set the principals on the group:\n\n  >>> g1.principals = ['auth.p1', 'auth.p2']\n  >>> g1.principals\n  ('auth.p1', 'auth.p2')\n\nAdding principals fires an event.\n\n  >>> getEvents(interfaces.IPrincipalsAddedToGroup)[-1]\n  <PrincipalsAddedToGroup ['auth.p1', 'auth.p2'] u'auth.group.g1'>\n\nWe can now look up groups for the principals:\n\n  >>> groups.getGroupsForPrincipal('auth.p1')\n  (u'group.g1',)\n\nNote that the group id is a concatenation of the group-folder prefix\nand the name of the group-information object within the folder.\n\nIf we delete a group:\n\n  >>> del groups['g1']\n\nthen the groups folder loses the group information for that group's\nprincipals:\n\n  >>> groups.getGroupsForPrincipal('auth.p1')\n  ()\n\nbut the principal information on the group is unchanged:\n\n  >>> g1.principals\n  ('auth.p1', 'auth.p2')\n\nIt also fires an event showing that the principals are removed from the group\n(g1 is group information, not a zope.security.interfaces.IGroup).\n\n  >>> getEvents(interfaces.IPrincipalsRemovedFromGroup)[-1]\n  <PrincipalsRemovedFromGroup ['auth.p1', 'auth.p2'] u'auth.group.g1'>\n\nAdding the group sets the folder principal information.  Let's use a\ndifferent group name:\n\n  >>> groups['G1'] = g1\n\n  >>> groups.getGroupsForPrincipal('auth.p1')\n  (u'group.G1',)\n\nHere we see that the new name is reflected in the group information.\n\nAn event is fired, as usual.\n\n  >>> getEvents(interfaces.IPrincipalsAddedToGroup)[-1]\n  <PrincipalsAddedToGroup ['auth.p1', 'auth.p2'] u'auth.group.G1'>\n\nIn terms of member events (principals added and removed from groups), we have\nnow seen that events are fired when a group information object is added and\nwhen it is removed from a group folder; and we have seen that events are fired\nwhen a principal is added to an already-registered group.  Events are also\nfired when a principal is removed from an already-registered group.  Let's\nquickly see some more examples.\n\n  >>> g1.principals = ('auth.p1', 'auth.p3', 'auth.p4')\n  >>> getEvents(interfaces.IPrincipalsAddedToGroup)[-1]\n  <PrincipalsAddedToGroup ['auth.p3', 'auth.p4'] u'auth.group.G1'>\n  >>> getEvents(interfaces.IPrincipalsRemovedFromGroup)[-1]\n  <PrincipalsRemovedFromGroup ['auth.p2'] u'auth.group.G1'>\n  >>> g1.principals = ('auth.p1', 'auth.p2')\n  >>> getEvents(interfaces.IPrincipalsAddedToGroup)[-1]\n  <PrincipalsAddedToGroup ['auth.p2'] u'auth.group.G1'>\n  >>> getEvents(interfaces.IPrincipalsRemovedFromGroup)[-1]\n  <PrincipalsRemovedFromGroup ['auth.p3', 'auth.p4'] u'auth.group.G1'>\n\nGroups can contain groups:\n\n  >>> g2 = zope.pluggableauth.plugins.groupfolder.GroupInformation(\"Group Two\")\n  >>> groups['G2'] = g2\n  >>> g2.principals = ['auth.group.G1']\n\n  >>> groups.getGroupsForPrincipal('auth.group.G1')\n  (u'group.G2',)\n\n  >>> old = getEvents(interfaces.IPrincipalsAddedToGroup)[-1]\n  >>> old\n  <PrincipalsAddedToGroup ['auth.group.G1'] u'auth.group.G2'>\n\nGroups cannot contain cycles:\n\n  >>> g1.principals = ('auth.p1', 'auth.p2', 'auth.group.G2')\n  ... # doctest: +NORMALIZE_WHITESPACE\n  Traceback (most recent call last):\n  ...\n  zope.pluggableauth.plugins.groupfolder.GroupCycle: (u'auth.group.G2', [u'auth.group.G2', u'auth.group.G1'])\n\nTrying to do so does not fire an event.\n\n  >>> getEvents(interfaces.IPrincipalsAddedToGroup)[-1] is old\n  True\n\nThey need not be hierarchical:\n\n  >>> ga = zope.pluggableauth.plugins.groupfolder.GroupInformation(\"Group A\")\n  >>> groups['GA'] = ga\n\n  >>> gb = zope.pluggableauth.plugins.groupfolder.GroupInformation(\"Group B\")\n  >>> groups['GB'] = gb\n  >>> gb.principals = ['auth.group.GA']\n\n  >>> gc = zope.pluggableauth.plugins.groupfolder.GroupInformation(\"Group C\")\n  >>> groups['GC'] = gc\n  >>> gc.principals = ['auth.group.GA']\n\n  >>> gd = zope.pluggableauth.plugins.groupfolder.GroupInformation(\"Group D\")\n  >>> groups['GD'] = gd\n  >>> gd.principals = ['auth.group.GA', 'auth.group.GB']\n\n  >>> ga.principals = ['auth.p1']\n\nGroup folders provide a very simple search interface.  They perform\nsimple string searches on group titles and descriptions.\n\n  >>> list(groups.search({'search': 'grou'})) # doctest: +NORMALIZE_WHITESPACE\n  [u'group.G1', u'group.G2',\n   u'group.GA', u'group.GB', u'group.GC', u'group.GD']\n\n  >>> list(groups.search({'search': 'two'}))\n  [u'group.G2']\n\nThey also support batching:\n\n  >>> list(groups.search({'search': 'grou'}, 2, 3))\n  [u'group.GA', u'group.GB', u'group.GC']\n\n\nIf you don't supply a search key, no results will be returned:\n\n  >>> list(groups.search({}))\n  []\n\nIdentifying groups\n==================\nThe function, `setGroupsForPrincipal`, is a subscriber to\nprincipal-creation events.  It adds any group-folder-defined groups to\nusers in those groups:\n\n  >>> principal = principals.getPrincipal('auth.p1')\n\n  >>> principal.groups\n  [u'auth.group.G1', u'auth.group.GA']\n\nOf course, this applies to groups too:\n\n  >>> principal = principals.getPrincipal('auth.group.G1')\n  >>> principal.id\n  'auth.group.G1'\n\n  >>> principal.groups\n  [u'auth.group.G2']\n\nIn addition to setting principal groups, the `setGroupsForPrincipal`\nfunction also declares the `IGroup` interface on groups:\n\n  >>> [iface.__name__ for iface in interface.providedBy(principal)]\n  ['IGroup', 'IGroupAwarePrincipal']\n\n  >>> [iface.__name__\n  ...  for iface in interface.providedBy(principals.getPrincipal('auth.p1'))]\n  ['IGroupAwarePrincipal']\n\nSpecial groups\n==============\nTwo special groups, Authenticated, and Everyone may apply to users\ncreated by the pluggable-authentication utility.  There is a\nsubscriber, specialGroups, that will set these groups on any non-group\nprincipals if IAuthenticatedGroup, or IEveryoneGroup utilities are\nprovided.\n\nLets define a group-aware principal:\n\n  >>> import zope.security.interfaces\n  >>> @interface.implementer(zope.security.interfaces.IGroupAwarePrincipal)\n  ... class GroupAwarePrincipal(Principal):\n  ...     def __init__(self, id):\n  ...         Principal.__init__(self, id)\n  ...         self.groups = []\n\nIf we notify the subscriber with this principal, nothing will happen\nbecause the groups haven't been defined:\n\n  >>> prin = GroupAwarePrincipal('x')\n  >>> event = interfaces.FoundPrincipalCreated(42, prin, {})\n  >>> zope.pluggableauth.plugins.groupfolder.specialGroups(event)\n  >>> prin.groups\n  []\n\nNow, if we define the Everybody group:\n\n  >>> import zope.authentication.interfaces\n  >>> @interface.implementer(zope.authentication.interfaces.IEveryoneGroup)\n  ... class EverybodyGroup(Principal):\n  ...     pass\n\n  >>> everybody = EverybodyGroup('all')\n  >>> provideUtility(everybody, zope.authentication.interfaces.IEveryoneGroup)\n\nThen the group will be added to the principal:\n\n  >>> zope.pluggableauth.plugins.groupfolder.specialGroups(event)\n  >>> prin.groups\n  ['all']\n\nSimilarly for the authenticated group:\n\n  >>> @interface.implementer(\n  ...         zope.authentication.interfaces.IAuthenticatedGroup)\n  ... class AuthenticatedGroup(Principal):\n  ...     pass\n\n  >>> authenticated = AuthenticatedGroup('auth')\n  >>> provideUtility(authenticated, zope.authentication.interfaces.IAuthenticatedGroup)\n\nThen the group will be added to the principal:\n\n  >>> prin.groups = []\n  >>> zope.pluggableauth.plugins.groupfolder.specialGroups(event)\n  >>> prin.groups.sort()\n  >>> prin.groups\n  ['all', 'auth']\n\nThese groups are only added to non-group principals:\n\n  >>> prin.groups = []\n  >>> interface.directlyProvides(prin, zope.security.interfaces.IGroup)\n  >>> zope.pluggableauth.plugins.groupfolder.specialGroups(event)\n  >>> prin.groups\n  []\n\nAnd they are only added to group aware principals:\n\n  >>> @interface.implementer(zope.security.interfaces.IPrincipal)\n  ... class SolitaryPrincipal:\n  ...     id = title = description = ''\n\n  >>> event = interfaces.FoundPrincipalCreated(42, SolitaryPrincipal(), {})\n  >>> zope.pluggableauth.plugins.groupfolder.specialGroups(event)\n  >>> prin.groups\n  []\n\nMember-aware groups\n===================\nThe groupfolder includes a subscriber that gives group principals the\nzope.security.interfaces.IGroupAware interface and an implementation thereof.\nThis allows groups to be able to get and set their members.\n\nGiven an info object and a group...\n\n    >>> @interface.implementer(\n    ...         zope.pluggableauth.plugins.groupfolder.IGroupInformation)\n    ... class DemoGroupInformation(object):\n    ...     def __init__(self, title, description, principals):\n    ...         self.title = title\n    ...         self.description = description\n    ...         self.principals = principals\n    ...\n    >>> i = DemoGroupInformation(\n    ...     'Managers', 'Taskmasters', ('joe', 'jane'))\n    ...\n    >>> info = zope.pluggableauth.plugins.groupfolder.GroupInfo(\n    ...     'groups.managers', i)\n    >>> @interface.implementer(IGroupAwarePrincipal)\n    ... class DummyGroup(object):\n    ...     def __init__(self, id, title=u'', description=u''):\n    ...         self.id = id\n    ...         self.title = title\n    ...         self.description = description\n    ...         self.groups = []\n    ...\n    >>> principal = DummyGroup('foo')\n    >>> zope.security.interfaces.IMemberAwareGroup.providedBy(principal)\n    False\n\n...when you call the subscriber, it adds the two pseudo-methods to the\nprincipal and makes the principal provide the IMemberAwareGroup interface.\n\n    >>> zope.pluggableauth.plugins.groupfolder.setMemberSubscriber(\n    ...     interfaces.FoundPrincipalCreated(\n    ...         'dummy auth (ignored)', principal, info))\n    >>> principal.getMembers()\n    ('joe', 'jane')\n    >>> principal.setMembers(('joe', 'jane', 'jaimie'))\n    >>> principal.getMembers()\n    ('joe', 'jane', 'jaimie')\n    >>> zope.security.interfaces.IMemberAwareGroup.providedBy(principal)\n    True\n\nThe two methods work with the value on the IGroupInformation object.\n\n    >>> i.principals == principal.getMembers()\n    True\n\nLimitation\n----------\n\nThe current group-folder design has an important limitation!\n\nThere is no point in assigning principals to a group\nfrom a group folder unless the principal is from the same pluggable\nauthentication utility.\n\n* If a principal is from a higher authentication utility, the user\n  will not get the group definition. Why? Because the principals\n  group assignments are set when the principal is authenticated. At\n  that point, the current site is the site containing the principal\n  definition. Groups defined in lower sites will not be consulted,\n\n* It is impossible to assign users from lower authentication\n  utilities because they can't be seen when managing the group,\n  from the site containing the group.\n\nA better design might be to store user-role assignments independent of\nthe group definitions and to look for assignments during (url)\ntraversal.  This could get quite complex though.\n\nWhile it is possible to have multiple authentication utilities long a\nURL path, it is generally better to stick to a simpler model in which\nthere is only one authentication utility along a URL path (in addition\nto the global utility, which is used for bootstrapping purposes).\n\n\n=========\n Changes\n=========\n\n2.3.0 (2017-11-12)\n==================\n\n- Drop support for Python 3.3.\n\n\n2.2.0 (2017-05-02)\n==================\n\n- Add support for Python 3.6.\n\n- Fix a NameError in the idpicker under Python 3.6.\n  See `issue 7 <https://github.com/zopefoundation/zope.pluggableauth/issues/7>`_.\n\n2.1.0 (2016-07-04)\n==================\n\n- Add support for Python 3.5.\n\n- Drop support for Python 2.6.\n\n\n2.0.0 (2014-12-24)\n==================\n\n- Add support for Python 3.4.\n\n- Refactor ``zope.pluggableauth.plugins.session.redirectWithComeFrom``\n  into a reusable function.\n\n- Fix: allow password containing colon(s) in HTTP basic authentication\n  credentials extraction plug-in, to conform with RFC2617\n\n\n2.0.0a1 (2013-02-21)\n====================\n\n- Add ``tox.ini`` and ``MANIFEST.in``.\n\n- Add support for Python 3.3.\n\n- Replace deprecated ``zope.component.adapts`` usage with equivalent\n  ``zope.component.adapter`` decorator.\n\n- Replace deprecated ``zope.interface.implements`` usage with equivalent\n  ``zope.interface.implementer`` decorator.\n\n- Drop support for Python 2.4 and 2.5.\n\n\n1.3 (2011-02-08)\n================\n\n- As the ``camefrom`` information is most probably used for a redirect,\n  require it to be an absolute URL (see also\n  http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.30).\n\n1.2 (2010-12-16)\n================\n\n- Add a hook to ``SessionCredentialsPlugin`` (``_makeCredentials``) that can\n  be overriden in subclasses to store the credentials in the session\n  differently.\n\n  For example, you could use ``keas.kmi`` and encrypt the passwords of the\n  currently logged-in users so they don't appear in plain text in the ZODB.\n\n1.1 (2010-10-18)\n================\n\n- Move concrete ``IAuthenticatorPlugin`` implementations from\n  ``zope.app.authentication`` to ``zope.pluggableauth.plugins``.\n\n  As a result, projects that want to use the ``IAuthenticator`` plugins\n  (previously found in ``zope.app.authentication``) do not automatically\n  also pull in the ``zope.app.*`` dependencies that are needed to register\n  the ZMI views.\n\n1.0.3 (2010-07-09)\n==================\n\n- Fix dependency declaration.\n\n1.0.2 (2010-07-90)\n==================\n\n- Add ``persistent.Persistent`` and ``zope.container.contained.Contained`` as\n  bases for ``zope.pluggableauth.plugins.session.SessionCredentialsPlugin``,\n  so instances of ``zope.app.authentication.session.SessionCredentialsPlugin``\n  won't be changed.\n  (https://mail.zope.org/pipermail/zope-dev/2010-July/040898.html)\n\n1.0.1 (2010-02-11)\n==================\n\n* Declare adapter in a new ZCML file : `principalfactories.zcml`.  Avoids\n  duplication errors in ``zope.app.authentication``.\n\n1.0 (2010-02-05)\n================\n\n* Splitting off from zope.app.authentication\n\n\n", "description_content_type": null, "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "http://pypi.python.org/pypi/zope.pluggableauth", "keywords": "zope3 ztk authentication pluggable", "license": "ZPL 2.1", "maintainer": "", "maintainer_email": "", "name": "zope.pluggableauth", "package_url": "https://pypi.org/project/zope.pluggableauth/", "platform": "", "project_url": "https://pypi.org/project/zope.pluggableauth/", "project_urls": {"Homepage": "http://pypi.python.org/pypi/zope.pluggableauth"}, "release_url": "https://pypi.org/project/zope.pluggableauth/2.3.0/", "requires_dist": ["persistent", "setuptools", "transaction", "zope.authentication", "zope.component", "zope.container", "zope.event", "zope.i18nmessageid", "zope.interface", "zope.password (>=3.5.1)", "zope.publisher (>=3.12)", "zope.schema", "zope.security", "zope.session", "zope.site", "zope.traversing", "zope.testing; extra == 'test'", "zope.testrunner; extra == 'test'"], "requires_python": "", "summary": "Pluggable Authentication Utility", "version": "2.3.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            <div id=\"zope-pluggableauth\">\n<h2><tt>zope.pluggableauth</tt></h2>\n<a href=\"https://travis-ci.org/zopefoundation/zope.pluggableauth\" rel=\"nofollow\"><img alt=\"https://travis-ci.org/zopefoundation/zope.pluggableauth.svg?branch=master\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/34a12b8a59f227440bea41a5c669933dd91b9be9/68747470733a2f2f7472617669732d63692e6f72672f7a6f7065666f756e646174696f6e2f7a6f70652e706c75676761626c65617574682e7376673f6272616e63683d6d6173746572\"></a>\n<p>Based on <tt>zope.authentication</tt>, this package provides a flexible and\npluggable authentication utility, and provides a number of common plugins.</p>\n</div>\n<div id=\"pluggable-authentication-utility\">\n<h2>Pluggable-Authentication Utility</h2>\n<p>The Pluggable-Authentication Utility (PAU) provides a framework for\nauthenticating principals and associating information with them. It uses\nplugins and subscribers to get its work done.</p>\n<p>For a pluggable-authentication utility to be used, it should be\nregistered as a utility providing the\n<cite>zope.authentication.interfaces.IAuthentication</cite> interface.</p>\n<div id=\"authentication\">\n<h3>Authentication</h3>\n<p>The primary job of PAU is to authenticate principals. It uses two types of\nplug-ins in its work:</p>\n<ul>\n<li>Credentials Plugins</li>\n<li>Authenticator Plugins</li>\n</ul>\n<p>Credentials plugins are responsible for extracting user credentials from a\nrequest. A credentials plugin may in some cases issue a \u2018challenge\u2019 to obtain\ncredentials. For example, a \u2018session\u2019 credentials plugin reads credentials\nfrom a session (the \u201cextraction\u201d). If it cannot find credentials, it will\nredirect the user to a login form in order to provide them (the \u201cchallenge\u201d).</p>\n<p>Authenticator plugins are responsible for authenticating the credentials\nextracted by a credentials plugin. They are also typically able to create\nprincipal objects for credentials they successfully authenticate.</p>\n<p>Given a request object, the PAU returns a principal object, if it can. The PAU\ndoes this by first iterating through its credentials plugins to obtain a\nset of credentials. If it gets credentials, it iterates through its\nauthenticator plugins to authenticate them.</p>\n<p>If an authenticator succeeds in authenticating a set of credentials, the PAU\nuses the authenticator to create a principal corresponding to the credentials.\nThe authenticator notifies subscribers if an authenticated principal is\ncreated. Subscribers are responsible for adding data, especially groups, to\nthe principal. Typically, if a subscriber adds data, it should also add\ncorresponding interface declarations.</p>\n<div id=\"simple-credentials-plugin\">\n<h4>Simple Credentials Plugin</h4>\n<p>To illustrate, we\u2019ll create a simple credentials plugin:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from zope import interface\n&gt;&gt;&gt; from zope.pluggableauth.authentication import interfaces\n</pre>\n<pre>&gt;&gt;&gt; @interface.implementer(interfaces.ICredentialsPlugin)\n... class MyCredentialsPlugin(object):\n...\n...     def extractCredentials(self, request):\n...         return request.get('credentials')\n...\n...     def challenge(self, request):\n...         pass # challenge is a no-op for this plugin\n...\n...     def logout(self, request):\n...         pass # logout is a no-op for this plugin\n</pre>\n</blockquote>\n<p>As a plugin, MyCredentialsPlugin needs to be registered as a named utility:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; myCredentialsPlugin = MyCredentialsPlugin()\n&gt;&gt;&gt; provideUtility(myCredentialsPlugin, name='My Credentials Plugin')\n</pre>\n</blockquote>\n</div>\n<div id=\"simple-authenticator-plugin\">\n<h4>Simple Authenticator Plugin</h4>\n<p>Next we\u2019ll create a simple authenticator plugin. For our plugin, we\u2019ll need\nan implementation of IPrincipalInfo:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; @interface.implementer(interfaces.IPrincipalInfo)\n... class PrincipalInfo(object):\n...\n...     def __init__(self, id, title, description):\n...         self.id = id\n...         self.title = title\n...         self.description = description\n...\n...     def __repr__(self):\n...         return 'PrincipalInfo(%r)' % self.id\n</pre>\n</blockquote>\n<p>Our authenticator uses this type when it creates a principal info:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; @interface.implementer(interfaces.IAuthenticatorPlugin)\n... class MyAuthenticatorPlugin(object):\n...\n...     def authenticateCredentials(self, credentials):\n...         if credentials == 'secretcode':\n...             return PrincipalInfo('bob', 'Bob', '')\n...\n...     def principalInfo(self, id):\n...         pass # plugin not currently supporting search\n</pre>\n</blockquote>\n<p>As with the credentials plugin, the authenticator plugin must be registered\nas a named utility:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; myAuthenticatorPlugin = MyAuthenticatorPlugin()\n&gt;&gt;&gt; provideUtility(myAuthenticatorPlugin, name='My Authenticator Plugin')\n</pre>\n</blockquote>\n</div>\n<div id=\"configuring-a-pau\">\n<h4>Configuring a PAU</h4>\n<p>Finally, we\u2019ll create the PAU itself:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from zope.pluggableauth import authentication\n&gt;&gt;&gt; pau = authentication.PluggableAuthentication('xyz_')\n</pre>\n</blockquote>\n<p>and configure it with the two plugins:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; pau.credentialsPlugins = ('My Credentials Plugin', )\n&gt;&gt;&gt; pau.authenticatorPlugins = ('My Authenticator Plugin', )\n</pre>\n</blockquote>\n</div>\n<div id=\"using-the-pau-to-authenticate\">\n<h4>Using the PAU to Authenticate</h4>\n<blockquote>\n<pre>&gt;&gt;&gt; from zope.pluggableauth.factories import AuthenticatedPrincipalFactory\n&gt;&gt;&gt; provideAdapter(AuthenticatedPrincipalFactory)\n</pre>\n</blockquote>\n<p>We can now use the PAU to authenticate a sample request:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from zope.publisher.browser import TestRequest\n&gt;&gt;&gt; print(pau.authenticate(TestRequest()))\nNone\n</pre>\n</blockquote>\n<p>In this case, we cannot authenticate an empty request. In the same way, we\nwill not be able to authenticate a request with the wrong credentials:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; print(pau.authenticate(TestRequest(credentials='let me in!')))\nNone\n</pre>\n</blockquote>\n<p>However, if we provide the proper credentials:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; request = TestRequest(credentials='secretcode')\n&gt;&gt;&gt; principal = pau.authenticate(request)\n&gt;&gt;&gt; principal\nPrincipal('xyz_bob')\n</pre>\n</blockquote>\n<p>we get an authenticated principal.</p>\n</div>\n<div id=\"multiple-authenticator-plugins\">\n<h4>Multiple Authenticator Plugins</h4>\n<p>The PAU works with multiple authenticator plugins. It uses each plugin, in the\norder specified in the PAU\u2019s authenticatorPlugins attribute, to authenticate\na set of credentials.</p>\n<p>To illustrate, we\u2019ll create another authenticator:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; class MyAuthenticatorPlugin2(MyAuthenticatorPlugin):\n...\n...     def authenticateCredentials(self, credentials):\n...         if credentials == 'secretcode':\n...             return PrincipalInfo('black', 'Black Spy', '')\n...         elif credentials == 'hiddenkey':\n...             return PrincipalInfo('white', 'White Spy', '')\n</pre>\n<pre>&gt;&gt;&gt; provideUtility(MyAuthenticatorPlugin2(), name='My Authenticator Plugin 2')\n</pre>\n</blockquote>\n<p>If we put it before the original authenticator:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; pau.authenticatorPlugins = (\n...     'My Authenticator Plugin 2',\n...     'My Authenticator Plugin')\n</pre>\n</blockquote>\n<p>Then it will be given the first opportunity to authenticate a request:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; pau.authenticate(TestRequest(credentials='secretcode'))\nPrincipal('xyz_black')\n</pre>\n</blockquote>\n<p>If neither plugins can authenticate, pau returns None:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; print(pau.authenticate(TestRequest(credentials='let me in!!')))\nNone\n</pre>\n</blockquote>\n<p>When we change the order of the authenticator plugins:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; pau.authenticatorPlugins = (\n...     'My Authenticator Plugin',\n...     'My Authenticator Plugin 2')\n</pre>\n</blockquote>\n<p>we see that our original plugin is now acting first:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; pau.authenticate(TestRequest(credentials='secretcode'))\nPrincipal('xyz_bob')\n</pre>\n</blockquote>\n<p>The second plugin, however, gets a chance to authenticate if first does not:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; pau.authenticate(TestRequest(credentials='hiddenkey'))\nPrincipal('xyz_white')\n</pre>\n</blockquote>\n</div>\n<div id=\"multiple-credentials-plugins\">\n<h4>Multiple Credentials Plugins</h4>\n<p>As with with authenticators, we can specify multiple credentials plugins. To\nillustrate, we\u2019ll create a credentials plugin that extracts credentials from\na request form:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; @interface.implementer(interfaces.ICredentialsPlugin)\n... class FormCredentialsPlugin:\n...\n...     def extractCredentials(self, request):\n...         return request.form.get('my_credentials')\n...\n...     def challenge(self, request):\n...         pass\n...\n...     def logout(request):\n...         pass\n</pre>\n<pre>&gt;&gt;&gt; provideUtility(FormCredentialsPlugin(),\n...                name='Form Credentials Plugin')\n</pre>\n</blockquote>\n<p>and insert the new credentials plugin before the existing plugin:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; pau.credentialsPlugins = (\n...     'Form Credentials Plugin',\n...     'My Credentials Plugin')\n</pre>\n</blockquote>\n<p>The PAU will use each plugin in order to try and obtain credentials from a\nrequest:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; pau.authenticate(TestRequest(credentials='secretcode',\n...                              form={'my_credentials': 'hiddenkey'}))\nPrincipal('xyz_white')\n</pre>\n</blockquote>\n<p>In this case, the first credentials plugin succeeded in getting credentials\nfrom the form and the second authenticator was able to authenticate the\ncredentials. Specifically, the PAU went through these steps:</p>\n<ul>\n<li>Get credentials using \u2018Form Credentials Plugin\u2019</li>\n<li>Got \u2018hiddenkey\u2019 credentials using \u2018Form Credentials Plugin\u2019, try to\nauthenticate using \u2018My Authenticator Plugin\u2019</li>\n<li>Failed to authenticate \u2018hiddenkey\u2019 with \u2018My Authenticator Plugin\u2019, try\n\u2018My Authenticator Plugin 2\u2019</li>\n<li>Succeeded in authenticating with \u2018My Authenticator Plugin 2\u2019</li>\n</ul>\n<p>Let\u2019s try a different scenario:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; pau.authenticate(TestRequest(credentials='secretcode'))\nPrincipal('xyz_bob')\n</pre>\n</blockquote>\n<p>In this case, the PAU went through these steps:</p>\n<pre>- Get credentials using 'Form Credentials Plugin'\n</pre>\n<ul>\n<li>Failed to get credentials using \u2018Form Credentials Plugin\u2019, try\n\u2018My Credentials Plugin\u2019</li>\n<li>Got \u2018scecretcode\u2019 credentials using \u2018My Credentials Plugin\u2019, try to\nauthenticate using \u2018My Authenticator Plugin\u2019</li>\n<li>Succeeded in authenticating with \u2018My Authenticator Plugin\u2019</li>\n</ul>\n<p>Let\u2019s try a slightly more complex scenario:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; pau.authenticate(TestRequest(credentials='hiddenkey',\n...                              form={'my_credentials': 'bogusvalue'}))\nPrincipal('xyz_white')\n</pre>\n</blockquote>\n<p>This highlights PAU\u2019s ability to use multiple plugins for authentication:</p>\n<ul>\n<li>Get credentials using \u2018Form Credentials Plugin\u2019</li>\n<li>Got \u2018bogusvalue\u2019 credentials using \u2018Form Credentials Plugin\u2019, try to\nauthenticate using \u2018My Authenticator Plugin\u2019</li>\n<li>Failed to authenticate \u2018boguskey\u2019 with \u2018My Authenticator Plugin\u2019, try\n\u2018My Authenticator Plugin 2\u2019</li>\n<li>Failed to authenticate \u2018boguskey\u2019 with \u2018My Authenticator Plugin 2\u2019 \u2013\nthere are no more authenticators to try, so lets try the next credentials\nplugin for some new credentials</li>\n<li>Get credentials using \u2018My Credentials Plugin\u2019</li>\n<li>Got \u2018hiddenkey\u2019 credentials using \u2018My Credentials Plugin\u2019, try to\nauthenticate using \u2018My Authenticator Plugin\u2019</li>\n<li>Failed to authenticate \u2018hiddenkey\u2019 using \u2018My Authenticator Plugin\u2019, try\n\u2018My Authenticator Plugin 2\u2019</li>\n<li>Succeeded in authenticating with \u2018My Authenticator Plugin 2\u2019 (shouts and\ncheers!)</li>\n</ul>\n</div>\n<div id=\"id1\">\n<h4>Multiple Authenticator Plugins</h4>\n<p>As with the other operations we\u2019ve seen, the PAU uses multiple plugins to\nfind a principal. If the first authenticator plugin can\u2019t find the requested\nprincipal, the next plugin is used, and so on.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; @interface.implementer(interfaces.IAuthenticatorPlugin)\n... class AnotherAuthenticatorPlugin:\n...\n...     def __init__(self):\n...         self.infos = {}\n...         self.ids = {}\n...\n...     def principalInfo(self, id):\n...         return self.infos.get(id)\n...\n...     def authenticateCredentials(self, credentials):\n...         id = self.ids.get(credentials)\n...         if id is not None:\n...             return self.infos[id]\n...\n...     def add(self, id, title, description, credentials):\n...         self.infos[id] = PrincipalInfo(id, title, description)\n...         self.ids[credentials] = id\n</pre>\n</blockquote>\n<p>To illustrate, we\u2019ll create and register two authenticators:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; authenticator1 = AnotherAuthenticatorPlugin()\n&gt;&gt;&gt; provideUtility(authenticator1, name='Authentication Plugin 1')\n</pre>\n<pre>&gt;&gt;&gt; authenticator2 = AnotherAuthenticatorPlugin()\n&gt;&gt;&gt; provideUtility(authenticator2, name='Authentication Plugin 2')\n</pre>\n</blockquote>\n<p>and add a principal to them:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; authenticator1.add('bob', 'Bob', 'A nice guy', 'b0b')\n&gt;&gt;&gt; authenticator1.add('white', 'White Spy', 'Sneaky', 'deathtoblack')\n&gt;&gt;&gt; authenticator2.add('black', 'Black Spy', 'Also sneaky', 'deathtowhite')\n</pre>\n</blockquote>\n<p>When we configure the PAU to use both searchable authenticators (note the\norder):</p>\n<blockquote>\n<pre>&gt;&gt;&gt; pau.authenticatorPlugins = (\n...     'Authentication Plugin 2',\n...     'Authentication Plugin 1')\n</pre>\n</blockquote>\n<p>we register the factories for our principals:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from zope.pluggableauth.factories import FoundPrincipalFactory\n&gt;&gt;&gt; provideAdapter(FoundPrincipalFactory)\n</pre>\n</blockquote>\n<p>we see how the PAU uses both plugins:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; pau.getPrincipal('xyz_white')\nPrincipal('xyz_white')\n</pre>\n<pre>&gt;&gt;&gt; pau.getPrincipal('xyz_black')\nPrincipal('xyz_black')\n</pre>\n</blockquote>\n<p>If more than one plugin know about the same principal ID, the first plugin is\nused and the remaining are not delegated to. To illustrate, we\u2019ll add\nanother principal with the same ID as an existing principal:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; authenticator2.add('white', 'White Rider', '', 'r1der')\n&gt;&gt;&gt; pau.getPrincipal('xyz_white').title\n'White Rider'\n</pre>\n</blockquote>\n<p>If we change the order of the plugins:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; pau.authenticatorPlugins = (\n...     'Authentication Plugin 1',\n...     'Authentication Plugin 2')\n</pre>\n</blockquote>\n<p>we get a different principal for ID \u2018white\u2019:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; pau.getPrincipal('xyz_white').title\n'White Spy'\n</pre>\n</blockquote>\n</div>\n</div>\n<div id=\"issuing-a-challenge\">\n<h3>Issuing a Challenge</h3>\n<p>Part of PAU\u2019s IAuthentication contract is to challenge the user for\ncredentials when its \u2018unauthorized\u2019 method is called. The need for this\nfunctionality is driven by the following use case:</p>\n<ul>\n<li>A user attempts to perform an operation he is not authorized to perform.</li>\n<li>A handler responds to the unauthorized error by calling IAuthentication\n\u2018unauthorized\u2019.</li>\n<li>The authentication component (in our case, a PAU) issues a challenge to\nthe user to collect new credentials (typically in the form of logging in\nas a new user).</li>\n</ul>\n<p>The PAU handles the credentials challenge by delegating to its credentials\nplugins.</p>\n<p>Currently, the PAU is configured with the credentials plugins that don\u2019t\nperform any action when asked to challenge (see above the \u2018challenge\u2019 methods).</p>\n<p>To illustrate challenges, we\u2019ll subclass an existing credentials plugin and\ndo something in its \u2018challenge\u2019:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; class LoginFormCredentialsPlugin(FormCredentialsPlugin):\n...\n...     def __init__(self, loginForm):\n...         self.loginForm = loginForm\n...\n...     def challenge(self, request):\n...         request.response.redirect(self.loginForm)\n...         return True\n</pre>\n</blockquote>\n<p>This plugin handles a challenge by redirecting the response to a login form.\nIt returns True to signal to the PAU that it handled the challenge.</p>\n<p>We will now create and register a couple of these plugins:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; provideUtility(LoginFormCredentialsPlugin('simplelogin.html'),\n...                name='Simple Login Form Plugin')\n</pre>\n<pre>&gt;&gt;&gt; provideUtility(LoginFormCredentialsPlugin('advancedlogin.html'),\n...                name='Advanced Login Form Plugin')\n</pre>\n</blockquote>\n<p>and configure the PAU to use them:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; pau.credentialsPlugins = (\n...     'Simple Login Form Plugin',\n...     'Advanced Login Form Plugin')\n</pre>\n</blockquote>\n<p>Now when we call \u2018unauthorized\u2019 on the PAU:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; request = TestRequest()\n&gt;&gt;&gt; pau.unauthorized(id=None, request=request)\n</pre>\n</blockquote>\n<p>we see that the user is redirected to the simple login form:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; request.response.getStatus()\n302\n&gt;&gt;&gt; request.response.getHeader('location')\n'simplelogin.html'\n</pre>\n</blockquote>\n<p>We can change the challenge policy by reordering the plugins:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; pau.credentialsPlugins = (\n...     'Advanced Login Form Plugin',\n...     'Simple Login Form Plugin')\n</pre>\n</blockquote>\n<p>Now when we call \u2018unauthorized\u2019:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; request = TestRequest()\n&gt;&gt;&gt; pau.unauthorized(id=None, request=request)\n</pre>\n</blockquote>\n<p>the advanced plugin is used because it\u2019s first:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; request.response.getStatus()\n302\n&gt;&gt;&gt; request.response.getHeader('location')\n'advancedlogin.html'\n</pre>\n</blockquote>\n<div id=\"challenge-protocols\">\n<h4>Challenge Protocols</h4>\n<p>Sometimes, we want multiple challengers to work together. For example, the\nHTTP specification allows multiple challenges to be issued in a response. A\nchallenge plugin can provide a <cite>challengeProtocol</cite> attribute that effectively\ngroups related plugins together for challenging. If a plugin returns <cite>True</cite>\nfrom its challenge and provides a non-None challengeProtocol, subsequent\nplugins in the credentialsPlugins list that have the same challenge protocol\nwill also be used to challenge.</p>\n<p>Without a challengeProtocol, only the first plugin to succeed in a challenge\nwill be used.</p>\n<p>Let\u2019s look at an example. We\u2019ll define a new plugin that specifies an\n\u2018X-Challenge\u2019 protocol:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; class XChallengeCredentialsPlugin(FormCredentialsPlugin):\n...\n...     challengeProtocol = 'X-Challenge'\n...\n...     def __init__(self, challengeValue):\n...         self.challengeValue = challengeValue\n...\n...     def challenge(self, request):\n...         value = self.challengeValue\n...         existing = request.response.getHeader('X-Challenge', '')\n...         if existing:\n...             value += ' ' + existing\n...         request.response.setHeader('X-Challenge', value)\n...         return True\n</pre>\n</blockquote>\n<p>and register a couple instances as utilities:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; provideUtility(XChallengeCredentialsPlugin('basic'),\n...                name='Basic X-Challenge Plugin')\n</pre>\n<pre>&gt;&gt;&gt; provideUtility(XChallengeCredentialsPlugin('advanced'),\n...                name='Advanced X-Challenge Plugin')\n</pre>\n</blockquote>\n<p>When we use both plugins with the PAU:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; pau.credentialsPlugins = (\n...     'Basic X-Challenge Plugin',\n...     'Advanced X-Challenge Plugin')\n</pre>\n</blockquote>\n<p>and call \u2018unauthorized\u2019:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; request = TestRequest()\n&gt;&gt;&gt; pau.unauthorized(None, request)\n</pre>\n</blockquote>\n<p>we see that both plugins participate in the challenge, rather than just the\nfirst plugin:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; request.response.getHeader('X-Challenge')\n'advanced basic'\n</pre>\n</blockquote>\n</div>\n</div>\n<div id=\"pluggable-authentication-prefixes\">\n<h3>Pluggable-Authentication Prefixes</h3>\n<p>Principal ids are required to be unique system wide. Plugins will often provide\noptions for providing id prefixes, so that different sets of plugins provide\nunique ids within a PAU. If there are multiple pluggable-authentication\nutilities in a system, it\u2019s a good idea to give each PAU a unique prefix, so\nthat principal ids from different PAUs don\u2019t conflict. We can provide a prefix\nwhen a PAU is created:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; pau = authentication.PluggableAuthentication('mypau_')\n&gt;&gt;&gt; pau.credentialsPlugins = ('My Credentials Plugin', )\n&gt;&gt;&gt; pau.authenticatorPlugins = ('My Authenticator Plugin', )\n</pre>\n</blockquote>\n<p>When we create a request and try to authenticate:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; pau.authenticate(TestRequest(credentials='secretcode'))\nPrincipal('mypau_bob')\n</pre>\n</blockquote>\n<p>Note that now, our principal\u2019s id has the pluggable-authentication\nutility prefix.</p>\n<p>We can still lookup a principal, as long as we supply the prefix:</p>\n<pre>&gt;&gt; pau.getPrincipal('mypas_42')\nPrincipal('mypas_42', \"{'domain': 42}\")\n\n&gt;&gt; pau.getPrincipal('mypas_41')\nOddPrincipal('mypas_41', \"{'int': 41}\")\n</pre>\n</div>\n</div>\n<div id=\"principal-folder\">\n<h2>Principal Folder</h2>\n<p>Principal folders contain principal-information objects that contain principal\ninformation. We create an internal principal using the <cite>InternalPrincipal</cite>\nclass:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from zope.pluggableauth.plugins.principalfolder import InternalPrincipal\n&gt;&gt;&gt; p1 = InternalPrincipal('login1', '123', \"Principal 1\",\n...     passwordManagerName=\"SHA1\")\n&gt;&gt;&gt; p2 = InternalPrincipal('login2', '456', \"The Other One\")\n</pre>\n</blockquote>\n<p>and add them to a principal folder:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from zope.pluggableauth.plugins.principalfolder import PrincipalFolder\n&gt;&gt;&gt; principals = PrincipalFolder(u'principal.')\n&gt;&gt;&gt; principals['p1'] = p1\n&gt;&gt;&gt; principals['p2'] = p2\n</pre>\n</blockquote>\n<div id=\"id2\">\n<h3>Authentication</h3>\n<p>Principal folders provide the <cite>IAuthenticatorPlugin</cite> interface. When we\nprovide suitable credentials:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from pprint import pprint\n&gt;&gt;&gt; principals.authenticateCredentials({'login': 'login1', 'password': '123'})\nPrincipalInfo(u'principal.p1')\n</pre>\n</blockquote>\n<p>We get back a principal id and supplementary information, including the\nprincipal title and description.  Note that the principal id is a concatenation\nof the principal-folder prefix and the name of the principal-information object\nwithin the folder.</p>\n<p>None is returned if the credentials are invalid:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; principals.authenticateCredentials({'login': 'login1',\n...                                     'password': '1234'})\n&gt;&gt;&gt; principals.authenticateCredentials(42)\n</pre>\n</blockquote>\n</div>\n<div id=\"search\">\n<h3>Search</h3>\n<p>Principal folders also provide the IQuerySchemaSearch interface.  This\nsupports both finding principal information based on their ids:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; principals.principalInfo('principal.p1')\nPrincipalInfo('principal.p1')\n</pre>\n<pre>&gt;&gt;&gt; principals.principalInfo('p1')\n</pre>\n</blockquote>\n<p>and searching for principals based on a search string:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; list(principals.search({'search': 'other'}))\n[u'principal.p2']\n</pre>\n<pre>&gt;&gt;&gt; list(principals.search({'search': 'OTHER'}))\n[u'principal.p2']\n</pre>\n<pre>&gt;&gt;&gt; list(principals.search({'search': ''}))\n[u'principal.p1', u'principal.p2']\n</pre>\n<pre>&gt;&gt;&gt; list(principals.search({'search': 'eek'}))\n[]\n</pre>\n<pre>&gt;&gt;&gt; list(principals.search({}))\n[]\n</pre>\n</blockquote>\n<p>If there are a large number of matches:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; for i in range(20):\n...     i = str(i)\n...     p = InternalPrincipal('l'+i, i, \"Dude \"+i)\n...     principals[i] = p\n</pre>\n<pre>&gt;&gt;&gt; pprint(list(principals.search({'search': 'D'})), width=25)\n[u'principal.0',\n u'principal.1',\n u'principal.10',\n u'principal.11',\n u'principal.12',\n u'principal.13',\n u'principal.14',\n u'principal.15',\n u'principal.16',\n u'principal.17',\n u'principal.18',\n u'principal.19',\n u'principal.2',\n u'principal.3',\n u'principal.4',\n u'principal.5',\n u'principal.6',\n u'principal.7',\n u'principal.8',\n u'principal.9']\n</pre>\n</blockquote>\n<p>We can use batching parameters to specify a subset of results:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; pprint(list(principals.search({'search': 'D'}, start=17)))\n[u'principal.7', u'principal.8', u'principal.9']\n</pre>\n<pre>&gt;&gt;&gt; pprint(list(principals.search({'search': 'D'}, batch_size=5)), width=60)\n[u'principal.0',\n u'principal.1',\n u'principal.10',\n u'principal.11',\n u'principal.12']\n</pre>\n<pre>&gt;&gt;&gt; pprint(list(principals.search({'search': 'D'}, start=5, batch_size=5)),\n...        width=25)\n[u'principal.13',\n u'principal.14',\n u'principal.15',\n u'principal.16',\n u'principal.17']\n</pre>\n</blockquote>\n<p>There is an additional method that allows requesting the principal id\nassociated with a login id.  The method raises KeyError when there is\nno associated principal:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; principals.getIdByLogin(\"not-there\")\nTraceback (most recent call last):\nKeyError: 'not-there'\n</pre>\n</blockquote>\n<p>If there is a matching principal, the id is returned:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; principals.getIdByLogin(\"login1\")\nu'principal.p1'\n</pre>\n</blockquote>\n</div>\n<div id=\"changing-credentials\">\n<h3>Changing credentials</h3>\n<p>Credentials can be changed by modifying principal-information objects:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; p1.login = 'bob'\n&gt;&gt;&gt; p1.password = 'eek'\n</pre>\n<pre>&gt;&gt;&gt; principals.authenticateCredentials({'login': 'bob', 'password': 'eek'})\nPrincipalInfo(u'principal.p1')\n</pre>\n<pre>&gt;&gt;&gt; principals.authenticateCredentials({'login': 'login1',\n...                                     'password': 'eek'})\n</pre>\n<pre>&gt;&gt;&gt; principals.authenticateCredentials({'login': 'bob',\n...                                     'password': '123'})\n</pre>\n</blockquote>\n<p>It is an error to try to pick a login name that is already taken:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; p1.login = 'login2'\nTraceback (most recent call last):\n...\nValueError: Principal Login already taken!\n</pre>\n</blockquote>\n<p>If such an attempt is made, the data are unchanged:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; principals.authenticateCredentials({'login': 'bob', 'password': 'eek'})\nPrincipalInfo(u'principal.p1')\n</pre>\n</blockquote>\n</div>\n<div id=\"removing-principals\">\n<h3>Removing principals</h3>\n<p>Of course, if a principal is removed, we can no-longer authenticate it:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; del principals['p1']\n&gt;&gt;&gt; principals.authenticateCredentials({'login': 'bob',\n...                                     'password': 'eek'})\n</pre>\n</blockquote>\n</div>\n</div>\n<div id=\"group-folders\">\n<h2>Group Folders</h2>\n<p>Group folders provide support for groups information stored in the ZODB.  They\nare persistent, and must be contained within the PAUs that use them.</p>\n<p>Like other principals, groups are created when they are needed.</p>\n<p>Group folders contain group-information objects that contain group information.\nWe create group information using the <cite>GroupInformation</cite> class:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; import zope.pluggableauth.plugins.groupfolder\n&gt;&gt;&gt; g1 = zope.pluggableauth.plugins.groupfolder.GroupInformation(\"Group 1\")\n</pre>\n<pre>&gt;&gt;&gt; groups = zope.pluggableauth.plugins.groupfolder.GroupFolder('group.')\n&gt;&gt;&gt; groups['g1'] = g1\n</pre>\n</blockquote>\n<p>Note that when group-info is added, a GroupAdded event is generated:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from zope.pluggableauth import interfaces\n&gt;&gt;&gt; from zope.component.eventtesting import getEvents\n&gt;&gt;&gt; getEvents(interfaces.IGroupAdded)\n[&lt;GroupAdded 'group.g1'&gt;]\n</pre>\n</blockquote>\n<p>Groups are defined with respect to an authentication service.  Groups\nmust be accessible via an authentication service and can contain\nprincipals accessible via an authentication service.</p>\n<p>To illustrate the group interaction with the authentication service,\nwe\u2019ll create a sample authentication service:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from zope import interface\n&gt;&gt;&gt; from zope.authentication.interfaces import IAuthentication\n&gt;&gt;&gt; from zope.authentication.interfaces import PrincipalLookupError\n&gt;&gt;&gt; from zope.security.interfaces import IGroupAwarePrincipal\n&gt;&gt;&gt; from zope.pluggableauth.plugins.groupfolder import setGroupsForPrincipal\n</pre>\n<pre>&gt;&gt;&gt; @interface.implementer(IGroupAwarePrincipal)\n... class Principal:\n...     def __init__(self, id, title='', description=''):\n...         self.id, self.title, self.description = id, title, description\n...         self.groups = []\n</pre>\n<pre>&gt;&gt;&gt; class PrincipalCreatedEvent:\n...     def __init__(self, authentication, principal):\n...         self.authentication = authentication\n...         self.principal = principal\n</pre>\n<pre>&gt;&gt;&gt; from zope.pluggableauth.plugins import principalfolder\n</pre>\n<pre>&gt;&gt;&gt; @interface.implementer(IAuthentication)\n... class Principals:\n...     def __init__(self, groups, prefix='auth.'):\n...         self.prefix = prefix\n...         self.principals = {\n...            'p1': principalfolder.PrincipalInfo('p1', '', '', ''),\n...            'p2': principalfolder.PrincipalInfo('p2', '', '', ''),\n...            'p3': principalfolder.PrincipalInfo('p3', '', '', ''),\n...            'p4': principalfolder.PrincipalInfo('p4', '', '', ''),\n...            }\n...         self.groups = groups\n...         groups.__parent__ = self\n...\n...     def getAuthenticatorPlugins(self):\n...         return [('principals', self.principals), ('groups', self.groups)]\n...\n...     def getPrincipal(self, id):\n...         if not id.startswith(self.prefix):\n...             raise PrincipalLookupError(id)\n...         id = id[len(self.prefix):]\n...         info = self.principals.get(id)\n...         if info is None:\n...             info = self.groups.principalInfo(id)\n...             if info is None:\n...                raise PrincipalLookupError(id)\n...         principal = Principal(self.prefix+info.id,\n...                               info.title, info.description)\n...         setGroupsForPrincipal(PrincipalCreatedEvent(self, principal))\n...         return principal\n</pre>\n</blockquote>\n<p>This class doesn\u2019t really implement the full <cite>IAuthentication</cite> interface, but\nit implements the <cite>getPrincipal</cite> method used by groups. It works very much\nlike the pluggable authentication utility.  It creates principals on demand. It\ncalls <cite>setGroupsForPrincipal</cite>, which is normally called as an event subscriber,\nwhen principals are created. In order for <cite>setGroupsForPrincipal</cite> to find out\ngroup folder, we have to register it as a utility:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from zope.pluggableauth.interfaces import IAuthenticatorPlugin\n&gt;&gt;&gt; from zope.component import provideUtility\n&gt;&gt;&gt; provideUtility(groups, IAuthenticatorPlugin)\n</pre>\n</blockquote>\n<p>We will create and register a new principals utility:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; principals = Principals(groups)\n&gt;&gt;&gt; provideUtility(principals, IAuthentication)\n</pre>\n</blockquote>\n<p>Now we can set the principals on the group:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; g1.principals = ['auth.p1', 'auth.p2']\n&gt;&gt;&gt; g1.principals\n('auth.p1', 'auth.p2')\n</pre>\n</blockquote>\n<p>Adding principals fires an event.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; getEvents(interfaces.IPrincipalsAddedToGroup)[-1]\n&lt;PrincipalsAddedToGroup ['auth.p1', 'auth.p2'] u'auth.group.g1'&gt;\n</pre>\n</blockquote>\n<p>We can now look up groups for the principals:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; groups.getGroupsForPrincipal('auth.p1')\n(u'group.g1',)\n</pre>\n</blockquote>\n<p>Note that the group id is a concatenation of the group-folder prefix\nand the name of the group-information object within the folder.</p>\n<p>If we delete a group:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; del groups['g1']\n</pre>\n</blockquote>\n<p>then the groups folder loses the group information for that group\u2019s\nprincipals:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; groups.getGroupsForPrincipal('auth.p1')\n()\n</pre>\n</blockquote>\n<p>but the principal information on the group is unchanged:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; g1.principals\n('auth.p1', 'auth.p2')\n</pre>\n</blockquote>\n<p>It also fires an event showing that the principals are removed from the group\n(g1 is group information, not a zope.security.interfaces.IGroup).</p>\n<blockquote>\n<pre>&gt;&gt;&gt; getEvents(interfaces.IPrincipalsRemovedFromGroup)[-1]\n&lt;PrincipalsRemovedFromGroup ['auth.p1', 'auth.p2'] u'auth.group.g1'&gt;\n</pre>\n</blockquote>\n<p>Adding the group sets the folder principal information.  Let\u2019s use a\ndifferent group name:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; groups['G1'] = g1\n</pre>\n<pre>&gt;&gt;&gt; groups.getGroupsForPrincipal('auth.p1')\n(u'group.G1',)\n</pre>\n</blockquote>\n<p>Here we see that the new name is reflected in the group information.</p>\n<p>An event is fired, as usual.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; getEvents(interfaces.IPrincipalsAddedToGroup)[-1]\n&lt;PrincipalsAddedToGroup ['auth.p1', 'auth.p2'] u'auth.group.G1'&gt;\n</pre>\n</blockquote>\n<p>In terms of member events (principals added and removed from groups), we have\nnow seen that events are fired when a group information object is added and\nwhen it is removed from a group folder; and we have seen that events are fired\nwhen a principal is added to an already-registered group.  Events are also\nfired when a principal is removed from an already-registered group.  Let\u2019s\nquickly see some more examples.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; g1.principals = ('auth.p1', 'auth.p3', 'auth.p4')\n&gt;&gt;&gt; getEvents(interfaces.IPrincipalsAddedToGroup)[-1]\n&lt;PrincipalsAddedToGroup ['auth.p3', 'auth.p4'] u'auth.group.G1'&gt;\n&gt;&gt;&gt; getEvents(interfaces.IPrincipalsRemovedFromGroup)[-1]\n&lt;PrincipalsRemovedFromGroup ['auth.p2'] u'auth.group.G1'&gt;\n&gt;&gt;&gt; g1.principals = ('auth.p1', 'auth.p2')\n&gt;&gt;&gt; getEvents(interfaces.IPrincipalsAddedToGroup)[-1]\n&lt;PrincipalsAddedToGroup ['auth.p2'] u'auth.group.G1'&gt;\n&gt;&gt;&gt; getEvents(interfaces.IPrincipalsRemovedFromGroup)[-1]\n&lt;PrincipalsRemovedFromGroup ['auth.p3', 'auth.p4'] u'auth.group.G1'&gt;\n</pre>\n</blockquote>\n<p>Groups can contain groups:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; g2 = zope.pluggableauth.plugins.groupfolder.GroupInformation(\"Group Two\")\n&gt;&gt;&gt; groups['G2'] = g2\n&gt;&gt;&gt; g2.principals = ['auth.group.G1']\n</pre>\n<pre>&gt;&gt;&gt; groups.getGroupsForPrincipal('auth.group.G1')\n(u'group.G2',)\n</pre>\n<pre>&gt;&gt;&gt; old = getEvents(interfaces.IPrincipalsAddedToGroup)[-1]\n&gt;&gt;&gt; old\n&lt;PrincipalsAddedToGroup ['auth.group.G1'] u'auth.group.G2'&gt;\n</pre>\n</blockquote>\n<p>Groups cannot contain cycles:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; g1.principals = ('auth.p1', 'auth.p2', 'auth.group.G2')\n... # doctest: +NORMALIZE_WHITESPACE\nTraceback (most recent call last):\n...\nzope.pluggableauth.plugins.groupfolder.GroupCycle: (u'auth.group.G2', [u'auth.group.G2', u'auth.group.G1'])\n</pre>\n</blockquote>\n<p>Trying to do so does not fire an event.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; getEvents(interfaces.IPrincipalsAddedToGroup)[-1] is old\nTrue\n</pre>\n</blockquote>\n<p>They need not be hierarchical:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; ga = zope.pluggableauth.plugins.groupfolder.GroupInformation(\"Group A\")\n&gt;&gt;&gt; groups['GA'] = ga\n</pre>\n<pre>&gt;&gt;&gt; gb = zope.pluggableauth.plugins.groupfolder.GroupInformation(\"Group B\")\n&gt;&gt;&gt; groups['GB'] = gb\n&gt;&gt;&gt; gb.principals = ['auth.group.GA']\n</pre>\n<pre>&gt;&gt;&gt; gc = zope.pluggableauth.plugins.groupfolder.GroupInformation(\"Group C\")\n&gt;&gt;&gt; groups['GC'] = gc\n&gt;&gt;&gt; gc.principals = ['auth.group.GA']\n</pre>\n<pre>&gt;&gt;&gt; gd = zope.pluggableauth.plugins.groupfolder.GroupInformation(\"Group D\")\n&gt;&gt;&gt; groups['GD'] = gd\n&gt;&gt;&gt; gd.principals = ['auth.group.GA', 'auth.group.GB']\n</pre>\n<pre>&gt;&gt;&gt; ga.principals = ['auth.p1']\n</pre>\n</blockquote>\n<p>Group folders provide a very simple search interface.  They perform\nsimple string searches on group titles and descriptions.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; list(groups.search({'search': 'grou'})) # doctest: +NORMALIZE_WHITESPACE\n[u'group.G1', u'group.G2',\n u'group.GA', u'group.GB', u'group.GC', u'group.GD']\n</pre>\n<pre>&gt;&gt;&gt; list(groups.search({'search': 'two'}))\n[u'group.G2']\n</pre>\n</blockquote>\n<p>They also support batching:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; list(groups.search({'search': 'grou'}, 2, 3))\n[u'group.GA', u'group.GB', u'group.GC']\n</pre>\n</blockquote>\n<p>If you don\u2019t supply a search key, no results will be returned:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; list(groups.search({}))\n[]\n</pre>\n</blockquote>\n<div id=\"identifying-groups\">\n<h3>Identifying groups</h3>\n<p>The function, <cite>setGroupsForPrincipal</cite>, is a subscriber to\nprincipal-creation events.  It adds any group-folder-defined groups to\nusers in those groups:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; principal = principals.getPrincipal('auth.p1')\n</pre>\n<pre>&gt;&gt;&gt; principal.groups\n[u'auth.group.G1', u'auth.group.GA']\n</pre>\n</blockquote>\n<p>Of course, this applies to groups too:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; principal = principals.getPrincipal('auth.group.G1')\n&gt;&gt;&gt; principal.id\n'auth.group.G1'\n</pre>\n<pre>&gt;&gt;&gt; principal.groups\n[u'auth.group.G2']\n</pre>\n</blockquote>\n<p>In addition to setting principal groups, the <cite>setGroupsForPrincipal</cite>\nfunction also declares the <cite>IGroup</cite> interface on groups:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; [iface.__name__ for iface in interface.providedBy(principal)]\n['IGroup', 'IGroupAwarePrincipal']\n</pre>\n<pre>&gt;&gt;&gt; [iface.__name__\n...  for iface in interface.providedBy(principals.getPrincipal('auth.p1'))]\n['IGroupAwarePrincipal']\n</pre>\n</blockquote>\n</div>\n<div id=\"special-groups\">\n<h3>Special groups</h3>\n<p>Two special groups, Authenticated, and Everyone may apply to users\ncreated by the pluggable-authentication utility.  There is a\nsubscriber, specialGroups, that will set these groups on any non-group\nprincipals if IAuthenticatedGroup, or IEveryoneGroup utilities are\nprovided.</p>\n<p>Lets define a group-aware principal:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; import zope.security.interfaces\n&gt;&gt;&gt; @interface.implementer(zope.security.interfaces.IGroupAwarePrincipal)\n... class GroupAwarePrincipal(Principal):\n...     def __init__(self, id):\n...         Principal.__init__(self, id)\n...         self.groups = []\n</pre>\n</blockquote>\n<p>If we notify the subscriber with this principal, nothing will happen\nbecause the groups haven\u2019t been defined:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; prin = GroupAwarePrincipal('x')\n&gt;&gt;&gt; event = interfaces.FoundPrincipalCreated(42, prin, {})\n&gt;&gt;&gt; zope.pluggableauth.plugins.groupfolder.specialGroups(event)\n&gt;&gt;&gt; prin.groups\n[]\n</pre>\n</blockquote>\n<p>Now, if we define the Everybody group:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; import zope.authentication.interfaces\n&gt;&gt;&gt; @interface.implementer(zope.authentication.interfaces.IEveryoneGroup)\n... class EverybodyGroup(Principal):\n...     pass\n</pre>\n<pre>&gt;&gt;&gt; everybody = EverybodyGroup('all')\n&gt;&gt;&gt; provideUtility(everybody, zope.authentication.interfaces.IEveryoneGroup)\n</pre>\n</blockquote>\n<p>Then the group will be added to the principal:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; zope.pluggableauth.plugins.groupfolder.specialGroups(event)\n&gt;&gt;&gt; prin.groups\n['all']\n</pre>\n</blockquote>\n<p>Similarly for the authenticated group:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; @interface.implementer(\n...         zope.authentication.interfaces.IAuthenticatedGroup)\n... class AuthenticatedGroup(Principal):\n...     pass\n</pre>\n<pre>&gt;&gt;&gt; authenticated = AuthenticatedGroup('auth')\n&gt;&gt;&gt; provideUtility(authenticated, zope.authentication.interfaces.IAuthenticatedGroup)\n</pre>\n</blockquote>\n<p>Then the group will be added to the principal:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; prin.groups = []\n&gt;&gt;&gt; zope.pluggableauth.plugins.groupfolder.specialGroups(event)\n&gt;&gt;&gt; prin.groups.sort()\n&gt;&gt;&gt; prin.groups\n['all', 'auth']\n</pre>\n</blockquote>\n<p>These groups are only added to non-group principals:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; prin.groups = []\n&gt;&gt;&gt; interface.directlyProvides(prin, zope.security.interfaces.IGroup)\n&gt;&gt;&gt; zope.pluggableauth.plugins.groupfolder.specialGroups(event)\n&gt;&gt;&gt; prin.groups\n[]\n</pre>\n</blockquote>\n<p>And they are only added to group aware principals:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; @interface.implementer(zope.security.interfaces.IPrincipal)\n... class SolitaryPrincipal:\n...     id = title = description = ''\n</pre>\n<pre>&gt;&gt;&gt; event = interfaces.FoundPrincipalCreated(42, SolitaryPrincipal(), {})\n&gt;&gt;&gt; zope.pluggableauth.plugins.groupfolder.specialGroups(event)\n&gt;&gt;&gt; prin.groups\n[]\n</pre>\n</blockquote>\n</div>\n<div id=\"member-aware-groups\">\n<h3>Member-aware groups</h3>\n<p>The groupfolder includes a subscriber that gives group principals the\nzope.security.interfaces.IGroupAware interface and an implementation thereof.\nThis allows groups to be able to get and set their members.</p>\n<p>Given an info object and a group\u2026</p>\n<blockquote>\n<pre>&gt;&gt;&gt; @interface.implementer(\n...         zope.pluggableauth.plugins.groupfolder.IGroupInformation)\n... class DemoGroupInformation(object):\n...     def __init__(self, title, description, principals):\n...         self.title = title\n...         self.description = description\n...         self.principals = principals\n...\n&gt;&gt;&gt; i = DemoGroupInformation(\n...     'Managers', 'Taskmasters', ('joe', 'jane'))\n...\n&gt;&gt;&gt; info = zope.pluggableauth.plugins.groupfolder.GroupInfo(\n...     'groups.managers', i)\n&gt;&gt;&gt; @interface.implementer(IGroupAwarePrincipal)\n... class DummyGroup(object):\n...     def __init__(self, id, title=u'', description=u''):\n...         self.id = id\n...         self.title = title\n...         self.description = description\n...         self.groups = []\n...\n&gt;&gt;&gt; principal = DummyGroup('foo')\n&gt;&gt;&gt; zope.security.interfaces.IMemberAwareGroup.providedBy(principal)\nFalse\n</pre>\n</blockquote>\n<p>\u2026when you call the subscriber, it adds the two pseudo-methods to the\nprincipal and makes the principal provide the IMemberAwareGroup interface.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; zope.pluggableauth.plugins.groupfolder.setMemberSubscriber(\n...     interfaces.FoundPrincipalCreated(\n...         'dummy auth (ignored)', principal, info))\n&gt;&gt;&gt; principal.getMembers()\n('joe', 'jane')\n&gt;&gt;&gt; principal.setMembers(('joe', 'jane', 'jaimie'))\n&gt;&gt;&gt; principal.getMembers()\n('joe', 'jane', 'jaimie')\n&gt;&gt;&gt; zope.security.interfaces.IMemberAwareGroup.providedBy(principal)\nTrue\n</pre>\n</blockquote>\n<p>The two methods work with the value on the IGroupInformation object.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; i.principals == principal.getMembers()\nTrue\n</pre>\n</blockquote>\n<div id=\"limitation\">\n<h4>Limitation</h4>\n<p>The current group-folder design has an important limitation!</p>\n<p>There is no point in assigning principals to a group\nfrom a group folder unless the principal is from the same pluggable\nauthentication utility.</p>\n<ul>\n<li>If a principal is from a higher authentication utility, the user\nwill not get the group definition. Why? Because the principals\ngroup assignments are set when the principal is authenticated. At\nthat point, the current site is the site containing the principal\ndefinition. Groups defined in lower sites will not be consulted,</li>\n<li>It is impossible to assign users from lower authentication\nutilities because they can\u2019t be seen when managing the group,\nfrom the site containing the group.</li>\n</ul>\n<p>A better design might be to store user-role assignments independent of\nthe group definitions and to look for assignments during (url)\ntraversal.  This could get quite complex though.</p>\n<p>While it is possible to have multiple authentication utilities long a\nURL path, it is generally better to stick to a simpler model in which\nthere is only one authentication utility along a URL path (in addition\nto the global utility, which is used for bootstrapping purposes).</p>\n</div>\n</div>\n</div>\n<div id=\"changes\">\n<h2>Changes</h2>\n<div id=\"id3\">\n<h3>2.3.0 (2017-11-12)</h3>\n<ul>\n<li>Drop support for Python 3.3.</li>\n</ul>\n</div>\n<div id=\"id4\">\n<h3>2.2.0 (2017-05-02)</h3>\n<ul>\n<li>Add support for Python 3.6.</li>\n<li>Fix a NameError in the idpicker under Python 3.6.\nSee <a href=\"https://github.com/zopefoundation/zope.pluggableauth/issues/7\" rel=\"nofollow\">issue 7</a>.</li>\n</ul>\n</div>\n<div id=\"id5\">\n<h3>2.1.0 (2016-07-04)</h3>\n<ul>\n<li>Add support for Python 3.5.</li>\n<li>Drop support for Python 2.6.</li>\n</ul>\n</div>\n<div id=\"id6\">\n<h3>2.0.0 (2014-12-24)</h3>\n<ul>\n<li>Add support for Python 3.4.</li>\n<li>Refactor <tt>zope.pluggableauth.plugins.session.redirectWithComeFrom</tt>\ninto a reusable function.</li>\n<li>Fix: allow password containing colon(s) in HTTP basic authentication\ncredentials extraction plug-in, to conform with RFC2617</li>\n</ul>\n</div>\n<div id=\"a1-2013-02-21\">\n<h3>2.0.0a1 (2013-02-21)</h3>\n<ul>\n<li>Add <tt>tox.ini</tt> and <tt>MANIFEST.in</tt>.</li>\n<li>Add support for Python 3.3.</li>\n<li>Replace deprecated <tt>zope.component.adapts</tt> usage with equivalent\n<tt>zope.component.adapter</tt> decorator.</li>\n<li>Replace deprecated <tt>zope.interface.implements</tt> usage with equivalent\n<tt>zope.interface.implementer</tt> decorator.</li>\n<li>Drop support for Python 2.4 and 2.5.</li>\n</ul>\n</div>\n<div id=\"id7\">\n<h3>1.3 (2011-02-08)</h3>\n<ul>\n<li>As the <tt>camefrom</tt> information is most probably used for a redirect,\nrequire it to be an absolute URL (see also\n<a href=\"http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.30\" rel=\"nofollow\">http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.30</a>).</li>\n</ul>\n</div>\n<div id=\"id8\">\n<h3>1.2 (2010-12-16)</h3>\n<ul>\n<li><p>Add a hook to <tt>SessionCredentialsPlugin</tt> (<tt>_makeCredentials</tt>) that can\nbe overriden in subclasses to store the credentials in the session\ndifferently.</p>\n<p>For example, you could use <tt>keas.kmi</tt> and encrypt the passwords of the\ncurrently logged-in users so they don\u2019t appear in plain text in the ZODB.</p>\n</li>\n</ul>\n</div>\n<div id=\"id9\">\n<h3>1.1 (2010-10-18)</h3>\n<ul>\n<li><p>Move concrete <tt>IAuthenticatorPlugin</tt> implementations from\n<tt>zope.app.authentication</tt> to <tt>zope.pluggableauth.plugins</tt>.</p>\n<p>As a result, projects that want to use the <tt>IAuthenticator</tt> plugins\n(previously found in <tt>zope.app.authentication</tt>) do not automatically\nalso pull in the <tt>zope.app.*</tt> dependencies that are needed to register\nthe ZMI views.</p>\n</li>\n</ul>\n</div>\n<div id=\"id10\">\n<h3>1.0.3 (2010-07-09)</h3>\n<ul>\n<li>Fix dependency declaration.</li>\n</ul>\n</div>\n<div id=\"id11\">\n<h3>1.0.2 (2010-07-90)</h3>\n<ul>\n<li>Add <tt>persistent.Persistent</tt> and <tt>zope.container.contained.Contained</tt> as\nbases for <tt>zope.pluggableauth.plugins.session.SessionCredentialsPlugin</tt>,\nso instances of <tt>zope.app.authentication.session.SessionCredentialsPlugin</tt>\nwon\u2019t be changed.\n(<a href=\"https://mail.zope.org/pipermail/zope-dev/2010-July/040898.html\" rel=\"nofollow\">https://mail.zope.org/pipermail/zope-dev/2010-July/040898.html</a>)</li>\n</ul>\n</div>\n<div id=\"id12\">\n<h3>1.0.1 (2010-02-11)</h3>\n<ul>\n<li>Declare adapter in a new ZCML file : <cite>principalfactories.zcml</cite>.  Avoids\nduplication errors in <tt>zope.app.authentication</tt>.</li>\n</ul>\n</div>\n<div id=\"id13\">\n<h3>1.0 (2010-02-05)</h3>\n<ul>\n<li>Splitting off from zope.app.authentication</li>\n</ul>\n</div>\n</div>\n\n          </div>"}, "last_serial": 3326309, "releases": {"1.0": [{"comment_text": "", "digests": {"md5": "9c6b4d4c65b8c1cfb655eb7e554d3714", "sha256": "ee55ec27a8eb8699cd9ab1315fd7759f78d6c3ba9467c2a3e3324ff8215c223c"}, "downloads": -1, "filename": "zope.pluggableauth-1.0.tar.gz", "has_sig": false, "md5_digest": "9c6b4d4c65b8c1cfb655eb7e554d3714", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 20273, "upload_time": "2010-02-05T16:04:13", "upload_time_iso_8601": "2010-02-05T16:04:13.713744Z", "url": "https://files.pythonhosted.org/packages/9d/8e/d41285f0b6e4af586d23917395869464d0b39736608ecc6b1022281d78a6/zope.pluggableauth-1.0.tar.gz", "yanked": false}], "1.0.1": [{"comment_text": "", "digests": {"md5": "53574369fe6682c0f812d6d0903695ad", "sha256": "d43e317605d45dbabbed68605997ecf3d822049d2e67479edb34bca3504eec53"}, "downloads": -1, "filename": "zope.pluggableauth-1.0.1.tar.gz", "has_sig": false, "md5_digest": "53574369fe6682c0f812d6d0903695ad", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 21316, "upload_time": "2010-02-11T19:50:19", "upload_time_iso_8601": "2010-02-11T19:50:19.136604Z", "url": "https://files.pythonhosted.org/packages/97/3e/c32f798e42e0466b3b5b4e564e4f4b9a38143ef0cea43b63f27fd6dd25a7/zope.pluggableauth-1.0.1.tar.gz", "yanked": false}], "1.0.2": [{"comment_text": "", "digests": {"md5": "ada816874b6372f918d5322b387017a4", "sha256": "c522b45f104028b261c17678ee0273bd33439d2b241e778c5243d462702f7475"}, "downloads": -1, "filename": "zope.pluggableauth-1.0.2.tar.gz", "has_sig": false, "md5_digest": "ada816874b6372f918d5322b387017a4", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 25160, "upload_time": "2010-07-09T23:05:44", "upload_time_iso_8601": "2010-07-09T23:05:44.567827Z", "url": "https://files.pythonhosted.org/packages/c0/75/f8489ebd2092bb1e2497af05b2692308a750d64d147768fd7ef3f5af7f0a/zope.pluggableauth-1.0.2.tar.gz", "yanked": false}], "1.0.3": [{"comment_text": "", "digests": {"md5": "85d16cb2e5b41bf2a438828857719566", "sha256": "89751171cdc8680fba4bef495ef7a2e21fac21ac8d51bb5989fce04f65749985"}, "downloads": -1, "filename": "zope.pluggableauth-1.0.3.tar.gz", "has_sig": false, "md5_digest": "85d16cb2e5b41bf2a438828857719566", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 25274, "upload_time": "2010-07-09T23:13:44", "upload_time_iso_8601": "2010-07-09T23:13:44.498932Z", "url": "https://files.pythonhosted.org/packages/66/62/0ac9dd244256d6d97e141c47e25588b2ffc1ba7bd56fa5c2b23fbccda106/zope.pluggableauth-1.0.3.tar.gz", "yanked": false}], "1.1": [{"comment_text": "", "digests": {"md5": "755a0959165f7320a1562a29f799b979", "sha256": "0b6a2081701b0619e3c8654284d0e5716aab45c81d602bcf221040ddd855c031"}, "downloads": -1, "filename": "zope.pluggableauth-1.1.tar.gz", "has_sig": false, "md5_digest": "755a0959165f7320a1562a29f799b979", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 41182, "upload_time": "2010-10-18T11:32:44", "upload_time_iso_8601": "2010-10-18T11:32:44.795822Z", "url": "https://files.pythonhosted.org/packages/e5/51/0d6cdf6840c4bb193faa0e6e08d42259951a1724a5c47026f314bedf5962/zope.pluggableauth-1.1.tar.gz", "yanked": false}], "1.2": [{"comment_text": "", "digests": {"md5": "4fbf84575b46a70d8d824b794192efda", "sha256": "3c95404e9cf269246ed358bdce9645de63b168c72ab6f70ab2e16b78e297f9d0"}, "downloads": -1, "filename": "zope.pluggableauth-1.2.tar.gz", "has_sig": false, "md5_digest": "4fbf84575b46a70d8d824b794192efda", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 40615, "upload_time": "2010-12-16T22:46:59", "upload_time_iso_8601": "2010-12-16T22:46:59.291501Z", "url": "https://files.pythonhosted.org/packages/af/71/cbf0e83885f74017a6b59c851190c6eb7f7a1200e3bf81578516b5212f2e/zope.pluggableauth-1.2.tar.gz", "yanked": false}], "1.3": [{"comment_text": "", "digests": {"md5": "ecc72432c8b7dec5864cf33fcdd29d2f", "sha256": "521e86c5abbcfd7794c00a92301dc0132c29de80e4a6b67469811b14a3594ad0"}, "downloads": -1, "filename": "zope.pluggableauth-1.3.tar.gz", "has_sig": false, "md5_digest": "ecc72432c8b7dec5864cf33fcdd29d2f", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 42198, "upload_time": "2011-02-08T09:55:32", "upload_time_iso_8601": "2011-02-08T09:55:32.265234Z", "url": "https://files.pythonhosted.org/packages/5a/79/7e5dd5e0f68597066f521f8340866c47c91d769f74c29af1fa826b2133c3/zope.pluggableauth-1.3.tar.gz", "yanked": false}], "2.0.0": [{"comment_text": "", "digests": {"md5": "c0c15a5f17aa2852b020b051b9527701", "sha256": "34666709a7abd6f515ed5f958dbd5234139557daa5b1d71bd45b1488c823a020"}, "downloads": -1, "filename": "zope.pluggableauth-2.0.0.tar.gz", "has_sig": false, "md5_digest": "c0c15a5f17aa2852b020b051b9527701", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 44344, "upload_time": "2014-12-24T22:45:07", "upload_time_iso_8601": "2014-12-24T22:45:07.624187Z", "url": "https://files.pythonhosted.org/packages/fd/72/0ef1be292bcd6876fcacbd8ce3ddd98444f114813d9e4d03225f4e1dee50/zope.pluggableauth-2.0.0.tar.gz", "yanked": false}], "2.0.0a1": [{"comment_text": "", "digests": {"md5": "c659492323cce9384ad4cd770075dbb0", "sha256": "5c09660b973079ed2d70deb57ac85246998a076a1a5127236eef8818229b9f50"}, "downloads": -1, "filename": "zope.pluggableauth-2.0.0a1.zip", "has_sig": false, "md5_digest": "c659492323cce9384ad4cd770075dbb0", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 63675, "upload_time": "2013-02-21T21:46:02", "upload_time_iso_8601": "2013-02-21T21:46:02.365301Z", "url": "https://files.pythonhosted.org/packages/83/9d/579d93e7a8b9c952e0d3dc452c8c7275905557fa20cef3e3b2e3c71fc0e8/zope.pluggableauth-2.0.0a1.zip", "yanked": false}], "2.1.0": [{"comment_text": "", "digests": {"md5": "7f258e25dfbf68d1a966bf8016c05b2c", "sha256": "63fe99b760014a5a4c5a9630e83b8554fe56a296a0e2c2ee6a0e3189b9e5309b"}, "downloads": -1, "filename": "zope.pluggableauth-2.1.0.tar.gz", "has_sig": true, "md5_digest": "7f258e25dfbf68d1a966bf8016c05b2c", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 44708, "upload_time": "2016-07-04T20:32:20", "upload_time_iso_8601": "2016-07-04T20:32:20.065483Z", "url": "https://files.pythonhosted.org/packages/21/26/f1b506941ee29a2fd842e318bf4e56423bdd1c587dfdd64ed63f8bc40922/zope.pluggableauth-2.1.0.tar.gz", "yanked": false}], "2.2.0": [{"comment_text": "", "digests": {"md5": "42450038bb022161e19515a1ae8d90a9", "sha256": "e85ea6a6f6adc1a1da512032f455b7581cbb64c7f2e5a86f4e3001540a5c9d72"}, "downloads": -1, "filename": "zope.pluggableauth-2.2.0-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "42450038bb022161e19515a1ae8d90a9", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 63683, "upload_time": "2017-05-02T13:43:13", "upload_time_iso_8601": "2017-05-02T13:43:13.885283Z", "url": "https://files.pythonhosted.org/packages/0d/75/8cb9fbbe229af9a80477ab6cd7d47a526b8ef7dcf31f6566e09c6bd401e8/zope.pluggableauth-2.2.0-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "c1f95b183f2b8712fc1e9250fc37491c", "sha256": "9f6f67f43eaf8750862f72b960c713d1a90da8cba1beffc4dc011b7847f3fdec"}, "downloads": -1, "filename": "zope.pluggableauth-2.2.0.tar.gz", "has_sig": false, "md5_digest": "c1f95b183f2b8712fc1e9250fc37491c", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 55726, "upload_time": "2017-05-02T13:43:15", "upload_time_iso_8601": "2017-05-02T13:43:15.815454Z", "url": "https://files.pythonhosted.org/packages/df/d4/312fc728a11200fdd68ccff8041faccb1d9f393c345f3b9237c61be3252f/zope.pluggableauth-2.2.0.tar.gz", "yanked": false}], "2.3.0": [{"comment_text": "", "digests": {"md5": "f72f6f94ab4861acc031511c189f9e5d", "sha256": "7531cd056bcbe578a1ee55a3047840e12cf5f82bad05b189f025ce2153234f45"}, "downloads": -1, "filename": "zope.pluggableauth-2.3.0-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "f72f6f94ab4861acc031511c189f9e5d", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 63739, "upload_time": "2017-11-12T14:00:06", "upload_time_iso_8601": "2017-11-12T14:00:06.959720Z", "url": "https://files.pythonhosted.org/packages/7f/1c/5c9ab2d630a9c67ac59139effec9a7051b333353d19841f84c2843586d13/zope.pluggableauth-2.3.0-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "c86e15319999b8a5533d74b8bfb95bc3", "sha256": "77dc2646bbb799c69c381e71e80c1443637fda6cd41de9c366e6fe5a659bcde6"}, "downloads": -1, "filename": "zope.pluggableauth-2.3.0.tar.gz", "has_sig": false, "md5_digest": "c86e15319999b8a5533d74b8bfb95bc3", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 55170, "upload_time": "2017-11-12T14:00:08", "upload_time_iso_8601": "2017-11-12T14:00:08.159904Z", "url": "https://files.pythonhosted.org/packages/f1/22/f2158606696985723e329e927de57d5da7e8456edf3e28867a8a454ccb37/zope.pluggableauth-2.3.0.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "f72f6f94ab4861acc031511c189f9e5d", "sha256": "7531cd056bcbe578a1ee55a3047840e12cf5f82bad05b189f025ce2153234f45"}, "downloads": -1, "filename": "zope.pluggableauth-2.3.0-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "f72f6f94ab4861acc031511c189f9e5d", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 63739, "upload_time": "2017-11-12T14:00:06", "upload_time_iso_8601": "2017-11-12T14:00:06.959720Z", "url": "https://files.pythonhosted.org/packages/7f/1c/5c9ab2d630a9c67ac59139effec9a7051b333353d19841f84c2843586d13/zope.pluggableauth-2.3.0-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "c86e15319999b8a5533d74b8bfb95bc3", "sha256": "77dc2646bbb799c69c381e71e80c1443637fda6cd41de9c366e6fe5a659bcde6"}, "downloads": -1, "filename": "zope.pluggableauth-2.3.0.tar.gz", "has_sig": false, "md5_digest": "c86e15319999b8a5533d74b8bfb95bc3", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 55170, "upload_time": "2017-11-12T14:00:08", "upload_time_iso_8601": "2017-11-12T14:00:08.159904Z", "url": "https://files.pythonhosted.org/packages/f1/22/f2158606696985723e329e927de57d5da7e8456edf3e28867a8a454ccb37/zope.pluggableauth-2.3.0.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:12:56 2020"}