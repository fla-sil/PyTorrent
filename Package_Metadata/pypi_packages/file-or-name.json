{"info": {"author": "blester125", "author_email": "blester125@gmail.com", "bugtrack_url": null, "classifiers": ["Development Status :: 3 - Alpha", "Environment :: Console", "Intended Audience :: Developers", "Intended Audience :: Science/Research", "License :: OSI Approved :: MIT License", "Natural Language :: English", "Programming Language :: Python :: 3 :: Only", "Topic :: Scientific/Engineering"], "description": "# File Or Name\n\n[![PyPi Version](https://img.shields.io/pypi/v/file-or-name)](https://pypi.org/project/file-or-name/) [![Actions Status](https://github.com/blester125/file-or-name/workflows/Unit%20Test/badge.svg)](https://github.com/blester125/file-or-name/actions) [![Code style: black](https://img.shields.io/badge/code%20style-black-000000.svg)](https://github.com/psf/black)\n\nTransparently handle input parameters that are either strings or pre-opened file objects.\n\n## Why?\n\nwhen writing a function that reads or writes data to a file you often end up with something that looks like this\n\n```python\ndef read_my_cool_file(file_name):\n    with open(file_name) as f:\n        # Process file object f\n        ...\n```\n\nThis has some problems.\n\n 1. It couples your data processing code and the opening of the file. This makes it\n    harder to test. You only want to test your code that processes the data but with functions like this\n    you need to coordinate the opening of the file during you test, either creating fake data on disk or\n    patching the open call.\n 2. It can't handle special files. If you have file in your special format but it uses `latin-1` encoding\n    instead of `ascii` how can you use that file? You can't because you are opening the file in function\n    instead of passing the file object in you are forced to open it in one way.\n\nFor maximum flexibility and easy testability you probably actually want a function that looks like this\n\n```python\ndef read_my_cool_file(f):\n    # Process file object f\n    ...\n```\n\nThis is nice because when testing you can use things like the `io.StringIO` objects to dynamically create test\ndata. You can also open files with different encodings and pass them in to get processed just like normal. There\nis a usability draw back though. This way of processing files is onerous on the user. It turns single function\ncalls into multi-line calls. This\n\n```python\ndata = read_my_cool_file(\"/path/to/my/imporant/data\")\n```\n\ninto this\n\n```python\nwith open(\"/path/to/my/important/data\") as f:\n    data = read_my_cool_file(f)\n```\n\nIt also is a divergence from a lot of other functions they probably use, forcing the user to do things differently for\nyour library is hard for them and could result in them not using your code.\n\nWe need a way to accept both file paths (as strings) and file objects without having to write code to check which it is\nfor every io function we write.\n\n\n## What?\n\nEnter `file_or_name`.\n\n`file_or_name` introduces a decorator `file_or_name` that solves this issue.\n\nBy decorating a function with `@file_or_name` we can accept both strings and file objects. Our example above becomes\n\n```python\n@file_or_name\ndef read_my_cool_file(f):\n    # Process file object f\n    ...\n```\n\nAs writer of the function we can write functions that assume they get a file object and input. This means we can stop\nopening files as functions it makes it easier to test.\n\nAs a user we can pass in either a string making the function easy to call or we can pass in a file object which lets us\nhandle files with other encodings.\n\n\n## Usage\n\nThe `@file_or_name` decorator will open and close files automatically for you when your function takes a file. If you\nuse the decorator with no arguments it will open the first argument as a file in read mode.\n\n```python\n@file_or_name\ndef read_json(f):\n    return json.load(f)\n```\n\nIn order to handle multiple files as well as writing use keyword arguments to the decorator in the form `parameter=mode`.\nThis will open a file using the value of parameter as a file in the specified mode.\n\nWriting to file example:\n\n```python\n@file_or_name(wf='w')\ndef write_json(data, wf):\n    json.dumps(data, wf, indent=2)\n```\n\nReading and writing example:\n\n```python\n@file_or_name(rf='r', wf='w')\ndef convert_jsonl_to_yaml(rf, wf):\n    for line in rf:\n        wf.write(yaml.dump(json.loads(line)) + \"\\n\")\n```\n\nFile or Name lets you the library develop write function that operate on files object making code cleaner and more\ntestable while letting your users interact with your code using simple file path string arguments.\n\n\n# Shadow Paging\n\nA common problem I have is that I have code that will read from a file with a generator, this lets me process chunks of\ndata and I don't have to worry about memory concerns. The problem is when I want to read data from a file, make changes\nto it and then write back to that same file. You can't open the file for writing because that would destroy the data you\nwant to read in it. A common solution is to read the data in and keep it in memory until you process it all. Then open\nthe file for writing and write it all back. This defeats out want of having a generator to not process it all at once,\nit also means it is possible to have a error when writing data that will leave you in a state with no data. That is why\nI introduced the shadow page to this library. Using a `NamedTemporaryFile` you can write to this file as much as you\nwant and when you close the file it will be automatically used to replace the file on disk in an atomic way, This means\nyou can't lose you data by having a bug during writing and it lets you write back to a file that you are using a\ngenerator to read from.\n\nYou can use this functionality by prefixing your write modes with a `s`\n\n\n```python\n@file_or_name(f='r', wf='sw')\ndef reverse(f, wf):\n    data = f.read()[::-1]\n    if random.random() < 0.5:\n        raise ValueError\n    wf.write(data)\n```\n\nThis function will either leave you data intact or reverse it. You don't end up with a state where the data is deleted.", "description_content_type": "text/markdown", "docs_url": null, "download_url": "https://github.com/blester125/file-or-name/archive/1.1.3.tar.gz", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/blester125/file-or-name", "keywords": "", "license": "MIT", "maintainer": "", "maintainer_email": "", "name": "file-or-name", "package_url": "https://pypi.org/project/file-or-name/", "platform": "", "project_url": "https://pypi.org/project/file-or-name/", "project_urls": {"Download": "https://github.com/blester125/file-or-name/archive/1.1.3.tar.gz", "Homepage": "https://github.com/blester125/file-or-name"}, "release_url": "https://pypi.org/project/file-or-name/1.1.3/", "requires_dist": null, "requires_python": ">=3.6", "summary": "File Or Name", "version": "1.1.3", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>File Or Name</h1>\n<p><a href=\"https://pypi.org/project/file-or-name/\" rel=\"nofollow\"><img alt=\"PyPi Version\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/fdb5526f1ce5ec3d31d8fbb830c14eaf9190c2d8/68747470733a2f2f696d672e736869656c64732e696f2f707970692f762f66696c652d6f722d6e616d65\"></a> <a href=\"https://github.com/blester125/file-or-name/actions\" rel=\"nofollow\"><img alt=\"Actions Status\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/e8f1bcd5bc9f61b449e88cdeeb43c0022390535e/68747470733a2f2f6769746875622e636f6d2f626c65737465723132352f66696c652d6f722d6e616d652f776f726b666c6f77732f556e6974253230546573742f62616467652e737667\"></a> <a href=\"https://github.com/psf/black\" rel=\"nofollow\"><img alt=\"Code style: black\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/fbfdc7754183ecf079bc71ddeabaf88f6cbc5c00/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f636f64652532307374796c652d626c61636b2d3030303030302e737667\"></a></p>\n<p>Transparently handle input parameters that are either strings or pre-opened file objects.</p>\n<h2>Why?</h2>\n<p>when writing a function that reads or writes data to a file you often end up with something that looks like this</p>\n<pre><span class=\"k\">def</span> <span class=\"nf\">read_my_cool_file</span><span class=\"p\">(</span><span class=\"n\">file_name</span><span class=\"p\">):</span>\n    <span class=\"k\">with</span> <span class=\"nb\">open</span><span class=\"p\">(</span><span class=\"n\">file_name</span><span class=\"p\">)</span> <span class=\"k\">as</span> <span class=\"n\">f</span><span class=\"p\">:</span>\n        <span class=\"c1\"># Process file object f</span>\n        <span class=\"o\">...</span>\n</pre>\n<p>This has some problems.</p>\n<ol>\n<li>It couples your data processing code and the opening of the file. This makes it\nharder to test. You only want to test your code that processes the data but with functions like this\nyou need to coordinate the opening of the file during you test, either creating fake data on disk or\npatching the open call.</li>\n<li>It can't handle special files. If you have file in your special format but it uses <code>latin-1</code> encoding\ninstead of <code>ascii</code> how can you use that file? You can't because you are opening the file in function\ninstead of passing the file object in you are forced to open it in one way.</li>\n</ol>\n<p>For maximum flexibility and easy testability you probably actually want a function that looks like this</p>\n<pre><span class=\"k\">def</span> <span class=\"nf\">read_my_cool_file</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"p\">):</span>\n    <span class=\"c1\"># Process file object f</span>\n    <span class=\"o\">...</span>\n</pre>\n<p>This is nice because when testing you can use things like the <code>io.StringIO</code> objects to dynamically create test\ndata. You can also open files with different encodings and pass them in to get processed just like normal. There\nis a usability draw back though. This way of processing files is onerous on the user. It turns single function\ncalls into multi-line calls. This</p>\n<pre><span class=\"n\">data</span> <span class=\"o\">=</span> <span class=\"n\">read_my_cool_file</span><span class=\"p\">(</span><span class=\"s2\">\"/path/to/my/imporant/data\"</span><span class=\"p\">)</span>\n</pre>\n<p>into this</p>\n<pre><span class=\"k\">with</span> <span class=\"nb\">open</span><span class=\"p\">(</span><span class=\"s2\">\"/path/to/my/important/data\"</span><span class=\"p\">)</span> <span class=\"k\">as</span> <span class=\"n\">f</span><span class=\"p\">:</span>\n    <span class=\"n\">data</span> <span class=\"o\">=</span> <span class=\"n\">read_my_cool_file</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"p\">)</span>\n</pre>\n<p>It also is a divergence from a lot of other functions they probably use, forcing the user to do things differently for\nyour library is hard for them and could result in them not using your code.</p>\n<p>We need a way to accept both file paths (as strings) and file objects without having to write code to check which it is\nfor every io function we write.</p>\n<h2>What?</h2>\n<p>Enter <code>file_or_name</code>.</p>\n<p><code>file_or_name</code> introduces a decorator <code>file_or_name</code> that solves this issue.</p>\n<p>By decorating a function with <code>@file_or_name</code> we can accept both strings and file objects. Our example above becomes</p>\n<pre><span class=\"nd\">@file_or_name</span>\n<span class=\"k\">def</span> <span class=\"nf\">read_my_cool_file</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"p\">):</span>\n    <span class=\"c1\"># Process file object f</span>\n    <span class=\"o\">...</span>\n</pre>\n<p>As writer of the function we can write functions that assume they get a file object and input. This means we can stop\nopening files as functions it makes it easier to test.</p>\n<p>As a user we can pass in either a string making the function easy to call or we can pass in a file object which lets us\nhandle files with other encodings.</p>\n<h2>Usage</h2>\n<p>The <code>@file_or_name</code> decorator will open and close files automatically for you when your function takes a file. If you\nuse the decorator with no arguments it will open the first argument as a file in read mode.</p>\n<pre><span class=\"nd\">@file_or_name</span>\n<span class=\"k\">def</span> <span class=\"nf\">read_json</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"p\">):</span>\n    <span class=\"k\">return</span> <span class=\"n\">json</span><span class=\"o\">.</span><span class=\"n\">load</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"p\">)</span>\n</pre>\n<p>In order to handle multiple files as well as writing use keyword arguments to the decorator in the form <code>parameter=mode</code>.\nThis will open a file using the value of parameter as a file in the specified mode.</p>\n<p>Writing to file example:</p>\n<pre><span class=\"nd\">@file_or_name</span><span class=\"p\">(</span><span class=\"n\">wf</span><span class=\"o\">=</span><span class=\"s1\">'w'</span><span class=\"p\">)</span>\n<span class=\"k\">def</span> <span class=\"nf\">write_json</span><span class=\"p\">(</span><span class=\"n\">data</span><span class=\"p\">,</span> <span class=\"n\">wf</span><span class=\"p\">):</span>\n    <span class=\"n\">json</span><span class=\"o\">.</span><span class=\"n\">dumps</span><span class=\"p\">(</span><span class=\"n\">data</span><span class=\"p\">,</span> <span class=\"n\">wf</span><span class=\"p\">,</span> <span class=\"n\">indent</span><span class=\"o\">=</span><span class=\"mi\">2</span><span class=\"p\">)</span>\n</pre>\n<p>Reading and writing example:</p>\n<pre><span class=\"nd\">@file_or_name</span><span class=\"p\">(</span><span class=\"n\">rf</span><span class=\"o\">=</span><span class=\"s1\">'r'</span><span class=\"p\">,</span> <span class=\"n\">wf</span><span class=\"o\">=</span><span class=\"s1\">'w'</span><span class=\"p\">)</span>\n<span class=\"k\">def</span> <span class=\"nf\">convert_jsonl_to_yaml</span><span class=\"p\">(</span><span class=\"n\">rf</span><span class=\"p\">,</span> <span class=\"n\">wf</span><span class=\"p\">):</span>\n    <span class=\"k\">for</span> <span class=\"n\">line</span> <span class=\"ow\">in</span> <span class=\"n\">rf</span><span class=\"p\">:</span>\n        <span class=\"n\">wf</span><span class=\"o\">.</span><span class=\"n\">write</span><span class=\"p\">(</span><span class=\"n\">yaml</span><span class=\"o\">.</span><span class=\"n\">dump</span><span class=\"p\">(</span><span class=\"n\">json</span><span class=\"o\">.</span><span class=\"n\">loads</span><span class=\"p\">(</span><span class=\"n\">line</span><span class=\"p\">))</span> <span class=\"o\">+</span> <span class=\"s2\">\"</span><span class=\"se\">\\n</span><span class=\"s2\">\"</span><span class=\"p\">)</span>\n</pre>\n<p>File or Name lets you the library develop write function that operate on files object making code cleaner and more\ntestable while letting your users interact with your code using simple file path string arguments.</p>\n<h1>Shadow Paging</h1>\n<p>A common problem I have is that I have code that will read from a file with a generator, this lets me process chunks of\ndata and I don't have to worry about memory concerns. The problem is when I want to read data from a file, make changes\nto it and then write back to that same file. You can't open the file for writing because that would destroy the data you\nwant to read in it. A common solution is to read the data in and keep it in memory until you process it all. Then open\nthe file for writing and write it all back. This defeats out want of having a generator to not process it all at once,\nit also means it is possible to have a error when writing data that will leave you in a state with no data. That is why\nI introduced the shadow page to this library. Using a <code>NamedTemporaryFile</code> you can write to this file as much as you\nwant and when you close the file it will be automatically used to replace the file on disk in an atomic way, This means\nyou can't lose you data by having a bug during writing and it lets you write back to a file that you are using a\ngenerator to read from.</p>\n<p>You can use this functionality by prefixing your write modes with a <code>s</code></p>\n<pre><span class=\"nd\">@file_or_name</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"o\">=</span><span class=\"s1\">'r'</span><span class=\"p\">,</span> <span class=\"n\">wf</span><span class=\"o\">=</span><span class=\"s1\">'sw'</span><span class=\"p\">)</span>\n<span class=\"k\">def</span> <span class=\"nf\">reverse</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"p\">,</span> <span class=\"n\">wf</span><span class=\"p\">):</span>\n    <span class=\"n\">data</span> <span class=\"o\">=</span> <span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">read</span><span class=\"p\">()[::</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">]</span>\n    <span class=\"k\">if</span> <span class=\"n\">random</span><span class=\"o\">.</span><span class=\"n\">random</span><span class=\"p\">()</span> <span class=\"o\">&lt;</span> <span class=\"mf\">0.5</span><span class=\"p\">:</span>\n        <span class=\"k\">raise</span> <span class=\"ne\">ValueError</span>\n    <span class=\"n\">wf</span><span class=\"o\">.</span><span class=\"n\">write</span><span class=\"p\">(</span><span class=\"n\">data</span><span class=\"p\">)</span>\n</pre>\n<p>This function will either leave you data intact or reverse it. You don't end up with a state where the data is deleted.</p>\n\n          </div>"}, "last_serial": 7056868, "releases": {"0.0.0": [{"comment_text": "", "digests": {"md5": "212c7d948a96810ad2c00fb97cf18882", "sha256": "e1b99f9e3fa42b65b994630cd1693a1e6a44233f97712fba8cb0242595fa38a9"}, "downloads": -1, "filename": "file-or-name-0.0.0.tar.gz", "has_sig": false, "md5_digest": "212c7d948a96810ad2c00fb97cf18882", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 1932, "upload_time": "2019-12-26T04:18:56", "upload_time_iso_8601": "2019-12-26T04:18:56.209200Z", "url": "https://files.pythonhosted.org/packages/df/ab/d12fa93157ca71a9d61048dd9eccee34e282bf32aa040f8b164d44b98b28/file-or-name-0.0.0.tar.gz", "yanked": false}], "1.0.0": [{"comment_text": "", "digests": {"md5": "00437e82223ea8fc9e52f70eb52abcec", "sha256": "504869c26dbd7f2b2388e5cbf839ae67ff6f7a1902521e73508111744b9573bc"}, "downloads": -1, "filename": "file-or-name-1.0.0.tar.gz", "has_sig": false, "md5_digest": "00437e82223ea8fc9e52f70eb52abcec", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 5193, "upload_time": "2019-12-27T16:14:39", "upload_time_iso_8601": "2019-12-27T16:14:39.200663Z", "url": "https://files.pythonhosted.org/packages/0e/1a/49e84f206448301bfc6ad9185b10adf0645ac08e89b68276ae8eadc70c80/file-or-name-1.0.0.tar.gz", "yanked": false}], "1.1.0": [{"comment_text": "", "digests": {"md5": "d9b042af940bc983056252432d9679bc", "sha256": "99ddd02ac55283e6255a5e6cb051002a28a151425e52e05ebf4f0e2a2d1f7884"}, "downloads": -1, "filename": "file-or-name-1.1.0.tar.gz", "has_sig": false, "md5_digest": "d9b042af940bc983056252432d9679bc", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 6425, "upload_time": "2020-04-14T23:43:54", "upload_time_iso_8601": "2020-04-14T23:43:54.687295Z", "url": "https://files.pythonhosted.org/packages/f0/2b/92b4b7e4a65988a55f1bd0f60a00e48c3610b5aab254fed6f8882ea93d3d/file-or-name-1.1.0.tar.gz", "yanked": false}], "1.1.1": [{"comment_text": "", "digests": {"md5": "7da3f1788895b0d91a3b970dff8d94e3", "sha256": "698ae2d04d2d7fe12455de38f047c645729ad0c52322e43c61edd63c0bfd53ba"}, "downloads": -1, "filename": "file-or-name-1.1.1.tar.gz", "has_sig": false, "md5_digest": "7da3f1788895b0d91a3b970dff8d94e3", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 6755, "upload_time": "2020-04-15T01:36:25", "upload_time_iso_8601": "2020-04-15T01:36:25.172519Z", "url": "https://files.pythonhosted.org/packages/73/85/f99d2abe4c266ae07f759ab9d009e382fac16cae410ac4e985850d53421e/file-or-name-1.1.1.tar.gz", "yanked": false}], "1.1.2": [{"comment_text": "", "digests": {"md5": "a550b68b81bc4594dcca3a9e51568d58", "sha256": "94a713643e66140e92212bfd7f64611eb4fde61773c06481cd8bf53c9d635852"}, "downloads": -1, "filename": "file-or-name-1.1.2.tar.gz", "has_sig": false, "md5_digest": "a550b68b81bc4594dcca3a9e51568d58", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 6747, "upload_time": "2020-04-15T01:47:59", "upload_time_iso_8601": "2020-04-15T01:47:59.112812Z", "url": "https://files.pythonhosted.org/packages/28/93/5505d7dfa3af8a4866856bb8c7d988092d9707f3ba1d8602d4ae60e99b56/file-or-name-1.1.2.tar.gz", "yanked": false}], "1.1.3": [{"comment_text": "", "digests": {"md5": "04592ddca99aff0fdbaabdf1b6da8a1a", "sha256": "acead79b325e7c40741bb3e8fbc5b8a02340b415a705c1a6f5daec396f3bce0f"}, "downloads": -1, "filename": "file-or-name-1.1.3.tar.gz", "has_sig": false, "md5_digest": "04592ddca99aff0fdbaabdf1b6da8a1a", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 6769, "upload_time": "2020-04-20T01:41:49", "upload_time_iso_8601": "2020-04-20T01:41:49.226357Z", "url": "https://files.pythonhosted.org/packages/52/d2/787adb2a2badc8338528984b76c0faa35033a37d5256f830b7688c05b177/file-or-name-1.1.3.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "04592ddca99aff0fdbaabdf1b6da8a1a", "sha256": "acead79b325e7c40741bb3e8fbc5b8a02340b415a705c1a6f5daec396f3bce0f"}, "downloads": -1, "filename": "file-or-name-1.1.3.tar.gz", "has_sig": false, "md5_digest": "04592ddca99aff0fdbaabdf1b6da8a1a", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 6769, "upload_time": "2020-04-20T01:41:49", "upload_time_iso_8601": "2020-04-20T01:41:49.226357Z", "url": "https://files.pythonhosted.org/packages/52/d2/787adb2a2badc8338528984b76c0faa35033a37d5256f830b7688c05b177/file-or-name-1.1.3.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:42:33 2020"}