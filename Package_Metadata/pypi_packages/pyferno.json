{"info": {"author": "Sven Varkel", "author_email": "sven@prototypely.com", "bugtrack_url": null, "classifiers": ["License :: OSI Approved :: MIT License", "Operating System :: OS Independent", "Programming Language :: Python :: 3"], "description": "# PyFerno - an async/promise library for Python 3 async inferno\n\nThe idea of this library is to provide simple methods for working with [async/await](https://docs.python.org/3/library/asyncio.html) in Python.  \n\nThe history behind creating this library is my background from Node.js development. \nNode.js has excellent support for async/await because of its event-based nature.\n\nThere's an excellent Javascript Promise library [Bluebird][https://github.com/petkaantonov/bluebird].\nIt's been used as source for inspiration.\n\nThe name \"Promise\" is also brought over from Javascript world.\n\nFor those who haven't used Javascript promises - you can think of these as \"methods that will or will not finish its job\nsome time in the future. But until then lets (a)wait for it. And it doesn't block/mess with others in the same time\" :)\n\nRight now this library exports 2 methods for working with lists and dicts in an async way.\n\n# Usage\n\n## With list of tasks\n\n```\nfrom pyferno.promise import Promise\n\nasync def async_worker_fn():\n    # do something asynchronously\n    return something\n\ntasks = [\n    async_worker_fn(),\n    async_worker_fn(),\n    async_worker_fn()\n]\nout = await Promise.all(tasks, progress=\"A nice progressbar\")\nprint(out)\n```\n\n## With dict of tasks\n\n```\nfrom pyferno.promise import Promise\n\nasync def async_worker_fn():\n    # do something asynchronously\n    return something\n\ntasks = {\n    \"task1\": async_worker_fn(),\n    \"task2\": async_worker_fn(),\n    \"task3\": async_worker_fn()\n}\nout = await Promise.props(tasks, concurrency=2, progress=\"A nice progressbar\")\nprint(out)\n```\n\n## With a bit more asyncio context\n\n```\nimport asyncio\nfrom pyferno.promise import Promise\n\nasync def async_worker_fn():\n    # do something asynchronously\n    return something\n\n# this function wraps the main logic into async method   \nasync def main_async_wrapper():\n    tasks = [\n        async_worker_fn(),\n        async_worker_fn(),\n        async_worker_fn()\n    ]\n    out = await Promise.all(tasks, progress=\"A nice progressbar\")\n    return out\n\n# note, this is \"normal\" synchronous function\ndef main():\n    loop = asyncio.get_event_loop()\n    out = loop.run_until_complete(main_async_wrapper())\n    loop.close()\n    print(out)\n\nif __name__ == \"__main__\":\n    main()  \n```\n\n# API\n\n## Promise.all(_Promise__tasks: list, concurrency: int = 10, progress: object = None) -> list\n\nRuns thru the list of tasks asynchronously by limiting the concurrency by using a semaphore\n\n    :param __tasks: List of tasks\n    :param concurrency: Concurrency of running tasks, integer. Defaults to 10\n    :param progress: Progress bar message or boolean True to display default progress bar\n    :return: Returns list of finished tasks (fulfilled promises)\n\n\n## Promise.props(_Promise__props: dict, concurrency: int = 10, progress: object = None) -> dict\n\nRuns thru the dict of key,task asynchronously by limiting the concurrency b using a semaphore.\nMaps results back to the dictionary with same keys with all tasks fulfilled.\nIt will fail if any task fails\n\n    :param __tasks: Dict with name:task pairs. Task is an async function\n    :param concurrency: Concurrency of running tasks, integer. Defaults to 10\n    :param progress: Progress bar message or boolean True to display default progress bar\n    :return: Returns dict with name:<finished task> pairs.\n\n\n# License\n\nThis library is licensed with MIT license.\n\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/svenvarkel/pyferno", "keywords": "", "license": "MIT", "maintainer": "", "maintainer_email": "", "name": "pyferno", "package_url": "https://pypi.org/project/pyferno/", "platform": "", "project_url": "https://pypi.org/project/pyferno/", "project_urls": {"Homepage": "https://github.com/svenvarkel/pyferno"}, "release_url": "https://pypi.org/project/pyferno/1.0.2/", "requires_dist": ["pytest (>=4.1.1)", "pytest-asyncio (>=0.10.0)", "tqdm (>=4.29.1)"], "requires_python": ">=3.6", "summary": "PyFerno - the async/promise library for Python 3 async inferno", "version": "1.0.2", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>PyFerno - an async/promise library for Python 3 async inferno</h1>\n<p>The idea of this library is to provide simple methods for working with <a href=\"https://docs.python.org/3/library/asyncio.html\" rel=\"nofollow\">async/await</a> in Python.</p>\n<p>The history behind creating this library is my background from Node.js development.\nNode.js has excellent support for async/await because of its event-based nature.</p>\n<p>There's an excellent Javascript Promise library [Bluebird][https://github.com/petkaantonov/bluebird].\nIt's been used as source for inspiration.</p>\n<p>The name \"Promise\" is also brought over from Javascript world.</p>\n<p>For those who haven't used Javascript promises - you can think of these as \"methods that will or will not finish its job\nsome time in the future. But until then lets (a)wait for it. And it doesn't block/mess with others in the same time\" :)</p>\n<p>Right now this library exports 2 methods for working with lists and dicts in an async way.</p>\n<h1>Usage</h1>\n<h2>With list of tasks</h2>\n<pre><code>from pyferno.promise import Promise\n\nasync def async_worker_fn():\n    # do something asynchronously\n    return something\n\ntasks = [\n    async_worker_fn(),\n    async_worker_fn(),\n    async_worker_fn()\n]\nout = await Promise.all(tasks, progress=\"A nice progressbar\")\nprint(out)\n</code></pre>\n<h2>With dict of tasks</h2>\n<pre><code>from pyferno.promise import Promise\n\nasync def async_worker_fn():\n    # do something asynchronously\n    return something\n\ntasks = {\n    \"task1\": async_worker_fn(),\n    \"task2\": async_worker_fn(),\n    \"task3\": async_worker_fn()\n}\nout = await Promise.props(tasks, concurrency=2, progress=\"A nice progressbar\")\nprint(out)\n</code></pre>\n<h2>With a bit more asyncio context</h2>\n<pre><code>import asyncio\nfrom pyferno.promise import Promise\n\nasync def async_worker_fn():\n    # do something asynchronously\n    return something\n\n# this function wraps the main logic into async method   \nasync def main_async_wrapper():\n    tasks = [\n        async_worker_fn(),\n        async_worker_fn(),\n        async_worker_fn()\n    ]\n    out = await Promise.all(tasks, progress=\"A nice progressbar\")\n    return out\n\n# note, this is \"normal\" synchronous function\ndef main():\n    loop = asyncio.get_event_loop()\n    out = loop.run_until_complete(main_async_wrapper())\n    loop.close()\n    print(out)\n\nif __name__ == \"__main__\":\n    main()  \n</code></pre>\n<h1>API</h1>\n<h2>Promise.all(_Promise__tasks: list, concurrency: int = 10, progress: object = None) -&gt; list</h2>\n<p>Runs thru the list of tasks asynchronously by limiting the concurrency by using a semaphore</p>\n<pre><code>:param __tasks: List of tasks\n:param concurrency: Concurrency of running tasks, integer. Defaults to 10\n:param progress: Progress bar message or boolean True to display default progress bar\n:return: Returns list of finished tasks (fulfilled promises)\n</code></pre>\n<h2>Promise.props(_Promise__props: dict, concurrency: int = 10, progress: object = None) -&gt; dict</h2>\n<p>Runs thru the dict of key,task asynchronously by limiting the concurrency b using a semaphore.\nMaps results back to the dictionary with same keys with all tasks fulfilled.\nIt will fail if any task fails</p>\n<pre><code>:param __tasks: Dict with name:task pairs. Task is an async function\n:param concurrency: Concurrency of running tasks, integer. Defaults to 10\n:param progress: Progress bar message or boolean True to display default progress bar\n:return: Returns dict with name:&lt;finished task&gt; pairs.\n</code></pre>\n<h1>License</h1>\n<p>This library is licensed with MIT license.</p>\n\n          </div>"}, "last_serial": 6399553, "releases": {"1.0.0": [{"comment_text": "", "digests": {"md5": "9fbedf2e32136aab6bf0530f4880081e", "sha256": "810df5e58117cc78362dfb46777877d25af85e5b88c89327df98bb6cd3173697"}, "downloads": -1, "filename": "pyferno-1.0.0-py3-none-any.whl", "has_sig": false, "md5_digest": "9fbedf2e32136aab6bf0530f4880081e", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 6638, "upload_time": "2019-11-08T12:11:41", "upload_time_iso_8601": "2019-11-08T12:11:41.991814Z", "url": "https://files.pythonhosted.org/packages/df/60/518fb37cc6439afc76b9cb834bc5c012e5c1ae58405144d2cec1a1dbd357/pyferno-1.0.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "1a0f0584a1f07dbd4caaae12d83d99b3", "sha256": "7ffd8a532681113e30addbd51f6c56e2a00cc15dd88b79f8e477bf85b5d1c81a"}, "downloads": -1, "filename": "pyferno-1.0.0.tar.gz", "has_sig": false, "md5_digest": "1a0f0584a1f07dbd4caaae12d83d99b3", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 4195, "upload_time": "2019-11-08T12:11:43", "upload_time_iso_8601": "2019-11-08T12:11:43.968934Z", "url": "https://files.pythonhosted.org/packages/50/63/b1bdcede5ef4c06c6e4bb629167abd16545a10c9e3e99cd9de46bd9ad5fe/pyferno-1.0.0.tar.gz", "yanked": false}], "1.0.2": [{"comment_text": "", "digests": {"md5": "0d1486c30cb3db6646ee211ed04a9f51", "sha256": "7b3d0ddb0e0afc4fb268ef4d3fb792114c46cffb68b42137c9cb90b5fe3e04d4"}, "downloads": -1, "filename": "pyferno-1.0.2-py3-none-any.whl", "has_sig": false, "md5_digest": "0d1486c30cb3db6646ee211ed04a9f51", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 6580, "upload_time": "2020-01-05T21:21:45", "upload_time_iso_8601": "2020-01-05T21:21:45.063534Z", "url": "https://files.pythonhosted.org/packages/d3/8b/5b29946ce95db51583e68f1b5619864eaf3e8354936aefa303999764828b/pyferno-1.0.2-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "36ec955669c7e7c95c87a438cafc52fa", "sha256": "0c212fc39676600a47899909a34db1f0060c564c823b8dab278d5fee8e12c6ed"}, "downloads": -1, "filename": "pyferno-1.0.2.tar.gz", "has_sig": false, "md5_digest": "36ec955669c7e7c95c87a438cafc52fa", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 4158, "upload_time": "2020-01-05T21:21:46", "upload_time_iso_8601": "2020-01-05T21:21:46.322607Z", "url": "https://files.pythonhosted.org/packages/d8/a4/da1701df87082a1edbef76aee551f6dbc96582f11ea588b60394c6a3510c/pyferno-1.0.2.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "0d1486c30cb3db6646ee211ed04a9f51", "sha256": "7b3d0ddb0e0afc4fb268ef4d3fb792114c46cffb68b42137c9cb90b5fe3e04d4"}, "downloads": -1, "filename": "pyferno-1.0.2-py3-none-any.whl", "has_sig": false, "md5_digest": "0d1486c30cb3db6646ee211ed04a9f51", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 6580, "upload_time": "2020-01-05T21:21:45", "upload_time_iso_8601": "2020-01-05T21:21:45.063534Z", "url": "https://files.pythonhosted.org/packages/d3/8b/5b29946ce95db51583e68f1b5619864eaf3e8354936aefa303999764828b/pyferno-1.0.2-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "36ec955669c7e7c95c87a438cafc52fa", "sha256": "0c212fc39676600a47899909a34db1f0060c564c823b8dab278d5fee8e12c6ed"}, "downloads": -1, "filename": "pyferno-1.0.2.tar.gz", "has_sig": false, "md5_digest": "36ec955669c7e7c95c87a438cafc52fa", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 4158, "upload_time": "2020-01-05T21:21:46", "upload_time_iso_8601": "2020-01-05T21:21:46.322607Z", "url": "https://files.pythonhosted.org/packages/d8/a4/da1701df87082a1edbef76aee551f6dbc96582f11ea588b60394c6a3510c/pyferno-1.0.2.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:05:53 2020"}