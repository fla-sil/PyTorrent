{"info": {"author": "Niall Douglas and David Beazley", "author_email": "", "bugtrack_url": null, "classifiers": ["Development Status :: 5 - Production/Stable", "Intended Audience :: Developers", "License :: OSI Approved :: BSD License", "Programming Language :: Python :: 2", "Programming Language :: Python :: 2.7", "Programming Language :: Python :: 3", "Topic :: Software Development :: Build Tools"], "description": "A C99 preprocessor written in pure Python\n=========================================\n.. role:: c(code)\n   :language: c\n\n.. |travis| image:: https://travis-ci.org/ned14/pcpp.svg?branch=master\n    :align: middle\n    :target: https://travis-ci.org/ned14/pcpp\n\n\\(C) 2018-2019 Niall Douglas http://www.nedproductions.biz/ and (C) 2007-2019 David Beazley http://www.dabeaz.com/\n\nPyPI: https://pypi.python.org/pypi/pcpp Github: https://github.com/ned14/pcpp API reference docs: https://ned14.github.io/pcpp/\n\nTravis master branch all tests passing for Python v2 and v3: |travis|\n\nA pure universal Python C (pre-)preprocessor implementation very useful for pre-preprocessing header only\nC++ libraries into single file includes and other such build or packaging stage malarky.\nThe implementation can be used as a Python module (`see API reference <https://ned14.github.io/pcpp/>`_)\nor as a command line tool ``pcpp`` which\ncan stand in for a conventional C preprocessor (i.e. it'll accept similar arguments).\n\nYour includes can be benchmarked for heft in order to improve your build times! See\nthe ``--times`` and ``--filetimes`` options.\n\nA very unique facility of this C preprocessor is *partial* preprocessing so you can\nprogrammatically control how much preprocessing is done by ``pcpp`` and how much is\ndone by the C or C++ compiler's preprocessor. The ultimate control is by subclassing\nthe :c:`Preprocessor` class in Python from which you can do anything you like, however\nfor your convenience the ``pcpp`` command line tool comes with the following canned\npartial preprocessing algorithms:\n\n**passthru-defines**\n  Pass through but still execute #defines and #undefs if not always removed by\n  preprocessor logic. This ensures that including the output sets exactly the same\n  macros as if you included the original, plus include guards work.\n\n**passthru-unfound-includes**\n  If an :c:`#include` is not found, pass it through unmodified. This is very useful\n  for passing through includes of system headers.\n\n**passthru-undefined-exprs**\n  This is one of the most powerful pass through algorithms. If an expression passed to\n  :c:`#if` (or its brethern) contains an unknown macro, expand the expression with\n  known macros and pass through *unexecuted*, and then pass through the remaining block.\n  Each :c:`#elif` is evaluated in turn and if it does not contain unknown macros, it will be\n  executed immediately. Finally, any :c:`#else` clause is always passed through *unexecuted*.\n  Note that include guards normally defeat this algorithm, so those are specially detected and\n  ignored.\n\n**passthru-comments**\n  A major use case for ``pcpp`` is as a preprocessor for the `doxygen <http://www.stack.nl/~dimitri/doxygen/>`_\n  reference documentation tool whose preprocessor is unable to handle any preprocessing\n  of any complexity. ``pcpp`` can partially execute the preprocessing which doxygen\n  is incapable of, thus generating output which produces good results with doxygen.\n  Hence the ability to pass through comments containing doxygen markup is very useful.\n\n**passthru-magic-macros**\n  Don't expand ``__DATE__``, ``__TIME__``, ``__FILE__``, ``__LINE__`` nor ``__COUNTER__``.\n\nStandards (non-)compliance\n--------------------------\n``pcpp`` passes a modified edition of the `mcpp <http://mcpp.sourceforge.net/>`_ unit\ntest suite. Modifications done were to clarify ternary operators with extra brackets,\nplus those testing the unusual special quirks in expression evaluation (see detailed\ndescription below). It also passes the list of \"preprocessor torture\" expansion fragments\nin the C11 standard, correctly expanding some very complex recursive macro expansions\nwhere expansions cause new macro expansions to be formed. In this, it handily beats\nthe MSVC preprocessor and ought to handle most C99 preprocessor metaprogramming.\nIf you compare its output side-by-side to that of GCC or clang's preprocessor, results\nare extremely close indeed with blank line collapsing being the only difference.\n\nThe most non-conforming part is :c:`#if` expression\nparsing (donations of a proper yacc based parser for executing :c:`#if` expressions based on\nhttp://www.dabeaz.com/ply/ are welcome). In practice, in most real world code, you\nwon't notice the departures and if you do, the application of extra brackets to\ngroup subexpressions so Python's :c:`eval()` executes right will fix it.\n\nA full, detailed list of known non-conformance with the C99 standard is below. We have\nbeen told that ``pcpp`` does not pass the Boost.Wave preprocessor test suite, but\nthe chances of that biting most people is low. If it does, pull requests with bug\nfixes and new unit tests for the fix are welcome.\n\nNote that most of this preprocessor was written originally by David Beazley to show\noff his excellent Python Lex-Yacc library PLY (http://www.dabeaz.com/ply/) and is\nhidden in there without being at all obvious given the number of Stackoverflow\nquestions which have asked for a pure Python C preprocessor implementation. This\nimplementation fixes a lot of conformance bugs (the original was never intended to\nrigidly adhere to the C standard) and adds in a test suite based on the C11 preprocessor\ntorture samples plus the mcpp preprocessor test suite. Still, this project would\nnot be possible without David's work, so please take off your hat and give a bow towards him.\n\nCommand line tool ``pcpp``:\n---------------------------\nThe help from the command line tool ``pcpp``::\n\n    usage: pcpp [-h] [-o [path]] [-D macro[=val]] [-U macro] [-N macro] [-I path]\n                [--passthru-defines] [--passthru-unfound-includes]\n                [--passthru-unknown-exprs] [--passthru-comments]\n                [--disable-auto-pragma-once] [--line-directive [form]] [--debug]\n                [--time] [--filetimes [path]] [--version]\n                [input [input ...]]\n\n    A pure universal Python C (pre-)preprocessor implementation very useful for\n    pre-preprocessing header only C++ libraries into single file includes and\n    other such build or packaging stage malarky.\n\n    positional arguments:\n      input                 Files to preprocess\n\n    optional arguments:\n      -h, --help            show this help message and exit\n      -o [path]             Output to a file instead of stdout\n      -D macro[=val]        Predefine name as a macro [with value]\n      -U macro              Pre-undefine name as a macro\n      -N macro              Never define name as a macro, even if defined during\n                            the preprocessing.\n      -I path               Path to search for unfound #include's\n      --passthru-defines    Pass through but still execute #defines and #undefs if\n                            not always removed by preprocessor logic\n      --passthru-unfound-includes\n                            Pass through #includes not found without execution\n      --passthru-unknown-exprs\n                            Unknown macros in expressions cause preprocessor logic\n                            to be passed through instead of executed by treating\n                            unknown macros as 0L\n      --passthru-comments   Pass through comments unmodified\n      --passthru-magic-macros\n                            Pass through double underscore magic macros unmodified\n      --disable-auto-pragma-once\n                            Disable the heuristics which auto apply #pragma once\n                            to #include files wholly wrapped in an obvious include\n                            guard macro\n      --line-directive [form]\n                            Form of line directive to use, defaults to #line,\n                            specify nothing to disable output of line directives\n      --debug               Generate a pcpp_debug.log file logging execution\n      --time                Print the time it took to #include each file\n      --filetimes [path]    Write CSV file with time spent inside each included\n                            file, inclusive and exclusive\n      --compress            Make output as small as possible\n      --version             show program's version number and exit\n\n    Note that so pcpp can stand in for other preprocessor tooling, it ignores any\n    arguments it does not understand.\n\nQuick demo of pass through mode\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nLet us look at an example for pass through mode. Here is the original:\n\n.. code-block:: c\n\n    #if !defined(__cpp_constexpr)\n    #if __cplusplus >= 201402L\n    #define __cpp_constexpr 201304  // relaxed constexpr\n    #else\n    #define __cpp_constexpr 190000\n    #endif\n    #endif\n    #ifndef BOOSTLITE_CONSTEXPR\n    #if __cpp_constexpr >= 201304\n    #define BOOSTLITE_CONSTEXPR constexpr\n    #endif\n    #endif\n    #ifndef BOOSTLITE_CONSTEXPR\n    #define BOOSTLITE_CONSTEXPR\n    #endif\n\n``pcpp test.h --passthru-defines --passthru-unknown-exprs`` will output:\n\n.. code-block:: c\n\n    #if !defined(__cpp_constexpr)\n    #if __cplusplus >= 201402\n    #define __cpp_constexpr 201304\n    #else\n    #define __cpp_constexpr 190000\n    #endif\n    #endif\n    #ifndef BOOSTLITE_CONSTEXPR\n    #if __cpp_constexpr >= 201304\n    #define BOOSTLITE_CONSTEXPR constexpr\n    #endif\n    #endif\n    #ifndef BOOSTLITE_CONSTEXPR\n    #define BOOSTLITE_CONSTEXPR\n    #endif\n\nThis is because ``__cpp_constexpr`` was not defined, so because of the ``--passthru-unknown-exprs`` flag\nwe pass through everything inside that if block **unexecuted** i.e. defines and undefs are NOT executed by\n``pcpp``. Let's define ``__cpp_constexpr``:\n\n``pcpp test.h --passthru-defines --passthru-unknown-exprs -D __cpp_constexpr``\n\n.. code-block:: c\n\n    #line 8 \"test.h\"\n    #ifndef BOOSTLITE_CONSTEXPR\n\n\n\n    #endif\n    #ifndef BOOSTLITE_CONSTEXPR\n    #define BOOSTLITE_CONSTEXPR\n    #endif\n\nSo, big difference now. We execute the entire first if block as ``__cpp_constexpr`` is now defined, thus\nleaving whitespace. Let's try setting ``__cpp_constexpr`` a bit higher:\n\n``pcpp test.h --passthru-defines --passthru-unknown-exprs -D __cpp_constexpr=201304``\n\n.. code-block:: c\n\n    #line 8 \"test.h\"\n    #ifndef BOOSTLITE_CONSTEXPR\n\n    #define BOOSTLITE_CONSTEXPR constexpr\n\n    #endif\n\nAs you can see, the lines related to the known ``__cpp_constexpr`` are executed and removed, passing through\nany if blocks with unknown macros in the expression.\n\nWhat if you want a macro to be known but undefined? The -U (to undefine) flag has an obvious meaning in pass\nthrough mode in that it makes a macro no longer unknown, but known to be undefined.\n\n``pcpp test.h --passthru-defines --passthru-unknown-exprs -U __cpp_constexpr``\n\n.. code-block:: c\n\n    #if __cplusplus >= 201402\n    #define __cpp_constexpr 201304\n    #else\n    #define __cpp_constexpr 190000\n    #endif\n\n    #ifndef BOOSTLITE_CONSTEXPR\n\n\n\n    #endif\n    #ifndef BOOSTLITE_CONSTEXPR\n    #define BOOSTLITE_CONSTEXPR\n    #endif\n\nHere ``__cpp_constexpr`` is known to be undefined so the first clause executes, but ``__cplusplus`` is\nunknown so that entire block is passed through unexecuted. In the next test comparing ``__cpp_constexpr``\nto 201304 it is still known to be undefined, and so 0 >= 201304 is the expressions tested which is false,\nhence the following stanza is removed entirely.\n\nHelping ``pcpp`` using source code annotation\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nYou can achieve a great deal using -D (define), -U (undefine) and -N (never define) on the command line,\nbut for more complex preprocessing it gets hard to pass through the correct logic without some source code\nannotation.\n\n``pcpp`` lets you annotate which part of an if block being passed through due to use of unknown macros\nto also be executed in addition to the pass through. For this use ``__PCPP_ALWAYS_FALSE__`` or\n``__PCPP_ALWAYS_TRUE__`` which tells ``pcpp`` to temporarily start executing the passed through\npreprocessor commands e.g.\n\n.. code-block:: c\n\n    #if !defined(__cpp_constexpr)\n    #if __cplusplus >= 201402L \n    #define __cpp_constexpr 201304\n    #elif !__PCPP_ALWAYS_FALSE__     // pcpp please execute this next block\n    #define __cpp_constexpr 190000\n    #endif\n    #endif\n    #ifndef BOOSTLITE_CONSTEXPR\n    #if __cpp_constexpr >= 201304\n    #define BOOSTLITE_CONSTEXPR constexpr\n    #endif\n    #endif\n    #ifndef BOOSTLITE_CONSTEXPR\n    #define BOOSTLITE_CONSTEXPR\n    #endif\n\nNote that ``__PCPP_ALWAYS_FALSE__`` will always be false in any other preprocessor, and it is also\nfalse in ``pcpp``. However it causes ``pcpp`` to execute the define of ``__cpp_constexpr`` to 190000:\n\n``pcpp test.h --passthru-defines --passthru-unknown-exprs``\n\n.. code-block:: c\n\n    #if !defined(__cpp_constexpr)\n    #if __cplusplus >= 201402\n    #define __cpp_constexpr 201304\n    #elif 1\n    #define __cpp_constexpr 190000\n    #endif\n    #endif\n    #ifndef BOOSTLITE_CONSTEXPR\n\n\n\n    #endif\n    #ifndef BOOSTLITE_CONSTEXPR\n    #define BOOSTLITE_CONSTEXPR\n    #endif\n\nThis is one way of marking up ``#else`` clauses so they always execute in a normal preprocessor\nand also pass through with execution with ``pcpp``. You can, of course, also place ``|| __PCPP_ALWAYS_FALSE__``\nin any ``#if`` stanza to cause it to be passed through with execution, but not affect the\npreprocessing logic otherwise.\n\nWhat's implemented by the ``Preprocessor`` class:\n=================================================\n- Digraphs and Trigraphs\n- line continuation operator '``\\``'\n- C99 correct elimination of comments and maintenance of whitespace in output.\n- :c:`__DATE__`, :c:`__TIME__`, :c:`__FILE__`, :c:`__LINE__`. Note that :c:`__STDC__` et al are NOT defined by\n  default, you need to define those manually before starting preprocessing.\n- :c:`__COUNTER__`, a very common extension\n- Object :c:`#define`\n- Function :c:`#define macro(...)`\n\n  - Retokenisation and reexpansion after expansion is C99 compliant.\n\n- :c:`#undef`\n- :c:`#include \"path\"`, :c:`<path>` and :c:`PATH`\n- :c:`defined` operator\n- C operators:\n\n  - :c:`+, -, !, ~`\n  - :c:`*, /, %`\n  - :c:`+, -`\n  - :c:`<<, >>`\n  - :c:`<, <=, >, >=`\n  - :c:`==, !=`\n  - :c:`&`\n  - :c:`^`\n  - :c:`|`\n  - :c:`&&`\n  - :c:`||`\n  - :c:`x ? y : z` (partial support, see known bugs)\n\n- :c:`#if`, :c:`#ifdef`, :c:`#ifndef`, :c:`#elif`, :c:`#else`, :c:`#endif`\n- Stringizing operator #\n- Token pasting operator ##\n- :c:`#pragma once`, a very common extension\n\nAdditionally implemented by ``pcpp`` command line tool:\n-------------------------------------------------------\n- :c:`#error` (default implementation prints to stderr and increments the exit code)\n- :c:`#warning` (default implementation prints to stderr)\n\nNot implemented yet (donations of code welcome):\n------------------------------------------------\n- :c:`#pragma` anything other than :c:`once`.\n- :c:`_Pragma` used to emit preprocessor calculated #pragma.\n- :c:`#line num`, :c:`num \"file\"` and :c:`NUMBER FILE`.\n\nKnown bugs (ordered from worst to least worst):\n-----------------------------------------------\n**Expression evaluation is a bit broken**\n Currently :c:`#if` expressions are evaluated by converting them into Python\n expressions and calling :c:`eval()` on them. This works surprisingly well\n most of the time, but because Python is not C, corner cases break.\n These are the known such broken corner cases:\n\n - Unary operator evaluation will break for evil expressions such as :c:`-!+!9`\n   because logical NOT in Python results in a boolean, not an integer, and\n   a unary plus or negative boolean is invalid syntax in Python\n - Similarly expressions which assume that boolean operations output either\n   a zero or a one will fail e.g. :c:`(2 || 3) == 0`\n - Python has no concept of an unsigned integer and C expressions relying\n   on unsigned integer semantics will fail badly e.g. :c:`-1 <= 0U`\n   is supposed to be evaluated as false in the C preprocessor, but it will be\n   evaluated as true under this implementation. To be honest\n   if your preprocessor logic is relying on those sorts of behaviours, you should rewrite it.\n - Without a back tracking parser, the C ternary operator is hard to accurately\n   convert into a Python ternary operation, so you need to help it by using one\n   of these two forms:\n\n   - :c:`(x) ? y : z` (z gets evaluated according to Python not C precedence)\n   - :c:`(x ? y : z)` (preferred, evaluates correctly, we inject brackets\n     around the subexpessions before sending to Python)\n\n A proper lexing parser based on http://www.dabeaz.com/ply/'s yacc module has\n been started and can be found in the https://github.com/ned14/pcpp/tree/yacc_expression_evaluator\n branch. Time to complete it, is the problem, and any pull requests helping with\n that are welcome.\n\n**We do not pass the Boost.Wave preprocessor test suite**\n A lot of bugs have been fixed since this was reported, however the chances are\n that ``pcpp`` still doesn't pass it. A TODO is to port the Wave test suite to\n Python and find out how bad things are. We suspect that any failures will be\n in highly estoric use cases i.e. known illegal input. If you only use valid\n input then we expect you generally won't have trouble.\n\nCustomising your own preprocessor:\n==================================\nSee the API reference docs at https://ned14.github.io/pcpp/\n\nYou can find an example of overriding the ``on_*()`` processing hooks at https://github.com/ned14/pcpp/blob/master/pcpp/pcpp_cmd.py\n\nHistory:\n========\nv1.21 (30th September 2019):\n----------------------------\n- Fix bug where token pasting two numeric tokens did not yield a numeric token. Thanks\n  to Sei-Lisa for reporting this.\n- BREAKING CHANGE: Paths emitted by pcpp into ``#line`` directives now are relative to the\n  working directory of the process when ``Preprocessor`` is initialised. This includes\n  added search paths - files included from those locations will be emitted with a sequence\n  of ``../`` to relativise the path emitted. If no path exists between the working\n  directory and the path of the file being emitted, an absolute path is emitted instead.\n\n  If you wish to disable this new behaviour, or use different behaviour, you can\n  customise the new `rewrite_paths` member variable of ``Preprocessor``.\n- Fix bug where ``__LINE__`` was expanding into the line number of its definition instead\n  of its use. Thanks to Sei-Lisa for reporting this.\n- Add ``--passthru-magic-macros`` command line option.\n- BREAKING CHANGE: The ``PreprocessorHooks`` and ``OutputDirective`` interface has\n  changed. One now must specify the kind of ``OutputDirective`` abort one wants, and one\n  can now both ignore AND remove directives. ``on_directive_handle()`` and\n  ``on_directive_unknown()`` now take an extra parameter ``precedingtoks``, these are the\n  tokens from the ``#`` up to the directive.\n- Fix a corner case where ``FUNC(void)foo()`` expanded to ``voidfoo()`` and not\n  ``void foo()`` which is a very common non-conforming extension of the C preprocessor.\n  Thanks to OmegaDoom for reporting this.\n- Add tokens for all the C operators, to help implementation of an expression evaluator.\n- Updated embedded ply to HEAD (2019-04-25)\n- Fix ``#include`` not working if no ``-I`` parameters were supplied. Thanks to csm10495\n  for reporting this.\n\nv1.20 (7th January 2019):\n-------------------------\n- Now supports character literals in expressions. Thanks to untaugh for the pull request\n  adding this.\n- Stopped the default collapsing of whitespace in output, and made it optional via a\n  new command line option ``--compress``.\n- Fixed extraneous whitespace in ``--passthru-comments`` caused by multiline comments.\n  Thanks to p2k for reporting this.\n- Fixed bug where defining a macro via string did not set the source attribute in the\n  token. Thanks to ZedThree for reporting this.\n- Stop triggering an exception when no arguments are supplied to pcpp. Thanks to\n  virtuald for reporting this.\n- Rebase onto PLY latest from Dec 28th 2018 (https://github.com/dabeaz/ply/commit/a37e0839583d683d95e70ce1445c0063c7d4bd21). Latest\n  PLY no longer works using pypi packaging, David wants people to include the source of\n  PLY directly. pcpp does this via a git submodule, and has setuptools bundle the submodule.\n- Add a formal LICENSE.txt file, as requested by Sei-Lisa.\n- Fix failure to issue ``#line`` directive for first include file in a file. Thanks to\n  Sei-Lisa for reporting this.\n\nv1.1 (19th June 2018):\n----------------------\n- Added the ``--times`` and ``--filetimes`` features.\n- Fix bug where macros containing operator `defined` were not being expanded properly.\n- Added the ability to accept multiple inputs, they are concatenated into the output.\n- Fix bug where lines beginning with `#` and no contents caused an internal preprocessor error.\n- Fix bug where the macro expansion ``par par##ext`` was expanding into ``parext parext``.\n\nv1.01 (21st Feb 2018):\n----------------------\n- Fix bug where in pass through mode, an #elif in an #if block inside an #if block in ifpassthru was failing to be passed through.\n- Downgraded failure to evaluate an expression to a warning.\n- Fix missing Readme.rst in pypi package.\n\nv1.00 (13th Mar 2017):\n----------------------\nFirst release\n\n\n", "description_content_type": "", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "http://pypi.python.org/pypi/pcpp", "keywords": "", "license": "BSD", "maintainer": "", "maintainer_email": "", "name": "pcpp", "package_url": "https://pypi.org/project/pcpp/", "platform": "", "project_url": "https://pypi.org/project/pcpp/", "project_urls": {"Homepage": "http://pypi.python.org/pypi/pcpp"}, "release_url": "https://pypi.org/project/pcpp/1.21/", "requires_dist": null, "requires_python": "", "summary": "A C99 preprocessor written in pure Python", "version": "1.21", "yanked": false, "html_description": "<div class=\"project-description\">\n            <div id=\"a-c99-preprocessor-written-in-pure-python\">\n<h2>A C99 preprocessor written in pure Python</h2>\n<p>(C) 2018-2019 Niall Douglas <a href=\"http://www.nedproductions.biz/\" rel=\"nofollow\">http://www.nedproductions.biz/</a> and (C) 2007-2019 David Beazley <a href=\"http://www.dabeaz.com/\" rel=\"nofollow\">http://www.dabeaz.com/</a></p>\n<p>PyPI: <a href=\"https://pypi.python.org/pypi/pcpp\" rel=\"nofollow\">https://pypi.python.org/pypi/pcpp</a> Github: <a href=\"https://github.com/ned14/pcpp\" rel=\"nofollow\">https://github.com/ned14/pcpp</a> API reference docs: <a href=\"https://ned14.github.io/pcpp/\" rel=\"nofollow\">https://ned14.github.io/pcpp/</a></p>\n<p>Travis master branch all tests passing for Python v2 and v3: <a href=\"https://travis-ci.org/ned14/pcpp\" rel=\"nofollow\"><img alt=\"travis\" class=\"align-middle\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/ccc1b7437d2c4599b449fc8b9a564996e372d1da/68747470733a2f2f7472617669732d63692e6f72672f6e656431342f706370702e7376673f6272616e63683d6d6173746572\"></a></p>\n<p>A pure universal Python C (pre-)preprocessor implementation very useful for pre-preprocessing header only\nC++ libraries into single file includes and other such build or packaging stage malarky.\nThe implementation can be used as a Python module (<a href=\"https://ned14.github.io/pcpp/\" rel=\"nofollow\">see API reference</a>)\nor as a command line tool <tt>pcpp</tt> which\ncan stand in for a conventional C preprocessor (i.e. it\u2019ll accept similar arguments).</p>\n<p>Your includes can be benchmarked for heft in order to improve your build times! See\nthe <tt><span class=\"pre\">--times</span></tt> and <tt><span class=\"pre\">--filetimes</span></tt> options.</p>\n<p>A very unique facility of this C preprocessor is <em>partial</em> preprocessing so you can\nprogrammatically control how much preprocessing is done by <tt>pcpp</tt> and how much is\ndone by the C or C++ compiler\u2019s preprocessor. The ultimate control is by subclassing\nthe <code class=\"c\"><span class=\"n\">Preprocessor</span></code> class in Python from which you can do anything you like, however\nfor your convenience the <tt>pcpp</tt> command line tool comes with the following canned\npartial preprocessing algorithms:</p>\n<dl>\n<dt><strong>passthru-defines</strong></dt>\n<dd>Pass through but still execute #defines and #undefs if not always removed by\npreprocessor logic. This ensures that including the output sets exactly the same\nmacros as if you included the original, plus include guards work.</dd>\n<dt><strong>passthru-unfound-includes</strong></dt>\n<dd>If an <code class=\"c\"><span class=\"cp\">#include</span></code> is not found, pass it through unmodified. This is very useful\nfor passing through includes of system headers.</dd>\n<dt><strong>passthru-undefined-exprs</strong></dt>\n<dd>This is one of the most powerful pass through algorithms. If an expression passed to\n<code class=\"c\"><span class=\"cp\">#if</span></code> (or its brethern) contains an unknown macro, expand the expression with\nknown macros and pass through <em>unexecuted</em>, and then pass through the remaining block.\nEach <code class=\"c\"><span class=\"cp\">#elif</span></code> is evaluated in turn and if it does not contain unknown macros, it will be\nexecuted immediately. Finally, any <code class=\"c\"><span class=\"cp\">#else</span></code> clause is always passed through <em>unexecuted</em>.\nNote that include guards normally defeat this algorithm, so those are specially detected and\nignored.</dd>\n<dt><strong>passthru-comments</strong></dt>\n<dd>A major use case for <tt>pcpp</tt> is as a preprocessor for the <a href=\"http://www.stack.nl/~dimitri/doxygen/\" rel=\"nofollow\">doxygen</a>\nreference documentation tool whose preprocessor is unable to handle any preprocessing\nof any complexity. <tt>pcpp</tt> can partially execute the preprocessing which doxygen\nis incapable of, thus generating output which produces good results with doxygen.\nHence the ability to pass through comments containing doxygen markup is very useful.</dd>\n<dt><strong>passthru-magic-macros</strong></dt>\n<dd>Don\u2019t expand <tt>__DATE__</tt>, <tt>__TIME__</tt>, <tt>__FILE__</tt>, <tt>__LINE__</tt> nor <tt>__COUNTER__</tt>.</dd>\n</dl>\n<div id=\"standards-non-compliance\">\n<h3>Standards (non-)compliance</h3>\n<p><tt>pcpp</tt> passes a modified edition of the <a href=\"http://mcpp.sourceforge.net/\" rel=\"nofollow\">mcpp</a> unit\ntest suite. Modifications done were to clarify ternary operators with extra brackets,\nplus those testing the unusual special quirks in expression evaluation (see detailed\ndescription below). It also passes the list of \u201cpreprocessor torture\u201d expansion fragments\nin the C11 standard, correctly expanding some very complex recursive macro expansions\nwhere expansions cause new macro expansions to be formed. In this, it handily beats\nthe MSVC preprocessor and ought to handle most C99 preprocessor metaprogramming.\nIf you compare its output side-by-side to that of GCC or clang\u2019s preprocessor, results\nare extremely close indeed with blank line collapsing being the only difference.</p>\n<p>The most non-conforming part is <code class=\"c\"><span class=\"cp\">#if</span></code> expression\nparsing (donations of a proper yacc based parser for executing <code class=\"c\"><span class=\"cp\">#if</span></code> expressions based on\n<a href=\"http://www.dabeaz.com/ply/\" rel=\"nofollow\">http://www.dabeaz.com/ply/</a> are welcome). In practice, in most real world code, you\nwon\u2019t notice the departures and if you do, the application of extra brackets to\ngroup subexpressions so Python\u2019s <code class=\"c\"><span class=\"n\">eval</span><span class=\"p\">()</span></code> executes right will fix it.</p>\n<p>A full, detailed list of known non-conformance with the C99 standard is below. We have\nbeen told that <tt>pcpp</tt> does not pass the Boost.Wave preprocessor test suite, but\nthe chances of that biting most people is low. If it does, pull requests with bug\nfixes and new unit tests for the fix are welcome.</p>\n<p>Note that most of this preprocessor was written originally by David Beazley to show\noff his excellent Python Lex-Yacc library PLY (<a href=\"http://www.dabeaz.com/ply/\" rel=\"nofollow\">http://www.dabeaz.com/ply/</a>) and is\nhidden in there without being at all obvious given the number of Stackoverflow\nquestions which have asked for a pure Python C preprocessor implementation. This\nimplementation fixes a lot of conformance bugs (the original was never intended to\nrigidly adhere to the C standard) and adds in a test suite based on the C11 preprocessor\ntorture samples plus the mcpp preprocessor test suite. Still, this project would\nnot be possible without David\u2019s work, so please take off your hat and give a bow towards him.</p>\n</div>\n<div id=\"command-line-tool-pcpp\">\n<h3>Command line tool <tt>pcpp</tt>:</h3>\n<p>The help from the command line tool <tt>pcpp</tt>:</p>\n<pre>usage: pcpp [-h] [-o [path]] [-D macro[=val]] [-U macro] [-N macro] [-I path]\n            [--passthru-defines] [--passthru-unfound-includes]\n            [--passthru-unknown-exprs] [--passthru-comments]\n            [--disable-auto-pragma-once] [--line-directive [form]] [--debug]\n            [--time] [--filetimes [path]] [--version]\n            [input [input ...]]\n\nA pure universal Python C (pre-)preprocessor implementation very useful for\npre-preprocessing header only C++ libraries into single file includes and\nother such build or packaging stage malarky.\n\npositional arguments:\n  input                 Files to preprocess\n\noptional arguments:\n  -h, --help            show this help message and exit\n  -o [path]             Output to a file instead of stdout\n  -D macro[=val]        Predefine name as a macro [with value]\n  -U macro              Pre-undefine name as a macro\n  -N macro              Never define name as a macro, even if defined during\n                        the preprocessing.\n  -I path               Path to search for unfound #include's\n  --passthru-defines    Pass through but still execute #defines and #undefs if\n                        not always removed by preprocessor logic\n  --passthru-unfound-includes\n                        Pass through #includes not found without execution\n  --passthru-unknown-exprs\n                        Unknown macros in expressions cause preprocessor logic\n                        to be passed through instead of executed by treating\n                        unknown macros as 0L\n  --passthru-comments   Pass through comments unmodified\n  --passthru-magic-macros\n                        Pass through double underscore magic macros unmodified\n  --disable-auto-pragma-once\n                        Disable the heuristics which auto apply #pragma once\n                        to #include files wholly wrapped in an obvious include\n                        guard macro\n  --line-directive [form]\n                        Form of line directive to use, defaults to #line,\n                        specify nothing to disable output of line directives\n  --debug               Generate a pcpp_debug.log file logging execution\n  --time                Print the time it took to #include each file\n  --filetimes [path]    Write CSV file with time spent inside each included\n                        file, inclusive and exclusive\n  --compress            Make output as small as possible\n  --version             show program's version number and exit\n\nNote that so pcpp can stand in for other preprocessor tooling, it ignores any\narguments it does not understand.\n</pre>\n<div id=\"quick-demo-of-pass-through-mode\">\n<h4>Quick demo of pass through mode</h4>\n<p>Let us look at an example for pass through mode. Here is the original:</p>\n<pre><span class=\"cp\">#if !defined(__cpp_constexpr)\n#if __cplusplus &gt;= 201402L\n#define __cpp_constexpr 201304  </span><span class=\"c1\">// relaxed constexpr\n</span><span class=\"cp\">#else\n#define __cpp_constexpr 190000\n#endif\n#endif\n#ifndef BOOSTLITE_CONSTEXPR\n#if __cpp_constexpr &gt;= 201304\n#define BOOSTLITE_CONSTEXPR constexpr\n#endif\n#endif\n#ifndef BOOSTLITE_CONSTEXPR\n#define BOOSTLITE_CONSTEXPR\n#endif</span>\n</pre>\n<p><tt>pcpp test.h <span class=\"pre\">--passthru-defines</span> <span class=\"pre\">--passthru-unknown-exprs</span></tt> will output:</p>\n<pre><span class=\"cp\">#if !defined(__cpp_constexpr)\n#if __cplusplus &gt;= 201402\n#define __cpp_constexpr 201304\n#else\n#define __cpp_constexpr 190000\n#endif\n#endif\n#ifndef BOOSTLITE_CONSTEXPR\n#if __cpp_constexpr &gt;= 201304\n#define BOOSTLITE_CONSTEXPR constexpr\n#endif\n#endif\n#ifndef BOOSTLITE_CONSTEXPR\n#define BOOSTLITE_CONSTEXPR\n#endif</span>\n</pre>\n<p>This is because <tt>__cpp_constexpr</tt> was not defined, so because of the <tt><span class=\"pre\">--passthru-unknown-exprs</span></tt> flag\nwe pass through everything inside that if block <strong>unexecuted</strong> i.e. defines and undefs are NOT executed by\n<tt>pcpp</tt>. Let\u2019s define <tt>__cpp_constexpr</tt>:</p>\n<p><tt>pcpp test.h <span class=\"pre\">--passthru-defines</span> <span class=\"pre\">--passthru-unknown-exprs</span> <span class=\"pre\">-D</span> __cpp_constexpr</tt></p>\n<pre><span class=\"cp\">#line 8 \"test.h\"\n#ifndef BOOSTLITE_CONSTEXPR\n</span>\n\n\n<span class=\"cp\">#endif\n#ifndef BOOSTLITE_CONSTEXPR\n#define BOOSTLITE_CONSTEXPR\n#endif</span>\n</pre>\n<p>So, big difference now. We execute the entire first if block as <tt>__cpp_constexpr</tt> is now defined, thus\nleaving whitespace. Let\u2019s try setting <tt>__cpp_constexpr</tt> a bit higher:</p>\n<p><tt>pcpp test.h <span class=\"pre\">--passthru-defines</span> <span class=\"pre\">--passthru-unknown-exprs</span> <span class=\"pre\">-D</span> __cpp_constexpr=201304</tt></p>\n<pre><span class=\"cp\">#line 8 \"test.h\"\n#ifndef BOOSTLITE_CONSTEXPR\n</span>\n<span class=\"cp\">#define BOOSTLITE_CONSTEXPR constexpr\n</span>\n<span class=\"cp\">#endif</span>\n</pre>\n<p>As you can see, the lines related to the known <tt>__cpp_constexpr</tt> are executed and removed, passing through\nany if blocks with unknown macros in the expression.</p>\n<p>What if you want a macro to be known but undefined? The -U (to undefine) flag has an obvious meaning in pass\nthrough mode in that it makes a macro no longer unknown, but known to be undefined.</p>\n<p><tt>pcpp test.h <span class=\"pre\">--passthru-defines</span> <span class=\"pre\">--passthru-unknown-exprs</span> <span class=\"pre\">-U</span> __cpp_constexpr</tt></p>\n<pre><span class=\"cp\">#if __cplusplus &gt;= 201402\n#define __cpp_constexpr 201304\n#else\n#define __cpp_constexpr 190000\n#endif\n</span>\n<span class=\"cp\">#ifndef BOOSTLITE_CONSTEXPR\n</span>\n\n\n<span class=\"cp\">#endif\n#ifndef BOOSTLITE_CONSTEXPR\n#define BOOSTLITE_CONSTEXPR\n#endif</span>\n</pre>\n<p>Here <tt>__cpp_constexpr</tt> is known to be undefined so the first clause executes, but <tt>__cplusplus</tt> is\nunknown so that entire block is passed through unexecuted. In the next test comparing <tt>__cpp_constexpr</tt>\nto 201304 it is still known to be undefined, and so 0 &gt;= 201304 is the expressions tested which is false,\nhence the following stanza is removed entirely.</p>\n</div>\n<div id=\"helping-pcpp-using-source-code-annotation\">\n<h4>Helping <tt>pcpp</tt> using source code annotation</h4>\n<p>You can achieve a great deal using -D (define), -U (undefine) and -N (never define) on the command line,\nbut for more complex preprocessing it gets hard to pass through the correct logic without some source code\nannotation.</p>\n<p><tt>pcpp</tt> lets you annotate which part of an if block being passed through due to use of unknown macros\nto also be executed in addition to the pass through. For this use <tt>__PCPP_ALWAYS_FALSE__</tt> or\n<tt>__PCPP_ALWAYS_TRUE__</tt> which tells <tt>pcpp</tt> to temporarily start executing the passed through\npreprocessor commands e.g.</p>\n<pre><span class=\"cp\">#if !defined(__cpp_constexpr)\n#if __cplusplus &gt;= 201402L\n#define __cpp_constexpr 201304\n#elif !__PCPP_ALWAYS_FALSE__     </span><span class=\"c1\">// pcpp please execute this next block\n</span><span class=\"cp\">#define __cpp_constexpr 190000\n#endif\n#endif\n#ifndef BOOSTLITE_CONSTEXPR\n#if __cpp_constexpr &gt;= 201304\n#define BOOSTLITE_CONSTEXPR constexpr\n#endif\n#endif\n#ifndef BOOSTLITE_CONSTEXPR\n#define BOOSTLITE_CONSTEXPR\n#endif</span>\n</pre>\n<p>Note that <tt>__PCPP_ALWAYS_FALSE__</tt> will always be false in any other preprocessor, and it is also\nfalse in <tt>pcpp</tt>. However it causes <tt>pcpp</tt> to execute the define of <tt>__cpp_constexpr</tt> to 190000:</p>\n<p><tt>pcpp test.h <span class=\"pre\">--passthru-defines</span> <span class=\"pre\">--passthru-unknown-exprs</span></tt></p>\n<pre><span class=\"cp\">#if !defined(__cpp_constexpr)\n#if __cplusplus &gt;= 201402\n#define __cpp_constexpr 201304\n#elif 1\n#define __cpp_constexpr 190000\n#endif\n#endif\n#ifndef BOOSTLITE_CONSTEXPR\n</span>\n\n\n<span class=\"cp\">#endif\n#ifndef BOOSTLITE_CONSTEXPR\n#define BOOSTLITE_CONSTEXPR\n#endif</span>\n</pre>\n<p>This is one way of marking up <tt>#else</tt> clauses so they always execute in a normal preprocessor\nand also pass through with execution with <tt>pcpp</tt>. You can, of course, also place <tt>|| __PCPP_ALWAYS_FALSE__</tt>\nin any <tt>#if</tt> stanza to cause it to be passed through with execution, but not affect the\npreprocessing logic otherwise.</p>\n</div>\n</div>\n</div>\n<div id=\"what-s-implemented-by-the-preprocessor-class\">\n<h2>What\u2019s implemented by the <tt>Preprocessor</tt> class:</h2>\n<ul>\n<li>Digraphs and Trigraphs</li>\n<li>line continuation operator \u2018<tt>\\</tt>\u2019</li>\n<li>C99 correct elimination of comments and maintenance of whitespace in output.</li>\n<li><code class=\"c\"><span class=\"n\">__DATE__</span></code>, <code class=\"c\"><span class=\"n\">__TIME__</span></code>, <code class=\"c\"><span class=\"n\">__FILE__</span></code>, <code class=\"c\"><span class=\"n\">__LINE__</span></code>. Note that <code class=\"c\"><span class=\"n\">__STDC__</span></code> et al are NOT defined by\ndefault, you need to define those manually before starting preprocessing.</li>\n<li><code class=\"c\"><span class=\"n\">__COUNTER__</span></code>, a very common extension</li>\n<li>Object <code class=\"c\"><span class=\"cp\">#define</span></code></li>\n<li>Function <code class=\"c\"><span class=\"cp\">#define macro(\u2026)</span></code><ul>\n<li>Retokenisation and reexpansion after expansion is C99 compliant.</li>\n</ul>\n</li>\n<li><code class=\"c\"><span class=\"cp\">#undef</span></code></li>\n<li><code class=\"c\"><span class=\"cp\">#include</span> <span class=\"cpf\">\u201cpath\u201d</span></code>, <code class=\"c\"><span class=\"o\">&lt;</span><span class=\"n\">path</span><span class=\"o\">&gt;</span></code> and <code class=\"c\"><span class=\"n\">PATH</span></code></li>\n<li><code class=\"c\"><span class=\"n\">defined</span></code> operator</li>\n<li>C operators:<ul>\n<li><code class=\"c\"><span class=\"o\">+</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"p\">,</span> <span class=\"o\">!</span><span class=\"p\">,</span> <span class=\"o\">~</span></code></li>\n<li><code class=\"c\"><span class=\"o\">*</span><span class=\"p\">,</span> <span class=\"o\">/</span><span class=\"p\">,</span> <span class=\"o\">%</span></code></li>\n<li><code class=\"c\"><span class=\"o\">+</span><span class=\"p\">,</span> <span class=\"o\">-</span></code></li>\n<li><code class=\"c\"><span class=\"o\">&lt;&lt;</span><span class=\"p\">,</span> <span class=\"o\">&gt;&gt;</span></code></li>\n<li><code class=\"c\"><span class=\"o\">&lt;</span><span class=\"p\">,</span> <span class=\"o\">&lt;=</span><span class=\"p\">,</span> <span class=\"o\">&gt;</span><span class=\"p\">,</span> <span class=\"o\">&gt;=</span></code></li>\n<li><code class=\"c\"><span class=\"o\">==</span><span class=\"p\">,</span> <span class=\"o\">!=</span></code></li>\n<li><code class=\"c\"><span class=\"o\">&amp;</span></code></li>\n<li><code class=\"c\"><span class=\"o\">^</span></code></li>\n<li><code class=\"c\"><span class=\"o\">|</span></code></li>\n<li><code class=\"c\"><span class=\"o\">&amp;&amp;</span></code></li>\n<li><code class=\"c\"><span class=\"o\">||</span></code></li>\n<li><code class=\"c\"><span class=\"n\">x</span> <span class=\"o\">?</span> <span class=\"nl\">y</span> <span class=\"p\">:</span> <span class=\"n\">z</span></code> (partial support, see known bugs)</li>\n</ul>\n</li>\n<li><code class=\"c\"><span class=\"cp\">#if</span></code>, <code class=\"c\"><span class=\"cp\">#ifdef</span></code>, <code class=\"c\"><span class=\"cp\">#ifndef</span></code>, <code class=\"c\"><span class=\"cp\">#elif</span></code>, <code class=\"c\"><span class=\"cp\">#else</span></code>, <code class=\"c\"><span class=\"cp\">#endif</span></code></li>\n<li>Stringizing operator #</li>\n<li>Token pasting operator ##</li>\n<li><code class=\"c\"><span class=\"cp\">#pragma once</span></code>, a very common extension</li>\n</ul>\n<div id=\"additionally-implemented-by-pcpp-command-line-tool\">\n<h3>Additionally implemented by <tt>pcpp</tt> command line tool:</h3>\n<ul>\n<li><code class=\"c\"><span class=\"cp\">#error</span></code> (default implementation prints to stderr and increments the exit code)</li>\n<li><code class=\"c\"><span class=\"cp\">#warning</span></code> (default implementation prints to stderr)</li>\n</ul>\n</div>\n<div id=\"not-implemented-yet-donations-of-code-welcome\">\n<h3>Not implemented yet (donations of code welcome):</h3>\n<ul>\n<li><code class=\"c\"><span class=\"cp\">#pragma</span></code> anything other than <code class=\"c\"><span class=\"n\">once</span></code>.</li>\n<li><code class=\"c\"><span class=\"n\">_Pragma</span></code> used to emit preprocessor calculated #pragma.</li>\n<li><code class=\"c\"><span class=\"cp\">#line num</span></code>, <code class=\"c\"><span class=\"n\">num</span> <span class=\"s\">\u201cfile\u201d</span></code> and <code class=\"c\"><span class=\"n\">NUMBER</span> <span class=\"kt\">FILE</span></code>.</li>\n</ul>\n</div>\n<div id=\"known-bugs-ordered-from-worst-to-least-worst\">\n<h3>Known bugs (ordered from worst to least worst):</h3>\n<dl>\n<dt><strong>Expression evaluation is a bit broken</strong></dt>\n<dd><p>Currently <code class=\"c\"><span class=\"cp\">#if</span></code> expressions are evaluated by converting them into Python\nexpressions and calling <code class=\"c\"><span class=\"n\">eval</span><span class=\"p\">()</span></code> on them. This works surprisingly well\nmost of the time, but because Python is not C, corner cases break.\nThese are the known such broken corner cases:</p>\n<ul>\n<li>Unary operator evaluation will break for evil expressions such as <code class=\"c\"><span class=\"o\">-!+!</span><span class=\"mi\">9</span></code>\nbecause logical NOT in Python results in a boolean, not an integer, and\na unary plus or negative boolean is invalid syntax in Python</li>\n<li>Similarly expressions which assume that boolean operations output either\na zero or a one will fail e.g. <code class=\"c\"><span class=\"p\">(</span><span class=\"mi\">2</span> <span class=\"o\">||</span> <span class=\"mi\">3</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"mi\">0</span></code></li>\n<li>Python has no concept of an unsigned integer and C expressions relying\non unsigned integer semantics will fail badly e.g. <code class=\"c\"><span class=\"o\">-</span><span class=\"mi\">1</span> <span class=\"o\">&lt;=</span> <span class=\"mi\">0U</span></code>\nis supposed to be evaluated as false in the C preprocessor, but it will be\nevaluated as true under this implementation. To be honest\nif your preprocessor logic is relying on those sorts of behaviours, you should rewrite it.</li>\n<li>Without a back tracking parser, the C ternary operator is hard to accurately\nconvert into a Python ternary operation, so you need to help it by using one\nof these two forms:<ul>\n<li><code class=\"c\"><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span> <span class=\"o\">?</span> <span class=\"nl\">y</span> <span class=\"p\">:</span> <span class=\"n\">z</span></code> (z gets evaluated according to Python not C precedence)</li>\n<li><code class=\"c\"><span class=\"p\">(</span><span class=\"n\">x</span> <span class=\"o\">?</span> <span class=\"nl\">y</span> <span class=\"p\">:</span> <span class=\"n\">z</span><span class=\"p\">)</span></code> (preferred, evaluates correctly, we inject brackets\naround the subexpessions before sending to Python)</li>\n</ul>\n</li>\n</ul>\n<p>A proper lexing parser based on <a href=\"http://www.dabeaz.com/ply/'s\" rel=\"nofollow\">http://www.dabeaz.com/ply/\u2019s</a> yacc module has\nbeen started and can be found in the <a href=\"https://github.com/ned14/pcpp/tree/yacc_expression_evaluator\" rel=\"nofollow\">https://github.com/ned14/pcpp/tree/yacc_expression_evaluator</a>\nbranch. Time to complete it, is the problem, and any pull requests helping with\nthat are welcome.</p>\n</dd>\n<dt><strong>We do not pass the Boost.Wave preprocessor test suite</strong></dt>\n<dd>A lot of bugs have been fixed since this was reported, however the chances are\nthat <tt>pcpp</tt> still doesn\u2019t pass it. A TODO is to port the Wave test suite to\nPython and find out how bad things are. We suspect that any failures will be\nin highly estoric use cases i.e. known illegal input. If you only use valid\ninput then we expect you generally won\u2019t have trouble.</dd>\n</dl>\n</div>\n</div>\n<div id=\"customising-your-own-preprocessor\">\n<h2>Customising your own preprocessor:</h2>\n<p>See the API reference docs at <a href=\"https://ned14.github.io/pcpp/\" rel=\"nofollow\">https://ned14.github.io/pcpp/</a></p>\n<p>You can find an example of overriding the <tt><span class=\"pre\">on_*()</span></tt> processing hooks at <a href=\"https://github.com/ned14/pcpp/blob/master/pcpp/pcpp_cmd.py\" rel=\"nofollow\">https://github.com/ned14/pcpp/blob/master/pcpp/pcpp_cmd.py</a></p>\n</div>\n<div id=\"history\">\n<h2>History:</h2>\n<div id=\"v1-21-30th-september-2019\">\n<h3>v1.21 (30th September 2019):</h3>\n<ul>\n<li><p>Fix bug where token pasting two numeric tokens did not yield a numeric token. Thanks\nto Sei-Lisa for reporting this.</p>\n</li>\n<li><p>BREAKING CHANGE: Paths emitted by pcpp into <tt>#line</tt> directives now are relative to the\nworking directory of the process when <tt>Preprocessor</tt> is initialised. This includes\nadded search paths - files included from those locations will be emitted with a sequence\nof <tt>../</tt> to relativise the path emitted. If no path exists between the working\ndirectory and the path of the file being emitted, an absolute path is emitted instead.</p>\n<p>If you wish to disable this new behaviour, or use different behaviour, you can\ncustomise the new <cite>rewrite_paths</cite> member variable of <tt>Preprocessor</tt>.</p>\n</li>\n<li><p>Fix bug where <tt>__LINE__</tt> was expanding into the line number of its definition instead\nof its use. Thanks to Sei-Lisa for reporting this.</p>\n</li>\n<li><p>Add <tt><span class=\"pre\">--passthru-magic-macros</span></tt> command line option.</p>\n</li>\n<li><p>BREAKING CHANGE: The <tt>PreprocessorHooks</tt> and <tt>OutputDirective</tt> interface has\nchanged. One now must specify the kind of <tt>OutputDirective</tt> abort one wants, and one\ncan now both ignore AND remove directives. <tt>on_directive_handle()</tt> and\n<tt>on_directive_unknown()</tt> now take an extra parameter <tt>precedingtoks</tt>, these are the\ntokens from the <tt>#</tt> up to the directive.</p>\n</li>\n<li><p>Fix a corner case where <tt>FUNC(void)foo()</tt> expanded to <tt>voidfoo()</tt> and not\n<tt>void foo()</tt> which is a very common non-conforming extension of the C preprocessor.\nThanks to OmegaDoom for reporting this.</p>\n</li>\n<li><p>Add tokens for all the C operators, to help implementation of an expression evaluator.</p>\n</li>\n<li><p>Updated embedded ply to HEAD (2019-04-25)</p>\n</li>\n<li><p>Fix <tt>#include</tt> not working if no <tt><span class=\"pre\">-I</span></tt> parameters were supplied. Thanks to csm10495\nfor reporting this.</p>\n</li>\n</ul>\n</div>\n<div id=\"v1-20-7th-january-2019\">\n<h3>v1.20 (7th January 2019):</h3>\n<ul>\n<li>Now supports character literals in expressions. Thanks to untaugh for the pull request\nadding this.</li>\n<li>Stopped the default collapsing of whitespace in output, and made it optional via a\nnew command line option <tt><span class=\"pre\">--compress</span></tt>.</li>\n<li>Fixed extraneous whitespace in <tt><span class=\"pre\">--passthru-comments</span></tt> caused by multiline comments.\nThanks to p2k for reporting this.</li>\n<li>Fixed bug where defining a macro via string did not set the source attribute in the\ntoken. Thanks to ZedThree for reporting this.</li>\n<li>Stop triggering an exception when no arguments are supplied to pcpp. Thanks to\nvirtuald for reporting this.</li>\n<li>Rebase onto PLY latest from Dec 28th 2018 (<a href=\"https://github.com/dabeaz/ply/commit/a37e0839583d683d95e70ce1445c0063c7d4bd21\" rel=\"nofollow\">https://github.com/dabeaz/ply/commit/a37e0839583d683d95e70ce1445c0063c7d4bd21</a>). Latest\nPLY no longer works using pypi packaging, David wants people to include the source of\nPLY directly. pcpp does this via a git submodule, and has setuptools bundle the submodule.</li>\n<li>Add a formal LICENSE.txt file, as requested by Sei-Lisa.</li>\n<li>Fix failure to issue <tt>#line</tt> directive for first include file in a file. Thanks to\nSei-Lisa for reporting this.</li>\n</ul>\n</div>\n<div id=\"v1-1-19th-june-2018\">\n<h3>v1.1 (19th June 2018):</h3>\n<ul>\n<li>Added the <tt><span class=\"pre\">--times</span></tt> and <tt><span class=\"pre\">--filetimes</span></tt> features.</li>\n<li>Fix bug where macros containing operator <cite>defined</cite> were not being expanded properly.</li>\n<li>Added the ability to accept multiple inputs, they are concatenated into the output.</li>\n<li>Fix bug where lines beginning with <cite>#</cite> and no contents caused an internal preprocessor error.</li>\n<li>Fix bug where the macro expansion <tt>par <span class=\"pre\">par##ext</span></tt> was expanding into <tt>parext parext</tt>.</li>\n</ul>\n</div>\n<div id=\"v1-01-21st-feb-2018\">\n<h3>v1.01 (21st Feb 2018):</h3>\n<ul>\n<li>Fix bug where in pass through mode, an #elif in an #if block inside an #if block in ifpassthru was failing to be passed through.</li>\n<li>Downgraded failure to evaluate an expression to a warning.</li>\n<li>Fix missing Readme.rst in pypi package.</li>\n</ul>\n</div>\n<div id=\"v1-00-13th-mar-2017\">\n<h3>v1.00 (13th Mar 2017):</h3>\n<p>First release</p>\n</div>\n</div>\n\n          </div>"}, "last_serial": 5906391, "releases": {"1.0.1": [{"comment_text": "", "digests": {"md5": "f307eeb5425e7d24dd1c69c1cb6ab598", "sha256": "dd454d3e30e7f735d4ca09fbc90ec400fbf5cb774af986c5a4601e010579e6b2"}, "downloads": -1, "filename": "pcpp-1.0.1-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "f307eeb5425e7d24dd1c69c1cb6ab598", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 29945, "upload_time": "2018-02-21T18:57:49", "upload_time_iso_8601": "2018-02-21T18:57:49.011837Z", "url": "https://files.pythonhosted.org/packages/1b/1d/d144fe46b71eaba087baa9c6e757b76504e2ea41bf54bd70db05c8a152d1/pcpp-1.0.1-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "a549ed8b69154d083db82521ea317df6", "sha256": "e67bc62a391d5c252f3498b1434374483c3cb3b11a3be7b51fea40ea61b057fc"}, "downloads": -1, "filename": "pcpp-1.0.1.tar.gz", "has_sig": false, "md5_digest": "a549ed8b69154d083db82521ea317df6", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 23569, "upload_time": "2018-02-21T18:57:51", "upload_time_iso_8601": "2018-02-21T18:57:51.658341Z", "url": "https://files.pythonhosted.org/packages/b1/f7/38c3d61e9303a67af208a9a6f2941f4feafccac9a04ffc56fd32238f6657/pcpp-1.0.1.tar.gz", "yanked": false}], "1.1.0": [{"comment_text": "", "digests": {"md5": "0b638858e8605492cf678f0cfc5a0fa4", "sha256": "5a0fd5a71a0c11afb519669e0555080796a92170474ccc74335cbf0ac1aaa2c2"}, "downloads": -1, "filename": "pcpp-1.1.0-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "0b638858e8605492cf678f0cfc5a0fa4", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 24864, "upload_time": "2018-06-20T08:11:30", "upload_time_iso_8601": "2018-06-20T08:11:30.365463Z", "url": "https://files.pythonhosted.org/packages/f0/1f/f28cabe90eb9557dc0354709ebcec666f3ecf3dd6b0ae3b176ac6c10c54a/pcpp-1.1.0-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "c6609f4eeb57d569da6a8bed33b79c05", "sha256": "765bdd8002889615fb23d5205f26b14f78768577e5d3883775218924a5f8e494"}, "downloads": -1, "filename": "pcpp-1.1.0.tar.gz", "has_sig": false, "md5_digest": "c6609f4eeb57d569da6a8bed33b79c05", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 25154, "upload_time": "2018-06-20T08:07:01", "upload_time_iso_8601": "2018-06-20T08:07:01.666956Z", "url": "https://files.pythonhosted.org/packages/39/a9/c7478af528a235cf88dabe583bc6651243c0531efc6f9967eafc33f4d151/pcpp-1.1.0.tar.gz", "yanked": false}], "1.20.1": [{"comment_text": "", "digests": {"md5": "b021c78abeba7f938216fa9feb197603", "sha256": "d4c2b208d3788a188b07f2865d51d4ea7ebc677ddf856554203c476ec7716755"}, "downloads": -1, "filename": "pcpp-1.20.1-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "b021c78abeba7f938216fa9feb197603", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 76216, "upload_time": "2019-01-07T20:31:50", "upload_time_iso_8601": "2019-01-07T20:31:50.202525Z", "url": "https://files.pythonhosted.org/packages/33/7b/e8ca3707a86a21685214cbe8d7d77a71a2964dfef01c1fe9bbfad9ff6b39/pcpp-1.20.1-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "0e5e8b330a3a0290aca50d226d40ea96", "sha256": "701955f95d25518f77a07563e69b478d6258241cf85946497721c629b0d8aab9"}, "downloads": -1, "filename": "pcpp-1.20.1.tar.gz", "has_sig": false, "md5_digest": "0e5e8b330a3a0290aca50d226d40ea96", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 72359, "upload_time": "2019-01-07T20:31:51", "upload_time_iso_8601": "2019-01-07T20:31:51.685738Z", "url": "https://files.pythonhosted.org/packages/0b/b3/2b0fb36c4cb5dc075da0953be3a027a20de4f1fecbb2870f841c972e72b7/pcpp-1.20.1.tar.gz", "yanked": false}], "1.21": [{"comment_text": "", "digests": {"md5": "7124ac0c6cc2c544163600cda8818c41", "sha256": "6f455b2296b6cd0353d3746b0b75a5445fbc1792ac20c15c559e1506a48bb047"}, "downloads": -1, "filename": "pcpp-1.21-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "7124ac0c6cc2c544163600cda8818c41", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 80731, "upload_time": "2019-09-30T10:26:35", "upload_time_iso_8601": "2019-09-30T10:26:35.501472Z", "url": "https://files.pythonhosted.org/packages/af/e3/b2d081ba1222a6bb43ccbb448c59039cc36f21481101f4091fc185683ff2/pcpp-1.21-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "3bb95325c77bd878ce8d39c4526c3ee8", "sha256": "ecc45588bb6f1d4f6e5af713be437f43114bbc3461ca07d2454e2049e2f7d502"}, "downloads": -1, "filename": "pcpp-1.21.tar.gz", "has_sig": false, "md5_digest": "3bb95325c77bd878ce8d39c4526c3ee8", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 84066, "upload_time": "2019-09-30T10:26:37", "upload_time_iso_8601": "2019-09-30T10:26:37.220795Z", "url": "https://files.pythonhosted.org/packages/b5/9d/e3afe1b6afb47a9062502a50cf729d6d651754e9d1171bb598083acda73b/pcpp-1.21.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "7124ac0c6cc2c544163600cda8818c41", "sha256": "6f455b2296b6cd0353d3746b0b75a5445fbc1792ac20c15c559e1506a48bb047"}, "downloads": -1, "filename": "pcpp-1.21-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "7124ac0c6cc2c544163600cda8818c41", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 80731, "upload_time": "2019-09-30T10:26:35", "upload_time_iso_8601": "2019-09-30T10:26:35.501472Z", "url": "https://files.pythonhosted.org/packages/af/e3/b2d081ba1222a6bb43ccbb448c59039cc36f21481101f4091fc185683ff2/pcpp-1.21-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "3bb95325c77bd878ce8d39c4526c3ee8", "sha256": "ecc45588bb6f1d4f6e5af713be437f43114bbc3461ca07d2454e2049e2f7d502"}, "downloads": -1, "filename": "pcpp-1.21.tar.gz", "has_sig": false, "md5_digest": "3bb95325c77bd878ce8d39c4526c3ee8", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 84066, "upload_time": "2019-09-30T10:26:37", "upload_time_iso_8601": "2019-09-30T10:26:37.220795Z", "url": "https://files.pythonhosted.org/packages/b5/9d/e3afe1b6afb47a9062502a50cf729d6d651754e9d1171bb598083acda73b/pcpp-1.21.tar.gz", "yanked": false}], "timestamp": "Fri May  8 02:57:24 2020"}