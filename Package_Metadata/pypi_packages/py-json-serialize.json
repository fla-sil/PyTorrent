{"info": {"author": "Randy Du", "author_email": "randydu@gmail.com", "bugtrack_url": null, "classifiers": ["Development Status :: 4 - Beta", "Intended Audience :: Developers", "License :: OSI Approved :: MIT License", "Operating System :: OS Independent", "Programming Language :: Python :: 2", "Programming Language :: Python :: 3", "Topic :: Software Development :: Libraries", "Topic :: Software Development :: Libraries :: Python Modules"], "description": "# py-json-serialize\n\nSerialize in JSON format\n\nFeatures:\n\n- Simple api: @json_serialize, to_json(), from_json();\n- Version support: version-based data migration;\n\n## Install\n\n```sh\npip install py-json-serialize\n```\n\n## Test\n\nin the project's root folder, run pytest:\n\n```bash\npytest\n```\n\n## Dependencies\n\nNone\n\n## API\n\n- class decortator __@json_serialize__\n\n  - format 1: no parameter\n\n   ```python\n    from py_json_serialize import json_serialize\n\n    @json_serialize\n    class A(object):pass\n    ```\n\n  - format 2: with parameter\n\n  @json_serialize(clsid = \"\", [version=0*|n])\n\n    1. _clsid_: the unique string to identify the class. the class-id will be the name of decorated if \n      not specified.\n    2. _version_: optional parameter to specify the version of serialized data format. the default value \n    is *0* if not specified.\n\n   ```python\n    from py_json_serialize import json_serialize\n\n    # old version\n    @json_serialize(\"app-config\", version=1)\n    class AppConfigV1(object):\n        servers = []\n\n    # new version\n    @json_serialize(\"app-config\", version=2)\n    class AppConfigV2(AppConfigV1):\n        timeout = 600\n    ```\n\n- to_json()/from_json()\n\n    The decorated class will have two new functions:\n\n    1. to_json(): convert class instance to json string\n\n        ```python\n        @json_serialize\n        class Hello(object):\n            def __init__(self, who = \"World\"):\n                self.who = who\n\n        a = Hello()\n        print(a.to_json())\n        ```\n\n        outputs:\n\n        ```json\n        {\n            \"_clsid_\": \"Hello\",\n            \"who\": \"World\"\n        }\n        ```\n\n    2. from_json(): reads json string to return an class object.\n\n        It is actually a *staticmethod* that can be called to return an object of any type deduced from the class-id in the data string.\n        so don't be surprised that you might get an object of different type if the input json data string is serialized from another class.\n\n        So the from_json() is simply a handy helper method to make your code more readable if your app only handles one type of data. \n  \n- function __json_decode__(jstr: str)-> object: convert json string to python object \n\n    This is a function to decode the serialized json string, its typical usage is as following:\n\n    ```python\n    class Task(object):pass\n        @staticmethod\n        def from_json(jstr):\n            return json_decode(jstr)\n\n    @json_serialize\n    class CopyFile(Task):pass\n\n    @json_serialize\n    class UploadFile(Task):pass\n\n    task1 = Task.from_json(\"{ '_clsid_':'CopyFile' }\")\n    assert isinstance(task1, CopyFile)\n\n    task2 = Task.from_json(\"{ '_clsid_':'UploadFile' }\")\n    assert isinstance(task2, UploadFile)\n    ```\n\n- function __json_encode__ : convert python object to json string \n\n    ```python\n\n    def json_encode(obj, pretty = True, encode_all_fields = False)\n\n    ```\n\n    When *pretty* is True, the fields are sorted by their name and the json string\n    is intented properly for human reading, otherwise the json string can save some\n    storage space and more efficient for machine processing.\n\n    If *encode_all_fields* is true, then all class fields are serialized, otherwise \n    the internal fields (field name starts with '_') are ignored.\n\n\n## Example\n\n\n\n## Limitation", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/randydu/py-json-serialize.git", "keywords": "serialize,json", "license": "MIT", "maintainer": "", "maintainer_email": "", "name": "py-json-serialize", "package_url": "https://pypi.org/project/py-json-serialize/", "platform": "", "project_url": "https://pypi.org/project/py-json-serialize/", "project_urls": {"Homepage": "https://github.com/randydu/py-json-serialize.git"}, "release_url": "https://pypi.org/project/py-json-serialize/0.8.0/", "requires_dist": null, "requires_python": "", "summary": "json serialize library for Python 2 and 3", "version": "0.8.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>py-json-serialize</h1>\n<p>Serialize in JSON format</p>\n<p>Features:</p>\n<ul>\n<li>Simple api: @json_serialize, to_json(), from_json();</li>\n<li>Version support: version-based data migration;</li>\n</ul>\n<h2>Install</h2>\n<pre>pip install py-json-serialize\n</pre>\n<h2>Test</h2>\n<p>in the project's root folder, run pytest:</p>\n<pre>pytest\n</pre>\n<h2>Dependencies</h2>\n<p>None</p>\n<h2>API</h2>\n<ul>\n<li>\n<p>class decortator <strong>@json_serialize</strong></p>\n<ul>\n<li>format 1: no parameter</li>\n</ul>\n<pre> <span class=\"kn\">from</span> <span class=\"nn\">py_json_serialize</span> <span class=\"kn\">import</span> <span class=\"n\">json_serialize</span>\n\n <span class=\"nd\">@json_serialize</span>\n <span class=\"k\">class</span> <span class=\"nc\">A</span><span class=\"p\">(</span><span class=\"nb\">object</span><span class=\"p\">):</span><span class=\"k\">pass</span>\n</pre>\n<ul>\n<li>format 2: with parameter</li>\n</ul>\n<p>@json_serialize(clsid = \"\", [version=0*|n])</p>\n<ol>\n<li><em>clsid</em>: the unique string to identify the class. the class-id will be the name of decorated if\nnot specified.</li>\n<li><em>version</em>: optional parameter to specify the version of serialized data format. the default value\nis <em>0</em> if not specified.</li>\n</ol>\n<pre> <span class=\"kn\">from</span> <span class=\"nn\">py_json_serialize</span> <span class=\"kn\">import</span> <span class=\"n\">json_serialize</span>\n\n <span class=\"c1\"># old version</span>\n <span class=\"nd\">@json_serialize</span><span class=\"p\">(</span><span class=\"s2\">\"app-config\"</span><span class=\"p\">,</span> <span class=\"n\">version</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n <span class=\"k\">class</span> <span class=\"nc\">AppConfigV1</span><span class=\"p\">(</span><span class=\"nb\">object</span><span class=\"p\">):</span>\n     <span class=\"n\">servers</span> <span class=\"o\">=</span> <span class=\"p\">[]</span>\n\n <span class=\"c1\"># new version</span>\n <span class=\"nd\">@json_serialize</span><span class=\"p\">(</span><span class=\"s2\">\"app-config\"</span><span class=\"p\">,</span> <span class=\"n\">version</span><span class=\"o\">=</span><span class=\"mi\">2</span><span class=\"p\">)</span>\n <span class=\"k\">class</span> <span class=\"nc\">AppConfigV2</span><span class=\"p\">(</span><span class=\"n\">AppConfigV1</span><span class=\"p\">):</span>\n     <span class=\"n\">timeout</span> <span class=\"o\">=</span> <span class=\"mi\">600</span>\n</pre>\n</li>\n<li>\n<p>to_json()/from_json()</p>\n<p>The decorated class will have two new functions:</p>\n<ol>\n<li>\n<p>to_json(): convert class instance to json string</p>\n<pre><span class=\"nd\">@json_serialize</span>\n<span class=\"k\">class</span> <span class=\"nc\">Hello</span><span class=\"p\">(</span><span class=\"nb\">object</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">who</span> <span class=\"o\">=</span> <span class=\"s2\">\"World\"</span><span class=\"p\">):</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">who</span> <span class=\"o\">=</span> <span class=\"n\">who</span>\n\n<span class=\"n\">a</span> <span class=\"o\">=</span> <span class=\"n\">Hello</span><span class=\"p\">()</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"o\">.</span><span class=\"n\">to_json</span><span class=\"p\">())</span>\n</pre>\n<p>outputs:</p>\n<pre><span class=\"p\">{</span>\n    <span class=\"nt\">\"_clsid_\"</span><span class=\"p\">:</span> <span class=\"s2\">\"Hello\"</span><span class=\"p\">,</span>\n    <span class=\"nt\">\"who\"</span><span class=\"p\">:</span> <span class=\"s2\">\"World\"</span>\n<span class=\"p\">}</span>\n</pre>\n</li>\n<li>\n<p>from_json(): reads json string to return an class object.</p>\n<p>It is actually a <em>staticmethod</em> that can be called to return an object of any type deduced from the class-id in the data string.\nso don't be surprised that you might get an object of different type if the input json data string is serialized from another class.</p>\n<p>So the from_json() is simply a handy helper method to make your code more readable if your app only handles one type of data.</p>\n</li>\n</ol>\n</li>\n<li>\n<p>function <strong>json_decode</strong>(jstr: str)-&gt; object: convert json string to python object</p>\n<p>This is a function to decode the serialized json string, its typical usage is as following:</p>\n<pre><span class=\"k\">class</span> <span class=\"nc\">Task</span><span class=\"p\">(</span><span class=\"nb\">object</span><span class=\"p\">):</span><span class=\"k\">pass</span>\n    <span class=\"nd\">@staticmethod</span>\n    <span class=\"k\">def</span> <span class=\"nf\">from_json</span><span class=\"p\">(</span><span class=\"n\">jstr</span><span class=\"p\">):</span>\n        <span class=\"k\">return</span> <span class=\"n\">json_decode</span><span class=\"p\">(</span><span class=\"n\">jstr</span><span class=\"p\">)</span>\n\n<span class=\"nd\">@json_serialize</span>\n<span class=\"k\">class</span> <span class=\"nc\">CopyFile</span><span class=\"p\">(</span><span class=\"n\">Task</span><span class=\"p\">):</span><span class=\"k\">pass</span>\n\n<span class=\"nd\">@json_serialize</span>\n<span class=\"k\">class</span> <span class=\"nc\">UploadFile</span><span class=\"p\">(</span><span class=\"n\">Task</span><span class=\"p\">):</span><span class=\"k\">pass</span>\n\n<span class=\"n\">task1</span> <span class=\"o\">=</span> <span class=\"n\">Task</span><span class=\"o\">.</span><span class=\"n\">from_json</span><span class=\"p\">(</span><span class=\"s2\">\"{ '_clsid_':'CopyFile' }\"</span><span class=\"p\">)</span>\n<span class=\"k\">assert</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">task1</span><span class=\"p\">,</span> <span class=\"n\">CopyFile</span><span class=\"p\">)</span>\n\n<span class=\"n\">task2</span> <span class=\"o\">=</span> <span class=\"n\">Task</span><span class=\"o\">.</span><span class=\"n\">from_json</span><span class=\"p\">(</span><span class=\"s2\">\"{ '_clsid_':'UploadFile' }\"</span><span class=\"p\">)</span>\n<span class=\"k\">assert</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">task2</span><span class=\"p\">,</span> <span class=\"n\">UploadFile</span><span class=\"p\">)</span>\n</pre>\n</li>\n<li>\n<p>function <strong>json_encode</strong> : convert python object to json string</p>\n<pre><span class=\"k\">def</span> <span class=\"nf\">json_encode</span><span class=\"p\">(</span><span class=\"n\">obj</span><span class=\"p\">,</span> <span class=\"n\">pretty</span> <span class=\"o\">=</span> <span class=\"kc\">True</span><span class=\"p\">,</span> <span class=\"n\">encode_all_fields</span> <span class=\"o\">=</span> <span class=\"kc\">False</span><span class=\"p\">)</span>\n</pre>\n<p>When <em>pretty</em> is True, the fields are sorted by their name and the json string\nis intented properly for human reading, otherwise the json string can save some\nstorage space and more efficient for machine processing.</p>\n<p>If <em>encode_all_fields</em> is true, then all class fields are serialized, otherwise\nthe internal fields (field name starts with '_') are ignored.</p>\n</li>\n</ul>\n<h2>Example</h2>\n<h2>Limitation</h2>\n\n          </div>"}, "last_serial": 7143502, "releases": {"0.8.0": [{"comment_text": "", "digests": {"md5": "db04b0df165a64624edf774ef486dbe5", "sha256": "da5b5a055d17748ec3706fe7f09827e144a10afa23799479d122b5e44b8b9dce"}, "downloads": -1, "filename": "py-json-serialize-0.8.0.tar.gz", "has_sig": false, "md5_digest": "db04b0df165a64624edf774ef486dbe5", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 5050, "upload_time": "2020-05-01T08:47:10", "upload_time_iso_8601": "2020-05-01T08:47:10.206510Z", "url": "https://files.pythonhosted.org/packages/dc/c3/d9a3f777ae2b208bbd9baa170e60a087aa29b4604d98e669c632c7479507/py-json-serialize-0.8.0.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "db04b0df165a64624edf774ef486dbe5", "sha256": "da5b5a055d17748ec3706fe7f09827e144a10afa23799479d122b5e44b8b9dce"}, "downloads": -1, "filename": "py-json-serialize-0.8.0.tar.gz", "has_sig": false, "md5_digest": "db04b0df165a64624edf774ef486dbe5", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 5050, "upload_time": "2020-05-01T08:47:10", "upload_time_iso_8601": "2020-05-01T08:47:10.206510Z", "url": "https://files.pythonhosted.org/packages/dc/c3/d9a3f777ae2b208bbd9baa170e60a087aa29b4604d98e669c632c7479507/py-json-serialize-0.8.0.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:03:42 2020"}