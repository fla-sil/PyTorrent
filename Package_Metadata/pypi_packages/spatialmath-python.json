{"info": {"author": "Peter Corke", "author_email": "rvc@petercorke.com", "bugtrack_url": null, "classifiers": ["Development Status :: 4 - Beta", "Intended Audience :: Developers", "License :: OSI Approved :: MIT License", "Programming Language :: Python :: 3 :: Only"], "description": "[![made-with-python](https://img.shields.io/badge/Made%20with-Python-1f425f.svg)](https://www.python.org/)[![Build Status](https://travis-ci.com/petercorke/spatialmath-python.svg?branch=master)](https://travis-ci.com/petercorke/spatialmath-python)\n![Coverage](https://codecov.io/gh/petercorke/spatialmath-python/branch/master/graph/badge.svg)\n[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)\n[![Maintenance](https://img.shields.io/badge/Maintained%3F-yes-green.svg)](https://GitHub.com/petercorke/spatialmath-python/graphs/commit-activity)\n[![GitHub stars](https://img.shields.io/github/stars/petercorke/spatialmath-python.svg?style=social&label=Star&maxAge=2592000)](https://GitHub.com/petercorke/spatialmath-python/stargazers/)\n\n# Spatial Maths for Python\n\nThis is a Python implementation of the [Spatial Math Toolbox for MATLAB<sup>&reg;</sup>](https://github.com/petercorke/spatial-math), which is a standalone component of the [Robotics Toolbox for MATLAB<sup>&reg;</sup>](https://github.com/petercorke/robotics-toolbox-matlab).\n\nSpatial mathematics capability underpins all of robotics and robotic vision where we need to describe the position, orientation or pose of objects in 2D or 3D spaces.\n\n\n* GitHub repository [https://github.com/petercorke/spatialmath-python](https://github.com/petercorke/spatialmath-python)      \n* Documentation [https://petercorke.github.io/spatialmath-python](https://petercorke.github.io/spatialmath-python)\n* Dependencies: `numpy`, `scipy`, `matplotlib`, `ffmpeg` (if rendering animations as a movie)\n\n\n# What it does\n\nProvides a set of classes:\n\n * `SO2` for orientation in 2-dimensions\n * `SE2` for position and orientation (pose) in 2-dimensions\n * `SO3` for orientation in 3-dimensions\n * `SE3` for position and orientation (pose) in 3-dimensions\n * `UnitQuaternion` for orientation in 3-dimensions\n\nwhich provide convenience and type safety.  These classes have methods and overloaded operators to support:\n\n * composition, using the `*` operator\n * exponent, using the `**` operator\n * normalization\n * inversion\n * exponential and logarithm\n * conversion of orientation to/from Euler angles, roll-pitch-yaw angles and angle-axis forms.\n * list operations such as append, insert and get\n\nThese are layered over a set of base functions that perform many of the same operations but represent everything in terms of `numpy` arrays.\n\nThe class, method and functions names largely mirror those of the MATLAB toolboxes, and the semantics are quite similar.\n\n# Examples\n\n\n## High-level classes\n\nThese classes abstract the low-level numpy arrays into objects that obey the rules associated with the mathematical groups SO(2), SE(2), SO(3), SE(3) as well as twists and quaternions.\n\nUsing classes ensures type safety, for example it stops us mixing a 2D homogeneous transformation with a 3D rotation matrix -- both are 3x3 matrices.\n\nFor example, to create an object representing a rotation of 0.3 radians about the x-axis is simply\n\n```python\n>>> R1 = SO3.Rx(0.3)\n>>> R1\n   1         0         0          \n   0         0.955336 -0.29552    \n   0         0.29552   0.955336         \n```\nwhile a rotation of 30 deg about the z-axis is\n\n```python\n>>> R2 = SO3.Rz(30, 'deg')\n>>> R2\n   0.866025 -0.5       0          \n   0.5       0.866025  0          \n   0         0         1    \n```\nand the composition of these two rotations is \n\n```python\n>>> R = R1 *R2\n   0.866025 -0.5       0          \n   0.433013  0.75     -0.5        \n   0.25      0.433013  0.866025 \n```\n\nWe can find the corresponding Euler angles\n\n```python\n>> R.eul\narray([-1.57079633,  0.52359878,  2.0943951 ])\n```\n\nFrequently in robotics we want a sequence, a trajectory, of rotation matrices or poses. These pose classes inherit capability from the `list` class\n\n```python\n>>> R = SO3()   # the identity\n>>> R.append(R1)\n>>> R.append(R2)\n>>> len(R)\n 3\n>>> R[1]\n   1         0         0       \n   0         0.866025 -0.5    \n   0         0.5       0.866025            \n```\nand this can be used in `for` loops and list comprehensions.\n\nAn alternative way of constructing this would be\n\n```python\n>>> R = SO3( [ SO3(), R1, R2 ] )       \n>>> len(R)\n 3\n```\n\nMany of the constructors such as `.Rx`, `.Ry` and `.Rz` support vectorization\n\n```python\n>>> R = SO3.Rx( np.arange(0, 2*np.pi, 0.2))\n>>> len(R)\n 32\n```\nwhich has created, in a single line, a list of rotation matrices.\n\nVectorization also applies to the operators, for instance\n\n```python\n>>> A = R * SO3.Ry(0.5)\n>>> len(R)\n 32\n```\nwill produce a result where each element is the product of each element of the left-hand side with the right-hand side, ie. `R[i] * SO3.Ry(0.5)`.\n\nSimilarly\n\n```python\n>>> A = SO3.Ry(0.5) * R \n>>> len(R)\n 32\n```\nwill produce a result where each element is the product of the left-hand side with each element of the right-hand side , ie. `SO3.Ry(0.5) * R[i] `.\n\nFinally\n\n```python\n>>> A = R * R \n>>> len(R)\n 32\n```\nwill produce a result where each element is the product of each element of the left-hand side with each element of the right-hand side , ie. `R[i] * R[i] `.\n\nThe underlying representation of these classes is a numpy matrix, but the class ensures that the structure of that matrix is valid for the particular group represented: SO(2), SE(2), SO(3), SE(3).  Any operation that is not valid for the group will return a matrix rather than a pose class, for example\n\n```python\n>>> SO3.Rx(0.3)*2\narray([[ 2.        ,  0.        ,  0.        ],\n       [ 0.        ,  1.91067298, -0.59104041],\n       [ 0.        ,  0.59104041,  1.91067298]])\n\n>>> SO3.Rx(0.3)-1\narray([[ 0.        , -1.        , -1.        ],\n       [-1.        , -0.04466351, -1.29552021],\n       [-1.        , -0.70447979, -0.04466351]])\n```\n\n\n## Low-level spatial math\n\nImport the low-level transform functions\n\n```\n>>> import spatialmath.base as tr\n```\n\nWe can create a 3D rotation matrix\n\n```\n>>> tr.rotx(0.3)\narray([[ 1.        ,  0.        ,  0.        ],\n       [ 0.        ,  0.95533649, -0.29552021],\n       [ 0.        ,  0.29552021,  0.95533649]])\n\n>>> tr.rotx(30, unit='deg')\narray([[ 1.       ,  0.       ,  0.       ],\n       [ 0.       ,  0.8660254, -0.5      ],\n       [ 0.       ,  0.5      ,  0.8660254]])\n```\nThe results are `numpy` arrays so to perform matrix multiplication you need to use the `@` operator, for example\n\n```\nrotx(0.3) @ roty(0.2)\n```\n\nWe also support multiple ways of passing vector information to functions that require it:\n\n* as separate positional arguments\n\n```\ntransl2(1, 2)\narray([[1., 0., 1.],\n       [0., 1., 2.],\n       [0., 0., 1.]])\n```\n\n* as a list or a tuple\n\n```\ntransl2( [1,2] )\narray([[1., 0., 1.],\n       [0., 1., 2.],\n       [0., 0., 1.]])\n\ntransl2( (1,2) )\nOut[444]: \narray([[1., 0., 1.],\n       [0., 1., 2.],\n       [0., 0., 1.]])\n```\n\n* or as a `numpy` array\n\n```\ntransl2( np.array([1,2]) )\nOut[445]: \narray([[1., 0., 1.],\n       [0., 1., 2.],\n       [0., 0., 1.]])\n```\n\ntrplot example\npackages, animation\n\nThere is a single module that deals with quaternions, unit or not, and the representation is a `numpy` array of four elements.  As above, functions can accept the `numpy` array, a list, dict or `numpy` row or column vectors.\n\n```\n>>> from spatialmath.base.quaternion import *\n>>> q = qqmul([1,2,3,4], [5,6,7,8])\n>>> q\narray([-60,  12,  30,  24])\n>>> qprint(q)\n-60.000000 < 12.000000, 30.000000, 24.000000 >\n>>> qnorm(q)\n72.24956747275377\n```\n\n## Symbolic support\n\nSome functions have support for symbolic variables, for example\n\n```\nimport sympy\n\ntheta = sym.symbols('theta')\nprint(rotx(theta))\n[[1 0 0]\n [0 cos(theta) -sin(theta)]\n [0 sin(theta) cos(theta)]]\n```\n\nThe resulting `numpy` array is an array of symbolic objects not numbers &ndash; the constants are also symbolic objects.  You can read the elements of the matrix\n\n```\na = T[0,0]\n\na\nOut[258]: 1\n\ntype(a)\nOut[259]: int\n\na = T[1,1]\na\nOut[256]: \ncos(theta)\ntype(a)\nOut[255]: cos\n```\nWe see that the symbolic constants are converted back to Python numeric types on read.\n\nSimilarly when we assign an element or slice of the symbolic matrix to a numeric value, they are converted to symbolic constants on the way in.", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/petercorke/spatialmath-python", "keywords": "python SO2 SE2 SO3 SE3 rotation euler roll-pitch-yaw quaternion transforms robotics vision pose", "license": "MIT", "maintainer": "", "maintainer_email": "", "name": "spatialmath-python", "package_url": "https://pypi.org/project/spatialmath-python/", "platform": "", "project_url": "https://pypi.org/project/spatialmath-python/", "project_urls": {"Documentation": "https://petercorke.github.io/spatialmath-python", "Homepage": "https://github.com/petercorke/spatialmath-python", "Source": "https://github.com/petercorke/spatialmath-python", "Tracker": "https://github.com/petercorke/spatialmath-python/issues"}, "release_url": "https://pypi.org/project/spatialmath-python/0.5/", "requires_dist": null, "requires_python": ">=3.2", "summary": "Provides spatial maths capability for Python.", "version": "0.5", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p><a href=\"https://www.python.org/\" rel=\"nofollow\"><img alt=\"made-with-python\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/68a99107ffdf24c5fb2cc4bca38b7b662e501b97/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f4d616465253230776974682d507974686f6e2d3166343235662e737667\"></a><a href=\"https://travis-ci.com/petercorke/spatialmath-python\" rel=\"nofollow\"><img alt=\"Build Status\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/c9b7c1546410fc3f93a7b88bd8a040d3c13c5ec5/68747470733a2f2f7472617669732d63692e636f6d2f7065746572636f726b652f7370617469616c6d6174682d707974686f6e2e7376673f6272616e63683d6d6173746572\"></a>\n<img alt=\"Coverage\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/cb5844bdf62ef98627782015bbc24682b3834ef4/68747470733a2f2f636f6465636f762e696f2f67682f7065746572636f726b652f7370617469616c6d6174682d707974686f6e2f6272616e63682f6d61737465722f67726170682f62616467652e737667\">\n<a href=\"https://opensource.org/licenses/MIT\" rel=\"nofollow\"><img alt=\"License: MIT\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/8645b002dd7ec1b54275a80574942e7a318e03c6/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f4c6963656e73652d4d49542d79656c6c6f772e737667\"></a>\n<a href=\"https://GitHub.com/petercorke/spatialmath-python/graphs/commit-activity\" rel=\"nofollow\"><img alt=\"Maintenance\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/90bf1b2a4d99698c4dffbc494b9734690a777fec/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f4d61696e7461696e65642533462d7965732d677265656e2e737667\"></a>\n<a href=\"https://GitHub.com/petercorke/spatialmath-python/stargazers/\" rel=\"nofollow\"><img alt=\"GitHub stars\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/7c4a1b0d5a44a521fd6f744821de448699c79904/68747470733a2f2f696d672e736869656c64732e696f2f6769746875622f73746172732f7065746572636f726b652f7370617469616c6d6174682d707974686f6e2e7376673f7374796c653d736f6369616c266c6162656c3d53746172266d61784167653d32353932303030\"></a></p>\n<h1>Spatial Maths for Python</h1>\n<p>This is a Python implementation of the <a href=\"https://github.com/petercorke/spatial-math\" rel=\"nofollow\">Spatial Math Toolbox for MATLAB<sup>\u00ae</sup></a>, which is a standalone component of the <a href=\"https://github.com/petercorke/robotics-toolbox-matlab\" rel=\"nofollow\">Robotics Toolbox for MATLAB<sup>\u00ae</sup></a>.</p>\n<p>Spatial mathematics capability underpins all of robotics and robotic vision where we need to describe the position, orientation or pose of objects in 2D or 3D spaces.</p>\n<ul>\n<li>GitHub repository <a href=\"https://github.com/petercorke/spatialmath-python\" rel=\"nofollow\">https://github.com/petercorke/spatialmath-python</a></li>\n<li>Documentation <a href=\"https://petercorke.github.io/spatialmath-python\" rel=\"nofollow\">https://petercorke.github.io/spatialmath-python</a></li>\n<li>Dependencies: <code>numpy</code>, <code>scipy</code>, <code>matplotlib</code>, <code>ffmpeg</code> (if rendering animations as a movie)</li>\n</ul>\n<h1>What it does</h1>\n<p>Provides a set of classes:</p>\n<ul>\n<li><code>SO2</code> for orientation in 2-dimensions</li>\n<li><code>SE2</code> for position and orientation (pose) in 2-dimensions</li>\n<li><code>SO3</code> for orientation in 3-dimensions</li>\n<li><code>SE3</code> for position and orientation (pose) in 3-dimensions</li>\n<li><code>UnitQuaternion</code> for orientation in 3-dimensions</li>\n</ul>\n<p>which provide convenience and type safety.  These classes have methods and overloaded operators to support:</p>\n<ul>\n<li>composition, using the <code>*</code> operator</li>\n<li>exponent, using the <code>**</code> operator</li>\n<li>normalization</li>\n<li>inversion</li>\n<li>exponential and logarithm</li>\n<li>conversion of orientation to/from Euler angles, roll-pitch-yaw angles and angle-axis forms.</li>\n<li>list operations such as append, insert and get</li>\n</ul>\n<p>These are layered over a set of base functions that perform many of the same operations but represent everything in terms of <code>numpy</code> arrays.</p>\n<p>The class, method and functions names largely mirror those of the MATLAB toolboxes, and the semantics are quite similar.</p>\n<h1>Examples</h1>\n<h2>High-level classes</h2>\n<p>These classes abstract the low-level numpy arrays into objects that obey the rules associated with the mathematical groups SO(2), SE(2), SO(3), SE(3) as well as twists and quaternions.</p>\n<p>Using classes ensures type safety, for example it stops us mixing a 2D homogeneous transformation with a 3D rotation matrix -- both are 3x3 matrices.</p>\n<p>For example, to create an object representing a rotation of 0.3 radians about the x-axis is simply</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">R1</span> <span class=\"o\">=</span> <span class=\"n\">SO3</span><span class=\"o\">.</span><span class=\"n\">Rx</span><span class=\"p\">(</span><span class=\"mf\">0.3</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">R1</span>\n   <span class=\"mi\">1</span>         <span class=\"mi\">0</span>         <span class=\"mi\">0</span>          \n   <span class=\"mi\">0</span>         <span class=\"mf\">0.955336</span> <span class=\"o\">-</span><span class=\"mf\">0.29552</span>    \n   <span class=\"mi\">0</span>         <span class=\"mf\">0.29552</span>   <span class=\"mf\">0.955336</span>         \n</pre>\n<p>while a rotation of 30 deg about the z-axis is</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">R2</span> <span class=\"o\">=</span> <span class=\"n\">SO3</span><span class=\"o\">.</span><span class=\"n\">Rz</span><span class=\"p\">(</span><span class=\"mi\">30</span><span class=\"p\">,</span> <span class=\"s1\">'deg'</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">R2</span>\n   <span class=\"mf\">0.866025</span> <span class=\"o\">-</span><span class=\"mf\">0.5</span>       <span class=\"mi\">0</span>          \n   <span class=\"mf\">0.5</span>       <span class=\"mf\">0.866025</span>  <span class=\"mi\">0</span>          \n   <span class=\"mi\">0</span>         <span class=\"mi\">0</span>         <span class=\"mi\">1</span>    \n</pre>\n<p>and the composition of these two rotations is</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">R</span> <span class=\"o\">=</span> <span class=\"n\">R1</span> <span class=\"o\">*</span><span class=\"n\">R2</span>\n   <span class=\"mf\">0.866025</span> <span class=\"o\">-</span><span class=\"mf\">0.5</span>       <span class=\"mi\">0</span>          \n   <span class=\"mf\">0.433013</span>  <span class=\"mf\">0.75</span>     <span class=\"o\">-</span><span class=\"mf\">0.5</span>        \n   <span class=\"mf\">0.25</span>      <span class=\"mf\">0.433013</span>  <span class=\"mf\">0.866025</span> \n</pre>\n<p>We can find the corresponding Euler angles</p>\n<pre><span class=\"o\">&gt;&gt;</span> <span class=\"n\">R</span><span class=\"o\">.</span><span class=\"n\">eul</span>\n<span class=\"n\">array</span><span class=\"p\">([</span><span class=\"o\">-</span><span class=\"mf\">1.57079633</span><span class=\"p\">,</span>  <span class=\"mf\">0.52359878</span><span class=\"p\">,</span>  <span class=\"mf\">2.0943951</span> <span class=\"p\">])</span>\n</pre>\n<p>Frequently in robotics we want a sequence, a trajectory, of rotation matrices or poses. These pose classes inherit capability from the <code>list</code> class</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">R</span> <span class=\"o\">=</span> <span class=\"n\">SO3</span><span class=\"p\">()</span>   <span class=\"c1\"># the identity</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">R</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"n\">R1</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">R</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"n\">R2</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">R</span><span class=\"p\">)</span>\n <span class=\"mi\">3</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">R</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span>\n   <span class=\"mi\">1</span>         <span class=\"mi\">0</span>         <span class=\"mi\">0</span>       \n   <span class=\"mi\">0</span>         <span class=\"mf\">0.866025</span> <span class=\"o\">-</span><span class=\"mf\">0.5</span>    \n   <span class=\"mi\">0</span>         <span class=\"mf\">0.5</span>       <span class=\"mf\">0.866025</span>            \n</pre>\n<p>and this can be used in <code>for</code> loops and list comprehensions.</p>\n<p>An alternative way of constructing this would be</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">R</span> <span class=\"o\">=</span> <span class=\"n\">SO3</span><span class=\"p\">(</span> <span class=\"p\">[</span> <span class=\"n\">SO3</span><span class=\"p\">(),</span> <span class=\"n\">R1</span><span class=\"p\">,</span> <span class=\"n\">R2</span> <span class=\"p\">]</span> <span class=\"p\">)</span>       \n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">R</span><span class=\"p\">)</span>\n <span class=\"mi\">3</span>\n</pre>\n<p>Many of the constructors such as <code>.Rx</code>, <code>.Ry</code> and <code>.Rz</code> support vectorization</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">R</span> <span class=\"o\">=</span> <span class=\"n\">SO3</span><span class=\"o\">.</span><span class=\"n\">Rx</span><span class=\"p\">(</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">arange</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"o\">*</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">pi</span><span class=\"p\">,</span> <span class=\"mf\">0.2</span><span class=\"p\">))</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">R</span><span class=\"p\">)</span>\n <span class=\"mi\">32</span>\n</pre>\n<p>which has created, in a single line, a list of rotation matrices.</p>\n<p>Vectorization also applies to the operators, for instance</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">A</span> <span class=\"o\">=</span> <span class=\"n\">R</span> <span class=\"o\">*</span> <span class=\"n\">SO3</span><span class=\"o\">.</span><span class=\"n\">Ry</span><span class=\"p\">(</span><span class=\"mf\">0.5</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">R</span><span class=\"p\">)</span>\n <span class=\"mi\">32</span>\n</pre>\n<p>will produce a result where each element is the product of each element of the left-hand side with the right-hand side, ie. <code>R[i] * SO3.Ry(0.5)</code>.</p>\n<p>Similarly</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">A</span> <span class=\"o\">=</span> <span class=\"n\">SO3</span><span class=\"o\">.</span><span class=\"n\">Ry</span><span class=\"p\">(</span><span class=\"mf\">0.5</span><span class=\"p\">)</span> <span class=\"o\">*</span> <span class=\"n\">R</span> \n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">R</span><span class=\"p\">)</span>\n <span class=\"mi\">32</span>\n</pre>\n<p>will produce a result where each element is the product of the left-hand side with each element of the right-hand side , ie. <code>SO3.Ry(0.5) * R[i]</code>.</p>\n<p>Finally</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">A</span> <span class=\"o\">=</span> <span class=\"n\">R</span> <span class=\"o\">*</span> <span class=\"n\">R</span> \n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">R</span><span class=\"p\">)</span>\n <span class=\"mi\">32</span>\n</pre>\n<p>will produce a result where each element is the product of each element of the left-hand side with each element of the right-hand side , ie. <code>R[i] * R[i]</code>.</p>\n<p>The underlying representation of these classes is a numpy matrix, but the class ensures that the structure of that matrix is valid for the particular group represented: SO(2), SE(2), SO(3), SE(3).  Any operation that is not valid for the group will return a matrix rather than a pose class, for example</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">SO3</span><span class=\"o\">.</span><span class=\"n\">Rx</span><span class=\"p\">(</span><span class=\"mf\">0.3</span><span class=\"p\">)</span><span class=\"o\">*</span><span class=\"mi\">2</span>\n<span class=\"n\">array</span><span class=\"p\">([[</span> <span class=\"mf\">2.</span>        <span class=\"p\">,</span>  <span class=\"mf\">0.</span>        <span class=\"p\">,</span>  <span class=\"mf\">0.</span>        <span class=\"p\">],</span>\n       <span class=\"p\">[</span> <span class=\"mf\">0.</span>        <span class=\"p\">,</span>  <span class=\"mf\">1.91067298</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mf\">0.59104041</span><span class=\"p\">],</span>\n       <span class=\"p\">[</span> <span class=\"mf\">0.</span>        <span class=\"p\">,</span>  <span class=\"mf\">0.59104041</span><span class=\"p\">,</span>  <span class=\"mf\">1.91067298</span><span class=\"p\">]])</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">SO3</span><span class=\"o\">.</span><span class=\"n\">Rx</span><span class=\"p\">(</span><span class=\"mf\">0.3</span><span class=\"p\">)</span><span class=\"o\">-</span><span class=\"mi\">1</span>\n<span class=\"n\">array</span><span class=\"p\">([[</span> <span class=\"mf\">0.</span>        <span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mf\">1.</span>        <span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mf\">1.</span>        <span class=\"p\">],</span>\n       <span class=\"p\">[</span><span class=\"o\">-</span><span class=\"mf\">1.</span>        <span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mf\">0.04466351</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mf\">1.29552021</span><span class=\"p\">],</span>\n       <span class=\"p\">[</span><span class=\"o\">-</span><span class=\"mf\">1.</span>        <span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mf\">0.70447979</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mf\">0.04466351</span><span class=\"p\">]])</span>\n</pre>\n<h2>Low-level spatial math</h2>\n<p>Import the low-level transform functions</p>\n<pre><code>&gt;&gt;&gt; import spatialmath.base as tr\n</code></pre>\n<p>We can create a 3D rotation matrix</p>\n<pre><code>&gt;&gt;&gt; tr.rotx(0.3)\narray([[ 1.        ,  0.        ,  0.        ],\n       [ 0.        ,  0.95533649, -0.29552021],\n       [ 0.        ,  0.29552021,  0.95533649]])\n\n&gt;&gt;&gt; tr.rotx(30, unit='deg')\narray([[ 1.       ,  0.       ,  0.       ],\n       [ 0.       ,  0.8660254, -0.5      ],\n       [ 0.       ,  0.5      ,  0.8660254]])\n</code></pre>\n<p>The results are <code>numpy</code> arrays so to perform matrix multiplication you need to use the <code>@</code> operator, for example</p>\n<pre><code>rotx(0.3) @ roty(0.2)\n</code></pre>\n<p>We also support multiple ways of passing vector information to functions that require it:</p>\n<ul>\n<li>as separate positional arguments</li>\n</ul>\n<pre><code>transl2(1, 2)\narray([[1., 0., 1.],\n       [0., 1., 2.],\n       [0., 0., 1.]])\n</code></pre>\n<ul>\n<li>as a list or a tuple</li>\n</ul>\n<pre><code>transl2( [1,2] )\narray([[1., 0., 1.],\n       [0., 1., 2.],\n       [0., 0., 1.]])\n\ntransl2( (1,2) )\nOut[444]: \narray([[1., 0., 1.],\n       [0., 1., 2.],\n       [0., 0., 1.]])\n</code></pre>\n<ul>\n<li>or as a <code>numpy</code> array</li>\n</ul>\n<pre><code>transl2( np.array([1,2]) )\nOut[445]: \narray([[1., 0., 1.],\n       [0., 1., 2.],\n       [0., 0., 1.]])\n</code></pre>\n<p>trplot example\npackages, animation</p>\n<p>There is a single module that deals with quaternions, unit or not, and the representation is a <code>numpy</code> array of four elements.  As above, functions can accept the <code>numpy</code> array, a list, dict or <code>numpy</code> row or column vectors.</p>\n<pre><code>&gt;&gt;&gt; from spatialmath.base.quaternion import *\n&gt;&gt;&gt; q = qqmul([1,2,3,4], [5,6,7,8])\n&gt;&gt;&gt; q\narray([-60,  12,  30,  24])\n&gt;&gt;&gt; qprint(q)\n-60.000000 &lt; 12.000000, 30.000000, 24.000000 &gt;\n&gt;&gt;&gt; qnorm(q)\n72.24956747275377\n</code></pre>\n<h2>Symbolic support</h2>\n<p>Some functions have support for symbolic variables, for example</p>\n<pre><code>import sympy\n\ntheta = sym.symbols('theta')\nprint(rotx(theta))\n[[1 0 0]\n [0 cos(theta) -sin(theta)]\n [0 sin(theta) cos(theta)]]\n</code></pre>\n<p>The resulting <code>numpy</code> array is an array of symbolic objects not numbers \u2013 the constants are also symbolic objects.  You can read the elements of the matrix</p>\n<pre><code>a = T[0,0]\n\na\nOut[258]: 1\n\ntype(a)\nOut[259]: int\n\na = T[1,1]\na\nOut[256]: \ncos(theta)\ntype(a)\nOut[255]: cos\n</code></pre>\n<p>We see that the symbolic constants are converted back to Python numeric types on read.</p>\n<p>Similarly when we assign an element or slice of the symbolic matrix to a numeric value, they are converted to symbolic constants on the way in.</p>\n\n          </div>"}, "last_serial": 7155797, "releases": {"0.5": [{"comment_text": "", "digests": {"md5": "73050298084d9ec86f0e97ceb5f890e2", "sha256": "04128c6b6149f6c81e77545fc2e3ead780075ec61f6a6666bef1d8348f899385"}, "downloads": -1, "filename": "spatialmath-python-0.5.tar.gz", "has_sig": false, "md5_digest": "73050298084d9ec86f0e97ceb5f890e2", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.2", "size": 59672, "upload_time": "2020-05-03T09:51:48", "upload_time_iso_8601": "2020-05-03T09:51:48.359655Z", "url": "https://files.pythonhosted.org/packages/db/a4/a9c9683903445524705b69fa5c191d7c5b0ce8b3238e918173935d2bf3f7/spatialmath-python-0.5.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "73050298084d9ec86f0e97ceb5f890e2", "sha256": "04128c6b6149f6c81e77545fc2e3ead780075ec61f6a6666bef1d8348f899385"}, "downloads": -1, "filename": "spatialmath-python-0.5.tar.gz", "has_sig": false, "md5_digest": "73050298084d9ec86f0e97ceb5f890e2", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.2", "size": 59672, "upload_time": "2020-05-03T09:51:48", "upload_time_iso_8601": "2020-05-03T09:51:48.359655Z", "url": "https://files.pythonhosted.org/packages/db/a4/a9c9683903445524705b69fa5c191d7c5b0ce8b3238e918173935d2bf3f7/spatialmath-python-0.5.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:05:46 2020"}