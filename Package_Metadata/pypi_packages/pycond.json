{"info": {"author": "gk", "author_email": "gk@axiros.com", "bugtrack_url": null, "classifiers": ["Development Status :: 5 - Production/Stable", "Intended Audience :: Developers", "License :: OSI Approved :: BSD License", "Operating System :: POSIX", "Programming Language :: Python :: 2", "Programming Language :: Python :: 2.7", "Programming Language :: Python :: 3", "Topic :: Software Development :: Code Generators", "Topic :: Software Development :: Pre-processors", "Topic :: Text Editors :: Text Processing"], "description": "---\n\nauthor: gk\nversion: 190523\n\n---\n\n\n# pycond: Lightweight Declarative Condition Expressions\n\n[![Build Status](https://travis-ci.org/axiros/pycond.svg?branch=master)](https://travis-ci.org/axiros/pycond) [![codecov](https://codecov.io/gh/axiros/pycond/branch/master/graph/badge.svg)](https://codecov.io/gh/axiros/pycond)[![PyPI    version][pypisvg]][pypi] [![][blacksvg]][black]\n\n[blacksvg]: https://img.shields.io/badge/code%20style-black-000000.svg\n[black]: https://github.com/ambv/black\n[pypisvg]: https://img.shields.io/pypi/v/pycond.svg\n[pypi]: https://badge.fury.io/py/pycond\n\n<!-- badges: http://thomas-cokelaer.info/blog/2014/08/1013/ -->\n\n\n<!-- TOC -->\n\n# Table Of Contents\n\n- <a name=\"toc1\"></a>[What](#what)\n- <a name=\"toc2\"></a>[Why](#why)\n    - <a name=\"toc3\"></a>[Alternatives](#alternatives)\n- <a name=\"toc4\"></a>[Mechanics](#mechanics)\n    - <a name=\"toc5\"></a>[Parsing](#parsing)\n    - <a name=\"toc6\"></a>[Building](#building)\n    - <a name=\"toc7\"></a>[Structured Conditions](#structured-conditions)\n    - <a name=\"toc8\"></a>[Evaluation](#evaluation)\n    - <a name=\"toc9\"></a>[Default Lookup](#default-lookup)\n    - <a name=\"toc10\"></a>[Passing Custom State](#passing-custom-state)\n    - <a name=\"toc11\"></a>[Deep Lookup / Nested State](#deep-lookup-nested-state)\n    - <a name=\"toc12\"></a>[Custom Lookup And Value Passing](#custom-lookup-and-value-passing)\n    - <a name=\"toc13\"></a>[Lazy Evaluation](#lazy-evaluation)\n    - <a name=\"toc14\"></a>[Building Conditions From Text](#building-conditions-from-text)\n        - <a name=\"toc15\"></a>[Grammar](#grammar)\n        - <a name=\"toc16\"></a>[Atomic Conditions](#atomic-conditions)\n    - <a name=\"toc17\"></a>[Condition Operators](#condition-operators)\n        - <a name=\"toc18\"></a>[Using Symbolic Operators](#using-symbolic-operators)\n        - <a name=\"toc19\"></a>[Extending Condition Operators](#extending-condition-operators)\n        - <a name=\"toc20\"></a>[Negation `not`](#negation-not)\n        - <a name=\"toc21\"></a>[Reversal `rev`](#reversal-rev)\n        - <a name=\"toc22\"></a>[Wrapping Condition Operators](#wrapping-condition-operators)\n            - <a name=\"toc23\"></a>[Global Wrapping](#global-wrapping)\n            - <a name=\"toc24\"></a>[Condition Local Wrapping](#condition-local-wrapping)\n    - <a name=\"toc25\"></a>[Combining Operations](#combining-operations)\n        - <a name=\"toc26\"></a>[Nesting](#nesting)\n    - <a name=\"toc27\"></a>[Tokenizing Details](#tokenizing-details)\n        - <a name=\"toc28\"></a>[Functioning](#functioning)\n        - <a name=\"toc29\"></a>[Separator `sep`](#separator-sep)\n        - <a name=\"toc30\"></a>[Apostrophes](#apostrophes)\n        - <a name=\"toc31\"></a>[Escaping](#escaping)\n        - <a name=\"toc32\"></a>[Building](#building)\n        - <a name=\"toc33\"></a>[Autoconv: Casting of values into python simple types](#autoconv-casting-of-values-into-python-simple-types)\n- <a name=\"toc34\"></a>[Context On Demand And Lazy Evaluation](#context-on-demand-and-lazy-evaluation)\n\n<!-- TOC -->\n\n\n# <a href=\"#toc1\">What</a>\n\nYou have a bunch of data, possibly streaming...\n\n```csv\nid,first_name,last_name,email,gender,ip_address\n1,Rufe,Morstatt,rmorstatt0@newsvine.de,Male,216.70.69.120\n2,Kaela,Scott,scott@opera.com,Female,73.248.145.44,2\n(...)\n```\n\n... and you need to filter. For now lets say we have them already as list of dicts.\n\nYou can do it imperatively:\n\n```python\nfoo_users = [ u for u in users\n              if ([u['gender'] == 'Male' or u['last_name'] == 'Scott') and\n                  '@' in u['email']) ]\n```\n\nor you have this module assemble a condition function from a declaration like:\n\n```python\nfrom pycond import parse_cond\ncond = 'email contains .de and gender eq Male or last_name eq Scott'\nis_foo, req_keys = parse_cond(cond)\n```\n\nand then apply as often as you need, against varying state / facts / models (...):\n\n```\nfoo_users = [ u for u in users if is_foo(state=u) ]\n```\n\nwith roughly the same performance (factor 2-3) than the handcrafted python.\n\n> In real life performance is often **better** then using imperative code, due to\n`pycond's` [lazy evaluation](#lazy-evaluation) feature. \n\n# <a href=\"#toc2\">Why</a>\n\nWhen the developer can decide upon the filters to apply on data he'll certainly\nuse Python's excellent expressive possibilities directly, e.g. as shown above\nthrough list comprehensions.   \nBut what if the filtering conditions are based on decisions outside of the program's\ncontrol? I.e. from an end user, hitting the program via the network, in a somehow serialized form, which is rarely directly evaluatable Python.\n\nThis is the main use case for this module.  \n\n## <a href=\"#toc3\">Alternatives</a>\n\nBut why yet another tool for such a standard job?  \n\nThere is a list of great tools and frameworks where condition parsing is a (small) part of them, e.g. [pyke](http://pyke.sourceforge.net/) or [durable](https://pypi.python.org/pypi/durable_rules) and many in the django world or from SQL statement parsers.\n\n\n`1.` I just needed a very **slim** tool for only the parsing into functions - but this pretty transparent and customizable\n\npycond allows to customize\n- the list of condition operators\n- the list of combination operators\n- the general behavior of condition operators via global or condition local wrappers\n- their names\n- the tokenizer\n- the value lookup function\n\nand ships as zero dependency single module.\n\nAll evaluation is done via [partials](https://stackoverflow.com/a/3252425/4583360) and not lambdas, i.e. operations can be introspected and debugged very simply, through breakpoints or custom logging operator or lookup wrappers.\n\n`2.` Simplicity of the grammar: Easy to type directly, readable by non\nprogrammers but also synthesisable from structured data, e.g. from a web framework.\n\n\n`3.` Performance: Good enough to have \"pyconditions\" used within [stream filters](https://github.com/ReactiveX/RxPY).\nWith the current feature set we are sometimes a factor 2-3 worse but (due to lazy eval) often better,\ncompared with handcrafted list comprehensions.\n\n\n# <a href=\"#toc4\">Mechanics</a>\n\n<!-- md_links_for: github -->\n<!-- autogen tutorial -->\n\n\n## <a href=\"#toc5\">Parsing</a>\npycond parses the condition expressions according to a set of constraints given to the parser in the `tokenizer` function.\nThe result of the tokenizer is given to the builder.\n\n\n```python\nimport pycond as pc\n\ncond = '[a eq b and [c lt 42 or foo eq bar]]'\ncond = pc.to_struct(pc.tokenize(cond, sep=' ', brkts='[]'))\nprint(cond)\nreturn cond\n```\nOutput:\n\n```\n[['a', 'eq', 'b', 'and', ['c', 'lt', '42', 'or', 'foo', 'eq', 'bar']]]\n```\n\n\n\n\n## <a href=\"#toc6\">Building</a>\nAfter parsing the builder is assembling a nested set of operator functions, combined via combining operators.\nThe functions are partials, i.e. not yet evaluated but information about the necessary keys is already\navailable:\n\n\n```python\nf, meta = pc.parse_cond('foo eq bar')\nassert meta['keys'] == ['foo']\n```\n\n## <a href=\"#toc7\">Structured Conditions</a>\n\nOther processes may deliver condition structures via serializable formats (e.g. json).\nIf you hand such already tokenized constructs to pycond, then the tokenizer is bypassed:\n\n\n```python\ncond = [['a', 'eq', 'b'], 'or', ['c', 'in', ['foo', 'bar']]]\nassert pc.pycond(cond)(state={'a': 'b'}) == True\n```\n\n## <a href=\"#toc8\">Evaluation</a>\n\nThe result of the builder is a 'pycondition', which can be run many times against a varying state of the system.\nHow state is evaluated is customizable at build and run time.\n\n## <a href=\"#toc9\">Default Lookup</a>\nThe default is to get lookup keys within expressions from an initially empty `State` dict within the module.\n\n\n```python\nf = pc.pycond('foo eq bar')\nassert f() == False\npc.State['foo'] = 'bar'\nassert f() == True\n```\n\n\n(`pycond` is a shortcut for `parse_cond`, when meta infos are not required).\n\n\n## <a href=\"#toc10\">Passing Custom State</a>\n\nUse the state argument at evaluation:  \n\n```python\nassert pc.pycond('a gt 2')(state={'a': 42}) == True\nassert pc.pycond('a gt 2')(state={'a': -2}) == False\n```\n\n## <a href=\"#toc11\">Deep Lookup / Nested State</a>\n\nYou may supply a path seperator for diving into nested structures like so:\n\n\n```python\nm = {'a': {'b': [{'c': 1}]}}\nassert (\n    pc.pycond([('a', 'b', 0, 'c'), 'eq', 1], deep='.')(state=m)\n    == True\n)\n\nassert pc.pycond('a.b.0.c', deep='.')(state=m) == True\nassert pc.pycond('a.b.1.c', deep='.')(state=m) == False\nassert pc.pycond('a.b.0.c eq 1', deep='.')(state=m) == True\n# convencience argument for string conditions:\nassert pc.pycond('deep: a.b.0.c')(state=m) == True\n```\n\n\n## <a href=\"#toc12\">Custom Lookup And Value Passing</a>\n\nYou can supply your own function for value acquisition.\n- Signature: See example.\n- Returns: The value for the key from the current state plus the\n  compare value for the operator function.  \n\n```python\n# must return a (key, value) tuple:\nmodel = {'eve': {'last_host': 'somehost'}}\n\ndef my_lu(k, v, req, user, model=model):\n    print('user check. locals:', dict(locals()))\n    return (model.get(user) or {}).get(k), req[v]\n\nf = pc.pycond('last_host eq host', lookup=my_lu)\n\nreq = {'host': 'somehost'}\nassert f(req=req, user='joe') == False\nassert f(req=req, user='eve') == True\n```\nOutput:\n\n```\nuser check. locals: {'k': 'last_host', 'v': 'host', 'req': {'host': 'somehost'}, 'user': 'joe', 'model': {'eve': {'last_host': 'somehost'}}}\nuser check. locals: {'k': 'last_host', 'v': 'host', 'req': {'host': 'somehost'}, 'user': 'eve', 'model': {'eve': {'last_host': 'somehost'}}}\n```\n\n> as you can see in the example, the state parameter is just a convention\nfor `pyconds'` [title: default lookup function,fmatch=pycond.py,lmatch:def state_get\nfunction.\n\n## <a href=\"#toc13\">Lazy Evaluation</a>\n\nThis is avoiding unnecessary calculations in many cases:\n\nWhen an evaluation branch contains an \"and\" or \"and_not\" combinator, then\nat runtime we evaluate the first expression - and stop if it is already\nFalse. That way expensive deep branch evaluations are omitted or, when\nthe lookup is done lazy, the values won't be even fetched:\n\n\n```python\nevaluated = []\n\ndef myget(key, val, cfg, state=None, **kw):\n    evaluated.append(key)\n    # lets say we are false - always:\n    return False, True\n\nf = pc.pycond(\n    '[a eq b] or foo eq bar and baz eq bar', lookup=myget\n)\nf()\n# the value for \"baz\" is not even fetched and the whole (possibly\n# deep) branch after the last and is ignored:\nassert evaluated == ['a', 'foo']\nprint(evaluated)\n```\nOutput:\n\n```\n['a', 'foo']\n```\n\n## <a href=\"#toc14\">Building Conditions From Text</a>\n\nCondition functions are created internally from structured expressions -\nbut those are [hard to type](#lazy-dynamic-context-assembly),\ninvolving many apostropies.\n\nThe text based condition syntax is intended for situations when end users\ntype them into text boxes directly.\n\n### <a href=\"#toc15\">Grammar</a>\n\nCombine atomic conditions with boolean operators and nesting brackets like:\n\n```\n[  <atom1> <and|or|and not|...> <atom2> ] <and|or...> [ [ <atom3> ....\n```\n\n### <a href=\"#toc16\">Atomic Conditions</a>\n\n```\n[not] <lookup_key> [ [rev] [not] <condition operator (co)> <value> ]\n```\n- When just `lookup_key` is given, then `co` is set to the `truthy` function:\n```python\ndef truthy(key, val=None):\n    return operatur.truth(k)\n```\n\nso such an expression is valid and True:\n\n\n```python\npc.State.update({'foo': 1, 'bar': 'a', 'baz': []})\nassert pc.pycond('[ foo and bar and not baz]')() == True\n```\n\n- When `not lookup_key` is given, then `co` is set to the `falsy`\n  function:\n\n\n```python\nm = {'x': 'y', 'falsy_val': {}}\n# normal way\nassert pc.pycond(['foo', 'eq', None])(state=m) == True\n# using \"not\" as prefix:\nassert pc.pycond('not foo')(state=m) == True\nassert pc.pycond(['not', 'foo'])(state=m) == True\nassert pc.pycond('not falsy_val')(state=m) == True\nassert pc.pycond('x and not foo')(state=m) == True\nassert pc.pycond('y and not falsy_val')(state=m) == False\n```\n\n## <a href=\"#toc17\">Condition Operators</a>\n\nAll boolean [standardlib operators](https://docs.python.org/2/library/operator.html)\nare available by default:\n\n\n```python\nfrom pytest2md import html_table as tbl  # just a table gen.\nfrom pycond import get_ops\n\nfor k in 'nr', 'str':\n    s = 'Default supported ' + k + ' operators...(click to extend)'\n    print(tbl(get_ops()[k], [k + ' operator', 'alias'], summary=s))\n```\n\n<details>\n        <summary>Default supported nr operators...(click to extend)</summary>\n        <table>\n<tr><td>nr operator</td><td>alias</td></tr>\n<tr><td>add</td><td>+</td></tr>\n<tr><td>and_</td><td>&</td></tr>\n<tr><td>eq</td><td>==</td></tr>\n<tr><td>floordiv</td><td>//</td></tr>\n<tr><td>ge</td><td>>=</td></tr>\n<tr><td>gt</td><td>></td></tr>\n<tr><td>iadd</td><td>+=</td></tr>\n<tr><td>iand</td><td>&=</td></tr>\n<tr><td>ifloordiv</td><td>//=</td></tr>\n<tr><td>ilshift</td><td><<=</td></tr>\n<tr><td>imod</td><td>%=</td></tr>\n<tr><td>imul</td><td>*=</td></tr>\n<tr><td>ior</td><td>|=</td></tr>\n<tr><td>ipow</td><td>**=</td></tr>\n<tr><td>irshift</td><td>>>=</td></tr>\n<tr><td>is_</td><td>is</td></tr>\n<tr><td>is_not</td><td>is</td></tr>\n<tr><td>isub</td><td>-=</td></tr>\n<tr><td>itruediv</td><td>/=</td></tr>\n<tr><td>ixor</td><td>^=</td></tr>\n<tr><td>le</td><td><=</td></tr>\n<tr><td>lshift</td><td><<</td></tr>\n<tr><td>lt</td><td><</td></tr>\n<tr><td>mod</td><td>%</td></tr>\n<tr><td>mul</td><td>*</td></tr>\n<tr><td>ne</td><td>!=</td></tr>\n<tr><td>or_</td><td>|</td></tr>\n<tr><td>pow</td><td>**</td></tr>\n<tr><td>rshift</td><td>>></td></tr>\n<tr><td>sub</td><td>-</td></tr>\n<tr><td>truediv</td><td>/</td></tr>\n<tr><td>xor</td><td>^</td></tr>\n<tr><td>itemgetter</td><td></td></tr>\n<tr><td>length_hint</td><td></td></tr>\n</table>\n        </details>\n\n\n\n<details>\n        <summary>Default supported str operators...(click to extend)</summary>\n        <table>\n<tr><td>str operator</td><td>alias</td></tr>\n<tr><td>attrgetter</td><td></td></tr>\n<tr><td>concat</td><td>+</td></tr>\n<tr><td>contains</td><td></td></tr>\n<tr><td>countOf</td><td></td></tr>\n<tr><td>iconcat</td><td>+=</td></tr>\n<tr><td>indexOf</td><td></td></tr>\n<tr><td>methodcaller</td><td></td></tr>\n</table>\n        </details>\n\n\n\n\n### <a href=\"#toc18\">Using Symbolic Operators</a>\n\nBy default pycond uses text style operators.\n\n- `ops_use_symbolic` switches processwide to symbolic style only.\n- `ops_use_symbolic_and_txt` switches processwide to both notations allowed.\n\n\n```python\npc.ops_use_symbolic()\npc.State['foo'] = 'bar'\nassert pc.pycond('foo == bar')() == True\ntry:\n    # this raises now, text ops not known anymore:\n    pc.pycond('foo eq bar')\nexcept:\n    pc.ops_use_symbolic_and_txt(allow_single_eq=True)\n    assert pc.pycond('foo = bar')() == True\n    assert pc.pycond('foo == bar')() == True\n    assert pc.pycond('foo eq bar')() == True\n    assert pc.pycond('foo != baz')() == True\n```\n\n\n> Operator namespace(s) should be assigned at process start, they are global.\n\n\n### <a href=\"#toc19\">Extending Condition Operators</a>\n\n\n```python\npc.OPS['maybe'] = lambda a, b: int(time.time()) % 2\n# valid expression now:\nassert pc.pycond('a maybe b')() in (True, False)\n```\n\n\n### <a href=\"#toc20\">Negation `not`</a>\n\nNegates the result of the condition operator:\n\n\n```python\npc.State['foo'] = 'abc'\nassert pc.pycond('foo eq abc')() == True\nassert pc.pycond('foo not eq abc')() == False\n```\n\n\n### <a href=\"#toc21\">Reversal `rev`</a>\n\nReverses the arguments before calling the operator  \n\n```python\npc.State['foo'] = 'abc'\nassert pc.pycond('foo contains a')() == True\nassert pc.pycond('foo rev contains abc')() == True\n```\n\n\n> `rev` and `not` can be combined in any order.\n\n### <a href=\"#toc22\">Wrapping Condition Operators</a>\n\n#### <a href=\"#toc23\">Global Wrapping</a>\nYou may globally wrap all evaluation time condition operations through a custom function:\n\n\n\n```python\nl = []\n\ndef hk(f_op, a, b, l=l):\n    l.append((getattr(f_op, '__name__', ''), a, b))\n    return f_op(a, b)\n\npc.run_all_ops_thru(hk)  # globally wrap the operators\n\npc.State.update({'a': 1, 'b': 2, 'c': 3})\nf = pc.pycond('a gt 0 and b lt 3 and not c gt 4')\nassert l == []\nf()\nexpected_log = [('gt', 1, 0.0), ('lt', 2, 3.0), ('gt', 3, 4.0)]\nassert l == expected_log\npc.ops_use_symbolic_and_txt()\n```\n\n\nYou may compose such wrappers via repeated application of the `run_all_ops_thru` API function.\n\n#### <a href=\"#toc24\">Condition Local Wrapping</a>\n\nThis is done through the `ops_thru` parameter as shown:\n\n\n```python\ndef myhk(f_op, a, b):\n    return True\n\npc.State['a'] = 1\nf = pc.pycond('a eq 2')\nassert f() == False\nf = pc.pycond('a eq 2', ops_thru=myhk)\nassert f() == True\n```\n\n\n> Using `ops_thru` is a good way to debug unexpected results, since you\n> can add breakpoints or loggers there.\n\n\n## <a href=\"#toc25\">Combining Operations</a>\n\nYou can combine single conditions with\n- `and`\n- `and not`\n- `or`\n- `or not`\n- `xor` by default.\n\nThe combining functions are stored in `pycond.COMB_OPS` dict and may be extended.\n\n> Do not use spaces for the names of combining operators. The user may use them but they are replaced at before tokenizing time, like `and not` -> `and_not`.\n\n### <a href=\"#toc26\">Nesting</a>\n\nCombined conditions may be arbitrarily nested using brackets \"[\" and \"]\".\n\n> Via the `brkts` config parameter you may change those to other separators at build time.\n\n\n## <a href=\"#toc27\">Tokenizing Details</a>\n\n\n> Brackets as strings in this flat list form, e.g. `['[', 'a', 'and' 'b', ']'...]`\n\n### <a href=\"#toc28\">Functioning</a>\n\nThe tokenizers job is to take apart expression strings for the builder.\n\n### <a href=\"#toc29\">Separator `sep`</a>\n\nSeparates the different parts of an expression. Default is ' '.\n\n\n```python\npc.State['a'] = 42\nassert pc.pycond('a.eq.42', sep='.')() == True\n```\n\n> sep can be a any single character including binary.\n\nBracket characters do not need to be separated, the tokenizer will do:\n\n\n```python\n# equal:\nassert (\n    pc.pycond('[[a eq 42] and b]')()\n    == pc.pycond('[ [ a eq 42 ] and b ]')()\n)\n```\n\n> The condition functions themselves do not evaluate equal - those\n> had been assembled two times.\n\n### <a href=\"#toc30\">Apostrophes</a>\n\nBy putting strings into Apostrophes you can tell the tokenizer to not further inspect them, e.g. for the seperator:\n\n\n```python\npc.State['a'] = 'Hello World'\nassert pc.pycond('a eq \"Hello World\"')() == True\n```\n\n\n\n\n### <a href=\"#toc31\">Escaping</a>\n\nTell the tokenizer to not interpret the next character:\n\n\n```python\npc.State['b'] = 'Hello World'\nassert pc.pycond('b eq Hello\\ World')() == True\n```\n\n\n\n### <a href=\"#toc32\">Building</a>\n\n### <a href=\"#toc33\">Autoconv: Casting of values into python simple types</a>\n\nExpression string values are automatically cast into bools and numbers via the public `pycond.py_type` function.\n\nThis can be prevented by setting the `autoconv` parameter to `False` or by using Apostrophes:\n\n\n```python\npc.State['a'] = '42'\nassert pc.pycond('a eq 42')() == False\n# compared as string now\nassert pc.pycond('a eq \"42\"')() == True\n# compared as string now\nassert pc.pycond('a eq 42', autoconv=False)() == True\n```\n\n\nIf you do not want to provide a custom lookup function (where you can do what you want)\nbut want to have looked up keys autoconverted then use:\n\n\n```python\nfor id in '1', 1:\n    pc.State['id'] = id\n    assert pc.pycond('id lt 42', autoconv_lookups=True)\n```\n\n\n# <a href=\"#toc34\">Context On Demand And Lazy Evaluation</a>\n\nOften the conditions are in user space, applied on data streams under\nthe developer's control only at development time.\n\nThe end user might pick only a few keys from many offered within an API.\n\npycond's `ctx_builder` allows to only calculate those keys at runtime,\nthe user decided to base conditions upon:\nAt condition build time hand over a namespace for *all* functions which\nare available to build the ctx.\n\n`pycon` will return a context builder function for you, calling only those functions\nwhich the condition actually requires.\n\n\n```python\npc.ops_use_symbolic_and_txt(allow_single_eq=True)\n\n# Condition the end user configured, e.g. at program run time:\ncond = [\n    ['group_type', 'in', ['lab', 'first1k', 'friendly', 'auto']],\n    'and',\n    [\n        [\n            [\n                [\n                    ['cur_q', '<', 0.5],\n                    'and',\n                    ['delta_q', '>=', 0.15],\n                ],\n                'and',\n                ['dt_last_enforce', '>', 28800],\n            ],\n            'and',\n            ['cur_hour', 'in', [3, 4, 5]],\n        ],\n        'or',\n        [\n            [\n                [\n                    ['cur_q', '<', 0.5],\n                    'and',\n                    ['delta_q', '>=', 0.15],\n                ],\n                'and',\n                ['dt_last_enforce', '>', 28800],\n            ],\n            'and',\n            ['clients', '=', 0],\n        ],\n    ],\n]\n\n# Getters for API keys offered to the user, involving potentially\n# expensive to fetch context delivery functions:\n# Signature must provide minimum a positional for the current\n# state:\nclass ApiCtxFuncs:\n    def expensive_but_not_needed_here(ctx):\n        raise Exception(\"Won't run with cond. from above\")\n\n    def group_type(ctx):\n        raise Exception(\n            \"Won't run since contained in example data\"\n        )\n\n    def cur_q(ctx):\n        print('Calculating cur_q')\n        return 0.1\n\n    def cur_hour(ctx):\n        print('Calculating cur_hour')\n        return 4\n\n    def dt_last_enforce(ctx):\n        print('Calculating dt_last_enforce')\n        return 10000000\n\n    def delta_q(ctx):\n        print('Calculating (expensive) delta_q')\n        time.sleep(0.1)\n        return 1\n\n    def clients(ctx):\n        print('Calculating clients')\n        return 0\n\nif sys.version_info[0] < 3:\n    # we don't think it is a good idea to make the getter API stateful:\n    p2m.convert_to_staticmethods(ApiCtxFuncs)\n\nf, nfos = pc.parse_cond(cond, ctx_provider=ApiCtxFuncs)\n# this key stores the context builder function\nmake_ctx = nfos['complete_ctx']\n\n# now we get (incomplete) data..\ndata1 = {'group_type': 'xxx'}, False\ndata2 = {'group_type': 'lab'}, True\n\nt0 = time.time()\nfor event, expected in data1, data2:\n    assert pc.pycond(cond)(state=make_ctx(event)) == expected\n\nprint('Calc.Time', round(time.time() - t0, 4))\nreturn cond, ApiCtxFuncs\n```\nOutput:\n\n```\nCalculating clients\nCalculating cur_hour\nCalculating cur_q\nCalculating (expensive) delta_q\nCalculating dt_last_enforce\nCalculating clients\nCalculating cur_hour\nCalculating cur_q\nCalculating (expensive) delta_q\nCalculating dt_last_enforce\nCalc.Time 0.206\n```\n\n\nBut we can do better - we still calculated values for keys which might be\nonly needed in dead ends of a lazily evaluated condition.\n\nLets avoid calculating these values, remembering the\n[custom lookup function](#custom-lookup-and-value-passing) feature.\n\n\n> pycond does generate such a custom lookup function readily for you,\n> if you pass a getter namespace as `lookup_provider`:\n\n\n```python\n# we let pycond generate the lookup function now:\nf = pc.pycond(cond, lookup_provider=ApiCtxFuncs)\n\n# Same events as above:\ndata1 = {'group_type': 'xxx'}, False\ndata2 = {'group_type': 'lab'}, True\n\nt0 = time.time()\nfor event, expected in data1, data2:\n    # we will lookup only once:\n    assert f(state=event) == expected\n\nprint(\n    'Calc.Time (only one expensive calculation):',\n    round(time.time() - t0, 4),\n)\n```\nOutput:\n\n```\nCalculating cur_q\nCalculating (expensive) delta_q\nCalculating dt_last_enforce\nCalculating cur_hour\nCalculating clients\nCalc.Time (only one expensive calculation): 0.1005\n```\n\nThe output demonstrates that we did not even call the value provider functions for the dead branches of the condition.  \n\n\n*Auto generated by [pytest2md](https://github.com/axiros/pytest2md), running [test_tutorial.py][test_tutorial.py]*\n\n<!-- autogen tutorial -->\n\n\n<!-- autogenlinks -->\n[test_tutorial.py]: https://github.com/axiros/pycond/blob/b5e39519d6da61922a9fd2253f6b0ff49d48e2da/tests/test_tutorial.py\n\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/axiros/pycond", "keywords": "conditions,expression,serialization,rxpy,reactivex", "license": "BSD", "maintainer": "", "maintainer_email": "", "name": "pycond", "package_url": "https://pypi.org/project/pycond/", "platform": "", "project_url": "https://pypi.org/project/pycond/", "project_urls": {"Homepage": "https://github.com/axiros/pycond"}, "release_url": "https://pypi.org/project/pycond/200222/", "requires_dist": null, "requires_python": "", "summary": "Lightweight Condition Parsing and Building of Evaluation Expressions", "version": "200222", "yanked": false, "html_description": "<div class=\"project-description\">\n            <hr>\n<p>author: gk\nversion: 190523</p>\n<hr>\n<h1>pycond: Lightweight Declarative Condition Expressions</h1>\n<p><a href=\"https://travis-ci.org/axiros/pycond\" rel=\"nofollow\"><img alt=\"Build Status\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/0fb426634156cb7d8b857e3c1d1bbe39250d0195/68747470733a2f2f7472617669732d63692e6f72672f617869726f732f7079636f6e642e7376673f6272616e63683d6d6173746572\"></a> <a href=\"https://codecov.io/gh/axiros/pycond\" rel=\"nofollow\"><img alt=\"codecov\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/3f50f9a7cba43e3dccf1e9d8f895161df0f80be6/68747470733a2f2f636f6465636f762e696f2f67682f617869726f732f7079636f6e642f6272616e63682f6d61737465722f67726170682f62616467652e737667\"></a><a href=\"https://badge.fury.io/py/pycond\" rel=\"nofollow\"><img alt=\"PyPI    version\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/b4de10dfb446098b546413e7c54c98b6262075a3/68747470733a2f2f696d672e736869656c64732e696f2f707970692f762f7079636f6e642e737667\"></a> <a href=\"https://github.com/ambv/black\" rel=\"nofollow\"><img alt=\"\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/fbfdc7754183ecf079bc71ddeabaf88f6cbc5c00/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f636f64652532307374796c652d626c61636b2d3030303030302e737667\"></a></p>\n\n\n<h1>Table Of Contents</h1>\n<ul>\n<li><a></a><a href=\"#what\" rel=\"nofollow\">What</a></li>\n<li><a></a><a href=\"#why\" rel=\"nofollow\">Why</a>\n<ul>\n<li><a></a><a href=\"#alternatives\" rel=\"nofollow\">Alternatives</a></li>\n</ul>\n</li>\n<li><a></a><a href=\"#mechanics\" rel=\"nofollow\">Mechanics</a>\n<ul>\n<li><a></a><a href=\"#parsing\" rel=\"nofollow\">Parsing</a></li>\n<li><a></a><a href=\"#building\" rel=\"nofollow\">Building</a></li>\n<li><a></a><a href=\"#structured-conditions\" rel=\"nofollow\">Structured Conditions</a></li>\n<li><a></a><a href=\"#evaluation\" rel=\"nofollow\">Evaluation</a></li>\n<li><a></a><a href=\"#default-lookup\" rel=\"nofollow\">Default Lookup</a></li>\n<li><a></a><a href=\"#passing-custom-state\" rel=\"nofollow\">Passing Custom State</a></li>\n<li><a></a><a href=\"#deep-lookup-nested-state\" rel=\"nofollow\">Deep Lookup / Nested State</a></li>\n<li><a></a><a href=\"#custom-lookup-and-value-passing\" rel=\"nofollow\">Custom Lookup And Value Passing</a></li>\n<li><a></a><a href=\"#lazy-evaluation\" rel=\"nofollow\">Lazy Evaluation</a></li>\n<li><a></a><a href=\"#building-conditions-from-text\" rel=\"nofollow\">Building Conditions From Text</a>\n<ul>\n<li><a></a><a href=\"#grammar\" rel=\"nofollow\">Grammar</a></li>\n<li><a></a><a href=\"#atomic-conditions\" rel=\"nofollow\">Atomic Conditions</a></li>\n</ul>\n</li>\n<li><a></a><a href=\"#condition-operators\" rel=\"nofollow\">Condition Operators</a>\n<ul>\n<li><a></a><a href=\"#using-symbolic-operators\" rel=\"nofollow\">Using Symbolic Operators</a></li>\n<li><a></a><a href=\"#extending-condition-operators\" rel=\"nofollow\">Extending Condition Operators</a></li>\n<li><a></a><a href=\"#negation-not\" rel=\"nofollow\">Negation <code>not</code></a></li>\n<li><a></a><a href=\"#reversal-rev\" rel=\"nofollow\">Reversal <code>rev</code></a></li>\n<li><a></a><a href=\"#wrapping-condition-operators\" rel=\"nofollow\">Wrapping Condition Operators</a>\n<ul>\n<li><a></a><a href=\"#global-wrapping\" rel=\"nofollow\">Global Wrapping</a></li>\n<li><a></a><a href=\"#condition-local-wrapping\" rel=\"nofollow\">Condition Local Wrapping</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a></a><a href=\"#combining-operations\" rel=\"nofollow\">Combining Operations</a>\n<ul>\n<li><a></a><a href=\"#nesting\" rel=\"nofollow\">Nesting</a></li>\n</ul>\n</li>\n<li><a></a><a href=\"#tokenizing-details\" rel=\"nofollow\">Tokenizing Details</a>\n<ul>\n<li><a></a><a href=\"#functioning\" rel=\"nofollow\">Functioning</a></li>\n<li><a></a><a href=\"#separator-sep\" rel=\"nofollow\">Separator <code>sep</code></a></li>\n<li><a></a><a href=\"#apostrophes\" rel=\"nofollow\">Apostrophes</a></li>\n<li><a></a><a href=\"#escaping\" rel=\"nofollow\">Escaping</a></li>\n<li><a></a><a href=\"#building\" rel=\"nofollow\">Building</a></li>\n<li><a></a><a href=\"#autoconv-casting-of-values-into-python-simple-types\" rel=\"nofollow\">Autoconv: Casting of values into python simple types</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a></a><a href=\"#context-on-demand-and-lazy-evaluation\" rel=\"nofollow\">Context On Demand And Lazy Evaluation</a></li>\n</ul>\n\n<h1><a href=\"#toc1\" rel=\"nofollow\">What</a></h1>\n<p>You have a bunch of data, possibly streaming...</p>\n<pre>id,first_name,last_name,email,gender,ip_address\n1,Rufe,Morstatt,rmorstatt0@newsvine.de,Male,216.70.69.120\n2,Kaela,Scott,scott@opera.com,Female,73.248.145.44,2\n(...)\n</pre>\n<p>... and you need to filter. For now lets say we have them already as list of dicts.</p>\n<p>You can do it imperatively:</p>\n<pre><span class=\"n\">foo_users</span> <span class=\"o\">=</span> <span class=\"p\">[</span> <span class=\"n\">u</span> <span class=\"k\">for</span> <span class=\"n\">u</span> <span class=\"ow\">in</span> <span class=\"n\">users</span>\n              <span class=\"k\">if</span> <span class=\"p\">([</span><span class=\"n\">u</span><span class=\"p\">[</span><span class=\"s1\">'gender'</span><span class=\"p\">]</span> <span class=\"o\">==</span> <span class=\"s1\">'Male'</span> <span class=\"ow\">or</span> <span class=\"n\">u</span><span class=\"p\">[</span><span class=\"s1\">'last_name'</span><span class=\"p\">]</span> <span class=\"o\">==</span> <span class=\"s1\">'Scott'</span><span class=\"p\">)</span> <span class=\"ow\">and</span>\n                  <span class=\"s1\">'@'</span> <span class=\"ow\">in</span> <span class=\"n\">u</span><span class=\"p\">[</span><span class=\"s1\">'email'</span><span class=\"p\">])</span> <span class=\"p\">]</span>\n</pre>\n<p>or you have this module assemble a condition function from a declaration like:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">pycond</span> <span class=\"kn\">import</span> <span class=\"n\">parse_cond</span>\n<span class=\"n\">cond</span> <span class=\"o\">=</span> <span class=\"s1\">'email contains .de and gender eq Male or last_name eq Scott'</span>\n<span class=\"n\">is_foo</span><span class=\"p\">,</span> <span class=\"n\">req_keys</span> <span class=\"o\">=</span> <span class=\"n\">parse_cond</span><span class=\"p\">(</span><span class=\"n\">cond</span><span class=\"p\">)</span>\n</pre>\n<p>and then apply as often as you need, against varying state / facts / models (...):</p>\n<pre><code>foo_users = [ u for u in users if is_foo(state=u) ]\n</code></pre>\n<p>with roughly the same performance (factor 2-3) than the handcrafted python.</p>\n<blockquote>\n<p>In real life performance is often <strong>better</strong> then using imperative code, due to\n<code>pycond's</code> <a href=\"#lazy-evaluation\" rel=\"nofollow\">lazy evaluation</a> feature.</p>\n</blockquote>\n<h1><a href=\"#toc2\" rel=\"nofollow\">Why</a></h1>\n<p>When the developer can decide upon the filters to apply on data he'll certainly\nuse Python's excellent expressive possibilities directly, e.g. as shown above\nthrough list comprehensions.<br>\nBut what if the filtering conditions are based on decisions outside of the program's\ncontrol? I.e. from an end user, hitting the program via the network, in a somehow serialized form, which is rarely directly evaluatable Python.</p>\n<p>This is the main use case for this module.</p>\n<h2><a href=\"#toc3\" rel=\"nofollow\">Alternatives</a></h2>\n<p>But why yet another tool for such a standard job?</p>\n<p>There is a list of great tools and frameworks where condition parsing is a (small) part of them, e.g. <a href=\"http://pyke.sourceforge.net/\" rel=\"nofollow\">pyke</a> or <a href=\"https://pypi.python.org/pypi/durable_rules\" rel=\"nofollow\">durable</a> and many in the django world or from SQL statement parsers.</p>\n<p><code>1.</code> I just needed a very <strong>slim</strong> tool for only the parsing into functions - but this pretty transparent and customizable</p>\n<p>pycond allows to customize</p>\n<ul>\n<li>the list of condition operators</li>\n<li>the list of combination operators</li>\n<li>the general behavior of condition operators via global or condition local wrappers</li>\n<li>their names</li>\n<li>the tokenizer</li>\n<li>the value lookup function</li>\n</ul>\n<p>and ships as zero dependency single module.</p>\n<p>All evaluation is done via <a href=\"https://stackoverflow.com/a/3252425/4583360\" rel=\"nofollow\">partials</a> and not lambdas, i.e. operations can be introspected and debugged very simply, through breakpoints or custom logging operator or lookup wrappers.</p>\n<p><code>2.</code> Simplicity of the grammar: Easy to type directly, readable by non\nprogrammers but also synthesisable from structured data, e.g. from a web framework.</p>\n<p><code>3.</code> Performance: Good enough to have \"pyconditions\" used within <a href=\"https://github.com/ReactiveX/RxPY\" rel=\"nofollow\">stream filters</a>.\nWith the current feature set we are sometimes a factor 2-3 worse but (due to lazy eval) often better,\ncompared with handcrafted list comprehensions.</p>\n<h1><a href=\"#toc4\" rel=\"nofollow\">Mechanics</a></h1>\n\n\n<h2><a href=\"#toc5\" rel=\"nofollow\">Parsing</a></h2>\n<p>pycond parses the condition expressions according to a set of constraints given to the parser in the <code>tokenizer</code> function.\nThe result of the tokenizer is given to the builder.</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">pycond</span> <span class=\"k\">as</span> <span class=\"nn\">pc</span>\n\n<span class=\"n\">cond</span> <span class=\"o\">=</span> <span class=\"s1\">'[a eq b and [c lt 42 or foo eq bar]]'</span>\n<span class=\"n\">cond</span> <span class=\"o\">=</span> <span class=\"n\">pc</span><span class=\"o\">.</span><span class=\"n\">to_struct</span><span class=\"p\">(</span><span class=\"n\">pc</span><span class=\"o\">.</span><span class=\"n\">tokenize</span><span class=\"p\">(</span><span class=\"n\">cond</span><span class=\"p\">,</span> <span class=\"n\">sep</span><span class=\"o\">=</span><span class=\"s1\">' '</span><span class=\"p\">,</span> <span class=\"n\">brkts</span><span class=\"o\">=</span><span class=\"s1\">'[]'</span><span class=\"p\">))</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">cond</span><span class=\"p\">)</span>\n<span class=\"k\">return</span> <span class=\"n\">cond</span>\n</pre>\n<p>Output:</p>\n<pre><code>[['a', 'eq', 'b', 'and', ['c', 'lt', '42', 'or', 'foo', 'eq', 'bar']]]\n</code></pre>\n<h2><a href=\"#toc6\" rel=\"nofollow\">Building</a></h2>\n<p>After parsing the builder is assembling a nested set of operator functions, combined via combining operators.\nThe functions are partials, i.e. not yet evaluated but information about the necessary keys is already\navailable:</p>\n<pre><span class=\"n\">f</span><span class=\"p\">,</span> <span class=\"n\">meta</span> <span class=\"o\">=</span> <span class=\"n\">pc</span><span class=\"o\">.</span><span class=\"n\">parse_cond</span><span class=\"p\">(</span><span class=\"s1\">'foo eq bar'</span><span class=\"p\">)</span>\n<span class=\"k\">assert</span> <span class=\"n\">meta</span><span class=\"p\">[</span><span class=\"s1\">'keys'</span><span class=\"p\">]</span> <span class=\"o\">==</span> <span class=\"p\">[</span><span class=\"s1\">'foo'</span><span class=\"p\">]</span>\n</pre>\n<h2><a href=\"#toc7\" rel=\"nofollow\">Structured Conditions</a></h2>\n<p>Other processes may deliver condition structures via serializable formats (e.g. json).\nIf you hand such already tokenized constructs to pycond, then the tokenizer is bypassed:</p>\n<pre><span class=\"n\">cond</span> <span class=\"o\">=</span> <span class=\"p\">[[</span><span class=\"s1\">'a'</span><span class=\"p\">,</span> <span class=\"s1\">'eq'</span><span class=\"p\">,</span> <span class=\"s1\">'b'</span><span class=\"p\">],</span> <span class=\"s1\">'or'</span><span class=\"p\">,</span> <span class=\"p\">[</span><span class=\"s1\">'c'</span><span class=\"p\">,</span> <span class=\"s1\">'in'</span><span class=\"p\">,</span> <span class=\"p\">[</span><span class=\"s1\">'foo'</span><span class=\"p\">,</span> <span class=\"s1\">'bar'</span><span class=\"p\">]]]</span>\n<span class=\"k\">assert</span> <span class=\"n\">pc</span><span class=\"o\">.</span><span class=\"n\">pycond</span><span class=\"p\">(</span><span class=\"n\">cond</span><span class=\"p\">)(</span><span class=\"n\">state</span><span class=\"o\">=</span><span class=\"p\">{</span><span class=\"s1\">'a'</span><span class=\"p\">:</span> <span class=\"s1\">'b'</span><span class=\"p\">})</span> <span class=\"o\">==</span> <span class=\"kc\">True</span>\n</pre>\n<h2><a href=\"#toc8\" rel=\"nofollow\">Evaluation</a></h2>\n<p>The result of the builder is a 'pycondition', which can be run many times against a varying state of the system.\nHow state is evaluated is customizable at build and run time.</p>\n<h2><a href=\"#toc9\" rel=\"nofollow\">Default Lookup</a></h2>\n<p>The default is to get lookup keys within expressions from an initially empty <code>State</code> dict within the module.</p>\n<pre><span class=\"n\">f</span> <span class=\"o\">=</span> <span class=\"n\">pc</span><span class=\"o\">.</span><span class=\"n\">pycond</span><span class=\"p\">(</span><span class=\"s1\">'foo eq bar'</span><span class=\"p\">)</span>\n<span class=\"k\">assert</span> <span class=\"n\">f</span><span class=\"p\">()</span> <span class=\"o\">==</span> <span class=\"kc\">False</span>\n<span class=\"n\">pc</span><span class=\"o\">.</span><span class=\"n\">State</span><span class=\"p\">[</span><span class=\"s1\">'foo'</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"s1\">'bar'</span>\n<span class=\"k\">assert</span> <span class=\"n\">f</span><span class=\"p\">()</span> <span class=\"o\">==</span> <span class=\"kc\">True</span>\n</pre>\n<p>(<code>pycond</code> is a shortcut for <code>parse_cond</code>, when meta infos are not required).</p>\n<h2><a href=\"#toc10\" rel=\"nofollow\">Passing Custom State</a></h2>\n<p>Use the state argument at evaluation:</p>\n<pre><span class=\"k\">assert</span> <span class=\"n\">pc</span><span class=\"o\">.</span><span class=\"n\">pycond</span><span class=\"p\">(</span><span class=\"s1\">'a gt 2'</span><span class=\"p\">)(</span><span class=\"n\">state</span><span class=\"o\">=</span><span class=\"p\">{</span><span class=\"s1\">'a'</span><span class=\"p\">:</span> <span class=\"mi\">42</span><span class=\"p\">})</span> <span class=\"o\">==</span> <span class=\"kc\">True</span>\n<span class=\"k\">assert</span> <span class=\"n\">pc</span><span class=\"o\">.</span><span class=\"n\">pycond</span><span class=\"p\">(</span><span class=\"s1\">'a gt 2'</span><span class=\"p\">)(</span><span class=\"n\">state</span><span class=\"o\">=</span><span class=\"p\">{</span><span class=\"s1\">'a'</span><span class=\"p\">:</span> <span class=\"o\">-</span><span class=\"mi\">2</span><span class=\"p\">})</span> <span class=\"o\">==</span> <span class=\"kc\">False</span>\n</pre>\n<h2><a href=\"#toc11\" rel=\"nofollow\">Deep Lookup / Nested State</a></h2>\n<p>You may supply a path seperator for diving into nested structures like so:</p>\n<pre><span class=\"n\">m</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"s1\">'a'</span><span class=\"p\">:</span> <span class=\"p\">{</span><span class=\"s1\">'b'</span><span class=\"p\">:</span> <span class=\"p\">[{</span><span class=\"s1\">'c'</span><span class=\"p\">:</span> <span class=\"mi\">1</span><span class=\"p\">}]}}</span>\n<span class=\"k\">assert</span> <span class=\"p\">(</span>\n    <span class=\"n\">pc</span><span class=\"o\">.</span><span class=\"n\">pycond</span><span class=\"p\">([(</span><span class=\"s1\">'a'</span><span class=\"p\">,</span> <span class=\"s1\">'b'</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"s1\">'c'</span><span class=\"p\">),</span> <span class=\"s1\">'eq'</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">],</span> <span class=\"n\">deep</span><span class=\"o\">=</span><span class=\"s1\">'.'</span><span class=\"p\">)(</span><span class=\"n\">state</span><span class=\"o\">=</span><span class=\"n\">m</span><span class=\"p\">)</span>\n    <span class=\"o\">==</span> <span class=\"kc\">True</span>\n<span class=\"p\">)</span>\n\n<span class=\"k\">assert</span> <span class=\"n\">pc</span><span class=\"o\">.</span><span class=\"n\">pycond</span><span class=\"p\">(</span><span class=\"s1\">'a.b.0.c'</span><span class=\"p\">,</span> <span class=\"n\">deep</span><span class=\"o\">=</span><span class=\"s1\">'.'</span><span class=\"p\">)(</span><span class=\"n\">state</span><span class=\"o\">=</span><span class=\"n\">m</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"kc\">True</span>\n<span class=\"k\">assert</span> <span class=\"n\">pc</span><span class=\"o\">.</span><span class=\"n\">pycond</span><span class=\"p\">(</span><span class=\"s1\">'a.b.1.c'</span><span class=\"p\">,</span> <span class=\"n\">deep</span><span class=\"o\">=</span><span class=\"s1\">'.'</span><span class=\"p\">)(</span><span class=\"n\">state</span><span class=\"o\">=</span><span class=\"n\">m</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"kc\">False</span>\n<span class=\"k\">assert</span> <span class=\"n\">pc</span><span class=\"o\">.</span><span class=\"n\">pycond</span><span class=\"p\">(</span><span class=\"s1\">'a.b.0.c eq 1'</span><span class=\"p\">,</span> <span class=\"n\">deep</span><span class=\"o\">=</span><span class=\"s1\">'.'</span><span class=\"p\">)(</span><span class=\"n\">state</span><span class=\"o\">=</span><span class=\"n\">m</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"kc\">True</span>\n<span class=\"c1\"># convencience argument for string conditions:</span>\n<span class=\"k\">assert</span> <span class=\"n\">pc</span><span class=\"o\">.</span><span class=\"n\">pycond</span><span class=\"p\">(</span><span class=\"s1\">'deep: a.b.0.c'</span><span class=\"p\">)(</span><span class=\"n\">state</span><span class=\"o\">=</span><span class=\"n\">m</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"kc\">True</span>\n</pre>\n<h2><a href=\"#toc12\" rel=\"nofollow\">Custom Lookup And Value Passing</a></h2>\n<p>You can supply your own function for value acquisition.</p>\n<ul>\n<li>Signature: See example.</li>\n<li>Returns: The value for the key from the current state plus the\ncompare value for the operator function.</li>\n</ul>\n<pre><span class=\"c1\"># must return a (key, value) tuple:</span>\n<span class=\"n\">model</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"s1\">'eve'</span><span class=\"p\">:</span> <span class=\"p\">{</span><span class=\"s1\">'last_host'</span><span class=\"p\">:</span> <span class=\"s1\">'somehost'</span><span class=\"p\">}}</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">my_lu</span><span class=\"p\">(</span><span class=\"n\">k</span><span class=\"p\">,</span> <span class=\"n\">v</span><span class=\"p\">,</span> <span class=\"n\">req</span><span class=\"p\">,</span> <span class=\"n\">user</span><span class=\"p\">,</span> <span class=\"n\">model</span><span class=\"o\">=</span><span class=\"n\">model</span><span class=\"p\">):</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">'user check. locals:'</span><span class=\"p\">,</span> <span class=\"nb\">dict</span><span class=\"p\">(</span><span class=\"nb\">locals</span><span class=\"p\">()))</span>\n    <span class=\"k\">return</span> <span class=\"p\">(</span><span class=\"n\">model</span><span class=\"o\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"n\">user</span><span class=\"p\">)</span> <span class=\"ow\">or</span> <span class=\"p\">{})</span><span class=\"o\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"n\">k</span><span class=\"p\">),</span> <span class=\"n\">req</span><span class=\"p\">[</span><span class=\"n\">v</span><span class=\"p\">]</span>\n\n<span class=\"n\">f</span> <span class=\"o\">=</span> <span class=\"n\">pc</span><span class=\"o\">.</span><span class=\"n\">pycond</span><span class=\"p\">(</span><span class=\"s1\">'last_host eq host'</span><span class=\"p\">,</span> <span class=\"n\">lookup</span><span class=\"o\">=</span><span class=\"n\">my_lu</span><span class=\"p\">)</span>\n\n<span class=\"n\">req</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"s1\">'host'</span><span class=\"p\">:</span> <span class=\"s1\">'somehost'</span><span class=\"p\">}</span>\n<span class=\"k\">assert</span> <span class=\"n\">f</span><span class=\"p\">(</span><span class=\"n\">req</span><span class=\"o\">=</span><span class=\"n\">req</span><span class=\"p\">,</span> <span class=\"n\">user</span><span class=\"o\">=</span><span class=\"s1\">'joe'</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"kc\">False</span>\n<span class=\"k\">assert</span> <span class=\"n\">f</span><span class=\"p\">(</span><span class=\"n\">req</span><span class=\"o\">=</span><span class=\"n\">req</span><span class=\"p\">,</span> <span class=\"n\">user</span><span class=\"o\">=</span><span class=\"s1\">'eve'</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"kc\">True</span>\n</pre>\n<p>Output:</p>\n<pre><code>user check. locals: {'k': 'last_host', 'v': 'host', 'req': {'host': 'somehost'}, 'user': 'joe', 'model': {'eve': {'last_host': 'somehost'}}}\nuser check. locals: {'k': 'last_host', 'v': 'host', 'req': {'host': 'somehost'}, 'user': 'eve', 'model': {'eve': {'last_host': 'somehost'}}}\n</code></pre>\n<blockquote>\n<p>as you can see in the example, the state parameter is just a convention\nfor <code>pyconds'</code> [title: default lookup function,fmatch=pycond.py,lmatch:def state_get\nfunction.</p>\n</blockquote>\n<h2><a href=\"#toc13\" rel=\"nofollow\">Lazy Evaluation</a></h2>\n<p>This is avoiding unnecessary calculations in many cases:</p>\n<p>When an evaluation branch contains an \"and\" or \"and_not\" combinator, then\nat runtime we evaluate the first expression - and stop if it is already\nFalse. That way expensive deep branch evaluations are omitted or, when\nthe lookup is done lazy, the values won't be even fetched:</p>\n<pre><span class=\"n\">evaluated</span> <span class=\"o\">=</span> <span class=\"p\">[]</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">myget</span><span class=\"p\">(</span><span class=\"n\">key</span><span class=\"p\">,</span> <span class=\"n\">val</span><span class=\"p\">,</span> <span class=\"n\">cfg</span><span class=\"p\">,</span> <span class=\"n\">state</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kw</span><span class=\"p\">):</span>\n    <span class=\"n\">evaluated</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"n\">key</span><span class=\"p\">)</span>\n    <span class=\"c1\"># lets say we are false - always:</span>\n    <span class=\"k\">return</span> <span class=\"kc\">False</span><span class=\"p\">,</span> <span class=\"kc\">True</span>\n\n<span class=\"n\">f</span> <span class=\"o\">=</span> <span class=\"n\">pc</span><span class=\"o\">.</span><span class=\"n\">pycond</span><span class=\"p\">(</span>\n    <span class=\"s1\">'[a eq b] or foo eq bar and baz eq bar'</span><span class=\"p\">,</span> <span class=\"n\">lookup</span><span class=\"o\">=</span><span class=\"n\">myget</span>\n<span class=\"p\">)</span>\n<span class=\"n\">f</span><span class=\"p\">()</span>\n<span class=\"c1\"># the value for \"baz\" is not even fetched and the whole (possibly</span>\n<span class=\"c1\"># deep) branch after the last and is ignored:</span>\n<span class=\"k\">assert</span> <span class=\"n\">evaluated</span> <span class=\"o\">==</span> <span class=\"p\">[</span><span class=\"s1\">'a'</span><span class=\"p\">,</span> <span class=\"s1\">'foo'</span><span class=\"p\">]</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">evaluated</span><span class=\"p\">)</span>\n</pre>\n<p>Output:</p>\n<pre><code>['a', 'foo']\n</code></pre>\n<h2><a href=\"#toc14\" rel=\"nofollow\">Building Conditions From Text</a></h2>\n<p>Condition functions are created internally from structured expressions -\nbut those are <a href=\"#lazy-dynamic-context-assembly\" rel=\"nofollow\">hard to type</a>,\ninvolving many apostropies.</p>\n<p>The text based condition syntax is intended for situations when end users\ntype them into text boxes directly.</p>\n<h3><a href=\"#toc15\" rel=\"nofollow\">Grammar</a></h3>\n<p>Combine atomic conditions with boolean operators and nesting brackets like:</p>\n<pre><code>[  &lt;atom1&gt; &lt;and|or|and not|...&gt; &lt;atom2&gt; ] &lt;and|or...&gt; [ [ &lt;atom3&gt; ....\n</code></pre>\n<h3><a href=\"#toc16\" rel=\"nofollow\">Atomic Conditions</a></h3>\n<pre><code>[not] &lt;lookup_key&gt; [ [rev] [not] &lt;condition operator (co)&gt; &lt;value&gt; ]\n</code></pre>\n<ul>\n<li>When just <code>lookup_key</code> is given, then <code>co</code> is set to the <code>truthy</code> function:</li>\n</ul>\n<pre><span class=\"k\">def</span> <span class=\"nf\">truthy</span><span class=\"p\">(</span><span class=\"n\">key</span><span class=\"p\">,</span> <span class=\"n\">val</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">):</span>\n    <span class=\"k\">return</span> <span class=\"n\">operatur</span><span class=\"o\">.</span><span class=\"n\">truth</span><span class=\"p\">(</span><span class=\"n\">k</span><span class=\"p\">)</span>\n</pre>\n<p>so such an expression is valid and True:</p>\n<pre><span class=\"n\">pc</span><span class=\"o\">.</span><span class=\"n\">State</span><span class=\"o\">.</span><span class=\"n\">update</span><span class=\"p\">({</span><span class=\"s1\">'foo'</span><span class=\"p\">:</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"s1\">'bar'</span><span class=\"p\">:</span> <span class=\"s1\">'a'</span><span class=\"p\">,</span> <span class=\"s1\">'baz'</span><span class=\"p\">:</span> <span class=\"p\">[]})</span>\n<span class=\"k\">assert</span> <span class=\"n\">pc</span><span class=\"o\">.</span><span class=\"n\">pycond</span><span class=\"p\">(</span><span class=\"s1\">'[ foo and bar and not baz]'</span><span class=\"p\">)()</span> <span class=\"o\">==</span> <span class=\"kc\">True</span>\n</pre>\n<ul>\n<li>When <code>not lookup_key</code> is given, then <code>co</code> is set to the <code>falsy</code>\nfunction:</li>\n</ul>\n<pre><span class=\"n\">m</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"s1\">'x'</span><span class=\"p\">:</span> <span class=\"s1\">'y'</span><span class=\"p\">,</span> <span class=\"s1\">'falsy_val'</span><span class=\"p\">:</span> <span class=\"p\">{}}</span>\n<span class=\"c1\"># normal way</span>\n<span class=\"k\">assert</span> <span class=\"n\">pc</span><span class=\"o\">.</span><span class=\"n\">pycond</span><span class=\"p\">([</span><span class=\"s1\">'foo'</span><span class=\"p\">,</span> <span class=\"s1\">'eq'</span><span class=\"p\">,</span> <span class=\"kc\">None</span><span class=\"p\">])(</span><span class=\"n\">state</span><span class=\"o\">=</span><span class=\"n\">m</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"kc\">True</span>\n<span class=\"c1\"># using \"not\" as prefix:</span>\n<span class=\"k\">assert</span> <span class=\"n\">pc</span><span class=\"o\">.</span><span class=\"n\">pycond</span><span class=\"p\">(</span><span class=\"s1\">'not foo'</span><span class=\"p\">)(</span><span class=\"n\">state</span><span class=\"o\">=</span><span class=\"n\">m</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"kc\">True</span>\n<span class=\"k\">assert</span> <span class=\"n\">pc</span><span class=\"o\">.</span><span class=\"n\">pycond</span><span class=\"p\">([</span><span class=\"s1\">'not'</span><span class=\"p\">,</span> <span class=\"s1\">'foo'</span><span class=\"p\">])(</span><span class=\"n\">state</span><span class=\"o\">=</span><span class=\"n\">m</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"kc\">True</span>\n<span class=\"k\">assert</span> <span class=\"n\">pc</span><span class=\"o\">.</span><span class=\"n\">pycond</span><span class=\"p\">(</span><span class=\"s1\">'not falsy_val'</span><span class=\"p\">)(</span><span class=\"n\">state</span><span class=\"o\">=</span><span class=\"n\">m</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"kc\">True</span>\n<span class=\"k\">assert</span> <span class=\"n\">pc</span><span class=\"o\">.</span><span class=\"n\">pycond</span><span class=\"p\">(</span><span class=\"s1\">'x and not foo'</span><span class=\"p\">)(</span><span class=\"n\">state</span><span class=\"o\">=</span><span class=\"n\">m</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"kc\">True</span>\n<span class=\"k\">assert</span> <span class=\"n\">pc</span><span class=\"o\">.</span><span class=\"n\">pycond</span><span class=\"p\">(</span><span class=\"s1\">'y and not falsy_val'</span><span class=\"p\">)(</span><span class=\"n\">state</span><span class=\"o\">=</span><span class=\"n\">m</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"kc\">False</span>\n</pre>\n<h2><a href=\"#toc17\" rel=\"nofollow\">Condition Operators</a></h2>\n<p>All boolean <a href=\"https://docs.python.org/2/library/operator.html\" rel=\"nofollow\">standardlib operators</a>\nare available by default:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">pytest2md</span> <span class=\"kn\">import</span> <span class=\"n\">html_table</span> <span class=\"k\">as</span> <span class=\"n\">tbl</span>  <span class=\"c1\"># just a table gen.</span>\n<span class=\"kn\">from</span> <span class=\"nn\">pycond</span> <span class=\"kn\">import</span> <span class=\"n\">get_ops</span>\n\n<span class=\"k\">for</span> <span class=\"n\">k</span> <span class=\"ow\">in</span> <span class=\"s1\">'nr'</span><span class=\"p\">,</span> <span class=\"s1\">'str'</span><span class=\"p\">:</span>\n    <span class=\"n\">s</span> <span class=\"o\">=</span> <span class=\"s1\">'Default supported '</span> <span class=\"o\">+</span> <span class=\"n\">k</span> <span class=\"o\">+</span> <span class=\"s1\">' operators...(click to extend)'</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">tbl</span><span class=\"p\">(</span><span class=\"n\">get_ops</span><span class=\"p\">()[</span><span class=\"n\">k</span><span class=\"p\">],</span> <span class=\"p\">[</span><span class=\"n\">k</span> <span class=\"o\">+</span> <span class=\"s1\">' operator'</span><span class=\"p\">,</span> <span class=\"s1\">'alias'</span><span class=\"p\">],</span> <span class=\"n\">summary</span><span class=\"o\">=</span><span class=\"n\">s</span><span class=\"p\">))</span>\n</pre>\n<details>\n        <summary>Default supported nr operators...(click to extend)</summary>\n        <table>\n<tr><td>nr operator</td><td>alias</td></tr>\n<tr><td>add</td><td>+</td></tr>\n<tr><td>and_</td><td>&amp;</td></tr>\n<tr><td>eq</td><td>==</td></tr>\n<tr><td>floordiv</td><td>//</td></tr>\n<tr><td>ge</td><td>&gt;=</td></tr>\n<tr><td>gt</td><td>&gt;</td></tr>\n<tr><td>iadd</td><td>+=</td></tr>\n<tr><td>iand</td><td>&amp;=</td></tr>\n<tr><td>ifloordiv</td><td>//=</td></tr>\n<tr><td>ilshift</td><td>&lt;&lt;=</td></tr>\n<tr><td>imod</td><td>%=</td></tr>\n<tr><td>imul</td><td>*=</td></tr>\n<tr><td>ior</td><td>|=</td></tr>\n<tr><td>ipow</td><td>**=</td></tr>\n<tr><td>irshift</td><td>&gt;&gt;=</td></tr>\n<tr><td>is_</td><td>is</td></tr>\n<tr><td>is_not</td><td>is</td></tr>\n<tr><td>isub</td><td>-=</td></tr>\n<tr><td>itruediv</td><td>/=</td></tr>\n<tr><td>ixor</td><td>^=</td></tr>\n<tr><td>le</td><td>&lt;=</td></tr>\n<tr><td>lshift</td><td>&lt;&lt;</td></tr>\n<tr><td>lt</td><td>&lt;</td></tr>\n<tr><td>mod</td><td>%</td></tr>\n<tr><td>mul</td><td>*</td></tr>\n<tr><td>ne</td><td>!=</td></tr>\n<tr><td>or_</td><td>|</td></tr>\n<tr><td>pow</td><td>**</td></tr>\n<tr><td>rshift</td><td>&gt;&gt;</td></tr>\n<tr><td>sub</td><td>-</td></tr>\n<tr><td>truediv</td><td>/</td></tr>\n<tr><td>xor</td><td>^</td></tr>\n<tr><td>itemgetter</td><td></td></tr>\n<tr><td>length_hint</td><td></td></tr>\n</table>\n        </details>\n<details>\n        <summary>Default supported str operators...(click to extend)</summary>\n        <table>\n<tr><td>str operator</td><td>alias</td></tr>\n<tr><td>attrgetter</td><td></td></tr>\n<tr><td>concat</td><td>+</td></tr>\n<tr><td>contains</td><td></td></tr>\n<tr><td>countOf</td><td></td></tr>\n<tr><td>iconcat</td><td>+=</td></tr>\n<tr><td>indexOf</td><td></td></tr>\n<tr><td>methodcaller</td><td></td></tr>\n</table>\n        </details>\n<h3><a href=\"#toc18\" rel=\"nofollow\">Using Symbolic Operators</a></h3>\n<p>By default pycond uses text style operators.</p>\n<ul>\n<li><code>ops_use_symbolic</code> switches processwide to symbolic style only.</li>\n<li><code>ops_use_symbolic_and_txt</code> switches processwide to both notations allowed.</li>\n</ul>\n<pre><span class=\"n\">pc</span><span class=\"o\">.</span><span class=\"n\">ops_use_symbolic</span><span class=\"p\">()</span>\n<span class=\"n\">pc</span><span class=\"o\">.</span><span class=\"n\">State</span><span class=\"p\">[</span><span class=\"s1\">'foo'</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"s1\">'bar'</span>\n<span class=\"k\">assert</span> <span class=\"n\">pc</span><span class=\"o\">.</span><span class=\"n\">pycond</span><span class=\"p\">(</span><span class=\"s1\">'foo == bar'</span><span class=\"p\">)()</span> <span class=\"o\">==</span> <span class=\"kc\">True</span>\n<span class=\"k\">try</span><span class=\"p\">:</span>\n    <span class=\"c1\"># this raises now, text ops not known anymore:</span>\n    <span class=\"n\">pc</span><span class=\"o\">.</span><span class=\"n\">pycond</span><span class=\"p\">(</span><span class=\"s1\">'foo eq bar'</span><span class=\"p\">)</span>\n<span class=\"k\">except</span><span class=\"p\">:</span>\n    <span class=\"n\">pc</span><span class=\"o\">.</span><span class=\"n\">ops_use_symbolic_and_txt</span><span class=\"p\">(</span><span class=\"n\">allow_single_eq</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n    <span class=\"k\">assert</span> <span class=\"n\">pc</span><span class=\"o\">.</span><span class=\"n\">pycond</span><span class=\"p\">(</span><span class=\"s1\">'foo = bar'</span><span class=\"p\">)()</span> <span class=\"o\">==</span> <span class=\"kc\">True</span>\n    <span class=\"k\">assert</span> <span class=\"n\">pc</span><span class=\"o\">.</span><span class=\"n\">pycond</span><span class=\"p\">(</span><span class=\"s1\">'foo == bar'</span><span class=\"p\">)()</span> <span class=\"o\">==</span> <span class=\"kc\">True</span>\n    <span class=\"k\">assert</span> <span class=\"n\">pc</span><span class=\"o\">.</span><span class=\"n\">pycond</span><span class=\"p\">(</span><span class=\"s1\">'foo eq bar'</span><span class=\"p\">)()</span> <span class=\"o\">==</span> <span class=\"kc\">True</span>\n    <span class=\"k\">assert</span> <span class=\"n\">pc</span><span class=\"o\">.</span><span class=\"n\">pycond</span><span class=\"p\">(</span><span class=\"s1\">'foo != baz'</span><span class=\"p\">)()</span> <span class=\"o\">==</span> <span class=\"kc\">True</span>\n</pre>\n<blockquote>\n<p>Operator namespace(s) should be assigned at process start, they are global.</p>\n</blockquote>\n<h3><a href=\"#toc19\" rel=\"nofollow\">Extending Condition Operators</a></h3>\n<pre><span class=\"n\">pc</span><span class=\"o\">.</span><span class=\"n\">OPS</span><span class=\"p\">[</span><span class=\"s1\">'maybe'</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"k\">lambda</span> <span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">b</span><span class=\"p\">:</span> <span class=\"nb\">int</span><span class=\"p\">(</span><span class=\"n\">time</span><span class=\"o\">.</span><span class=\"n\">time</span><span class=\"p\">())</span> <span class=\"o\">%</span> <span class=\"mi\">2</span>\n<span class=\"c1\"># valid expression now:</span>\n<span class=\"k\">assert</span> <span class=\"n\">pc</span><span class=\"o\">.</span><span class=\"n\">pycond</span><span class=\"p\">(</span><span class=\"s1\">'a maybe b'</span><span class=\"p\">)()</span> <span class=\"ow\">in</span> <span class=\"p\">(</span><span class=\"kc\">True</span><span class=\"p\">,</span> <span class=\"kc\">False</span><span class=\"p\">)</span>\n</pre>\n<h3><a href=\"#toc20\" rel=\"nofollow\">Negation <code>not</code></a></h3>\n<p>Negates the result of the condition operator:</p>\n<pre><span class=\"n\">pc</span><span class=\"o\">.</span><span class=\"n\">State</span><span class=\"p\">[</span><span class=\"s1\">'foo'</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"s1\">'abc'</span>\n<span class=\"k\">assert</span> <span class=\"n\">pc</span><span class=\"o\">.</span><span class=\"n\">pycond</span><span class=\"p\">(</span><span class=\"s1\">'foo eq abc'</span><span class=\"p\">)()</span> <span class=\"o\">==</span> <span class=\"kc\">True</span>\n<span class=\"k\">assert</span> <span class=\"n\">pc</span><span class=\"o\">.</span><span class=\"n\">pycond</span><span class=\"p\">(</span><span class=\"s1\">'foo not eq abc'</span><span class=\"p\">)()</span> <span class=\"o\">==</span> <span class=\"kc\">False</span>\n</pre>\n<h3><a href=\"#toc21\" rel=\"nofollow\">Reversal <code>rev</code></a></h3>\n<p>Reverses the arguments before calling the operator</p>\n<pre><span class=\"n\">pc</span><span class=\"o\">.</span><span class=\"n\">State</span><span class=\"p\">[</span><span class=\"s1\">'foo'</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"s1\">'abc'</span>\n<span class=\"k\">assert</span> <span class=\"n\">pc</span><span class=\"o\">.</span><span class=\"n\">pycond</span><span class=\"p\">(</span><span class=\"s1\">'foo contains a'</span><span class=\"p\">)()</span> <span class=\"o\">==</span> <span class=\"kc\">True</span>\n<span class=\"k\">assert</span> <span class=\"n\">pc</span><span class=\"o\">.</span><span class=\"n\">pycond</span><span class=\"p\">(</span><span class=\"s1\">'foo rev contains abc'</span><span class=\"p\">)()</span> <span class=\"o\">==</span> <span class=\"kc\">True</span>\n</pre>\n<blockquote>\n<p><code>rev</code> and <code>not</code> can be combined in any order.</p>\n</blockquote>\n<h3><a href=\"#toc22\" rel=\"nofollow\">Wrapping Condition Operators</a></h3>\n<h4><a href=\"#toc23\" rel=\"nofollow\">Global Wrapping</a></h4>\n<p>You may globally wrap all evaluation time condition operations through a custom function:</p>\n<pre><span class=\"n\">l</span> <span class=\"o\">=</span> <span class=\"p\">[]</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">hk</span><span class=\"p\">(</span><span class=\"n\">f_op</span><span class=\"p\">,</span> <span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">b</span><span class=\"p\">,</span> <span class=\"n\">l</span><span class=\"o\">=</span><span class=\"n\">l</span><span class=\"p\">):</span>\n    <span class=\"n\">l</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">((</span><span class=\"nb\">getattr</span><span class=\"p\">(</span><span class=\"n\">f_op</span><span class=\"p\">,</span> <span class=\"s1\">'__name__'</span><span class=\"p\">,</span> <span class=\"s1\">''</span><span class=\"p\">),</span> <span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">b</span><span class=\"p\">))</span>\n    <span class=\"k\">return</span> <span class=\"n\">f_op</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">b</span><span class=\"p\">)</span>\n\n<span class=\"n\">pc</span><span class=\"o\">.</span><span class=\"n\">run_all_ops_thru</span><span class=\"p\">(</span><span class=\"n\">hk</span><span class=\"p\">)</span>  <span class=\"c1\"># globally wrap the operators</span>\n\n<span class=\"n\">pc</span><span class=\"o\">.</span><span class=\"n\">State</span><span class=\"o\">.</span><span class=\"n\">update</span><span class=\"p\">({</span><span class=\"s1\">'a'</span><span class=\"p\">:</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"s1\">'b'</span><span class=\"p\">:</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"s1\">'c'</span><span class=\"p\">:</span> <span class=\"mi\">3</span><span class=\"p\">})</span>\n<span class=\"n\">f</span> <span class=\"o\">=</span> <span class=\"n\">pc</span><span class=\"o\">.</span><span class=\"n\">pycond</span><span class=\"p\">(</span><span class=\"s1\">'a gt 0 and b lt 3 and not c gt 4'</span><span class=\"p\">)</span>\n<span class=\"k\">assert</span> <span class=\"n\">l</span> <span class=\"o\">==</span> <span class=\"p\">[]</span>\n<span class=\"n\">f</span><span class=\"p\">()</span>\n<span class=\"n\">expected_log</span> <span class=\"o\">=</span> <span class=\"p\">[(</span><span class=\"s1\">'gt'</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mf\">0.0</span><span class=\"p\">),</span> <span class=\"p\">(</span><span class=\"s1\">'lt'</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mf\">3.0</span><span class=\"p\">),</span> <span class=\"p\">(</span><span class=\"s1\">'gt'</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mf\">4.0</span><span class=\"p\">)]</span>\n<span class=\"k\">assert</span> <span class=\"n\">l</span> <span class=\"o\">==</span> <span class=\"n\">expected_log</span>\n<span class=\"n\">pc</span><span class=\"o\">.</span><span class=\"n\">ops_use_symbolic_and_txt</span><span class=\"p\">()</span>\n</pre>\n<p>You may compose such wrappers via repeated application of the <code>run_all_ops_thru</code> API function.</p>\n<h4><a href=\"#toc24\" rel=\"nofollow\">Condition Local Wrapping</a></h4>\n<p>This is done through the <code>ops_thru</code> parameter as shown:</p>\n<pre><span class=\"k\">def</span> <span class=\"nf\">myhk</span><span class=\"p\">(</span><span class=\"n\">f_op</span><span class=\"p\">,</span> <span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">b</span><span class=\"p\">):</span>\n    <span class=\"k\">return</span> <span class=\"kc\">True</span>\n\n<span class=\"n\">pc</span><span class=\"o\">.</span><span class=\"n\">State</span><span class=\"p\">[</span><span class=\"s1\">'a'</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>\n<span class=\"n\">f</span> <span class=\"o\">=</span> <span class=\"n\">pc</span><span class=\"o\">.</span><span class=\"n\">pycond</span><span class=\"p\">(</span><span class=\"s1\">'a eq 2'</span><span class=\"p\">)</span>\n<span class=\"k\">assert</span> <span class=\"n\">f</span><span class=\"p\">()</span> <span class=\"o\">==</span> <span class=\"kc\">False</span>\n<span class=\"n\">f</span> <span class=\"o\">=</span> <span class=\"n\">pc</span><span class=\"o\">.</span><span class=\"n\">pycond</span><span class=\"p\">(</span><span class=\"s1\">'a eq 2'</span><span class=\"p\">,</span> <span class=\"n\">ops_thru</span><span class=\"o\">=</span><span class=\"n\">myhk</span><span class=\"p\">)</span>\n<span class=\"k\">assert</span> <span class=\"n\">f</span><span class=\"p\">()</span> <span class=\"o\">==</span> <span class=\"kc\">True</span>\n</pre>\n<blockquote>\n<p>Using <code>ops_thru</code> is a good way to debug unexpected results, since you\ncan add breakpoints or loggers there.</p>\n</blockquote>\n<h2><a href=\"#toc25\" rel=\"nofollow\">Combining Operations</a></h2>\n<p>You can combine single conditions with</p>\n<ul>\n<li><code>and</code></li>\n<li><code>and not</code></li>\n<li><code>or</code></li>\n<li><code>or not</code></li>\n<li><code>xor</code> by default.</li>\n</ul>\n<p>The combining functions are stored in <code>pycond.COMB_OPS</code> dict and may be extended.</p>\n<blockquote>\n<p>Do not use spaces for the names of combining operators. The user may use them but they are replaced at before tokenizing time, like <code>and not</code> -&gt; <code>and_not</code>.</p>\n</blockquote>\n<h3><a href=\"#toc26\" rel=\"nofollow\">Nesting</a></h3>\n<p>Combined conditions may be arbitrarily nested using brackets \"[\" and \"]\".</p>\n<blockquote>\n<p>Via the <code>brkts</code> config parameter you may change those to other separators at build time.</p>\n</blockquote>\n<h2><a href=\"#toc27\" rel=\"nofollow\">Tokenizing Details</a></h2>\n<blockquote>\n<p>Brackets as strings in this flat list form, e.g. <code>['[', 'a', 'and' 'b', ']'...]</code></p>\n</blockquote>\n<h3><a href=\"#toc28\" rel=\"nofollow\">Functioning</a></h3>\n<p>The tokenizers job is to take apart expression strings for the builder.</p>\n<h3><a href=\"#toc29\" rel=\"nofollow\">Separator <code>sep</code></a></h3>\n<p>Separates the different parts of an expression. Default is ' '.</p>\n<pre><span class=\"n\">pc</span><span class=\"o\">.</span><span class=\"n\">State</span><span class=\"p\">[</span><span class=\"s1\">'a'</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mi\">42</span>\n<span class=\"k\">assert</span> <span class=\"n\">pc</span><span class=\"o\">.</span><span class=\"n\">pycond</span><span class=\"p\">(</span><span class=\"s1\">'a.eq.42'</span><span class=\"p\">,</span> <span class=\"n\">sep</span><span class=\"o\">=</span><span class=\"s1\">'.'</span><span class=\"p\">)()</span> <span class=\"o\">==</span> <span class=\"kc\">True</span>\n</pre>\n<blockquote>\n<p>sep can be a any single character including binary.</p>\n</blockquote>\n<p>Bracket characters do not need to be separated, the tokenizer will do:</p>\n<pre><span class=\"c1\"># equal:</span>\n<span class=\"k\">assert</span> <span class=\"p\">(</span>\n    <span class=\"n\">pc</span><span class=\"o\">.</span><span class=\"n\">pycond</span><span class=\"p\">(</span><span class=\"s1\">'[[a eq 42] and b]'</span><span class=\"p\">)()</span>\n    <span class=\"o\">==</span> <span class=\"n\">pc</span><span class=\"o\">.</span><span class=\"n\">pycond</span><span class=\"p\">(</span><span class=\"s1\">'[ [ a eq 42 ] and b ]'</span><span class=\"p\">)()</span>\n<span class=\"p\">)</span>\n</pre>\n<blockquote>\n<p>The condition functions themselves do not evaluate equal - those\nhad been assembled two times.</p>\n</blockquote>\n<h3><a href=\"#toc30\" rel=\"nofollow\">Apostrophes</a></h3>\n<p>By putting strings into Apostrophes you can tell the tokenizer to not further inspect them, e.g. for the seperator:</p>\n<pre><span class=\"n\">pc</span><span class=\"o\">.</span><span class=\"n\">State</span><span class=\"p\">[</span><span class=\"s1\">'a'</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"s1\">'Hello World'</span>\n<span class=\"k\">assert</span> <span class=\"n\">pc</span><span class=\"o\">.</span><span class=\"n\">pycond</span><span class=\"p\">(</span><span class=\"s1\">'a eq \"Hello World\"'</span><span class=\"p\">)()</span> <span class=\"o\">==</span> <span class=\"kc\">True</span>\n</pre>\n<h3><a href=\"#toc31\" rel=\"nofollow\">Escaping</a></h3>\n<p>Tell the tokenizer to not interpret the next character:</p>\n<pre><span class=\"n\">pc</span><span class=\"o\">.</span><span class=\"n\">State</span><span class=\"p\">[</span><span class=\"s1\">'b'</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"s1\">'Hello World'</span>\n<span class=\"k\">assert</span> <span class=\"n\">pc</span><span class=\"o\">.</span><span class=\"n\">pycond</span><span class=\"p\">(</span><span class=\"s1\">'b eq Hello\\ World'</span><span class=\"p\">)()</span> <span class=\"o\">==</span> <span class=\"kc\">True</span>\n</pre>\n<h3><a href=\"#toc32\" rel=\"nofollow\">Building</a></h3>\n<h3><a href=\"#toc33\" rel=\"nofollow\">Autoconv: Casting of values into python simple types</a></h3>\n<p>Expression string values are automatically cast into bools and numbers via the public <code>pycond.py_type</code> function.</p>\n<p>This can be prevented by setting the <code>autoconv</code> parameter to <code>False</code> or by using Apostrophes:</p>\n<pre><span class=\"n\">pc</span><span class=\"o\">.</span><span class=\"n\">State</span><span class=\"p\">[</span><span class=\"s1\">'a'</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"s1\">'42'</span>\n<span class=\"k\">assert</span> <span class=\"n\">pc</span><span class=\"o\">.</span><span class=\"n\">pycond</span><span class=\"p\">(</span><span class=\"s1\">'a eq 42'</span><span class=\"p\">)()</span> <span class=\"o\">==</span> <span class=\"kc\">False</span>\n<span class=\"c1\"># compared as string now</span>\n<span class=\"k\">assert</span> <span class=\"n\">pc</span><span class=\"o\">.</span><span class=\"n\">pycond</span><span class=\"p\">(</span><span class=\"s1\">'a eq \"42\"'</span><span class=\"p\">)()</span> <span class=\"o\">==</span> <span class=\"kc\">True</span>\n<span class=\"c1\"># compared as string now</span>\n<span class=\"k\">assert</span> <span class=\"n\">pc</span><span class=\"o\">.</span><span class=\"n\">pycond</span><span class=\"p\">(</span><span class=\"s1\">'a eq 42'</span><span class=\"p\">,</span> <span class=\"n\">autoconv</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">)()</span> <span class=\"o\">==</span> <span class=\"kc\">True</span>\n</pre>\n<p>If you do not want to provide a custom lookup function (where you can do what you want)\nbut want to have looked up keys autoconverted then use:</p>\n<pre><span class=\"k\">for</span> <span class=\"nb\">id</span> <span class=\"ow\">in</span> <span class=\"s1\">'1'</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">:</span>\n    <span class=\"n\">pc</span><span class=\"o\">.</span><span class=\"n\">State</span><span class=\"p\">[</span><span class=\"s1\">'id'</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"nb\">id</span>\n    <span class=\"k\">assert</span> <span class=\"n\">pc</span><span class=\"o\">.</span><span class=\"n\">pycond</span><span class=\"p\">(</span><span class=\"s1\">'id lt 42'</span><span class=\"p\">,</span> <span class=\"n\">autoconv_lookups</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n</pre>\n<h1><a href=\"#toc34\" rel=\"nofollow\">Context On Demand And Lazy Evaluation</a></h1>\n<p>Often the conditions are in user space, applied on data streams under\nthe developer's control only at development time.</p>\n<p>The end user might pick only a few keys from many offered within an API.</p>\n<p>pycond's <code>ctx_builder</code> allows to only calculate those keys at runtime,\nthe user decided to base conditions upon:\nAt condition build time hand over a namespace for <em>all</em> functions which\nare available to build the ctx.</p>\n<p><code>pycon</code> will return a context builder function for you, calling only those functions\nwhich the condition actually requires.</p>\n<pre><span class=\"n\">pc</span><span class=\"o\">.</span><span class=\"n\">ops_use_symbolic_and_txt</span><span class=\"p\">(</span><span class=\"n\">allow_single_eq</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Condition the end user configured, e.g. at program run time:</span>\n<span class=\"n\">cond</span> <span class=\"o\">=</span> <span class=\"p\">[</span>\n    <span class=\"p\">[</span><span class=\"s1\">'group_type'</span><span class=\"p\">,</span> <span class=\"s1\">'in'</span><span class=\"p\">,</span> <span class=\"p\">[</span><span class=\"s1\">'lab'</span><span class=\"p\">,</span> <span class=\"s1\">'first1k'</span><span class=\"p\">,</span> <span class=\"s1\">'friendly'</span><span class=\"p\">,</span> <span class=\"s1\">'auto'</span><span class=\"p\">]],</span>\n    <span class=\"s1\">'and'</span><span class=\"p\">,</span>\n    <span class=\"p\">[</span>\n        <span class=\"p\">[</span>\n            <span class=\"p\">[</span>\n                <span class=\"p\">[</span>\n                    <span class=\"p\">[</span><span class=\"s1\">'cur_q'</span><span class=\"p\">,</span> <span class=\"s1\">'&lt;'</span><span class=\"p\">,</span> <span class=\"mf\">0.5</span><span class=\"p\">],</span>\n                    <span class=\"s1\">'and'</span><span class=\"p\">,</span>\n                    <span class=\"p\">[</span><span class=\"s1\">'delta_q'</span><span class=\"p\">,</span> <span class=\"s1\">'&gt;='</span><span class=\"p\">,</span> <span class=\"mf\">0.15</span><span class=\"p\">],</span>\n                <span class=\"p\">],</span>\n                <span class=\"s1\">'and'</span><span class=\"p\">,</span>\n                <span class=\"p\">[</span><span class=\"s1\">'dt_last_enforce'</span><span class=\"p\">,</span> <span class=\"s1\">'&gt;'</span><span class=\"p\">,</span> <span class=\"mi\">28800</span><span class=\"p\">],</span>\n            <span class=\"p\">],</span>\n            <span class=\"s1\">'and'</span><span class=\"p\">,</span>\n            <span class=\"p\">[</span><span class=\"s1\">'cur_hour'</span><span class=\"p\">,</span> <span class=\"s1\">'in'</span><span class=\"p\">,</span> <span class=\"p\">[</span><span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">]],</span>\n        <span class=\"p\">],</span>\n        <span class=\"s1\">'or'</span><span class=\"p\">,</span>\n        <span class=\"p\">[</span>\n            <span class=\"p\">[</span>\n                <span class=\"p\">[</span>\n                    <span class=\"p\">[</span><span class=\"s1\">'cur_q'</span><span class=\"p\">,</span> <span class=\"s1\">'&lt;'</span><span class=\"p\">,</span> <span class=\"mf\">0.5</span><span class=\"p\">],</span>\n                    <span class=\"s1\">'and'</span><span class=\"p\">,</span>\n                    <span class=\"p\">[</span><span class=\"s1\">'delta_q'</span><span class=\"p\">,</span> <span class=\"s1\">'&gt;='</span><span class=\"p\">,</span> <span class=\"mf\">0.15</span><span class=\"p\">],</span>\n                <span class=\"p\">],</span>\n                <span class=\"s1\">'and'</span><span class=\"p\">,</span>\n                <span class=\"p\">[</span><span class=\"s1\">'dt_last_enforce'</span><span class=\"p\">,</span> <span class=\"s1\">'&gt;'</span><span class=\"p\">,</span> <span class=\"mi\">28800</span><span class=\"p\">],</span>\n            <span class=\"p\">],</span>\n            <span class=\"s1\">'and'</span><span class=\"p\">,</span>\n            <span class=\"p\">[</span><span class=\"s1\">'clients'</span><span class=\"p\">,</span> <span class=\"s1\">'='</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">],</span>\n        <span class=\"p\">],</span>\n    <span class=\"p\">],</span>\n<span class=\"p\">]</span>\n\n<span class=\"c1\"># Getters for API keys offered to the user, involving potentially</span>\n<span class=\"c1\"># expensive to fetch context delivery functions:</span>\n<span class=\"c1\"># Signature must provide minimum a positional for the current</span>\n<span class=\"c1\"># state:</span>\n<span class=\"k\">class</span> <span class=\"nc\">ApiCtxFuncs</span><span class=\"p\">:</span>\n    <span class=\"k\">def</span> <span class=\"nf\">expensive_but_not_needed_here</span><span class=\"p\">(</span><span class=\"n\">ctx</span><span class=\"p\">):</span>\n        <span class=\"k\">raise</span> <span class=\"ne\">Exception</span><span class=\"p\">(</span><span class=\"s2\">\"Won't run with cond. from above\"</span><span class=\"p\">)</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">group_type</span><span class=\"p\">(</span><span class=\"n\">ctx</span><span class=\"p\">):</span>\n        <span class=\"k\">raise</span> <span class=\"ne\">Exception</span><span class=\"p\">(</span>\n            <span class=\"s2\">\"Won't run since contained in example data\"</span>\n        <span class=\"p\">)</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">cur_q</span><span class=\"p\">(</span><span class=\"n\">ctx</span><span class=\"p\">):</span>\n        <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">'Calculating cur_q'</span><span class=\"p\">)</span>\n        <span class=\"k\">return</span> <span class=\"mf\">0.1</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">cur_hour</span><span class=\"p\">(</span><span class=\"n\">ctx</span><span class=\"p\">):</span>\n        <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">'Calculating cur_hour'</span><span class=\"p\">)</span>\n        <span class=\"k\">return</span> <span class=\"mi\">4</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">dt_last_enforce</span><span class=\"p\">(</span><span class=\"n\">ctx</span><span class=\"p\">):</span>\n        <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">'Calculating dt_last_enforce'</span><span class=\"p\">)</span>\n        <span class=\"k\">return</span> <span class=\"mi\">10000000</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">delta_q</span><span class=\"p\">(</span><span class=\"n\">ctx</span><span class=\"p\">):</span>\n        <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">'Calculating (expensive) delta_q'</span><span class=\"p\">)</span>\n        <span class=\"n\">time</span><span class=\"o\">.</span><span class=\"n\">sleep</span><span class=\"p\">(</span><span class=\"mf\">0.1</span><span class=\"p\">)</span>\n        <span class=\"k\">return</span> <span class=\"mi\">1</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">clients</span><span class=\"p\">(</span><span class=\"n\">ctx</span><span class=\"p\">):</span>\n        <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">'Calculating clients'</span><span class=\"p\">)</span>\n        <span class=\"k\">return</span> <span class=\"mi\">0</span>\n\n<span class=\"k\">if</span> <span class=\"n\">sys</span><span class=\"o\">.</span><span class=\"n\">version_info</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">&lt;</span> <span class=\"mi\">3</span><span class=\"p\">:</span>\n    <span class=\"c1\"># we don't think it is a good idea to make the getter API stateful:</span>\n    <span class=\"n\">p2m</span><span class=\"o\">.</span><span class=\"n\">convert_to_staticmethods</span><span class=\"p\">(</span><span class=\"n\">ApiCtxFuncs</span><span class=\"p\">)</span>\n\n<span class=\"n\">f</span><span class=\"p\">,</span> <span class=\"n\">nfos</span> <span class=\"o\">=</span> <span class=\"n\">pc</span><span class=\"o\">.</span><span class=\"n\">parse_cond</span><span class=\"p\">(</span><span class=\"n\">cond</span><span class=\"p\">,</span> <span class=\"n\">ctx_provider</span><span class=\"o\">=</span><span class=\"n\">ApiCtxFuncs</span><span class=\"p\">)</span>\n<span class=\"c1\"># this key stores the context builder function</span>\n<span class=\"n\">make_ctx</span> <span class=\"o\">=</span> <span class=\"n\">nfos</span><span class=\"p\">[</span><span class=\"s1\">'complete_ctx'</span><span class=\"p\">]</span>\n\n<span class=\"c1\"># now we get (incomplete) data..</span>\n<span class=\"n\">data1</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"s1\">'group_type'</span><span class=\"p\">:</span> <span class=\"s1\">'xxx'</span><span class=\"p\">},</span> <span class=\"kc\">False</span>\n<span class=\"n\">data2</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"s1\">'group_type'</span><span class=\"p\">:</span> <span class=\"s1\">'lab'</span><span class=\"p\">},</span> <span class=\"kc\">True</span>\n\n<span class=\"n\">t0</span> <span class=\"o\">=</span> <span class=\"n\">time</span><span class=\"o\">.</span><span class=\"n\">time</span><span class=\"p\">()</span>\n<span class=\"k\">for</span> <span class=\"n\">event</span><span class=\"p\">,</span> <span class=\"n\">expected</span> <span class=\"ow\">in</span> <span class=\"n\">data1</span><span class=\"p\">,</span> <span class=\"n\">data2</span><span class=\"p\">:</span>\n    <span class=\"k\">assert</span> <span class=\"n\">pc</span><span class=\"o\">.</span><span class=\"n\">pycond</span><span class=\"p\">(</span><span class=\"n\">cond</span><span class=\"p\">)(</span><span class=\"n\">state</span><span class=\"o\">=</span><span class=\"n\">make_ctx</span><span class=\"p\">(</span><span class=\"n\">event</span><span class=\"p\">))</span> <span class=\"o\">==</span> <span class=\"n\">expected</span>\n\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">'Calc.Time'</span><span class=\"p\">,</span> <span class=\"nb\">round</span><span class=\"p\">(</span><span class=\"n\">time</span><span class=\"o\">.</span><span class=\"n\">time</span><span class=\"p\">()</span> <span class=\"o\">-</span> <span class=\"n\">t0</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">))</span>\n<span class=\"k\">return</span> <span class=\"n\">cond</span><span class=\"p\">,</span> <span class=\"n\">ApiCtxFuncs</span>\n</pre>\n<p>Output:</p>\n<pre><code>Calculating clients\nCalculating cur_hour\nCalculating cur_q\nCalculating (expensive) delta_q\nCalculating dt_last_enforce\nCalculating clients\nCalculating cur_hour\nCalculating cur_q\nCalculating (expensive) delta_q\nCalculating dt_last_enforce\nCalc.Time 0.206\n</code></pre>\n<p>But we can do better - we still calculated values for keys which might be\nonly needed in dead ends of a lazily evaluated condition.</p>\n<p>Lets avoid calculating these values, remembering the\n<a href=\"#custom-lookup-and-value-passing\" rel=\"nofollow\">custom lookup function</a> feature.</p>\n<blockquote>\n<p>pycond does generate such a custom lookup function readily for you,\nif you pass a getter namespace as <code>lookup_provider</code>:</p>\n</blockquote>\n<pre><span class=\"c1\"># we let pycond generate the lookup function now:</span>\n<span class=\"n\">f</span> <span class=\"o\">=</span> <span class=\"n\">pc</span><span class=\"o\">.</span><span class=\"n\">pycond</span><span class=\"p\">(</span><span class=\"n\">cond</span><span class=\"p\">,</span> <span class=\"n\">lookup_provider</span><span class=\"o\">=</span><span class=\"n\">ApiCtxFuncs</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Same events as above:</span>\n<span class=\"n\">data1</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"s1\">'group_type'</span><span class=\"p\">:</span> <span class=\"s1\">'xxx'</span><span class=\"p\">},</span> <span class=\"kc\">False</span>\n<span class=\"n\">data2</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"s1\">'group_type'</span><span class=\"p\">:</span> <span class=\"s1\">'lab'</span><span class=\"p\">},</span> <span class=\"kc\">True</span>\n\n<span class=\"n\">t0</span> <span class=\"o\">=</span> <span class=\"n\">time</span><span class=\"o\">.</span><span class=\"n\">time</span><span class=\"p\">()</span>\n<span class=\"k\">for</span> <span class=\"n\">event</span><span class=\"p\">,</span> <span class=\"n\">expected</span> <span class=\"ow\">in</span> <span class=\"n\">data1</span><span class=\"p\">,</span> <span class=\"n\">data2</span><span class=\"p\">:</span>\n    <span class=\"c1\"># we will lookup only once:</span>\n    <span class=\"k\">assert</span> <span class=\"n\">f</span><span class=\"p\">(</span><span class=\"n\">state</span><span class=\"o\">=</span><span class=\"n\">event</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"n\">expected</span>\n\n<span class=\"nb\">print</span><span class=\"p\">(</span>\n    <span class=\"s1\">'Calc.Time (only one expensive calculation):'</span><span class=\"p\">,</span>\n    <span class=\"nb\">round</span><span class=\"p\">(</span><span class=\"n\">time</span><span class=\"o\">.</span><span class=\"n\">time</span><span class=\"p\">()</span> <span class=\"o\">-</span> <span class=\"n\">t0</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">),</span>\n<span class=\"p\">)</span>\n</pre>\n<p>Output:</p>\n<pre><code>Calculating cur_q\nCalculating (expensive) delta_q\nCalculating dt_last_enforce\nCalculating cur_hour\nCalculating clients\nCalc.Time (only one expensive calculation): 0.1005\n</code></pre>\n<p>The output demonstrates that we did not even call the value provider functions for the dead branches of the condition.</p>\n<p><em>Auto generated by <a href=\"https://github.com/axiros/pytest2md\" rel=\"nofollow\">pytest2md</a>, running <a href=\"https://github.com/axiros/pycond/blob/b5e39519d6da61922a9fd2253f6b0ff49d48e2da/tests/test_tutorial.py\" rel=\"nofollow\">test_tutorial.py</a></em></p>\n\n\n\n          </div>"}, "last_serial": 6679835, "releases": {"190427": [{"comment_text": "", "digests": {"md5": "37d77d934b0bd334af009a6f16c74dc1", "sha256": "b689b5c18b33d684b207ba58c1bb4cb666fd79c613507cf2064741cb55b26c68"}, "downloads": -1, "filename": "pycond-190427-py3-none-any.whl", "has_sig": false, "md5_digest": "37d77d934b0bd334af009a6f16c74dc1", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 15227, "upload_time": "2019-04-22T10:37:41", "upload_time_iso_8601": "2019-04-22T10:37:41.634533Z", "url": "https://files.pythonhosted.org/packages/c5/03/ef787e006dd3d4ee739df17c38684ee4e890c7e1b655c42fa74638e445b0/pycond-190427-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "61d36810919a9b3cb71ad145a62bd8e2", "sha256": "44730eea2af2246a192e16caa95aa0f5d87101adb76b5642eed790db1912763a"}, "downloads": -1, "filename": "pycond-190427.tar.gz", "has_sig": false, "md5_digest": "61d36810919a9b3cb71ad145a62bd8e2", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 20238, "upload_time": "2019-04-22T10:37:43", "upload_time_iso_8601": "2019-04-22T10:37:43.721152Z", "url": "https://files.pythonhosted.org/packages/45/b7/f6ddc9f8f85fec2beeabc5f38f005f383e51f1f5609aacbd9b71073a704a/pycond-190427.tar.gz", "yanked": false}], "190519": [{"comment_text": "", "digests": {"md5": "abf541e8ee70e07d92fe7772b02a3472", "sha256": "012386c54afadaa3cc45cd5d3f2cb40e1c296a4af6e1fe6c63e9ab9e038d6ca5"}, "downloads": -1, "filename": "pycond-190519-py3-none-any.whl", "has_sig": false, "md5_digest": "abf541e8ee70e07d92fe7772b02a3472", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 15754, "upload_time": "2019-05-16T00:20:04", "upload_time_iso_8601": "2019-05-16T00:20:04.543453Z", "url": "https://files.pythonhosted.org/packages/e8/2e/fca2949d8851422d5b3d850f22f684df48cd664ede20e5c960fdc160d4d2/pycond-190519-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "cba1efaf0d79cae3822f359305955294", "sha256": "dfa61829c2e5aaa68138af02b8f4f467cfe732a4b4dd6d62997615cfa4150fc7"}, "downloads": -1, "filename": "pycond-190519.tar.gz", "has_sig": false, "md5_digest": "cba1efaf0d79cae3822f359305955294", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 20906, "upload_time": "2019-05-16T00:20:07", "upload_time_iso_8601": "2019-05-16T00:20:07.999083Z", "url": "https://files.pythonhosted.org/packages/26/46/136fe1b42dcca2129440b0e2bb5218b874dd7feb7d14f8cb74bc87045cbf/pycond-190519.tar.gz", "yanked": false}], "190520": [{"comment_text": "", "digests": {"md5": "7e26fbbe912cbd02cb9177992e6cf7fe", "sha256": "3ec62ff436b4f1c98a3e4098d28bb8663b9704a065cd6be990422fc3bef26fad"}, "downloads": -1, "filename": "pycond-190520-py3-none-any.whl", "has_sig": false, "md5_digest": "7e26fbbe912cbd02cb9177992e6cf7fe", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 15806, "upload_time": "2019-05-16T00:47:49", "upload_time_iso_8601": "2019-05-16T00:47:49.414277Z", "url": "https://files.pythonhosted.org/packages/5f/fc/c715d2e58d85b839ee1028057740843cd99c95ab4b7fa42c24d74ca81f1c/pycond-190520-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "1217816e4e3802e5214e344f6fa3f49a", "sha256": "0b780389a45b2d810557c602f284eacdf1c3b1acb81935183fd4d5b718f79266"}, "downloads": -1, "filename": "pycond-190520.tar.gz", "has_sig": false, "md5_digest": "1217816e4e3802e5214e344f6fa3f49a", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 21041, "upload_time": "2019-05-16T00:47:53", "upload_time_iso_8601": "2019-05-16T00:47:53.738474Z", "url": "https://files.pythonhosted.org/packages/5b/f1/c3b921d8e39a198e21b5167c7852f25ec344514b4685c1d1a600dc2a4966/pycond-190520.tar.gz", "yanked": false}], "190521": [{"comment_text": "", "digests": {"md5": "654a5ffffdbfe684403ca3665309aae9", "sha256": "65578bdf507c5807f822ec50d6e457b72ae3b8e5ce571809ffbc2f3155db9076"}, "downloads": -1, "filename": "pycond-190521-py3-none-any.whl", "has_sig": false, "md5_digest": "654a5ffffdbfe684403ca3665309aae9", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 15806, "upload_time": "2019-05-16T00:50:30", "upload_time_iso_8601": "2019-05-16T00:50:30.242023Z", "url": "https://files.pythonhosted.org/packages/13/ac/6b58addce6592311c75f04571c0b463bea68f5264a34c18caa1920f44e9c/pycond-190521-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "9f14368b424dffa3447dd64cc137fa8d", "sha256": "a1e3206227ce93f48de59c34ed3c54518d6f3f853220067b30e058fac853c8bd"}, "downloads": -1, "filename": "pycond-190521.tar.gz", "has_sig": false, "md5_digest": "9f14368b424dffa3447dd64cc137fa8d", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 21044, "upload_time": "2019-05-16T00:50:32", "upload_time_iso_8601": "2019-05-16T00:50:32.310488Z", "url": "https://files.pythonhosted.org/packages/6b/a2/a89a8b565f3c7469a0eea22d4d45f90f0f7e9260f4f2b962612242fffa05/pycond-190521.tar.gz", "yanked": false}], "190522": [{"comment_text": "", "digests": {"md5": "d05c150f20eb62823483107cac29880a", "sha256": "eb66ccac57dbe95af2690c8b2a74a324189a80a87a5b2e1b7ab7a27478e65d92"}, "downloads": -1, "filename": "pycond-190522-py3-none-any.whl", "has_sig": false, "md5_digest": "d05c150f20eb62823483107cac29880a", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 15862, "upload_time": "2019-05-16T08:41:39", "upload_time_iso_8601": "2019-05-16T08:41:39.087668Z", "url": "https://files.pythonhosted.org/packages/47/45/9ebad489d3fd126442245710fd60d7f75a4de9a2e2028fc57dc65189c35c/pycond-190522-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "f6e6744d8f41c75e0dd2264e82b3f63c", "sha256": "043e65234c72d750a6300b6d759497a23fd2b92b7e12371e940f20b749e00d7f"}, "downloads": -1, "filename": "pycond-190522.tar.gz", "has_sig": false, "md5_digest": "f6e6744d8f41c75e0dd2264e82b3f63c", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 21121, "upload_time": "2019-05-16T08:41:41", "upload_time_iso_8601": "2019-05-16T08:41:41.301831Z", "url": "https://files.pythonhosted.org/packages/a4/64/05c61213eb6941371b1385c5fc1710175bd332b8bae071b53b9e1e46ab19/pycond-190522.tar.gz", "yanked": false}], "190523": [{"comment_text": "", "digests": {"md5": "82948e122b5f1bc62a7a78be5a844d94", "sha256": "8435ff4ac521af6bcc6e9fc64d9b7a2c474c187f6e42af067cd2e7e0dfcbae09"}, "downloads": -1, "filename": "pycond-190523-py3-none-any.whl", "has_sig": false, "md5_digest": "82948e122b5f1bc62a7a78be5a844d94", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 15838, "upload_time": "2019-05-16T08:47:55", "upload_time_iso_8601": "2019-05-16T08:47:55.901855Z", "url": "https://files.pythonhosted.org/packages/f1/2f/c55abd315fdce6393d4cafdd66ad51ac085781537587a311d2343b64262b/pycond-190523-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "9321650bece558992d4d188e7a8ef18c", "sha256": "6e058cf73e8d9b5b8dbf700b99052ab7788f3a2ad859b86bd228e2f163d2d589"}, "downloads": -1, "filename": "pycond-190523.tar.gz", "has_sig": false, "md5_digest": "9321650bece558992d4d188e7a8ef18c", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 21100, "upload_time": "2019-05-16T08:47:57", "upload_time_iso_8601": "2019-05-16T08:47:57.924947Z", "url": "https://files.pythonhosted.org/packages/6d/1a/e9671c0961538a2fa2f616c2033be81055b5f8ab60a7fafdaaf32aa4c958/pycond-190523.tar.gz", "yanked": false}], "200222": [{"comment_text": "", "digests": {"md5": "31e96fb701254a6e8a96d23cc63c1094", "sha256": "e9183491819222ecc95390d843f06de84459da231396a41812e86dd6548015fe"}, "downloads": -1, "filename": "pycond-200222-py3-none-any.whl", "has_sig": false, "md5_digest": "31e96fb701254a6e8a96d23cc63c1094", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 15849, "upload_time": "2020-02-22T07:53:43", "upload_time_iso_8601": "2020-02-22T07:53:43.677945Z", "url": "https://files.pythonhosted.org/packages/9b/ab/00c740c795e0101bae4350a1a28c71241de9e02b2191b54cad9bd081eea9/pycond-200222-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "0aa3d26975b5a8d0eed5622e5ef4e76e", "sha256": "3e42db025f005334f857b698386f96d58c3df71d0b66e74638815eb82fc541b0"}, "downloads": -1, "filename": "pycond-200222.tar.gz", "has_sig": false, "md5_digest": "0aa3d26975b5a8d0eed5622e5ef4e76e", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 21078, "upload_time": "2020-02-22T07:53:45", "upload_time_iso_8601": "2020-02-22T07:53:45.978441Z", "url": "https://files.pythonhosted.org/packages/76/4b/ea365f9d0e434026d54886e6e38f3bed6c2480860cc7b95c691260250de3/pycond-200222.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "31e96fb701254a6e8a96d23cc63c1094", "sha256": "e9183491819222ecc95390d843f06de84459da231396a41812e86dd6548015fe"}, "downloads": -1, "filename": "pycond-200222-py3-none-any.whl", "has_sig": false, "md5_digest": "31e96fb701254a6e8a96d23cc63c1094", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 15849, "upload_time": "2020-02-22T07:53:43", "upload_time_iso_8601": "2020-02-22T07:53:43.677945Z", "url": "https://files.pythonhosted.org/packages/9b/ab/00c740c795e0101bae4350a1a28c71241de9e02b2191b54cad9bd081eea9/pycond-200222-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "0aa3d26975b5a8d0eed5622e5ef4e76e", "sha256": "3e42db025f005334f857b698386f96d58c3df71d0b66e74638815eb82fc541b0"}, "downloads": -1, "filename": "pycond-200222.tar.gz", "has_sig": false, "md5_digest": "0aa3d26975b5a8d0eed5622e5ef4e76e", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 21078, "upload_time": "2020-02-22T07:53:45", "upload_time_iso_8601": "2020-02-22T07:53:45.978441Z", "url": "https://files.pythonhosted.org/packages/76/4b/ea365f9d0e434026d54886e6e38f3bed6c2480860cc7b95c691260250de3/pycond-200222.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:08:09 2020"}