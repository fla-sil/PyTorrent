{"info": {"author": "Ross Patterson", "author_email": "me@rpatterson.net", "bugtrack_url": null, "classifiers": ["Framework :: Plone", "Framework :: Zope2", "Framework :: Zope3", "Programming Language :: Python", "Topic :: Software Development :: Libraries :: Python Modules"], "description": ";-*-Doctest-*-\n\n============\nField Events\n============\n\nEventProperty is a zope.schema FieldProperty that fires an event when\nthe field is modified and sends the old and new values to the event.\n\n    >>> from zope import interface, schema\n    >>> import grouparchy.schema.event\n    >>> class IFoo(interface.Interface):\n    ...     field = schema.Field()\n    >>> class Foo(object):\n    ...     interface.implements(IFoo)\n    ...     field = grouparchy.schema.event.EventProperty(\n    ...         IFoo['field'])\n    >>> foo = Foo()\n\nBefore configuring a handler for the event nothing will happen::\n\n    >>> foo.field\n    >>> foo.field = 'foo'\n    >>> foo.field\n    'foo'\n\nWhen we provide a handler for the event, it will be triggered when we\nchange the value::\n\n    >>> from zope import component\n    >>> def handler(event):\n    ...     print 'event: %s' % event\n    ...     print 'object: %s' % event.object\n    ...     print 'event.old: %s' % event.old\n    ...     print 'event.new: %s' % event.new\n    >>> component.provideHandler(\n    ...     handler, (grouparchy.schema.event.IFieldModifiedEvent,))\n\n    >>> foo.field = 'bar'\n    event: <grouparchy.schema.event.FieldModifiedEvent object at ...>\n    object: <Foo object at ...>\n    event.old: foo\n    event.new: bar\n\nIf the new value is equal to the existing value, the event isn't\ntriggered::\n\n    >>> foo.field\n    'bar'\n    >>> foo.field = 'bar'\n\nA different event can also be passed in to the property::\n\n    >>> class FooEvent(grouparchy.schema.event.FieldModifiedEvent):\n    ...     pass\n    >>> Foo.field = grouparchy.schema.event.EventProperty(\n    ...     IFoo['field'], event=FooEvent)\n    >>> foo.field = 'foo'\n    event: <FooEvent object at ...>\n    object: <Foo object at ...>\n    event.old: bar\n    event.new: foo\n\nIf the event is None, no event will be triggered::\n\n    >>> Foo.field = grouparchy.schema.event.EventProperty(\n    ...     IFoo['field'], event=None)\n    >>> foo.field = 'bar'\n\nDescriptors that subclass EventProperty can override the notify()\nmethod for further control.  For example, the descriptor below will\ntrigger the event even if the field value is unchanged::\n\n    >>> from zope import event\n    >>> class AlwaysEventProperty(\n    ...     grouparchy.schema.event.EventProperty):\n    ...     def notify(self, instance, new, old):\n    ...         event.notify(self.event(instance, new, old))\n    >>> Foo.field = AlwaysEventProperty(IFoo['field'])\n    >>> foo.field\n    'bar'\n    >>> foo.field = 'bar'\n    event: <grouparchy.schema.event.FieldModifiedEvent object at ...>\n    object: <Foo object at ...>\n    event.old: bar\n    event.new: bar\n\n;-*-Doctest-*-\n\n================\nInterface Fields\n================\n\ngrouparchy.schema.interface includes zope.schema fields for\nmanipulating the interfaces provided by the context.\n\nAn implementation is included for managing the interfaces directly\nprovided by an object::\n\n    >>> from zope import interface\n    >>> from grouparchy.schema.bbb import component_iface\n    >>> class IFoo(interface.Interface): pass\n    >>> component_iface.provideInterface('', IFoo)\n\n    >>> class Context(object):\n    ...     interface.implements(interface.Interface)\n\n    >>> from zope import component\n    >>> import grouparchy.schema.interface\n    >>> component.provideAdapter(\n    ...     factory=grouparchy.schema.interface.DirectlyProvided)\n\n    >>> provider = Context()\n    >>> directlyProvided = (\n    ...     grouparchy.schema.interface.IDirectlyProvided(\n    ...         provider))\n    >>> tuple(directlyProvided.directlyProvided)\n    ()\n\n    >>> directlyProvided.directlyProvided = (IFoo,)\n\n    >>> tuple(directlyProvided.directlyProvided)\n    (<InterfaceClass __builtin__.IFoo>,)\n\nThe individual components offer much more flexibility.\n\nFields\n------\n\nInterfacesField describes a set of interfaces provided by the\ncontext.\n\nAn InterfacesField must have an InterfaceField or Choice value_type::\n\n    >>> from zope import schema\n    >>> grouparchy.schema.interface.InterfacesField()\n    Traceback (most recent call last):\n    ...\n    ValueError: 'value_type' must be an InterfaceField or a Choice.\n    >>> grouparchy.schema.interface.InterfacesField(\n    ...     value_type=schema.Field())\n    Traceback (most recent call last):\n    ...\n    ValueError: 'value_type' must be an InterfaceField or a Choice.\n    >>> field = grouparchy.schema.interface.InterfacesField(\n    ...     value_type=schema.InterfaceField())\n\nValid values are sequences of interfaces::\n\n    >>> foo = object()\n    >>> bound = field.bind(foo)\n    >>> bound.validate(interface.Interface)\n    Traceback (most recent call last):\n    ...\n    WrongType: (<InterfaceClass zope.interface.Interface>,\n                (<type 'set'>, <type 'tuple'>, <type 'list'>))\n    >>> bound.validate((None,))\n    Traceback (most recent call last):\n    ...\n    WrongContainedType: []\n    >>> bound.validate((interface.Interface,))\n    >>> bound.validate([interface.Interface])\n\nLike any Set field, it accepts a Choice field with a vocabulary or\nsource to narrow the set of interfaces::\n\n    >>> field = grouparchy.schema.interface.InterfacesField(\n    ...     value_type=schema.Choice(values=(IFoo,)))\n    >>> bound = field.bind(foo)\n    >>> bound.validate((interface.Interface,))\n    Traceback (most recent call last):\n    ...\n    WrongContainedType: [<InterfaceClass zope.interface.Interface>]\n    >>> bound.validate((IFoo,))\n\nA Choice field cannot circumvent the validation::\n\n    >>> field = grouparchy.schema.interface.InterfacesField(\n    ...     value_type=schema.Choice(values=(None,)))\n    >>> bound = field.bind(foo)\n    >>> bound.validate((None,))\n    Traceback (most recent call last):\n    ...\n    WrongContainedType: []\n\nSources\n-------\n\nA source is also provided which can be used with an interface type\nused to determine set of valid interfaces for the field::\n\n    >>> [i for i in grouparchy.schema.interface.InterfacesSource()]\n    [<InterfaceClass __builtin__.IFoo>]\n\nSubsets of interfaces can be specified by passing an interface type::\n\n    >>> import zope.interface.interfaces\n    >>> class IIBar(zope.interface.interfaces.IInterface): pass\n    >>> class IBar(interface.Interface): pass\n    >>> component_iface.provideInterface('', IBar)\n    >>> component_iface.provideInterface('', IBar, IIBar)\n    >>> [i for i in grouparchy.schema.interface.InterfacesSource()]\n    [<InterfaceClass __builtin__.IFoo>,\n     <InterfaceClass __builtin__.IBar>]\n    >>> source = grouparchy.schema.interface.InterfacesSource(IIBar)\n    >>> [i for i in source]\n    [<InterfaceClass __builtin__.IBar>]\n\nProperties\n----------\n\nTwo properties are also provided for getting and setting the field\nvalue for either interface objects or dotted names for interfaces::\n\n    >>> class IFoo(interface.Interface):\n    ...     all = grouparchy.schema.interface.InterfacesField(\n    ...         value_type=schema.InterfaceField())\n    ...     bar = grouparchy.schema.interface.InterfacesField(\n    ...         value_type=schema.Choice(source=source))\n    ...     dotted = grouparchy.schema.interface.InterfacesField(\n    ...         value_type=schema.InterfaceField())\n    >>> class Foo(object):\n    ...     all = grouparchy.schema.interface.InterfacesProperty(\n    ...         IFoo['all'])\n    ...     bar = grouparchy.schema.interface.InterfacesProperty(\n    ...         IFoo['bar'])\n    ...     dotted = (\n    ...         grouparchy.schema.interface.InterfaceIdentsProperty(\n    ...             IFoo['dotted']))\n    >>> foo = Foo()\n\nThe properties return an IDeclaration::\n\n    >>> isinstance(foo.all, interface.Declaration)\n    True\n\nBefore the object provides anything, the declarations are empty::\n\n    >>> tuple(foo.all)\n    ()\n    >>> tuple(foo.bar)\n    ()\n    >>> tuple(foo.dotted)\n    ()\n\n    >>> interface.alsoProvides(foo, interface.Interface)\n    >>> tuple(foo.all)\n    (<InterfaceClass zope.interface.Interface>,)\n    >>> tuple(foo.dotted)\n    ('zope.interface.Interface',)\n\n    >>> interface.alsoProvides(foo, IBar)\n    >>> tuple(foo.all)\n    (<InterfaceClass zope.interface.Interface>,\n     <InterfaceClass __builtin__.IBar>)\n    >>> tuple(foo.bar)\n    (<InterfaceClass __builtin__.IBar>,)\n\n    >>> IBar.providedBy(foo)\n    True\n    >>> foo.bar = ()\n    >>> tuple(foo.bar)\n    ()\n    >>> IBar.providedBy(foo)\n    False\n    >>> foo.bar = (IBar,)\n    >>> tuple(foo.bar)\n    (<InterfaceClass __builtin__.IBar>,)\n    >>> IBar.providedBy(foo)\n    True\n\nThe properties need to know how to get the context providing the\ninterfaces from the object the property lives on.  This is\naccomplished with an adapter to the object.  The following checks some\nnames where the context is often found on adapters and fallsback to\nthe object itself::\n\n    >>> context = foo.context = Foo()\n    >>> interface.alsoProvides(foo.context, interface.Interface)\n    >>> tuple(foo.all)\n    (<InterfaceClass zope.interface.Interface>,\n     <InterfaceClass __builtin__.IBar>)\n\n    >>> component.provideAdapter(\n    ...     grouparchy.schema.interface.getInterfacesContext)\n\n    >>> tuple(foo.all)\n    (<InterfaceClass zope.interface.Interface>,)\n    >>> del foo.context\n    >>> tuple(foo.all)\n    (<InterfaceClass zope.interface.Interface>,\n     <InterfaceClass __builtin__.IBar>)\n    >>> foo.object = context\n    >>> tuple(foo.all)\n    (<InterfaceClass zope.interface.Interface>,)\n    >>> del foo.object\n\nEvents\n------\n\nThe properties trigger an event by default::\n\n    >>> import zope.interface.interfaces\n    >>> def getIfacesStr(ifaces):\n    ...     return ', '.join((str(i) for i in sorted(ifaces)))\n    >>> def printInterfacesModified(event):\n    ...     print 'Event: %s' % event\n    ...     print 'Object: %s' % event.object\n    ...     print 'New: ' + getIfacesStr(event.new)\n    ...     print 'Old: ' + getIfacesStr(event.old)\n    ...     print 'Added: ' + getIfacesStr(event.added)\n    ...     print 'Removed: ' + getIfacesStr(event.removed)\n    >>> component.provideHandler(\n    ...     factory=printInterfacesModified,\n    ...     adapts=(\n    ...         grouparchy.schema.interface.IInterfacesModified,))\n\n    >>> class IBaz(interface.Interface): pass\n    >>> component_iface.provideInterface('', IBaz)\n    >>> component_iface.provideInterface('', IBaz, IIBar)\n\nThe default events all provide IInterfacesModified, but the event\ntriggered provides one of the more specific IInterfacesPopulated,\nIInterfacesCleared, IInterfacesAdded, IInterfacesRemoved, or\nIInterfacesChanged as apporpriate::\n\n    >>> foo.bar = ()\n    Event:\n    <grouparchy.schema.interface.InterfacesCleared object at ...>\n    Object: <Foo object at ...>\n    New: \n    Old: <InterfaceClass __builtin__.IBar>\n    Added: \n    Removed: <InterfaceClass __builtin__.IBar>\n    >>> foo.bar = (IBar,)\n    Event:\n    <grouparchy.schema.interface.InterfacesPopulated object at ...>\n    Object: <Foo object at ...>\n    New: <InterfaceClass __builtin__.IBar>\n    Old: \n    Added: <InterfaceClass __builtin__.IBar>\n    Removed: \n    >>> foo.bar = (IBar, IBaz)\n    Event:\n    <grouparchy.schema.interface.InterfacesAdded object at ...>\n    Object: <Foo object at ...>\n    New: <InterfaceClass __builtin__.IBar>,\n    <InterfaceClass __builtin__.IBaz>\n    Old: <InterfaceClass __builtin__.IBar>\n    Added: <InterfaceClass __builtin__.IBaz>\n    Removed: \n    >>> foo.bar = (IBar,)\n    Event:\n    <grouparchy.schema.interface.InterfacesRemoved object at ...>\n    Object: <Foo object at ...>\n    New: <InterfaceClass __builtin__.IBar>\n    Old: <InterfaceClass __builtin__.IBar>,\n    <InterfaceClass __builtin__.IBaz>\n    Added:\n    Removed: <InterfaceClass __builtin__.IBaz>\n    >>> foo.bar = (IBaz,)\n    Event:\n    <grouparchy.schema.interface.InterfacesChanged object at ...>\n    Object: <Foo object at ...>\n    New: <InterfaceClass __builtin__.IBaz>\n    Old: <InterfaceClass __builtin__.IBar>\n    Added: <InterfaceClass __builtin__.IBaz>\n    Removed: <InterfaceClass __builtin__.IBar>\n\nIInterfacesPopulated and IInterfacesCleared extend IInterfacesAdded\nand IInterfacesRemoved respectively.  IInterfacesChanged extends\nboth::\n\n    >>> def printInterfacesAdded(event): print 'Interfaces Added'\n    >>> component.provideHandler(\n    ...     factory=printInterfacesAdded,\n    ...     adapts=(\n    ...         grouparchy.schema.interface.IInterfacesAdded,))\n\n    >>> def printInterfacesRemoved(event): print 'Interfaces Removed'\n    >>> component.provideHandler(\n    ...     factory=printInterfacesRemoved,\n    ...     adapts=(\n    ...         grouparchy.schema.interface.IInterfacesRemoved,))\n\n    >>> foo.bar = ()\n    Event:\n    <grouparchy.schema.interface.InterfacesCleared object at ...>\n    Object: <Foo object at ...>\n    New: \n    Old: <InterfaceClass __builtin__.IBaz>\n    Added: \n    Removed: <InterfaceClass __builtin__.IBaz>\n    Interfaces Removed\n    >>> foo.bar = (IBar,)\n    Event:\n    <grouparchy.schema.interface.InterfacesPopulated object at ...>\n    Object: <Foo object at ...>\n    New: <InterfaceClass __builtin__.IBar>\n    Old: \n    Added: <InterfaceClass __builtin__.IBar>\n    Removed: \n    Interfaces Added\n    >>> foo.bar = (IBaz,)\n    Event:\n    <grouparchy.schema.interface.InterfacesChanged object at ...>\n    Object: <Foo object at ...>\n    New: <InterfaceClass __builtin__.IBaz>\n    Old: <InterfaceClass __builtin__.IBar>\n    Added: <InterfaceClass __builtin__.IBaz>\n    Removed: <InterfaceClass __builtin__.IBar>\n    Interfaces Removed\n    Interfaces Added\n\nAn event class can be passed to the property as with\ngrouparchy.schema.event.EventProperty::\n\n    >>> import grouparchy.schema.event\n    >>> class IBarInterfacesModified(\n    ...     grouparchy.schema.event.IFieldModifiedEvent): pass\n    >>> class BarInterfacesModified(\n    ...     grouparchy.schema.event.FieldModifiedEvent):\n    ...         interface.implements(IBarInterfacesModified)\n\n    >>> def printBarInterfacesModified(event):\n    ...     print 'Event: %s' % event\n    ...     print 'Object: %s' % event.object\n    ...     print 'New: ' + getIfacesStr(event.new)\n    ...     print 'Old: ' + getIfacesStr(event.old)\n    >>> component.provideHandler(\n    ...     factory=printBarInterfacesModified,\n    ...     adapts=(IBarInterfacesModified,))\n\n    >>> foo.bar = ()\n    Event:\n    <grouparchy.schema.interface.InterfacesCleared object at ...>\n    Object: <Foo object at ...>\n    New: \n    Old: <InterfaceClass __builtin__.IBaz>\n    Added: \n    Removed: <InterfaceClass __builtin__.IBaz>\n    Interfaces Removed\n    >>> foo.bar = (IBar,)\n    Event:\n    <grouparchy.schema.interface.InterfacesPopulated object at ...>\n    Object: <Foo object at ...>\n    New: <InterfaceClass __builtin__.IBar>\n    Old: \n    Added: <InterfaceClass __builtin__.IBar>\n    Removed: \n    Interfaces Added\n\n    >>> Foo.bar = grouparchy.schema.interface.InterfacesProperty(\n    ...     IFoo['bar'],\n    ...     event=BarInterfacesModified)\n\n    >>> foo.bar = ()\n    Event: <BarInterfacesModified object at ...>\n    Object: <Foo object at ...>\n    New: \n    Old: <InterfaceClass __builtin__.IBar>\n    >>> foo.bar = (IBar,)\n    Event: <BarInterfacesModified object at ...>\n    Object: <Foo object at ...>\n    New: <InterfaceClass __builtin__.IBar>\n    Old:", "description_content_type": null, "docs_url": null, "download_url": "UNKNOWN", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "http://pypi.python.org/pypi/grouparchy.schema", "keywords": "", "license": "GPL", "maintainer": null, "maintainer_email": null, "name": "grouparchy.schema", "package_url": "https://pypi.org/project/grouparchy.schema/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/grouparchy.schema/", "project_urls": {"Download": "UNKNOWN", "Homepage": "http://pypi.python.org/pypi/grouparchy.schema"}, "release_url": "https://pypi.org/project/grouparchy.schema/0.1/", "requires_dist": null, "requires_python": null, "summary": "Grouparchy zope.schema extensions", "version": "0.1", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p>;-<em>-Doctest-</em>-</p>\n<div id=\"field-events\">\n<h2>Field Events</h2>\n<p>EventProperty is a zope.schema FieldProperty that fires an event when\nthe field is modified and sends the old and new values to the event.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from zope import interface, schema\n&gt;&gt;&gt; import grouparchy.schema.event\n&gt;&gt;&gt; class IFoo(interface.Interface):\n...     field = schema.Field()\n&gt;&gt;&gt; class Foo(object):\n...     interface.implements(IFoo)\n...     field = grouparchy.schema.event.EventProperty(\n...         IFoo['field'])\n&gt;&gt;&gt; foo = Foo()\n</pre>\n</blockquote>\n<p>Before configuring a handler for the event nothing will happen:</p>\n<pre>&gt;&gt;&gt; foo.field\n&gt;&gt;&gt; foo.field = 'foo'\n&gt;&gt;&gt; foo.field\n'foo'\n</pre>\n<p>When we provide a handler for the event, it will be triggered when we\nchange the value:</p>\n<pre>&gt;&gt;&gt; from zope import component\n&gt;&gt;&gt; def handler(event):\n...     print 'event: %s' % event\n...     print 'object: %s' % event.object\n...     print 'event.old: %s' % event.old\n...     print 'event.new: %s' % event.new\n&gt;&gt;&gt; component.provideHandler(\n...     handler, (grouparchy.schema.event.IFieldModifiedEvent,))\n\n&gt;&gt;&gt; foo.field = 'bar'\nevent: &lt;grouparchy.schema.event.FieldModifiedEvent object at ...&gt;\nobject: &lt;Foo object at ...&gt;\nevent.old: foo\nevent.new: bar\n</pre>\n<p>If the new value is equal to the existing value, the event isn\u2019t\ntriggered:</p>\n<pre>&gt;&gt;&gt; foo.field\n'bar'\n&gt;&gt;&gt; foo.field = 'bar'\n</pre>\n<p>A different event can also be passed in to the property:</p>\n<pre>&gt;&gt;&gt; class FooEvent(grouparchy.schema.event.FieldModifiedEvent):\n...     pass\n&gt;&gt;&gt; Foo.field = grouparchy.schema.event.EventProperty(\n...     IFoo['field'], event=FooEvent)\n&gt;&gt;&gt; foo.field = 'foo'\nevent: &lt;FooEvent object at ...&gt;\nobject: &lt;Foo object at ...&gt;\nevent.old: bar\nevent.new: foo\n</pre>\n<p>If the event is None, no event will be triggered:</p>\n<pre>&gt;&gt;&gt; Foo.field = grouparchy.schema.event.EventProperty(\n...     IFoo['field'], event=None)\n&gt;&gt;&gt; foo.field = 'bar'\n</pre>\n<p>Descriptors that subclass EventProperty can override the notify()\nmethod for further control.  For example, the descriptor below will\ntrigger the event even if the field value is unchanged:</p>\n<pre>&gt;&gt;&gt; from zope import event\n&gt;&gt;&gt; class AlwaysEventProperty(\n...     grouparchy.schema.event.EventProperty):\n...     def notify(self, instance, new, old):\n...         event.notify(self.event(instance, new, old))\n&gt;&gt;&gt; Foo.field = AlwaysEventProperty(IFoo['field'])\n&gt;&gt;&gt; foo.field\n'bar'\n&gt;&gt;&gt; foo.field = 'bar'\nevent: &lt;grouparchy.schema.event.FieldModifiedEvent object at ...&gt;\nobject: &lt;Foo object at ...&gt;\nevent.old: bar\nevent.new: bar\n</pre>\n<p>;-<em>-Doctest-</em>-</p>\n</div>\n<div id=\"interface-fields\">\n<h2>Interface Fields</h2>\n<p>grouparchy.schema.interface includes zope.schema fields for\nmanipulating the interfaces provided by the context.</p>\n<p>An implementation is included for managing the interfaces directly\nprovided by an object:</p>\n<pre>&gt;&gt;&gt; from zope import interface\n&gt;&gt;&gt; from grouparchy.schema.bbb import component_iface\n&gt;&gt;&gt; class IFoo(interface.Interface): pass\n&gt;&gt;&gt; component_iface.provideInterface('', IFoo)\n\n&gt;&gt;&gt; class Context(object):\n...     interface.implements(interface.Interface)\n\n&gt;&gt;&gt; from zope import component\n&gt;&gt;&gt; import grouparchy.schema.interface\n&gt;&gt;&gt; component.provideAdapter(\n...     factory=grouparchy.schema.interface.DirectlyProvided)\n\n&gt;&gt;&gt; provider = Context()\n&gt;&gt;&gt; directlyProvided = (\n...     grouparchy.schema.interface.IDirectlyProvided(\n...         provider))\n&gt;&gt;&gt; tuple(directlyProvided.directlyProvided)\n()\n\n&gt;&gt;&gt; directlyProvided.directlyProvided = (IFoo,)\n\n&gt;&gt;&gt; tuple(directlyProvided.directlyProvided)\n(&lt;InterfaceClass __builtin__.IFoo&gt;,)\n</pre>\n<p>The individual components offer much more flexibility.</p>\n<div id=\"fields\">\n<h3>Fields</h3>\n<p>InterfacesField describes a set of interfaces provided by the\ncontext.</p>\n<p>An InterfacesField must have an InterfaceField or Choice value_type:</p>\n<pre>&gt;&gt;&gt; from zope import schema\n&gt;&gt;&gt; grouparchy.schema.interface.InterfacesField()\nTraceback (most recent call last):\n...\nValueError: 'value_type' must be an InterfaceField or a Choice.\n&gt;&gt;&gt; grouparchy.schema.interface.InterfacesField(\n...     value_type=schema.Field())\nTraceback (most recent call last):\n...\nValueError: 'value_type' must be an InterfaceField or a Choice.\n&gt;&gt;&gt; field = grouparchy.schema.interface.InterfacesField(\n...     value_type=schema.InterfaceField())\n</pre>\n<p>Valid values are sequences of interfaces:</p>\n<pre>&gt;&gt;&gt; foo = object()\n&gt;&gt;&gt; bound = field.bind(foo)\n&gt;&gt;&gt; bound.validate(interface.Interface)\nTraceback (most recent call last):\n...\nWrongType: (&lt;InterfaceClass zope.interface.Interface&gt;,\n            (&lt;type 'set'&gt;, &lt;type 'tuple'&gt;, &lt;type 'list'&gt;))\n&gt;&gt;&gt; bound.validate((None,))\nTraceback (most recent call last):\n...\nWrongContainedType: []\n&gt;&gt;&gt; bound.validate((interface.Interface,))\n&gt;&gt;&gt; bound.validate([interface.Interface])\n</pre>\n<p>Like any Set field, it accepts a Choice field with a vocabulary or\nsource to narrow the set of interfaces:</p>\n<pre>&gt;&gt;&gt; field = grouparchy.schema.interface.InterfacesField(\n...     value_type=schema.Choice(values=(IFoo,)))\n&gt;&gt;&gt; bound = field.bind(foo)\n&gt;&gt;&gt; bound.validate((interface.Interface,))\nTraceback (most recent call last):\n...\nWrongContainedType: [&lt;InterfaceClass zope.interface.Interface&gt;]\n&gt;&gt;&gt; bound.validate((IFoo,))\n</pre>\n<p>A Choice field cannot circumvent the validation:</p>\n<pre>&gt;&gt;&gt; field = grouparchy.schema.interface.InterfacesField(\n...     value_type=schema.Choice(values=(None,)))\n&gt;&gt;&gt; bound = field.bind(foo)\n&gt;&gt;&gt; bound.validate((None,))\nTraceback (most recent call last):\n...\nWrongContainedType: []\n</pre>\n</div>\n<div id=\"sources\">\n<h3>Sources</h3>\n<p>A source is also provided which can be used with an interface type\nused to determine set of valid interfaces for the field:</p>\n<pre>&gt;&gt;&gt; [i for i in grouparchy.schema.interface.InterfacesSource()]\n[&lt;InterfaceClass __builtin__.IFoo&gt;]\n</pre>\n<p>Subsets of interfaces can be specified by passing an interface type:</p>\n<pre>&gt;&gt;&gt; import zope.interface.interfaces\n&gt;&gt;&gt; class IIBar(zope.interface.interfaces.IInterface): pass\n&gt;&gt;&gt; class IBar(interface.Interface): pass\n&gt;&gt;&gt; component_iface.provideInterface('', IBar)\n&gt;&gt;&gt; component_iface.provideInterface('', IBar, IIBar)\n&gt;&gt;&gt; [i for i in grouparchy.schema.interface.InterfacesSource()]\n[&lt;InterfaceClass __builtin__.IFoo&gt;,\n &lt;InterfaceClass __builtin__.IBar&gt;]\n&gt;&gt;&gt; source = grouparchy.schema.interface.InterfacesSource(IIBar)\n&gt;&gt;&gt; [i for i in source]\n[&lt;InterfaceClass __builtin__.IBar&gt;]\n</pre>\n</div>\n<div id=\"properties\">\n<h3>Properties</h3>\n<p>Two properties are also provided for getting and setting the field\nvalue for either interface objects or dotted names for interfaces:</p>\n<pre>&gt;&gt;&gt; class IFoo(interface.Interface):\n...     all = grouparchy.schema.interface.InterfacesField(\n...         value_type=schema.InterfaceField())\n...     bar = grouparchy.schema.interface.InterfacesField(\n...         value_type=schema.Choice(source=source))\n...     dotted = grouparchy.schema.interface.InterfacesField(\n...         value_type=schema.InterfaceField())\n&gt;&gt;&gt; class Foo(object):\n...     all = grouparchy.schema.interface.InterfacesProperty(\n...         IFoo['all'])\n...     bar = grouparchy.schema.interface.InterfacesProperty(\n...         IFoo['bar'])\n...     dotted = (\n...         grouparchy.schema.interface.InterfaceIdentsProperty(\n...             IFoo['dotted']))\n&gt;&gt;&gt; foo = Foo()\n</pre>\n<p>The properties return an IDeclaration:</p>\n<pre>&gt;&gt;&gt; isinstance(foo.all, interface.Declaration)\nTrue\n</pre>\n<p>Before the object provides anything, the declarations are empty:</p>\n<pre>&gt;&gt;&gt; tuple(foo.all)\n()\n&gt;&gt;&gt; tuple(foo.bar)\n()\n&gt;&gt;&gt; tuple(foo.dotted)\n()\n\n&gt;&gt;&gt; interface.alsoProvides(foo, interface.Interface)\n&gt;&gt;&gt; tuple(foo.all)\n(&lt;InterfaceClass zope.interface.Interface&gt;,)\n&gt;&gt;&gt; tuple(foo.dotted)\n('zope.interface.Interface',)\n\n&gt;&gt;&gt; interface.alsoProvides(foo, IBar)\n&gt;&gt;&gt; tuple(foo.all)\n(&lt;InterfaceClass zope.interface.Interface&gt;,\n &lt;InterfaceClass __builtin__.IBar&gt;)\n&gt;&gt;&gt; tuple(foo.bar)\n(&lt;InterfaceClass __builtin__.IBar&gt;,)\n\n&gt;&gt;&gt; IBar.providedBy(foo)\nTrue\n&gt;&gt;&gt; foo.bar = ()\n&gt;&gt;&gt; tuple(foo.bar)\n()\n&gt;&gt;&gt; IBar.providedBy(foo)\nFalse\n&gt;&gt;&gt; foo.bar = (IBar,)\n&gt;&gt;&gt; tuple(foo.bar)\n(&lt;InterfaceClass __builtin__.IBar&gt;,)\n&gt;&gt;&gt; IBar.providedBy(foo)\nTrue\n</pre>\n<p>The properties need to know how to get the context providing the\ninterfaces from the object the property lives on.  This is\naccomplished with an adapter to the object.  The following checks some\nnames where the context is often found on adapters and fallsback to\nthe object itself:</p>\n<pre>&gt;&gt;&gt; context = foo.context = Foo()\n&gt;&gt;&gt; interface.alsoProvides(foo.context, interface.Interface)\n&gt;&gt;&gt; tuple(foo.all)\n(&lt;InterfaceClass zope.interface.Interface&gt;,\n &lt;InterfaceClass __builtin__.IBar&gt;)\n\n&gt;&gt;&gt; component.provideAdapter(\n...     grouparchy.schema.interface.getInterfacesContext)\n\n&gt;&gt;&gt; tuple(foo.all)\n(&lt;InterfaceClass zope.interface.Interface&gt;,)\n&gt;&gt;&gt; del foo.context\n&gt;&gt;&gt; tuple(foo.all)\n(&lt;InterfaceClass zope.interface.Interface&gt;,\n &lt;InterfaceClass __builtin__.IBar&gt;)\n&gt;&gt;&gt; foo.object = context\n&gt;&gt;&gt; tuple(foo.all)\n(&lt;InterfaceClass zope.interface.Interface&gt;,)\n&gt;&gt;&gt; del foo.object\n</pre>\n</div>\n<div id=\"events\">\n<h3>Events</h3>\n<p>The properties trigger an event by default:</p>\n<pre>&gt;&gt;&gt; import zope.interface.interfaces\n&gt;&gt;&gt; def getIfacesStr(ifaces):\n...     return ', '.join((str(i) for i in sorted(ifaces)))\n&gt;&gt;&gt; def printInterfacesModified(event):\n...     print 'Event: %s' % event\n...     print 'Object: %s' % event.object\n...     print 'New: ' + getIfacesStr(event.new)\n...     print 'Old: ' + getIfacesStr(event.old)\n...     print 'Added: ' + getIfacesStr(event.added)\n...     print 'Removed: ' + getIfacesStr(event.removed)\n&gt;&gt;&gt; component.provideHandler(\n...     factory=printInterfacesModified,\n...     adapts=(\n...         grouparchy.schema.interface.IInterfacesModified,))\n\n&gt;&gt;&gt; class IBaz(interface.Interface): pass\n&gt;&gt;&gt; component_iface.provideInterface('', IBaz)\n&gt;&gt;&gt; component_iface.provideInterface('', IBaz, IIBar)\n</pre>\n<p>The default events all provide IInterfacesModified, but the event\ntriggered provides one of the more specific IInterfacesPopulated,\nIInterfacesCleared, IInterfacesAdded, IInterfacesRemoved, or\nIInterfacesChanged as apporpriate:</p>\n<pre>&gt;&gt;&gt; foo.bar = ()\nEvent:\n&lt;grouparchy.schema.interface.InterfacesCleared object at ...&gt;\nObject: &lt;Foo object at ...&gt;\nNew:\nOld: &lt;InterfaceClass __builtin__.IBar&gt;\nAdded:\nRemoved: &lt;InterfaceClass __builtin__.IBar&gt;\n&gt;&gt;&gt; foo.bar = (IBar,)\nEvent:\n&lt;grouparchy.schema.interface.InterfacesPopulated object at ...&gt;\nObject: &lt;Foo object at ...&gt;\nNew: &lt;InterfaceClass __builtin__.IBar&gt;\nOld:\nAdded: &lt;InterfaceClass __builtin__.IBar&gt;\nRemoved:\n&gt;&gt;&gt; foo.bar = (IBar, IBaz)\nEvent:\n&lt;grouparchy.schema.interface.InterfacesAdded object at ...&gt;\nObject: &lt;Foo object at ...&gt;\nNew: &lt;InterfaceClass __builtin__.IBar&gt;,\n&lt;InterfaceClass __builtin__.IBaz&gt;\nOld: &lt;InterfaceClass __builtin__.IBar&gt;\nAdded: &lt;InterfaceClass __builtin__.IBaz&gt;\nRemoved:\n&gt;&gt;&gt; foo.bar = (IBar,)\nEvent:\n&lt;grouparchy.schema.interface.InterfacesRemoved object at ...&gt;\nObject: &lt;Foo object at ...&gt;\nNew: &lt;InterfaceClass __builtin__.IBar&gt;\nOld: &lt;InterfaceClass __builtin__.IBar&gt;,\n&lt;InterfaceClass __builtin__.IBaz&gt;\nAdded:\nRemoved: &lt;InterfaceClass __builtin__.IBaz&gt;\n&gt;&gt;&gt; foo.bar = (IBaz,)\nEvent:\n&lt;grouparchy.schema.interface.InterfacesChanged object at ...&gt;\nObject: &lt;Foo object at ...&gt;\nNew: &lt;InterfaceClass __builtin__.IBaz&gt;\nOld: &lt;InterfaceClass __builtin__.IBar&gt;\nAdded: &lt;InterfaceClass __builtin__.IBaz&gt;\nRemoved: &lt;InterfaceClass __builtin__.IBar&gt;\n</pre>\n<p>IInterfacesPopulated and IInterfacesCleared extend IInterfacesAdded\nand IInterfacesRemoved respectively.  IInterfacesChanged extends\nboth:</p>\n<pre>&gt;&gt;&gt; def printInterfacesAdded(event): print 'Interfaces Added'\n&gt;&gt;&gt; component.provideHandler(\n...     factory=printInterfacesAdded,\n...     adapts=(\n...         grouparchy.schema.interface.IInterfacesAdded,))\n\n&gt;&gt;&gt; def printInterfacesRemoved(event): print 'Interfaces Removed'\n&gt;&gt;&gt; component.provideHandler(\n...     factory=printInterfacesRemoved,\n...     adapts=(\n...         grouparchy.schema.interface.IInterfacesRemoved,))\n\n&gt;&gt;&gt; foo.bar = ()\nEvent:\n&lt;grouparchy.schema.interface.InterfacesCleared object at ...&gt;\nObject: &lt;Foo object at ...&gt;\nNew:\nOld: &lt;InterfaceClass __builtin__.IBaz&gt;\nAdded:\nRemoved: &lt;InterfaceClass __builtin__.IBaz&gt;\nInterfaces Removed\n&gt;&gt;&gt; foo.bar = (IBar,)\nEvent:\n&lt;grouparchy.schema.interface.InterfacesPopulated object at ...&gt;\nObject: &lt;Foo object at ...&gt;\nNew: &lt;InterfaceClass __builtin__.IBar&gt;\nOld:\nAdded: &lt;InterfaceClass __builtin__.IBar&gt;\nRemoved:\nInterfaces Added\n&gt;&gt;&gt; foo.bar = (IBaz,)\nEvent:\n&lt;grouparchy.schema.interface.InterfacesChanged object at ...&gt;\nObject: &lt;Foo object at ...&gt;\nNew: &lt;InterfaceClass __builtin__.IBaz&gt;\nOld: &lt;InterfaceClass __builtin__.IBar&gt;\nAdded: &lt;InterfaceClass __builtin__.IBaz&gt;\nRemoved: &lt;InterfaceClass __builtin__.IBar&gt;\nInterfaces Removed\nInterfaces Added\n</pre>\n<p>An event class can be passed to the property as with\ngrouparchy.schema.event.EventProperty:</p>\n<pre>&gt;&gt;&gt; import grouparchy.schema.event\n&gt;&gt;&gt; class IBarInterfacesModified(\n...     grouparchy.schema.event.IFieldModifiedEvent): pass\n&gt;&gt;&gt; class BarInterfacesModified(\n...     grouparchy.schema.event.FieldModifiedEvent):\n...         interface.implements(IBarInterfacesModified)\n\n&gt;&gt;&gt; def printBarInterfacesModified(event):\n...     print 'Event: %s' % event\n...     print 'Object: %s' % event.object\n...     print 'New: ' + getIfacesStr(event.new)\n...     print 'Old: ' + getIfacesStr(event.old)\n&gt;&gt;&gt; component.provideHandler(\n...     factory=printBarInterfacesModified,\n...     adapts=(IBarInterfacesModified,))\n\n&gt;&gt;&gt; foo.bar = ()\nEvent:\n&lt;grouparchy.schema.interface.InterfacesCleared object at ...&gt;\nObject: &lt;Foo object at ...&gt;\nNew:\nOld: &lt;InterfaceClass __builtin__.IBaz&gt;\nAdded:\nRemoved: &lt;InterfaceClass __builtin__.IBaz&gt;\nInterfaces Removed\n&gt;&gt;&gt; foo.bar = (IBar,)\nEvent:\n&lt;grouparchy.schema.interface.InterfacesPopulated object at ...&gt;\nObject: &lt;Foo object at ...&gt;\nNew: &lt;InterfaceClass __builtin__.IBar&gt;\nOld:\nAdded: &lt;InterfaceClass __builtin__.IBar&gt;\nRemoved:\nInterfaces Added\n\n&gt;&gt;&gt; Foo.bar = grouparchy.schema.interface.InterfacesProperty(\n...     IFoo['bar'],\n...     event=BarInterfacesModified)\n\n&gt;&gt;&gt; foo.bar = ()\nEvent: &lt;BarInterfacesModified object at ...&gt;\nObject: &lt;Foo object at ...&gt;\nNew:\nOld: &lt;InterfaceClass __builtin__.IBar&gt;\n&gt;&gt;&gt; foo.bar = (IBar,)\nEvent: &lt;BarInterfacesModified object at ...&gt;\nObject: &lt;Foo object at ...&gt;\nNew: &lt;InterfaceClass __builtin__.IBar&gt;\nOld:\n</pre>\n</div>\n</div>\n\n          </div>"}, "last_serial": 792730, "releases": {"0.1": [{"comment_text": "", "digests": {"md5": "99c138fe3c345cc5139f61ee96d33f2a", "sha256": "448f802fac8247c44e2d6a343d57795ce0fd2b465c53ae81780ae8f990136d45"}, "downloads": -1, "filename": "grouparchy.schema-0.1.tar.gz", "has_sig": false, "md5_digest": "99c138fe3c345cc5139f61ee96d33f2a", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 16783, "upload_time": "2008-04-09T09:41:46", "upload_time_iso_8601": "2008-04-09T09:41:46Z", "url": "https://files.pythonhosted.org/packages/36/ab/79d26d3d1b4bfa47950c1c3c4624c5b81f3a97e5469121e459e6e6294ad2/grouparchy.schema-0.1.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "99c138fe3c345cc5139f61ee96d33f2a", "sha256": "448f802fac8247c44e2d6a343d57795ce0fd2b465c53ae81780ae8f990136d45"}, "downloads": -1, "filename": "grouparchy.schema-0.1.tar.gz", "has_sig": false, "md5_digest": "99c138fe3c345cc5139f61ee96d33f2a", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 16783, "upload_time": "2008-04-09T09:41:46", "upload_time_iso_8601": "2008-04-09T09:41:46Z", "url": "https://files.pythonhosted.org/packages/36/ab/79d26d3d1b4bfa47950c1c3c4624c5b81f3a97e5469121e459e6e6294ad2/grouparchy.schema-0.1.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:54:04 2020"}