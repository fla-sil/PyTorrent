{"info": {"author": "Jon Brandvein", "author_email": "jon.brandvein@gmail.com", "bugtrack_url": null, "classifiers": ["Development Status :: 3 - Alpha", "Intended Audience :: Developers", "License :: OSI Approved :: MIT License", "Programming Language :: Python :: 3", "Topic :: Software Development :: Libraries :: Python Modules"], "description": "# SimpleStruct #\n\n*(Supports Python 3.3 and up)*\n\nThis small library makes it easier to create \"struct\" classes in Python\nwithout writing boilerplate code. Structs are similar to the standard\nlibrary's [`collections.namedtuple`][1] but are more flexible, relying on an\ninheritance-based approach instead of `eval()`ing a code template. If\nyou like using `namedtuple` classes but wish they were more composable\nand extensible, this project is for you.\n\n## Example ##\n\nWriting struct classes by hand is tedious and error prone. Consider a\nsimple point class. The bare minimum we can write in Python is\n\n```python\nclass Point2D:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n```\n\nWe'll likely want to compare points for equality and pretty-print them\nfor debugging.\n\n```python\nclass Point2D:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n    def __repr__(self):\n        # Separate __str__() would be nice too\n        return 'Point2D({!r}, {!r})'.format(self.x, self.y)\n    def __eq__(self, other):\n        # Should check other's type too\n        return self.x == other.x and self.y == other.y\n    def __hash__(self):\n        # Required because we're overriding __eq__().\n        return hash(self.x) ^ hash(self.y)\n```\n\nAlready the code is becoming pretty verbose for such a simple concept.\nWorse, it violates the [DRY principle](http://en.wikipedia.org/wiki/Don%27t_repeat_yourself)\nin that the `x` and `y` fields appear many times. This isn't very\nrobust. If we decide to turn this into a `Point3D` class, we'll have\nto upgrade each method to accommodate a new z coordinate. We could be\nin for an infuriating bug if we forget to update `__eq__()` or\n`__hash__()`. Adding more utilities like a copy/replace method will\nexacerbate the situation.\n\nThen there's the added code for consistency checking. Maybe you're the\nsort of heathen who prefers dynamic type checking over blindly trusting\nMama Ducktype. Or maybe you want to disallow overwriting `x` and `y` so\nas to avoid changing its hash value. Either way you'd need to use\ndescriptors or properties to intercept writes.\n\nSimpleStruct provides a simple alternative. Here is a `Point2D` class\nthat provides everything described above.\n\n```python\nfrom numbers import Number      # standard library abstract base class\nfrom simplestruct import Struct, Field, TypedField\n\nclass Point2D(Struct):\n    # Note that field declaration order matters.\n    x = TypedField(Number)\n    y = TypedField(Number)\n```\n\nOf course, customizations are possible. Type checking is by no means\nrequired, objects may be mutable so long as they are not hashed,\nand you can add your own non-Field attributes and properties.\n\n```python\nclass Point2D(Struct):\n    _immutable = False\n    x = Field\n    y = Field\n    \n    # magnitude won't be considered when hashing or testing equality\n    @property\n    def magnitude(self):\n        return (self.x**2 + self.y**2) ** .5\n```\n\nFor more usage examples, see the sample files:\n\nFile | Purpose\n---|---\n[point.py](examples/point.py) | introduction, basic use\n[typed.py](examples/typed.py) | type-checked fields\n[vector.py](examples/vector.py) | advanced features\n[abstract.py](examples/abstract.py) | mixing structs and metaclasses\n\n## Comparison and feature matrix ##\n\nThe most important problems mentioned above are solved by using\n`namedtuple`, but this approach begins to break down when you\nstart to customize classes. To add a property to a `namedtuple`,\nyou must define a subclass:\n\n```python\nBasePerson = namedtuple('BasePerson', 'fname lname age')\nclass Person(BasePerson):\n    @property\n    def full_name(self):\n        return self.fname + ' ' + self.lname\n```\n\nIf on the other hand you want to extend an existing `namedtuple` with\nnew fields, it's a bit harder. You need to regenerate (not inherit)\nthe boilerplate methods so they recognize the new fields. This can be\ndone using multiple inheritance:\n\n```python\nBaseEmployee = namedtuple('BaseEmployee', BasePerson._fields + ('salary',))\nclass Employee(BaseEmployee, Person):\n    pass\n```\n\nImplementation wise, `namedtuple` works by dynamically evaluating\na templated class definition based on the built-in `tuple` type.\nThis gives it a speed advantage, but is also the main reason why\nit is less extensible (and unable to handle mutable values).\n\nIn contrast, SimpleStruct is based on metaclasses, descriptors, and\ndynamic dispatch. The below matrix summarizes the feature comparison.\n\nFeature | Avoids boilerplate for | Supported by `namedtuple`?\n---|:---:|:---:\neasy construction | `__init__()` | \u2713\nextra attributes on self | | subclasses only\npretty printing | `__str()__`, `__repr()__` | \u2713\nstructural equality | `__eq__()` | \u2713\neasy inheritance | | \u2717\noptional mutability | | \u2717\nhashing (if immutable) | `__hash__()` | \u2713\npickling / deep-copying |  | \u2713\ntuple decomposition | `__len__`, `__iter__` | \u2713\nindexing | `__getitem__`, `__setitem__` | `__getitem__` only\noptional type checking | `__init__()`, `@property` | \u2717\n`_asdict()` / `_replace()` | | \u2713\n\n[MacroPy][2]'s \"case classes\" provide similar functionality, but are\nimplemented in a very different way. Instead of metaclass hacking\nor source code templating, MacroPy relies on syntactic transformation\nof the module's AST. This allows for a syntax that's very different\nfrom what we've seen above. So different, in fact, that we might view\nMacroPy as an extension to the Python language rather than as just\na library. Case classes are subject to limitations on\ninheritance and class members.\n\n## Installation ##\n\nAs with most Python packages, SimpleStruct is available on PyPI:\n\n```\npython -m pip install simplestruct\n```\n\nOr grab a development version if you're so inclined:\n\n```\npython -m pip install https://github.com/brandjon/simplestruct/tree/tarball/develop\n```\n\nPython 3.3 and 3.4 are supported. There are no additional dependencies.\n\n## Developers ##\n\nTests can be run with `python setup.py test`, or alternatively by\ninstalling [Tox](http://testrun.org/tox/latest/) and running \n`python -m tox` in the project root. Tox has the advantage of automatically\ntesting under both Python 3.3 and 3.4. Building a source distribution\n(`python setup.py sdist`) requires the setuptools extension package\n[setuptools-git](https://github.com/wichert/setuptools-git).\n\n## References ##\n\n[1]: https://docs.python.org/3/library/collections.html#collections.namedtuple\n[[1]] The standard library's `namedtuple` feature\n\n[2]: https://github.com/lihaoyi/macropy#case-classes\n[[2]] Li Haoyi's case classes (part of MacroPy)\n\n[3]: http://harts.net/reece/2013/06/02/using-namedtuples-with-method-and-instance-variable-inheritance/\n[[3]] Reece Hart's blog post on inheriting from `namedtuple`\n", "description_content_type": null, "docs_url": null, "download_url": "UNKNOWN", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/brandjon/simplestruct", "keywords": null, "license": "MIT License", "maintainer": null, "maintainer_email": null, "name": "SimpleStruct", "package_url": "https://pypi.org/project/SimpleStruct/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/SimpleStruct/", "project_urls": {"Download": "UNKNOWN", "Homepage": "https://github.com/brandjon/simplestruct"}, "release_url": "https://pypi.org/project/SimpleStruct/0.2.2/", "requires_dist": null, "requires_python": null, "summary": "A library for defining struct-like classes", "version": "0.2.2", "yanked": false, "html_description": "<div class=\"project-description\">\n            # SimpleStruct #<br><br>*(Supports Python 3.3 and up)*<br><br>This small library makes it easier to create \"struct\" classes in Python<br>without writing boilerplate code. Structs are similar to the standard<br>library's [`collections.namedtuple`][1] but are more flexible, relying on an<br>inheritance-based approach instead of `eval()`ing a code template. If<br>you like using `namedtuple` classes but wish they were more composable<br>and extensible, this project is for you.<br><br>## Example ##<br><br>Writing struct classes by hand is tedious and error prone. Consider a<br>simple point class. The bare minimum we can write in Python is<br><br>```python<br>class Point2D:<br>    def __init__(self, x, y):<br>        self.x = x<br>        self.y = y<br>```<br><br>We'll likely want to compare points for equality and pretty-print them<br>for debugging.<br><br>```python<br>class Point2D:<br>    def __init__(self, x, y):<br>        self.x = x<br>        self.y = y<br>    def __repr__(self):<br>        # Separate __str__() would be nice too<br>        return 'Point2D({!r}, {!r})'.format(self.x, self.y)<br>    def __eq__(self, other):<br>        # Should check other's type too<br>        return self.x == other.x and self.y == other.y<br>    def __hash__(self):<br>        # Required because we're overriding __eq__().<br>        return hash(self.x) ^ hash(self.y)<br>```<br><br>Already the code is becoming pretty verbose for such a simple concept.<br>Worse, it violates the [DRY principle](http://en.wikipedia.org/wiki/Don%27t_repeat_yourself)<br>in that the `x` and `y` fields appear many times. This isn't very<br>robust. If we decide to turn this into a `Point3D` class, we'll have<br>to upgrade each method to accommodate a new z coordinate. We could be<br>in for an infuriating bug if we forget to update `__eq__()` or<br>`__hash__()`. Adding more utilities like a copy/replace method will<br>exacerbate the situation.<br><br>Then there's the added code for consistency checking. Maybe you're the<br>sort of heathen who prefers dynamic type checking over blindly trusting<br>Mama Ducktype. Or maybe you want to disallow overwriting `x` and `y` so<br>as to avoid changing its hash value. Either way you'd need to use<br>descriptors or properties to intercept writes.<br><br>SimpleStruct provides a simple alternative. Here is a `Point2D` class<br>that provides everything described above.<br><br>```python<br>from numbers import Number      # standard library abstract base class<br>from simplestruct import Struct, Field, TypedField<br><br>class Point2D(Struct):<br>    # Note that field declaration order matters.<br>    x = TypedField(Number)<br>    y = TypedField(Number)<br>```<br><br>Of course, customizations are possible. Type checking is by no means<br>required, objects may be mutable so long as they are not hashed,<br>and you can add your own non-Field attributes and properties.<br><br>```python<br>class Point2D(Struct):<br>    _immutable = False<br>    x = Field<br>    y = Field<br>    <br>    # magnitude won't be considered when hashing or testing equality<br>    @property<br>    def magnitude(self):<br>        return (self.x**2 + self.y**2) ** .5<br>```<br><br>For more usage examples, see the sample files:<br><br>File | Purpose<br>---|---<br>[point.py](examples/point.py) | introduction, basic use<br>[typed.py](examples/typed.py) | type-checked fields<br>[vector.py](examples/vector.py) | advanced features<br>[abstract.py](examples/abstract.py) | mixing structs and metaclasses<br><br>## Comparison and feature matrix ##<br><br>The most important problems mentioned above are solved by using<br>`namedtuple`, but this approach begins to break down when you<br>start to customize classes. To add a property to a `namedtuple`,<br>you must define a subclass:<br><br>```python<br>BasePerson = namedtuple('BasePerson', 'fname lname age')<br>class Person(BasePerson):<br>    @property<br>    def full_name(self):<br>        return self.fname + ' ' + self.lname<br>```<br><br>If on the other hand you want to extend an existing `namedtuple` with<br>new fields, it's a bit harder. You need to regenerate (not inherit)<br>the boilerplate methods so they recognize the new fields. This can be<br>done using multiple inheritance:<br><br>```python<br>BaseEmployee = namedtuple('BaseEmployee', BasePerson._fields + ('salary',))<br>class Employee(BaseEmployee, Person):<br>    pass<br>```<br><br>Implementation wise, `namedtuple` works by dynamically evaluating<br>a templated class definition based on the built-in `tuple` type.<br>This gives it a speed advantage, but is also the main reason why<br>it is less extensible (and unable to handle mutable values).<br><br>In contrast, SimpleStruct is based on metaclasses, descriptors, and<br>dynamic dispatch. The below matrix summarizes the feature comparison.<br><br>Feature | Avoids boilerplate for | Supported by `namedtuple`?<br>---|:---:|:---:<br>easy construction | `__init__()` | \u2713<br>extra attributes on self | | subclasses only<br>pretty printing | `__str()__`, `__repr()__` | \u2713<br>structural equality | `__eq__()` | \u2713<br>easy inheritance | | \u2717<br>optional mutability | | \u2717<br>hashing (if immutable) | `__hash__()` | \u2713<br>pickling / deep-copying |  | \u2713<br>tuple decomposition | `__len__`, `__iter__` | \u2713<br>indexing | `__getitem__`, `__setitem__` | `__getitem__` only<br>optional type checking | `__init__()`, `@property` | \u2717<br>`_asdict()` / `_replace()` | | \u2713<br><br>[MacroPy][2]'s \"case classes\" provide similar functionality, but are<br>implemented in a very different way. Instead of metaclass hacking<br>or source code templating, MacroPy relies on syntactic transformation<br>of the module's AST. This allows for a syntax that's very different<br>from what we've seen above. So different, in fact, that we might view<br>MacroPy as an extension to the Python language rather than as just<br>a library. Case classes are subject to limitations on<br>inheritance and class members.<br><br>## Installation ##<br><br>As with most Python packages, SimpleStruct is available on PyPI:<br><br>```<br>python -m pip install simplestruct<br>```<br><br>Or grab a development version if you're so inclined:<br><br>```<br>python -m pip install https://github.com/brandjon/simplestruct/tree/tarball/develop<br>```<br><br>Python 3.3 and 3.4 are supported. There are no additional dependencies.<br><br>## Developers ##<br><br>Tests can be run with `python setup.py test`, or alternatively by<br>installing [Tox](http://testrun.org/tox/latest/) and running <br>`python -m tox` in the project root. Tox has the advantage of automatically<br>testing under both Python 3.3 and 3.4. Building a source distribution<br>(`python setup.py sdist`) requires the setuptools extension package<br>[setuptools-git](https://github.com/wichert/setuptools-git).<br><br>## References ##<br><br>[1]: https://docs.python.org/3/library/collections.html#collections.namedtuple<br>[[1]] The standard library's `namedtuple` feature<br><br>[2]: https://github.com/lihaoyi/macropy#case-classes<br>[[2]] Li Haoyi's case classes (part of MacroPy)<br><br>[3]: http://harts.net/reece/2013/06/02/using-namedtuples-with-method-and-instance-variable-inheritance/<br>[[3]] Reece Hart's blog post on inheriting from `namedtuple`<br>\n          </div>"}, "last_serial": 2117260, "releases": {"0.2.0": [{"comment_text": "", "digests": {"md5": "e90f0a6aef107f1f4b5915600f676d6c", "sha256": "2a971e0b8d3ad7a3faa70d111d9b2db4b6fbe52b1ef73855cebe2d07bdf84851"}, "downloads": -1, "filename": "SimpleStruct-0.2.0.zip", "has_sig": false, "md5_digest": "e90f0a6aef107f1f4b5915600f676d6c", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 15612, "upload_time": "2014-12-16T01:18:47", "upload_time_iso_8601": "2014-12-16T01:18:47.487764Z", "url": "https://files.pythonhosted.org/packages/eb/42/2cfc725db59c91431fc78a5fa7b4a251e008dedc33d25c43365da5b7b06f/SimpleStruct-0.2.0.zip", "yanked": false}], "0.2.1": [{"comment_text": "", "digests": {"md5": "4e57e3167b54183ad9e2535a6f951836", "sha256": "051c2f1ddb4112cdc8db3df873408dcdded41e8478b53bfc0d71f83df88e883b"}, "downloads": -1, "filename": "SimpleStruct-0.2.1.zip", "has_sig": false, "md5_digest": "4e57e3167b54183ad9e2535a6f951836", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 22242, "upload_time": "2014-12-21T03:05:44", "upload_time_iso_8601": "2014-12-21T03:05:44.448227Z", "url": "https://files.pythonhosted.org/packages/78/68/d36a51c6166026786063505bd37449be38888cdda51c4042d55a04ea1f33/SimpleStruct-0.2.1.zip", "yanked": false}], "0.2.2": [{"comment_text": "", "digests": {"md5": "50f3ba755fef91a3512c3f40a56c18bf", "sha256": "90abf21390843d426be82d4d1da7e14a8b89faac29834e3fe7a06fee13c3d0fd"}, "downloads": -1, "filename": "SimpleStruct-0.2.2.zip", "has_sig": false, "md5_digest": "50f3ba755fef91a3512c3f40a56c18bf", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 23864, "upload_time": "2016-05-15T23:17:26", "upload_time_iso_8601": "2016-05-15T23:17:26.671784Z", "url": "https://files.pythonhosted.org/packages/99/8e/967153785f9a9bfe3c9612abb5564263a67d29bc185e8bc644a7a05fa84c/SimpleStruct-0.2.2.zip", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "50f3ba755fef91a3512c3f40a56c18bf", "sha256": "90abf21390843d426be82d4d1da7e14a8b89faac29834e3fe7a06fee13c3d0fd"}, "downloads": -1, "filename": "SimpleStruct-0.2.2.zip", "has_sig": false, "md5_digest": "50f3ba755fef91a3512c3f40a56c18bf", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 23864, "upload_time": "2016-05-15T23:17:26", "upload_time_iso_8601": "2016-05-15T23:17:26.671784Z", "url": "https://files.pythonhosted.org/packages/99/8e/967153785f9a9bfe3c9612abb5564263a67d29bc185e8bc644a7a05fa84c/SimpleStruct-0.2.2.zip", "yanked": false}], "timestamp": "Fri May  8 03:10:03 2020"}