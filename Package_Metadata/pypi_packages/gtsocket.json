{"info": {"author": "Markus Funke", "author_email": "gtsocket@funke-software.de", "bugtrack_url": null, "classifiers": ["Development Status :: 4 - Beta", "Intended Audience :: Developers", "License :: OSI Approved :: GNU General Public License v3 or later (GPLv3+)", "Operating System :: POSIX :: Linux", "Programming Language :: Python :: 2.7", "Programming Language :: Python :: 3", "Topic :: Communications", "Topic :: Home Automation"], "description": "Introduction\n============\n\nThis package provides the Python module 'gtsocket' which can be used to send commands to (switch on and off) 433Mhz controlled \nsockets (model GT-FSI-11) from the manufacturer 'Globaltronics' and to receive such commands sent by the corresponding remote.\n\nSupported models (known so far) are:\n* Globaltronics: GT-FSI-11 (also sold as EasyHome by ALDI S\u00fcd)\n\nIf you were able to successfully work with another model, please send me an [e-mail](gtsocket@funke-software.de) and I'll update this document.\n\nI'll try to describe this module as completely as possible in this document. If you prefer a quick overview please read at least the sections **Usage** and **Scripts**.\n\nInstallation\n============\n\nThis package can be installed via PIP:\n\n\tpip install gtsocket\n\nor cloned from the GitHub page:\n\n\tgit clone git@github.com:funkesoftware/gtsocket.git\n\nHow it works\n============\n\nAs far as I analysed the protocol, sending commands (on/off) to the sockets by the remote works as follows:\n\nThe remote transmits information by switching on and off sending on 433Mhz. \n\nA **signal** (as used in this document) is a period of time during which sending on 433Mhz is either ON the whole time or OFF the whole time.\nSuch signals are defined as positive or negative integers in the config.\nPositive values mean X microsec ON, negatives mean X microsec OFF, i.e. 300 = 300 microsec ON (receiving a signal on 433Mhz), -2400 = 2400 microsec. OFF (not receiving any signal).\n\nA **signal sequence** (as used in this document) refers to a sequence of signals, for example: [-300, 700] meaning first 300 microsec. OFF, then 700 microsec. ON.\n\nA **data sequence** is a sequence of binary 1s and 0s. An encoding defines how to transmit a data sequence as a signal sequence. For example a 1 might be transmitted as [300, -700] and a 0 as [1000, -200].\n\nEach command as sent from the remote to a socket consists of four parts with the following schema: \n\n\tinit start data end\n\n- the **init** signal sequence: shared by all commands sent in the same encoding\n- the **start** data sequence: shared by all commands\n- the **data** data sequence: shared by one or more socket-command combinations\n- the **end** data sequence: shared by all commands for a specific socket\n\nEach socket-command combination has difference data sequences that work. The remote sends those one after the other. Each command sequence is sent in all available encodings (in my case two) and repeated several times (in my case four times).\n\nIn summary, sending command ON to socket A might look like this:\n\n\tinit start data(A-on1) end(A) [sent in encoding 1 four times]\n\tinit start data(A-on1) end(A) [sent in encoding 2 four times]\n\tinit start data(A-on2) end(A) [sent in encoding 1 four times]\n\tinit start data(A-on2) end(A) [sent in encoding 2 four times]\n\tinit start data(A-on3) end(A) [sent in encoding 1 four times]\n\tinit start data(A-on3) end(A) [sent in encoding 2 four times]\n\tinit start data(A-on4) end(A) [sent in encoding 1 four times]\n\tinit start data(A-on4) end(A) [sent in encoding 2 four times]\n\nThe following configuration section describes how to define the encodings and data sequences for the needed commands.\n\nConfiguration\n=============\n\n(Please see script section below - the gtsocket-setup script provides a wizard for creating a config file.)\n(Please also see the gtsocket.cfg file for a default config with explaining comments.)\n\nIn the [general] section with:\n\n- **receiving_GPIO_pin** and **sending_GPIO_pin** set the Rasperry Pi GPIO BCM pin numbers the 433Mhz receiver and sender are connected to\n- **max_signal_difference** define the maximum difference between the measured signal length and the signal length defined in an encoding for the measured signal to be recognized as the defined signal (in percent)\n- **sequence_min_length** define the minimum length of a sequence of signals to be considered valid, shorter sequences will not trigger a signal/command \nhandler\n- **sequence_repetitions** define how often a command signal sequence is repeated using a given encoding when sending a command (the manufacturer's \nremote repeats four times)\n\nThe command signal sequences are sent in different encodings. My remote sends commands in two different encodings and I assume other remotes use the same encodings. So you probably can keep the default config here. The encodings are defined as follows:\n\n\t[encoding:1]\n\tinit=300,-2400\n\t1=1000,-500\n\t0=300,-1200\n\nThe section must be named [encoding:NAME]. The NAME of the encoding can be chosen freely (but you should better omit whitespace characters).\nEach command sequence starts with an init sequence consisting of two signals, each binary 1 and each binary 0 is encoded as two signals each.\n\nSockets switched by the same remote share the same encodings and the same start data sequence. Those are defined in a [group:NAME] section.\n\n\t[group:1]\n\tencodings=1,2\n\tstart_data=1110\n\nWith **encodings** define the names of the encodings and with **start_data** the start data sequence used by the group of sockets.\n\nEach individual socket is defined in a [socket:NAME] section.\n\n\t[socket:A]\n\tgroup=1\n\ton_command_data=1101111110100110,0111001011010001,1100011110010101,1001101101011010\n\toff_command_data=0100001101100010,0001000000101000,1011111011101011,0000100100000111\n\tend_data=1100\n\nWith **group** define the group of sockets this socket belongs to. With **end_data** define the end data sequence this socket uses. With **on_command_data** and **off_command_data** define the data sequences for commands ON and OFF as a comma-separated list. Some socket-command combinations share the same data sequences. For my sockets the data sequences for A-on and C-off are the same. In such cases you can reuse the data sequences of another socket as follows:\n\n\t[socket:C]\n\toff_command_data=socket:A|on_command_data\n\nUsage\n=====\n\nMake sure you complete the configuration part first. The default configuration will most probably not work with your sockets. The `bin/gtsocket-setup` script provides a wizard for creating a config file specific for your setup.\nPlease have a look at the `bin/gtsocket-test` script which contains working examples for sending and receiving commands.\n\nSending commands\n----------------\n\nAfter importing the module\n\n\timport gtsocket\n\ninitialize GPIOs of Raspberry Pi as configured in config file. This configures sending pin as output pin and \nreceiving pin as input pin. This has to be done only once at the beginning of the script, **not** every time a command is sent.\n\n\tgtsocket.initialize_GPIOs()\n\nCreate socket object specifying the name (as defined in the config) of the socket the command should be sent to ('A' in this case) and send command 'on' \nto (switch on) this socket.\n\n\tsocket = gtsocket.Socket('A')\n\tsocket.send_command('on')\n\nClear GPIOs of Raspberry Pi which have been initialized with initialize_GPIOs(). This sets those pins back to input mode.\nThis has to be done only once at the end of the script, **not** every time a command is sent.\n\n\tgtsocket.clear_GPIOs()\n\nReceiving commands\n------------------\n\nImport module:\n\n\timport gtsocket\n\nInitialize GPIOs of Raspberry Pi as described in *sending commands*:\n\n\tgtsocket.initialize_GPIOs()\n\nCreate socket object, which commands should be received for:\n\n\tsocket = gtsocket.Socket('A')\n\nRegister any function as a command handler for this socket:\n\n\tsocket.add_command_handler(my_command_handler)\n\nThe function will receive the socket object and the command received as arguments. It might for example look like this:\n\n\tdef my_command_handler(socket, command):\n\t\tprint(\"Received command\", command, \"for socket\", socket.get_name())\n\nStart receiving commands for this socket. This will create a new thread which does the receiving. The thread is saved in \n`socket.receiving_thread` and returned by `start_receiving()`.\n\n\tsocket.start_receiving()\n\nOnce you want to stop receiving:\n\n\tsocket.stop_receiving()\n\tsocket.receiving_thread.join()\n\nClear GPIOs of Raspberry Pi as described in *sending commands*.\n\n\tgtsocket.clear_GPIOs()\n\nScripts\n=======\n\nWhen installed via pip the commands `gtsocket-setup` and `gtsocket-test` are available (otherwise you'll find them in the `bin/` folder).\n`gtsocket-setup` is a helper tool to find out the correct encoding and signal/data sequences for your specific sockets and \ncreate a config file for your setup. \n`gtsocket-test` serves as a demo which shows how to use the module and can be used to manually send commands and test if \nreceiving commands works.\n\nSetup script - gtsocket-setup\n----------------------------------\n\nExecute script with `gtsocket-setup` and follow the instructions. A config file specific for your setup will be created as `~/.gtsocket/config.ini`.\n\nThe setup script consists of three steps: *pins*, *encodings* and *sequences*.\nInvoking the script without any option will start with the first step. \nWith the option **-s / --step** you can directly jump to a certain step.\n\nAt the beginning of the script (regardless of the step) you are asked which group of sockets you want to create the config for. A group of sockets are \nthose sockets controlled by the same remote. You can choose a name freely but you should avoid whitespace characters.\n\n**pins** defines the GPIO pins the sending and receiving devices are connected to.\n\n**encodings** is used to determine the encodings your remote uses to send the data (how long the signals sent via radio are, which are used to \nsend binary 1s and 0s). (Please see also sections *How it works* and *Configuration*)\n\nYou'll be asked to press and hold a button on your remote so that the script can receive transmitted signals and determine the encoding (with your help).\nAfter that you'll get an overview of the received signals which should look similar to this:\n\n\tP(0)=-200, P(1)=800, P(2)=-500, P(3)=1000, P(4)=200, P(5)=-100, P(6)=300, P(7)=-1200, P(8)=-1300, P(9)=-2400, P(a)=1100, P(b)=2900, P(c)=-7300, P(d)=900, P(e)=-600, P(f)=400, P(10)=-1100, P(11)=-5700, P(12)=100, P(13)=-1500, P(14)=-1400, P(15)=-1000, P(16)=-400, P(17)=700, P(18)=-800, P(19)=3000, P(1a)=600, P(1b)=-2500, P(1c)=-3400, P(1d)=-900, P(1e)=-700\n\tReceived signals: 0.1.2.3.2.4.5.1.2.6.7.6.8.3.2.6.8.3.2.3.2.6.8.3.2.4.8.6.7.6.8.3.2.3.2.3.2.4.8.6.8.6.9.3.2.a.2.3.2.6.8.6.8.3.2.3.2.a.2.6.7.6.8.a.2.4.8.a.2.3.2.6.7.3.2.6.7.6.7.6.8.a.2.3.2.3.2.6.8.6.8.6.9.a.2.3.2.3.2.6.8.6.7.a.\n\t2.3.2.3.2.6.8.6.8.3.2.4.8.3.2.3.2.6.8.3.2.6.8.6.8.6.8.3.2.a.2.3.2.6.8.6.8.b.c.d.e.d.e.d.e.f.10.f.10.d.e.3.e.d.e.f.10.f.7.d.e.f.10.f.11.12.13.12.14.12.13.12.0.12.0.12.15.12.16.12.15.12.0.12.7.12.13.12.5.12.8.4.5.12.5.12.5.12.5.12.5.12.5.12.5.12.5.12.5.12.5.12.5.12.5.12.5.\n\t12.5.12.5.12.5.12.c.d.e.d.e.d.e.f.7.f.10.d.e.d.e.d.e.f.7.f.10.d.e.f.10.d.e.d.e.f.7.d.e.f.10.f.10.f.10.d.e.d.e.d.e.f.10.f.10.b.c.d.e.d.e.d.e.f.10.f.10.d.e.d.e.d.e.f.10.f.10.d.e.f.10.d.e.d.e.f.10.d.e.f.10.f.10.f.10.d.e.d.e.17.18.f.10.f.10.19.c.d.e.d.e.d.e.f.10.f.\n\t10.d.e.d.e.d.e.f.10.f.10.1a.1b.12.0.12.16.12.18.12.1c.12.0.12.1d.12.0.12.7.12.5.12.8.12.5.12.8.12.5.12.5.12.5.12.5.12.e.d.e.d.e.f.10.f.7.6.9.3.2.a.2.3.2.6.7.a.2.3.2.6.7.6.7.6.7.3.2.3.2.3.2.3.2.6.7.6.7.3.2.6.8.3.2.6.7.3.2.3.2.3.2.6.8.6.8.6.9.3.2.3.2.3.2.6.8.3.2.a.2.6.7.\n\t6.7.6.7.a.2.3.2.3.2.3.2.6.7.6.7.3.2.6.8.3.2.6.8.3.2.3.2.3.2.6.7.6.7.6.9.3.2.3.2.3.2.6.7.a.2.3.2.6.8.6.8.6.8.3.2.3.2.3.2.3.2.6.7.6.8.3.2.6.8.3.2.6.7.3.2.3.2.3.2.6.8.6.8.6.9.3.2.3.2.3.2.6.7.a.2.3.2.6.7.6.7.6.8.3.2.3.2.a.2.3.2.\n\t6.8.6.7.3.2.6.8.3.2.6.8.3.2.3.2.3.2.6.8.6.8.b.c.d.e.d.e.d.e.f.10.d.e.d.e.f.10.f.10.f.10.d.e.d.e.d.e.d.e.f.10.f.10.d.e.f.10.d.e.f.10.d.e.d.e.d.e.f.10.f.10.19.c.d.e.d.e.d.e.f.10.d.e.d.e.f.10.f.10.f.10.d.e.d.e.d.e.d.e.f.10.f.10.d.e.f.10.d.e.f.10.d.e.d.e.d.e.f.10.f.10.19.\n\tc.d.e.d.e.d.e.f.10.d.e.d.e.f.10.f.10.f.10.d.e.d.e.d.e.d.e.f.10.f.10.d.e.f.10.d.e.f.10.d.e.d.e.d.e.f.10.f.10.19.c.d.e.d.e.d.e.f.10.d.e.d.e.f.10.f.10.f.10.d.e.d.e.d.1e.d.e.f.10.f.10.d.e.f.10.d.e.f.10.d.e.d.e.d.e.f.10.f.\n\nThe first line is a legend and shows how (with which indices) the received signals are shown to you below. Received signals are separated by dots and each number corresponds to a received signal. In this example a \"0\" means we received a low signal of 200\u00b5s and a \"6\" means we received a high signal of 300\u00b5s.\n\nNow you have to specify which signals you think belong to the actual command signals and which are noise. This looks more complicated than it is. Just look which indices repeat in the sequence and which do not. In this example the indices \"0\" and \"1\" you can find in the beginning but they do not appear later, so they are most probably noise. \"3\", \"8\", \"10\" for example appear pretty often.\n\nNow decide which indices to keep (command signals) and which to dismiss (noise). You do not have to be 100% correct on the first try. Just keep those you are sure are command signals and those you are not sure about. You'll repeat this until you are pretty sure about the command signals. Better keep too many than too few. A couple of wrong signals won't harm that much later. (Reading *How it works* and *Configuration* will help you here.)\n\nOnce you have narrowed down the command signals long enough you should see something like this (The dots disappear once we don't need them anymore to distinguish between indices like \"1\", \"0\" and \"10\"):\n\n\tP(0)=300, P(1)=-2400, P(2)=1000, P(3)=-500, P(4)=-1200, P(5)=2900, P(6)=-7300, P(7)=900, P(8)=-600, P(9)=400, P(a)=-1100\n\tReceived signals: 04787878949401232323042304042323042323042304232304230423230404012323230423040423230423230423042323042304232304040123232304710404040404040403000003030400000000000800030003080004280423000000000003040401232323042304042323042323042304232304230423230404567878789a789a9a78789a78789a789a78789a789a7\n\t8789a9a567878789a789a9a78789a78789a789a78789a789a78789a9a567878789a789a9a78789a78789a789a78789a789a78789a9a567878789a789a9a78789a78789a789a78789a789a78789a9401232323042323042323232323230423040423230423230404012323230423230423232323232304230404232304232304040123232304232304232323232323042304\n\t042323042323040401232323042323042323232323230423040423230423230404567878789a78789a7878787878789a789a9a78789a78789a94567878789a78789a7878787878789a789a9a78789a78789a9a567878789a78789a7878787878789a789a9a78789a78789a94567878789478789a7878787878789a789a9a78789a78789a940123232304042323230404230\n\t4232304230404042323230404012323230404232323040423042323042304040423232304040123232304042323230404230423230423040404232323040401232323040423232304042304232304230404042323230404567878789a9a7878789a9a789a78789a789a9a9a7878789a9a567878789a9a7878789a9a789a78789a789a9a9a7878789a9a567878789a9a7878\n\t789a9a789a78789a789a9a9a7878789a9a567878789a9a7878789a9a789a78789a789a9a9a7878789a94012323230423230404042323232304042304230423232304040123232304232304040423232323040423042304232323040401232323042323040404232323230404230423042323230404012323230423230404042323232304042304230423232304045678787\n\t89a7878949a9a787878789a9a789a789a7878789a9a567878789a7878949a9a787878789a9a789a789a7878789a9a567878789a78789a9a9a787878789a9a789a789a7878789a9a567878789a78789a9a9a787878789a9a789a789a7878789a9401232323042304042323042323042304232304230423230404012323230423040423230423230423042323042304232304\n\t040123232304230404232304232304230423230423042323040401232323042304042323042323042304232304230423230404567878789a789a9a78789a78789a789a78789a789a78789a94567878789a789a9a78789a78789a789a787894789a78789a9a567878789a789a9a78789a78789a789a78789a789a78789a9a567878789a789a9a78789a78789a789a78789a7\n\t89a78789a9401232323042323042323232323230423040423230423230404012323230423230423232323232304230\n\nAfter choosing a name for the encoding (you can choose freely but I suggest to keep the default) you'll be asked to give the signal sequences for \"init\", \"binary 1\" and \"binary 0\". Those have to be extracted from the received signal sequence above. Once you've understood the underlying system (see sections *How it works* and *Configuration*) those are easy to spot:\n\nIn the received signal sequence you should find repeating patterns which start with an \"init\" sequence consisting of two signals followed by a sequence of binary 1s and 0s each encoding by two signals. The received signal sequence above for example contains the following patterns:\n\n\t047878789494 (initial rubbish)\n\t01232323042304042323042323042304232304230423230404 (init sequence 01, followed by pairs of 23 and 04)\n\t01232323042304042323042323042304232304230423230404\n\t012323230471\n\tLater on:\n\t567878789a789a9a78789a78789a789a78789a789a78789a9a (init sequence 56, followed by pairs of 78 and 9a)\n\t567878789a789a9a78789a78789a789a78789a789a78789a9a\n\t567878789a789a9a78789a78789a789a78789a789a78789a9a\n\t567878789a789a9a78789a78789a789a78789a789a78789a94\n\nThose are your encodings:\n\n - Encoding 1: 01 = Init, 23 = binary 1, 04 = binary 0\n - Encoding 2: 56 = Init, 78 = binary 1, 9a = binary 0\n\nWhich one you define as binary 1 and which as binary 0 does not matter. But you have to be consistent between the two encodings. You might have noticed that `01232323042304042323042323042304232304230423230404` and `567878789a789a9a78789a78789a789a78789a789a78789a9a` encode the same data just with two different encodings. So if you choose to set `23` as binary 1 you also have to set `78` as binary 1.\n\n**sequences** is used to determine the actual data that is sent for each command (like \"switch on socket A\").\n\nFor that you have to determine the data which is sent for each button (socket command combination) you want to be able to use.\nPlease follow the instructions of the script. You should get an output similar to the following. (If not, you most probably made a mistake during the \"encodings\" step. Please try to redo it.):\n\n\t1110-1100011110010101-1100\n\t1110-1100011110010101-1100\n\t1110-1100-0111\n\t1110-1100\n\t1110-110001111001010-1110\n\t1110-110001-1110\n\t1110-1001101101011010-1100\n\t1110-1001101101011010-1100\n\t1110-1001101101011010-1100\n\t1110-1001101101011010-1100\n\t1110-1001101101011010-1100\n\t1110-1001101101011010-1100\n\t1110-1001101101011010-1100\n\t1110-100110110101101-0110\n\t1110-1101111110100110-1100\n\t1110-1101111110100110-1100\n\t1110-1101111110100110-1100\n\t1110-1101111110100110-1100\n\t1110-1101111110100110-1100\n\t1110-1101111110100110-1100\n\t1110-1101111110100110-1100\n\t1110-11011111101001-1011\n\t1110-0111001011010001-1100\n\t[...]\n\nAs you can see each set of data is sent eight times (4 times in encoding 1 and 4 times in encoding 2 (you cannot see the different encodings here)). Now you have to tell the script the \"start data\", \"data sequence\" and \"end data\" for each button (socket command combination). The \"start data\" should be the same for all buttons, the \"end data\" should be unique for each socket (not button!) and you should be able to see four different \"data sequences\". The script helps to distinguish between the three by separating them with dashes. In this example the \"start data\" is `1110`, the \"end data\" is `1100` and the \"data sequences\" are `1100011110010101`, `1001101101011010`, `1101111110100110` and `0111001011010001` (the last one was be repated, too, but was truncated here).\n\nOnce you have found all the data sent with the buttons on your remote, you'll find your config file specific for your sockets in `~/.gtsocket/config.ini` and you are ready to go and test with the `gtsocket-test` script.\n\nTesting script - gtsocket-test\n------------------------------\n\nUse the following command to send a command to a specific socket (in this example send command 'on' to socket 'A'):\n\n\tgtsocket-test -m send -s A -c on\n\nTo receive and print to stdout commands for a specific socket for a certain amount of time (in this example socket 'B' for 5 sec):\n\n\tgtsocket-test -m receive -s B -t 5\n\nKnown issues\n============\n\n - Receiving signals/commands from the remote for multiple sockets at the same time does not work well. \n\tIn that case many signals are not recognized correctly which leads to commands not being detected.\n\n\n", "description_content_type": "", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/funkesoftware/gtsocket", "keywords": "radio socket 433Mhz Globaltronics GT-FSI-11 RPi EasyHome", "license": "GPLv3+", "maintainer": "", "maintainer_email": "", "name": "gtsocket", "package_url": "https://pypi.org/project/gtsocket/", "platform": "", "project_url": "https://pypi.org/project/gtsocket/", "project_urls": {"Homepage": "https://github.com/funkesoftware/gtsocket"}, "release_url": "https://pypi.org/project/gtsocket/0.1/", "requires_dist": ["configparser", "future"], "requires_python": "", "summary": "Receive and/or send commands to radio controlled sockets (model GT-FSI-11) from brand \"Globaltronics\".", "version": "0.1", "yanked": false, "html_description": "<div class=\"project-description\">\n            Introduction<br>============<br><br>This package provides the Python module 'gtsocket' which can be used to send commands to (switch on and off) 433Mhz controlled <br>sockets (model GT-FSI-11) from the manufacturer 'Globaltronics' and to receive such commands sent by the corresponding remote.<br><br>Supported models (known so far) are:<br>* Globaltronics: GT-FSI-11 (also sold as EasyHome by ALDI S\u00fcd)<br><br>If you were able to successfully work with another model, please send me an [e-mail](gtsocket@funke-software.de) and I'll update this document.<br><br>I'll try to describe this module as completely as possible in this document. If you prefer a quick overview please read at least the sections **Usage** and **Scripts**.<br><br>Installation<br>============<br><br>This package can be installed via PIP:<br><br>\tpip install gtsocket<br><br>or cloned from the GitHub page:<br><br>\tgit clone git@github.com:funkesoftware/gtsocket.git<br><br>How it works<br>============<br><br>As far as I analysed the protocol, sending commands (on/off) to the sockets by the remote works as follows:<br><br>The remote transmits information by switching on and off sending on 433Mhz. <br><br>A **signal** (as used in this document) is a period of time during which sending on 433Mhz is either ON the whole time or OFF the whole time.<br>Such signals are defined as positive or negative integers in the config.<br>Positive values mean X microsec ON, negatives mean X microsec OFF, i.e. 300 = 300 microsec ON (receiving a signal on 433Mhz), -2400 = 2400 microsec. OFF (not receiving any signal).<br><br>A **signal sequence** (as used in this document) refers to a sequence of signals, for example: [-300, 700] meaning first 300 microsec. OFF, then 700 microsec. ON.<br><br>A **data sequence** is a sequence of binary 1s and 0s. An encoding defines how to transmit a data sequence as a signal sequence. For example a 1 might be transmitted as [300, -700] and a 0 as [1000, -200].<br><br>Each command as sent from the remote to a socket consists of four parts with the following schema: <br><br>\tinit start data end<br><br>- the **init** signal sequence: shared by all commands sent in the same encoding<br>- the **start** data sequence: shared by all commands<br>- the **data** data sequence: shared by one or more socket-command combinations<br>- the **end** data sequence: shared by all commands for a specific socket<br><br>Each socket-command combination has difference data sequences that work. The remote sends those one after the other. Each command sequence is sent in all available encodings (in my case two) and repeated several times (in my case four times).<br><br>In summary, sending command ON to socket A might look like this:<br><br>\tinit start data(A-on1) end(A) [sent in encoding 1 four times]<br>\tinit start data(A-on1) end(A) [sent in encoding 2 four times]<br>\tinit start data(A-on2) end(A) [sent in encoding 1 four times]<br>\tinit start data(A-on2) end(A) [sent in encoding 2 four times]<br>\tinit start data(A-on3) end(A) [sent in encoding 1 four times]<br>\tinit start data(A-on3) end(A) [sent in encoding 2 four times]<br>\tinit start data(A-on4) end(A) [sent in encoding 1 four times]<br>\tinit start data(A-on4) end(A) [sent in encoding 2 four times]<br><br>The following configuration section describes how to define the encodings and data sequences for the needed commands.<br><br>Configuration<br>=============<br><br>(Please see script section below - the gtsocket-setup script provides a wizard for creating a config file.)<br>(Please also see the gtsocket.cfg file for a default config with explaining comments.)<br><br>In the [general] section with:<br><br>- **receiving_GPIO_pin** and **sending_GPIO_pin** set the Rasperry Pi GPIO BCM pin numbers the 433Mhz receiver and sender are connected to<br>- **max_signal_difference** define the maximum difference between the measured signal length and the signal length defined in an encoding for the measured signal to be recognized as the defined signal (in percent)<br>- **sequence_min_length** define the minimum length of a sequence of signals to be considered valid, shorter sequences will not trigger a signal/command <br>handler<br>- **sequence_repetitions** define how often a command signal sequence is repeated using a given encoding when sending a command (the manufacturer's <br>remote repeats four times)<br><br>The command signal sequences are sent in different encodings. My remote sends commands in two different encodings and I assume other remotes use the same encodings. So you probably can keep the default config here. The encodings are defined as follows:<br><br>\t[encoding:1]<br>\tinit=300,-2400<br>\t1=1000,-500<br>\t0=300,-1200<br><br>The section must be named [encoding:NAME]. The NAME of the encoding can be chosen freely (but you should better omit whitespace characters).<br>Each command sequence starts with an init sequence consisting of two signals, each binary 1 and each binary 0 is encoded as two signals each.<br><br>Sockets switched by the same remote share the same encodings and the same start data sequence. Those are defined in a [group:NAME] section.<br><br>\t[group:1]<br>\tencodings=1,2<br>\tstart_data=1110<br><br>With **encodings** define the names of the encodings and with **start_data** the start data sequence used by the group of sockets.<br><br>Each individual socket is defined in a [socket:NAME] section.<br><br>\t[socket:A]<br>\tgroup=1<br>\ton_command_data=1101111110100110,0111001011010001,1100011110010101,1001101101011010<br>\toff_command_data=0100001101100010,0001000000101000,1011111011101011,0000100100000111<br>\tend_data=1100<br><br>With **group** define the group of sockets this socket belongs to. With **end_data** define the end data sequence this socket uses. With **on_command_data** and **off_command_data** define the data sequences for commands ON and OFF as a comma-separated list. Some socket-command combinations share the same data sequences. For my sockets the data sequences for A-on and C-off are the same. In such cases you can reuse the data sequences of another socket as follows:<br><br>\t[socket:C]<br>\toff_command_data=socket:A|on_command_data<br><br>Usage<br>=====<br><br>Make sure you complete the configuration part first. The default configuration will most probably not work with your sockets. The `bin/gtsocket-setup` script provides a wizard for creating a config file specific for your setup.<br>Please have a look at the `bin/gtsocket-test` script which contains working examples for sending and receiving commands.<br><br>Sending commands<br>----------------<br><br>After importing the module<br><br>\timport gtsocket<br><br>initialize GPIOs of Raspberry Pi as configured in config file. This configures sending pin as output pin and <br>receiving pin as input pin. This has to be done only once at the beginning of the script, **not** every time a command is sent.<br><br>\tgtsocket.initialize_GPIOs()<br><br>Create socket object specifying the name (as defined in the config) of the socket the command should be sent to ('A' in this case) and send command 'on' <br>to (switch on) this socket.<br><br>\tsocket = gtsocket.Socket('A')<br>\tsocket.send_command('on')<br><br>Clear GPIOs of Raspberry Pi which have been initialized with initialize_GPIOs(). This sets those pins back to input mode.<br>This has to be done only once at the end of the script, **not** every time a command is sent.<br><br>\tgtsocket.clear_GPIOs()<br><br>Receiving commands<br>------------------<br><br>Import module:<br><br>\timport gtsocket<br><br>Initialize GPIOs of Raspberry Pi as described in *sending commands*:<br><br>\tgtsocket.initialize_GPIOs()<br><br>Create socket object, which commands should be received for:<br><br>\tsocket = gtsocket.Socket('A')<br><br>Register any function as a command handler for this socket:<br><br>\tsocket.add_command_handler(my_command_handler)<br><br>The function will receive the socket object and the command received as arguments. It might for example look like this:<br><br>\tdef my_command_handler(socket, command):<br>\t\tprint(\"Received command\", command, \"for socket\", socket.get_name())<br><br>Start receiving commands for this socket. This will create a new thread which does the receiving. The thread is saved in <br>`socket.receiving_thread` and returned by `start_receiving()`.<br><br>\tsocket.start_receiving()<br><br>Once you want to stop receiving:<br><br>\tsocket.stop_receiving()<br>\tsocket.receiving_thread.join()<br><br>Clear GPIOs of Raspberry Pi as described in *sending commands*.<br><br>\tgtsocket.clear_GPIOs()<br><br>Scripts<br>=======<br><br>When installed via pip the commands `gtsocket-setup` and `gtsocket-test` are available (otherwise you'll find them in the `bin/` folder).<br>`gtsocket-setup` is a helper tool to find out the correct encoding and signal/data sequences for your specific sockets and <br>create a config file for your setup. <br>`gtsocket-test` serves as a demo which shows how to use the module and can be used to manually send commands and test if <br>receiving commands works.<br><br>Setup script - gtsocket-setup<br>----------------------------------<br><br>Execute script with `gtsocket-setup` and follow the instructions. A config file specific for your setup will be created as `~/.gtsocket/config.ini`.<br><br>The setup script consists of three steps: *pins*, *encodings* and *sequences*.<br>Invoking the script without any option will start with the first step. <br>With the option **-s / --step** you can directly jump to a certain step.<br><br>At the beginning of the script (regardless of the step) you are asked which group of sockets you want to create the config for. A group of sockets are <br>those sockets controlled by the same remote. You can choose a name freely but you should avoid whitespace characters.<br><br>**pins** defines the GPIO pins the sending and receiving devices are connected to.<br><br>**encodings** is used to determine the encodings your remote uses to send the data (how long the signals sent via radio are, which are used to <br>send binary 1s and 0s). (Please see also sections *How it works* and *Configuration*)<br><br>You'll be asked to press and hold a button on your remote so that the script can receive transmitted signals and determine the encoding (with your help).<br>After that you'll get an overview of the received signals which should look similar to this:<br><br>\tP(0)=-200, P(1)=800, P(2)=-500, P(3)=1000, P(4)=200, P(5)=-100, P(6)=300, P(7)=-1200, P(8)=-1300, P(9)=-2400, P(a)=1100, P(b)=2900, P(c)=-7300, P(d)=900, P(e)=-600, P(f)=400, P(10)=-1100, P(11)=-5700, P(12)=100, P(13)=-1500, P(14)=-1400, P(15)=-1000, P(16)=-400, P(17)=700, P(18)=-800, P(19)=3000, P(1a)=600, P(1b)=-2500, P(1c)=-3400, P(1d)=-900, P(1e)=-700<br>\tReceived signals: 0.1.2.3.2.4.5.1.2.6.7.6.8.3.2.6.8.3.2.3.2.6.8.3.2.4.8.6.7.6.8.3.2.3.2.3.2.4.8.6.8.6.9.3.2.a.2.3.2.6.8.6.8.3.2.3.2.a.2.6.7.6.8.a.2.4.8.a.2.3.2.6.7.3.2.6.7.6.7.6.8.a.2.3.2.3.2.6.8.6.8.6.9.a.2.3.2.3.2.6.8.6.7.a.<br>\t2.3.2.3.2.6.8.6.8.3.2.4.8.3.2.3.2.6.8.3.2.6.8.6.8.6.8.3.2.a.2.3.2.6.8.6.8.b.c.d.e.d.e.d.e.f.10.f.10.d.e.3.e.d.e.f.10.f.7.d.e.f.10.f.11.12.13.12.14.12.13.12.0.12.0.12.15.12.16.12.15.12.0.12.7.12.13.12.5.12.8.4.5.12.5.12.5.12.5.12.5.12.5.12.5.12.5.12.5.12.5.12.5.12.5.12.5.<br>\t12.5.12.5.12.5.12.c.d.e.d.e.d.e.f.7.f.10.d.e.d.e.d.e.f.7.f.10.d.e.f.10.d.e.d.e.f.7.d.e.f.10.f.10.f.10.d.e.d.e.d.e.f.10.f.10.b.c.d.e.d.e.d.e.f.10.f.10.d.e.d.e.d.e.f.10.f.10.d.e.f.10.d.e.d.e.f.10.d.e.f.10.f.10.f.10.d.e.d.e.17.18.f.10.f.10.19.c.d.e.d.e.d.e.f.10.f.<br>\t10.d.e.d.e.d.e.f.10.f.10.1a.1b.12.0.12.16.12.18.12.1c.12.0.12.1d.12.0.12.7.12.5.12.8.12.5.12.8.12.5.12.5.12.5.12.5.12.e.d.e.d.e.f.10.f.7.6.9.3.2.a.2.3.2.6.7.a.2.3.2.6.7.6.7.6.7.3.2.3.2.3.2.3.2.6.7.6.7.3.2.6.8.3.2.6.7.3.2.3.2.3.2.6.8.6.8.6.9.3.2.3.2.3.2.6.8.3.2.a.2.6.7.<br>\t6.7.6.7.a.2.3.2.3.2.3.2.6.7.6.7.3.2.6.8.3.2.6.8.3.2.3.2.3.2.6.7.6.7.6.9.3.2.3.2.3.2.6.7.a.2.3.2.6.8.6.8.6.8.3.2.3.2.3.2.3.2.6.7.6.8.3.2.6.8.3.2.6.7.3.2.3.2.3.2.6.8.6.8.6.9.3.2.3.2.3.2.6.7.a.2.3.2.6.7.6.7.6.8.3.2.3.2.a.2.3.2.<br>\t6.8.6.7.3.2.6.8.3.2.6.8.3.2.3.2.3.2.6.8.6.8.b.c.d.e.d.e.d.e.f.10.d.e.d.e.f.10.f.10.f.10.d.e.d.e.d.e.d.e.f.10.f.10.d.e.f.10.d.e.f.10.d.e.d.e.d.e.f.10.f.10.19.c.d.e.d.e.d.e.f.10.d.e.d.e.f.10.f.10.f.10.d.e.d.e.d.e.d.e.f.10.f.10.d.e.f.10.d.e.f.10.d.e.d.e.d.e.f.10.f.10.19.<br>\tc.d.e.d.e.d.e.f.10.d.e.d.e.f.10.f.10.f.10.d.e.d.e.d.e.d.e.f.10.f.10.d.e.f.10.d.e.f.10.d.e.d.e.d.e.f.10.f.10.19.c.d.e.d.e.d.e.f.10.d.e.d.e.f.10.f.10.f.10.d.e.d.e.d.1e.d.e.f.10.f.10.d.e.f.10.d.e.f.10.d.e.d.e.d.e.f.10.f.<br><br>The first line is a legend and shows how (with which indices) the received signals are shown to you below. Received signals are separated by dots and each number corresponds to a received signal. In this example a \"0\" means we received a low signal of 200\u00b5s and a \"6\" means we received a high signal of 300\u00b5s.<br><br>Now you have to specify which signals you think belong to the actual command signals and which are noise. This looks more complicated than it is. Just look which indices repeat in the sequence and which do not. In this example the indices \"0\" and \"1\" you can find in the beginning but they do not appear later, so they are most probably noise. \"3\", \"8\", \"10\" for example appear pretty often.<br><br>Now decide which indices to keep (command signals) and which to dismiss (noise). You do not have to be 100% correct on the first try. Just keep those you are sure are command signals and those you are not sure about. You'll repeat this until you are pretty sure about the command signals. Better keep too many than too few. A couple of wrong signals won't harm that much later. (Reading *How it works* and *Configuration* will help you here.)<br><br>Once you have narrowed down the command signals long enough you should see something like this (The dots disappear once we don't need them anymore to distinguish between indices like \"1\", \"0\" and \"10\"):<br><br>\tP(0)=300, P(1)=-2400, P(2)=1000, P(3)=-500, P(4)=-1200, P(5)=2900, P(6)=-7300, P(7)=900, P(8)=-600, P(9)=400, P(a)=-1100<br>\tReceived signals: 04787878949401232323042304042323042323042304232304230423230404012323230423040423230423230423042323042304232304040123232304710404040404040403000003030400000000000800030003080004280423000000000003040401232323042304042323042323042304232304230423230404567878789a789a9a78789a78789a789a78789a789a7<br>\t8789a9a567878789a789a9a78789a78789a789a78789a789a78789a9a567878789a789a9a78789a78789a789a78789a789a78789a9a567878789a789a9a78789a78789a789a78789a789a78789a9401232323042323042323232323230423040423230423230404012323230423230423232323232304230404232304232304040123232304232304232323232323042304<br>\t042323042323040401232323042323042323232323230423040423230423230404567878789a78789a7878787878789a789a9a78789a78789a94567878789a78789a7878787878789a789a9a78789a78789a9a567878789a78789a7878787878789a789a9a78789a78789a94567878789478789a7878787878789a789a9a78789a78789a940123232304042323230404230<br>\t4232304230404042323230404012323230404232323040423042323042304040423232304040123232304042323230404230423230423040404232323040401232323040423232304042304232304230404042323230404567878789a9a7878789a9a789a78789a789a9a9a7878789a9a567878789a9a7878789a9a789a78789a789a9a9a7878789a9a567878789a9a7878<br>\t789a9a789a78789a789a9a9a7878789a9a567878789a9a7878789a9a789a78789a789a9a9a7878789a94012323230423230404042323232304042304230423232304040123232304232304040423232323040423042304232323040401232323042323040404232323230404230423042323230404012323230423230404042323232304042304230423232304045678787<br>\t89a7878949a9a787878789a9a789a789a7878789a9a567878789a7878949a9a787878789a9a789a789a7878789a9a567878789a78789a9a9a787878789a9a789a789a7878789a9a567878789a78789a9a9a787878789a9a789a789a7878789a9401232323042304042323042323042304232304230423230404012323230423040423230423230423042323042304232304<br>\t040123232304230404232304232304230423230423042323040401232323042304042323042323042304232304230423230404567878789a789a9a78789a78789a789a78789a789a78789a94567878789a789a9a78789a78789a789a787894789a78789a9a567878789a789a9a78789a78789a789a78789a789a78789a9a567878789a789a9a78789a78789a789a78789a7<br>\t89a78789a9401232323042323042323232323230423040423230423230404012323230423230423232323232304230<br><br>After choosing a name for the encoding (you can choose freely but I suggest to keep the default) you'll be asked to give the signal sequences for \"init\", \"binary 1\" and \"binary 0\". Those have to be extracted from the received signal sequence above. Once you've understood the underlying system (see sections *How it works* and *Configuration*) those are easy to spot:<br><br>In the received signal sequence you should find repeating patterns which start with an \"init\" sequence consisting of two signals followed by a sequence of binary 1s and 0s each encoding by two signals. The received signal sequence above for example contains the following patterns:<br><br>\t047878789494 (initial rubbish)<br>\t01232323042304042323042323042304232304230423230404 (init sequence 01, followed by pairs of 23 and 04)<br>\t01232323042304042323042323042304232304230423230404<br>\t012323230471<br>\tLater on:<br>\t567878789a789a9a78789a78789a789a78789a789a78789a9a (init sequence 56, followed by pairs of 78 and 9a)<br>\t567878789a789a9a78789a78789a789a78789a789a78789a9a<br>\t567878789a789a9a78789a78789a789a78789a789a78789a9a<br>\t567878789a789a9a78789a78789a789a78789a789a78789a94<br><br>Those are your encodings:<br><br> - Encoding 1: 01 = Init, 23 = binary 1, 04 = binary 0<br> - Encoding 2: 56 = Init, 78 = binary 1, 9a = binary 0<br><br>Which one you define as binary 1 and which as binary 0 does not matter. But you have to be consistent between the two encodings. You might have noticed that `01232323042304042323042323042304232304230423230404` and `567878789a789a9a78789a78789a789a78789a789a78789a9a` encode the same data just with two different encodings. So if you choose to set `23` as binary 1 you also have to set `78` as binary 1.<br><br>**sequences** is used to determine the actual data that is sent for each command (like \"switch on socket A\").<br><br>For that you have to determine the data which is sent for each button (socket command combination) you want to be able to use.<br>Please follow the instructions of the script. You should get an output similar to the following. (If not, you most probably made a mistake during the \"encodings\" step. Please try to redo it.):<br><br>\t1110-1100011110010101-1100<br>\t1110-1100011110010101-1100<br>\t1110-1100-0111<br>\t1110-1100<br>\t1110-110001111001010-1110<br>\t1110-110001-1110<br>\t1110-1001101101011010-1100<br>\t1110-1001101101011010-1100<br>\t1110-1001101101011010-1100<br>\t1110-1001101101011010-1100<br>\t1110-1001101101011010-1100<br>\t1110-1001101101011010-1100<br>\t1110-1001101101011010-1100<br>\t1110-100110110101101-0110<br>\t1110-1101111110100110-1100<br>\t1110-1101111110100110-1100<br>\t1110-1101111110100110-1100<br>\t1110-1101111110100110-1100<br>\t1110-1101111110100110-1100<br>\t1110-1101111110100110-1100<br>\t1110-1101111110100110-1100<br>\t1110-11011111101001-1011<br>\t1110-0111001011010001-1100<br>\t[...]<br><br>As you can see each set of data is sent eight times (4 times in encoding 1 and 4 times in encoding 2 (you cannot see the different encodings here)). Now you have to tell the script the \"start data\", \"data sequence\" and \"end data\" for each button (socket command combination). The \"start data\" should be the same for all buttons, the \"end data\" should be unique for each socket (not button!) and you should be able to see four different \"data sequences\". The script helps to distinguish between the three by separating them with dashes. In this example the \"start data\" is `1110`, the \"end data\" is `1100` and the \"data sequences\" are `1100011110010101`, `1001101101011010`, `1101111110100110` and `0111001011010001` (the last one was be repated, too, but was truncated here).<br><br>Once you have found all the data sent with the buttons on your remote, you'll find your config file specific for your sockets in `~/.gtsocket/config.ini` and you are ready to go and test with the `gtsocket-test` script.<br><br>Testing script - gtsocket-test<br>------------------------------<br><br>Use the following command to send a command to a specific socket (in this example send command 'on' to socket 'A'):<br><br>\tgtsocket-test -m send -s A -c on<br><br>To receive and print to stdout commands for a specific socket for a certain amount of time (in this example socket 'B' for 5 sec):<br><br>\tgtsocket-test -m receive -s B -t 5<br><br>Known issues<br>============<br><br> - Receiving signals/commands from the remote for multiple sockets at the same time does not work well. <br>\tIn that case many signals are not recognized correctly which leads to commands not being detected.<br><br><br>\n          </div>"}, "last_serial": 4860714, "releases": {"0.1": [{"comment_text": "", "digests": {"md5": "34087c24a3cfe07a969d8bb6ce14065b", "sha256": "7f7a830e0885f075868ed4fc9de0e1f3faf966bbcc556e8c1896abdb4479e118"}, "downloads": -1, "filename": "gtsocket-0.1-py2-none-any.whl", "has_sig": false, "md5_digest": "34087c24a3cfe07a969d8bb6ce14065b", "packagetype": "bdist_wheel", "python_version": "py2", "requires_python": null, "size": 29602, "upload_time": "2019-02-24T11:44:30", "upload_time_iso_8601": "2019-02-24T11:44:30.637579Z", "url": "https://files.pythonhosted.org/packages/96/8c/2f07ed9a53041b7b481befc22fbb00ffc766f0d91f6ffc55b551c179b06e/gtsocket-0.1-py2-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "3ebc1234cab702b34a168f0a8929654d", "sha256": "d988bc34ede9513f153254ce797c26324aa616785cda68032632340a9f3f8cfc"}, "downloads": -1, "filename": "gtsocket-0.1-py3-none-any.whl", "has_sig": false, "md5_digest": "3ebc1234cab702b34a168f0a8929654d", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 33569, "upload_time": "2019-02-24T11:44:32", "upload_time_iso_8601": "2019-02-24T11:44:32.895200Z", "url": "https://files.pythonhosted.org/packages/26/50/18a35d980ae91a4b98ed8fb0961274edd3d3609e7683c0fa199e3939d9bf/gtsocket-0.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "6a317aec23147af160da618a74a5e43f", "sha256": "eae50ac013e51b951ce5e1898d0a8aca9e851353990c37d7c3e29c7d70000180"}, "downloads": -1, "filename": "gtsocket-0.1.tar.gz", "has_sig": false, "md5_digest": "6a317aec23147af160da618a74a5e43f", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 21725, "upload_time": "2019-02-24T11:44:34", "upload_time_iso_8601": "2019-02-24T11:44:34.390301Z", "url": "https://files.pythonhosted.org/packages/4d/59/89565f34ee145731efb1bd7966d6cf87d3f1db596306ee39f45d220ea6b8/gtsocket-0.1.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "34087c24a3cfe07a969d8bb6ce14065b", "sha256": "7f7a830e0885f075868ed4fc9de0e1f3faf966bbcc556e8c1896abdb4479e118"}, "downloads": -1, "filename": "gtsocket-0.1-py2-none-any.whl", "has_sig": false, "md5_digest": "34087c24a3cfe07a969d8bb6ce14065b", "packagetype": "bdist_wheel", "python_version": "py2", "requires_python": null, "size": 29602, "upload_time": "2019-02-24T11:44:30", "upload_time_iso_8601": "2019-02-24T11:44:30.637579Z", "url": "https://files.pythonhosted.org/packages/96/8c/2f07ed9a53041b7b481befc22fbb00ffc766f0d91f6ffc55b551c179b06e/gtsocket-0.1-py2-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "3ebc1234cab702b34a168f0a8929654d", "sha256": "d988bc34ede9513f153254ce797c26324aa616785cda68032632340a9f3f8cfc"}, "downloads": -1, "filename": "gtsocket-0.1-py3-none-any.whl", "has_sig": false, "md5_digest": "3ebc1234cab702b34a168f0a8929654d", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 33569, "upload_time": "2019-02-24T11:44:32", "upload_time_iso_8601": "2019-02-24T11:44:32.895200Z", "url": "https://files.pythonhosted.org/packages/26/50/18a35d980ae91a4b98ed8fb0961274edd3d3609e7683c0fa199e3939d9bf/gtsocket-0.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "6a317aec23147af160da618a74a5e43f", "sha256": "eae50ac013e51b951ce5e1898d0a8aca9e851353990c37d7c3e29c7d70000180"}, "downloads": -1, "filename": "gtsocket-0.1.tar.gz", "has_sig": false, "md5_digest": "6a317aec23147af160da618a74a5e43f", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 21725, "upload_time": "2019-02-24T11:44:34", "upload_time_iso_8601": "2019-02-24T11:44:34.390301Z", "url": "https://files.pythonhosted.org/packages/4d/59/89565f34ee145731efb1bd7966d6cf87d3f1db596306ee39f45d220ea6b8/gtsocket-0.1.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:53:29 2020"}