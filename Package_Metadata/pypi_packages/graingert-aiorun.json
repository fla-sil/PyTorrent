{"info": {"author": "Caleb Hattingh", "author_email": "caleb.hattingh@gmail.com", "bugtrack_url": null, "classifiers": ["License :: OSI Approved :: Apache Software License", "Natural Language :: English", "Operating System :: OS Independent", "Programming Language :: Python", "Programming Language :: Python :: 3.5", "Programming Language :: Python :: 3.6", "Programming Language :: Python :: 3.7"], "description": ".. image:: https://travis-ci.org/cjrh/aiorun.svg?branch=master\n    :target: https://travis-ci.org/cjrh/aiorun\n\n.. image:: https://coveralls.io/repos/github/cjrh/aiorun/badge.svg?branch=master\n    :target: https://coveralls.io/github/cjrh/aiorun?branch=master\n\n.. image:: https://img.shields.io/pypi/pyversions/aiorun.svg\n    :target: https://pypi.python.org/pypi/aiorun\n\n.. image:: https://img.shields.io/github/tag/cjrh/aiorun.svg\n    :target: https://img.shields.io/github/tag/cjrh/aiorun.svg\n\n.. image:: https://img.shields.io/badge/install-pip%20install%20aiorun-ff69b4.svg\n    :target: https://img.shields.io/badge/install-pip%20install%20aiorun-ff69b4.svg\n\n.. image:: https://img.shields.io/pypi/v/aiorun.svg\n    :target: https://img.shields.io/pypi/v/aiorun.svg\n\n.. image:: https://img.shields.io/badge/calver-YYYY.MM.MINOR-22bfda.svg\n    :target: http://calver.org/\n\n\n\ud83c\udfc3 aiorun\n======================\n\nHere's the big idea (how you use it):\n\n.. code-block:: python\n\n   import asyncio\n   from aiorun import run\n\n   async def main():\n       # Put your application code here\n       await asyncio.sleep(1.0)\n\n   if __name__ == '__main__':\n       run(main())\n\nThis package provides a ``run()`` function as the starting point\nof your ``asyncio``-based application. The ``run()`` function will\nrun forever. If you want to shut down when ``main()`` completes, just\ncall ``loop.stop()`` inside it: that will initiate shutdown.\n\n\ud83e\udd14 Why?\n----------------\n\nThe ``run()`` function will handle **everything** that normally needs\nto be done during the shutdown sequence of the application.  All you\nneed to do is write your coroutines and run them.\n\nSo what the heck does ``run()`` do exactly?? It does these standard,\nidiomatic actions for asyncio apps:\n\n- creates a ``Task`` for the given coroutine (schedules it on the\n  event loop),\n- calls ``loop.run_forever()``,\n- adds default (and smart) signal handlers for both ``SIGINT``\n  and ``SIGTERM`` that will stop the loop;\n- and *when* the loop stops (either by signal or called directly), then it will...\n- ...gather all outstanding tasks,\n- cancel them using ``task.cancel()``,\n- resume running the loop until all those tasks are done,\n- wait for the *executor* to complete shutdown, and\n- finally close the loop.\n\nAll of this stuff is boilerplate that you will never have to write\nagain. So, if you use ``aiorun`` this is what **you** need to remember:\n\n- Spawn all your work from a single, starting coroutine\n- When a shutdown signal is received, **all** currently-pending tasks\n  will have ``CancelledError`` raised internally. It's up to you whether\n  you want to handle this inside each coroutine with\n  a ``try/except`` or not.\n- If you want to protect coros from cancellation, see `shutdown_waits_for()`\n  further down.\n- Try to have executor jobs be shortish, since the shutdown process will wait\n  for them to finish. If you need a long-running thread or process tasks, use\n  a dedicated thread/subprocess and set ``daemon=True`` instead.\n\nThere's not much else to know for general use. `aiorun` has a few special\ntools that you might need in unusual circumstances. These are discussed\nnext.\n\n\ud83d\udda5\ufe0f What about TCP server startup?\n-----------------------------------\n\nYou will see in many examples online that for servers, startup happens in\nseveral ``run_until_complete()`` phases before the primary ``run_forever()``\nwhich is the \"main\" running part of the program. How do we handle that with\n*aiorun*?\n\nLet's recreate the `echo client & server <https://docs.python.org/3/library/asyncio-stream.html#tcp-echo-client-using-streams>`_\nexamples from the Standard Library documentation:\n\n**Client:**\n\n.. code-block:: python\n\n    # echo_client.py\n    import asyncio\n    from aiorun import run\n\n    async def tcp_echo_client(message):\n        # Same as original!\n        reader, writer = await asyncio.open_connection('127.0.0.1', 8888)\n        print('Send: %r' % message)\n        writer.write(message.encode())\n        data = await reader.read(100)\n        print('Received: %r' % data.decode())\n        print('Close the socket')\n        writer.close()\n        asyncio.get_event_loop().stop()  # Exit after one msg like original\n\n    message = 'Hello World!'\n    run(tcp_echo_client(message))\n\n**Server:**\n\n.. code-block:: python\n\n    import asyncio\n    from aiorun import run\n\n    async def handle_echo(reader, writer):\n        # Same as original!\n        data = await reader.read(100)\n        message = data.decode()\n        addr = writer.get_extra_info('peername')\n        print(\"Received %r from %r\" % (message, addr))\n        print(\"Send: %r\" % message)\n        writer.write(data)\n        await writer.drain()\n        print(\"Close the client socket\")\n        writer.close()\n\n    async def main():\n        server = await asyncio.start_server(handle_echo, '127.0.0.1', 8888)\n        print('Serving on {}'.format(server.sockets[0].getsockname()))\n        try:\n            # Wait for cancellation\n            while True:\n                await asyncio.sleep(10)\n        except asyncio.CancelledError:\n            server.close()\n            await server.wait_closed()\n\n    run(main())\n\nIt works the same as the original examples, except you see this\nwhen you hit ``CTRL-C`` on the server instance:\n\n.. code-block:: bash\n\n    $ python echo_server.py\n    Running forever.\n    Serving on ('127.0.0.1', 8888)\n    Received 'Hello World!' from ('127.0.0.1', 57198)\n    Send: 'Hello World!'\n    Close the client socket\n    ^CStopping the loop\n    Entering shutdown phase.\n    Cancelling pending tasks.\n    Cancelling task:  <Task pending coro=[...snip...]>\n    Running pending tasks till complete\n    Waiting for executor shutdown.\n    Leaving. Bye!\n\nTask gathering, cancellation, and executor shutdown all happen\nautomatically.\n\n\ud83d\udca8 Do you like `uvloop <https://github.com/magicstack/uvloop>`_?\n------------------------------------------------------------------\n\n.. code-block:: python\n\n   import asyncio, aiorun\n\n   async def main():\n       <snip>\n\n   if __name__ == '__main__':\n       run(main(), use_uvloop=True)\n\nNote that you have to ``pip install uvloop`` yourself.\n\n\ud83d\udee1\ufe0f Smart shield for shutdown\n---------------------------------\n\nIt's unusual, but sometimes you're going to want a coroutine to not get\ninterrupted by cancellation *during the shutdown sequence*. You'll look in\nthe official docs and find ``asyncio.shield()``.\n\nUnfortunately, ``shield()`` doesn't work in shutdown scenarios because\nthe protection offered by ``shield()`` only applies if the specific coroutine\n*inside which* the ``shield()`` is used, gets cancelled directly.\n\nLet me explain: if you do a conventional shutdown sequence (like ``aiorun``\nis doing internally), this is the sequence of steps:\n\n- ``tasks = all_tasks()``, followed by\n- ``group = gather(*tasks)``, and then\n- ``group.cancel()``\n\nThe way ``shield()`` works internally is it creates a *secret, inner*\ntask\u2014which also gets included in the ``all_tasks()`` call above! Thus\nit also receives a cancellation signal just like everything else.\n\nTherefore, we have an alternative version of ``shield()`` that works better for\nus: ``shutdown_waits_for()``. If you've got a coroutine that must **not** be\ncancelled during the shutdown sequence, just wrap it in\n``shutdown_waits_for()``!\n\nHere's an example:\n\n.. code-block:: python\n\n    import asyncio\n    from aiorun import run, shutdown_waits_for\n\n    async def corofn():\n        await asyncio.sleep(60)\n        print('done!')\n\n    async def main():\n        try:\n            await shutdown_waits_for(corofn())\n        except asyncio.CancelledError\n            print('oh noes!')\n\n    run(main())\n\nIf you hit ``CTRL-C`` *before* 60 seconds has passed, you will see\n``oh noes!`` printed immediately, and then after 60 seconds (since start),\n``done!`` is printed, and thereafter the program exits.\n\nBehind the scenes, ``all_tasks()`` would have been cancelled by ``CTRL-C``,\n*except* ones wrapped in ``shutdown_waits_for()`` calls.  In this respect, it\nis loosely similar to ``asyncio.shield()``, but with special applicability\nto our shutdown scenario in ``aiorun()``.\n\nBe careful with this: the coroutine should still finish up at some point.\nThe main use case for this is short-lived tasks that you don't want to\nwrite explicit cancellation handling.\n\nOh, and you can use ``shutdown_waits_for()`` as if it were ``asyncio.shield()``\ntoo. For that use-case it works the same.  If you're using ``aiorun``, there\nis no reason to use ``shield()``.\n", "description_content_type": "text/x-rst", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/cjrh/aiorun", "keywords": "", "license": "", "maintainer": "", "maintainer_email": "", "name": "graingert-aiorun", "package_url": "https://pypi.org/project/graingert-aiorun/", "platform": "", "project_url": "https://pypi.org/project/graingert-aiorun/", "project_urls": {"Homepage": "https://github.com/cjrh/aiorun"}, "release_url": "https://pypi.org/project/graingert-aiorun/2018.9.1/", "requires_dist": ["typing; python_version < '3.5'", "pytest; extra == \"dev\"", "pytest-cov; extra == \"dev\""], "requires_python": "", "summary": "Boilerplate for asyncio applications", "version": "2018.9.1", "yanked": false, "html_description": "<div class=\"project-description\">\n            <a href=\"https://travis-ci.org/cjrh/aiorun\" rel=\"nofollow\"><img alt=\"https://travis-ci.org/cjrh/aiorun.svg?branch=master\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/9c2e5cc20f8bc2a284b5116abba00aa6882964d6/68747470733a2f2f7472617669732d63692e6f72672f636a72682f61696f72756e2e7376673f6272616e63683d6d6173746572\"></a>\n<a href=\"https://coveralls.io/github/cjrh/aiorun?branch=master\" rel=\"nofollow\"><img alt=\"https://coveralls.io/repos/github/cjrh/aiorun/badge.svg?branch=master\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/e0ebe2c964babe31c205392cc3a5cb5b0458862e/68747470733a2f2f636f766572616c6c732e696f2f7265706f732f6769746875622f636a72682f61696f72756e2f62616467652e7376673f6272616e63683d6d6173746572\"></a>\n<a href=\"https://pypi.python.org/pypi/aiorun\" rel=\"nofollow\"><img alt=\"https://img.shields.io/pypi/pyversions/aiorun.svg\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/9c23afb64e2f48e8cd914c343881d0f94fdf1a10/68747470733a2f2f696d672e736869656c64732e696f2f707970692f707976657273696f6e732f61696f72756e2e737667\"></a>\n<a href=\"https://img.shields.io/github/tag/cjrh/aiorun.svg\" rel=\"nofollow\"><img alt=\"https://img.shields.io/github/tag/cjrh/aiorun.svg\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/3229eb16a2c6581b2f41a73cc264c7c470bda802/68747470733a2f2f696d672e736869656c64732e696f2f6769746875622f7461672f636a72682f61696f72756e2e737667\"></a>\n<a href=\"https://img.shields.io/badge/install-pip%20install%20aiorun-ff69b4.svg\" rel=\"nofollow\"><img alt=\"https://img.shields.io/badge/install-pip%20install%20aiorun-ff69b4.svg\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/c03639125a4b7ae358292aa8364a510587111a53/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f696e7374616c6c2d706970253230696e7374616c6c25323061696f72756e2d6666363962342e737667\"></a>\n<a href=\"https://img.shields.io/pypi/v/aiorun.svg\" rel=\"nofollow\"><img alt=\"https://img.shields.io/pypi/v/aiorun.svg\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/334d9deffdc06b59a29f64db22c4579de8fb8b0a/68747470733a2f2f696d672e736869656c64732e696f2f707970692f762f61696f72756e2e737667\"></a>\n<a href=\"http://calver.org/\" rel=\"nofollow\"><img alt=\"https://img.shields.io/badge/calver-YYYY.MM.MINOR-22bfda.svg\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/957cdcd66ebe5225fea6bbf83a04bc66a232ab1c/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f63616c7665722d595959592e4d4d2e4d494e4f522d3232626664612e737667\"></a>\n<div id=\"aiorun\">\n<h2>\ud83c\udfc3 aiorun</h2>\n<p>Here\u2019s the big idea (how you use it):</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">asyncio</span>\n<span class=\"kn\">from</span> <span class=\"nn\">aiorun</span> <span class=\"kn\">import</span> <span class=\"n\">run</span>\n\n<span class=\"k\">async</span> <span class=\"k\">def</span> <span class=\"nf\">main</span><span class=\"p\">():</span>\n    <span class=\"c1\"># Put your application code here</span>\n    <span class=\"k\">await</span> <span class=\"n\">asyncio</span><span class=\"o\">.</span><span class=\"n\">sleep</span><span class=\"p\">(</span><span class=\"mf\">1.0</span><span class=\"p\">)</span>\n\n<span class=\"k\">if</span> <span class=\"vm\">__name__</span> <span class=\"o\">==</span> <span class=\"s1\">'__main__'</span><span class=\"p\">:</span>\n    <span class=\"n\">run</span><span class=\"p\">(</span><span class=\"n\">main</span><span class=\"p\">())</span>\n</pre>\n<p>This package provides a <tt>run()</tt> function as the starting point\nof your <tt>asyncio</tt>-based application. The <tt>run()</tt> function will\nrun forever. If you want to shut down when <tt>main()</tt> completes, just\ncall <tt>loop.stop()</tt> inside it: that will initiate shutdown.</p>\n<div id=\"why\">\n<h3>\ud83e\udd14 Why?</h3>\n<p>The <tt>run()</tt> function will handle <strong>everything</strong> that normally needs\nto be done during the shutdown sequence of the application.  All you\nneed to do is write your coroutines and run them.</p>\n<p>So what the heck does <tt>run()</tt> do exactly?? It does these standard,\nidiomatic actions for asyncio apps:</p>\n<ul>\n<li>creates a <tt>Task</tt> for the given coroutine (schedules it on the\nevent loop),</li>\n<li>calls <tt>loop.run_forever()</tt>,</li>\n<li>adds default (and smart) signal handlers for both <tt>SIGINT</tt>\nand <tt>SIGTERM</tt> that will stop the loop;</li>\n<li>and <em>when</em> the loop stops (either by signal or called directly), then it will\u2026</li>\n<li>\u2026gather all outstanding tasks,</li>\n<li>cancel them using <tt>task.cancel()</tt>,</li>\n<li>resume running the loop until all those tasks are done,</li>\n<li>wait for the <em>executor</em> to complete shutdown, and</li>\n<li>finally close the loop.</li>\n</ul>\n<p>All of this stuff is boilerplate that you will never have to write\nagain. So, if you use <tt>aiorun</tt> this is what <strong>you</strong> need to remember:</p>\n<ul>\n<li>Spawn all your work from a single, starting coroutine</li>\n<li>When a shutdown signal is received, <strong>all</strong> currently-pending tasks\nwill have <tt>CancelledError</tt> raised internally. It\u2019s up to you whether\nyou want to handle this inside each coroutine with\na <tt>try/except</tt> or not.</li>\n<li>If you want to protect coros from cancellation, see <cite>shutdown_waits_for()</cite>\nfurther down.</li>\n<li>Try to have executor jobs be shortish, since the shutdown process will wait\nfor them to finish. If you need a long-running thread or process tasks, use\na dedicated thread/subprocess and set <tt>daemon=True</tt> instead.</li>\n</ul>\n<p>There\u2019s not much else to know for general use. <cite>aiorun</cite> has a few special\ntools that you might need in unusual circumstances. These are discussed\nnext.</p>\n</div>\n<div id=\"what-about-tcp-server-startup\">\n<h3>\ud83d\udda5\ufe0f What about TCP server startup?</h3>\n<p>You will see in many examples online that for servers, startup happens in\nseveral <tt>run_until_complete()</tt> phases before the primary <tt>run_forever()</tt>\nwhich is the \u201cmain\u201d running part of the program. How do we handle that with\n<em>aiorun</em>?</p>\n<p>Let\u2019s recreate the <a href=\"https://docs.python.org/3/library/asyncio-stream.html#tcp-echo-client-using-streams\" rel=\"nofollow\">echo client &amp; server</a>\nexamples from the Standard Library documentation:</p>\n<p><strong>Client:</strong></p>\n<pre><span class=\"c1\"># echo_client.py</span>\n<span class=\"kn\">import</span> <span class=\"nn\">asyncio</span>\n<span class=\"kn\">from</span> <span class=\"nn\">aiorun</span> <span class=\"kn\">import</span> <span class=\"n\">run</span>\n\n<span class=\"k\">async</span> <span class=\"k\">def</span> <span class=\"nf\">tcp_echo_client</span><span class=\"p\">(</span><span class=\"n\">message</span><span class=\"p\">):</span>\n    <span class=\"c1\"># Same as original!</span>\n    <span class=\"n\">reader</span><span class=\"p\">,</span> <span class=\"n\">writer</span> <span class=\"o\">=</span> <span class=\"k\">await</span> <span class=\"n\">asyncio</span><span class=\"o\">.</span><span class=\"n\">open_connection</span><span class=\"p\">(</span><span class=\"s1\">'127.0.0.1'</span><span class=\"p\">,</span> <span class=\"mi\">8888</span><span class=\"p\">)</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">'Send: </span><span class=\"si\">%r</span><span class=\"s1\">'</span> <span class=\"o\">%</span> <span class=\"n\">message</span><span class=\"p\">)</span>\n    <span class=\"n\">writer</span><span class=\"o\">.</span><span class=\"n\">write</span><span class=\"p\">(</span><span class=\"n\">message</span><span class=\"o\">.</span><span class=\"n\">encode</span><span class=\"p\">())</span>\n    <span class=\"n\">data</span> <span class=\"o\">=</span> <span class=\"k\">await</span> <span class=\"n\">reader</span><span class=\"o\">.</span><span class=\"n\">read</span><span class=\"p\">(</span><span class=\"mi\">100</span><span class=\"p\">)</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">'Received: </span><span class=\"si\">%r</span><span class=\"s1\">'</span> <span class=\"o\">%</span> <span class=\"n\">data</span><span class=\"o\">.</span><span class=\"n\">decode</span><span class=\"p\">())</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">'Close the socket'</span><span class=\"p\">)</span>\n    <span class=\"n\">writer</span><span class=\"o\">.</span><span class=\"n\">close</span><span class=\"p\">()</span>\n    <span class=\"n\">asyncio</span><span class=\"o\">.</span><span class=\"n\">get_event_loop</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">stop</span><span class=\"p\">()</span>  <span class=\"c1\"># Exit after one msg like original</span>\n\n<span class=\"n\">message</span> <span class=\"o\">=</span> <span class=\"s1\">'Hello World!'</span>\n<span class=\"n\">run</span><span class=\"p\">(</span><span class=\"n\">tcp_echo_client</span><span class=\"p\">(</span><span class=\"n\">message</span><span class=\"p\">))</span>\n</pre>\n<p><strong>Server:</strong></p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">asyncio</span>\n<span class=\"kn\">from</span> <span class=\"nn\">aiorun</span> <span class=\"kn\">import</span> <span class=\"n\">run</span>\n\n<span class=\"k\">async</span> <span class=\"k\">def</span> <span class=\"nf\">handle_echo</span><span class=\"p\">(</span><span class=\"n\">reader</span><span class=\"p\">,</span> <span class=\"n\">writer</span><span class=\"p\">):</span>\n    <span class=\"c1\"># Same as original!</span>\n    <span class=\"n\">data</span> <span class=\"o\">=</span> <span class=\"k\">await</span> <span class=\"n\">reader</span><span class=\"o\">.</span><span class=\"n\">read</span><span class=\"p\">(</span><span class=\"mi\">100</span><span class=\"p\">)</span>\n    <span class=\"n\">message</span> <span class=\"o\">=</span> <span class=\"n\">data</span><span class=\"o\">.</span><span class=\"n\">decode</span><span class=\"p\">()</span>\n    <span class=\"n\">addr</span> <span class=\"o\">=</span> <span class=\"n\">writer</span><span class=\"o\">.</span><span class=\"n\">get_extra_info</span><span class=\"p\">(</span><span class=\"s1\">'peername'</span><span class=\"p\">)</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">\"Received </span><span class=\"si\">%r</span><span class=\"s2\"> from </span><span class=\"si\">%r</span><span class=\"s2\">\"</span> <span class=\"o\">%</span> <span class=\"p\">(</span><span class=\"n\">message</span><span class=\"p\">,</span> <span class=\"n\">addr</span><span class=\"p\">))</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">\"Send: </span><span class=\"si\">%r</span><span class=\"s2\">\"</span> <span class=\"o\">%</span> <span class=\"n\">message</span><span class=\"p\">)</span>\n    <span class=\"n\">writer</span><span class=\"o\">.</span><span class=\"n\">write</span><span class=\"p\">(</span><span class=\"n\">data</span><span class=\"p\">)</span>\n    <span class=\"k\">await</span> <span class=\"n\">writer</span><span class=\"o\">.</span><span class=\"n\">drain</span><span class=\"p\">()</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">\"Close the client socket\"</span><span class=\"p\">)</span>\n    <span class=\"n\">writer</span><span class=\"o\">.</span><span class=\"n\">close</span><span class=\"p\">()</span>\n\n<span class=\"k\">async</span> <span class=\"k\">def</span> <span class=\"nf\">main</span><span class=\"p\">():</span>\n    <span class=\"n\">server</span> <span class=\"o\">=</span> <span class=\"k\">await</span> <span class=\"n\">asyncio</span><span class=\"o\">.</span><span class=\"n\">start_server</span><span class=\"p\">(</span><span class=\"n\">handle_echo</span><span class=\"p\">,</span> <span class=\"s1\">'127.0.0.1'</span><span class=\"p\">,</span> <span class=\"mi\">8888</span><span class=\"p\">)</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">'Serving on </span><span class=\"si\">{}</span><span class=\"s1\">'</span><span class=\"o\">.</span><span class=\"n\">format</span><span class=\"p\">(</span><span class=\"n\">server</span><span class=\"o\">.</span><span class=\"n\">sockets</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">getsockname</span><span class=\"p\">()))</span>\n    <span class=\"k\">try</span><span class=\"p\">:</span>\n        <span class=\"c1\"># Wait for cancellation</span>\n        <span class=\"k\">while</span> <span class=\"kc\">True</span><span class=\"p\">:</span>\n            <span class=\"k\">await</span> <span class=\"n\">asyncio</span><span class=\"o\">.</span><span class=\"n\">sleep</span><span class=\"p\">(</span><span class=\"mi\">10</span><span class=\"p\">)</span>\n    <span class=\"k\">except</span> <span class=\"n\">asyncio</span><span class=\"o\">.</span><span class=\"n\">CancelledError</span><span class=\"p\">:</span>\n        <span class=\"n\">server</span><span class=\"o\">.</span><span class=\"n\">close</span><span class=\"p\">()</span>\n        <span class=\"k\">await</span> <span class=\"n\">server</span><span class=\"o\">.</span><span class=\"n\">wait_closed</span><span class=\"p\">()</span>\n\n<span class=\"n\">run</span><span class=\"p\">(</span><span class=\"n\">main</span><span class=\"p\">())</span>\n</pre>\n<p>It works the same as the original examples, except you see this\nwhen you hit <tt><span class=\"pre\">CTRL-C</span></tt> on the server instance:</p>\n<pre>$ python echo_server.py\nRunning forever.\nServing on <span class=\"o\">(</span><span class=\"s1\">'127.0.0.1'</span>, <span class=\"m\">8888</span><span class=\"o\">)</span>\nReceived <span class=\"s1\">'Hello World!'</span> from <span class=\"o\">(</span><span class=\"s1\">'127.0.0.1'</span>, <span class=\"m\">57198</span><span class=\"o\">)</span>\nSend: <span class=\"s1\">'Hello World!'</span>\nClose the client socket\n^CStopping the loop\nEntering shutdown phase.\nCancelling pending tasks.\nCancelling task:  &lt;Task pending <span class=\"nv\">coro</span><span class=\"o\">=[</span>...snip...<span class=\"o\">]</span>&gt;\nRunning pending tasks till <span class=\"nb\">complete</span>\nWaiting <span class=\"k\">for</span> executor shutdown.\nLeaving. Bye!\n</pre>\n<p>Task gathering, cancellation, and executor shutdown all happen\nautomatically.</p>\n</div>\n<div id=\"do-you-like-uvloop\">\n<h3>\ud83d\udca8 Do you like <a href=\"https://github.com/magicstack/uvloop\" rel=\"nofollow\">uvloop</a>?</h3>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">asyncio</span><span class=\"o\">,</span> <span class=\"nn\">aiorun</span>\n\n<span class=\"k\">async</span> <span class=\"k\">def</span> <span class=\"nf\">main</span><span class=\"p\">():</span>\n    <span class=\"o\">&lt;</span><span class=\"n\">snip</span><span class=\"o\">&gt;</span>\n\n<span class=\"k\">if</span> <span class=\"vm\">__name__</span> <span class=\"o\">==</span> <span class=\"s1\">'__main__'</span><span class=\"p\">:</span>\n    <span class=\"n\">run</span><span class=\"p\">(</span><span class=\"n\">main</span><span class=\"p\">(),</span> <span class=\"n\">use_uvloop</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n</pre>\n<p>Note that you have to <tt>pip install uvloop</tt> yourself.</p>\n</div>\n<div id=\"smart-shield-for-shutdown\">\n<h3>\ud83d\udee1\ufe0f Smart shield for shutdown</h3>\n<p>It\u2019s unusual, but sometimes you\u2019re going to want a coroutine to not get\ninterrupted by cancellation <em>during the shutdown sequence</em>. You\u2019ll look in\nthe official docs and find <tt>asyncio.shield()</tt>.</p>\n<p>Unfortunately, <tt>shield()</tt> doesn\u2019t work in shutdown scenarios because\nthe protection offered by <tt>shield()</tt> only applies if the specific coroutine\n<em>inside which</em> the <tt>shield()</tt> is used, gets cancelled directly.</p>\n<p>Let me explain: if you do a conventional shutdown sequence (like <tt>aiorun</tt>\nis doing internally), this is the sequence of steps:</p>\n<ul>\n<li><tt>tasks = all_tasks()</tt>, followed by</li>\n<li><tt>group = <span class=\"pre\">gather(*tasks)</span></tt>, and then</li>\n<li><tt>group.cancel()</tt></li>\n</ul>\n<p>The way <tt>shield()</tt> works internally is it creates a <em>secret, inner</em>\ntask\u2014which also gets included in the <tt>all_tasks()</tt> call above! Thus\nit also receives a cancellation signal just like everything else.</p>\n<p>Therefore, we have an alternative version of <tt>shield()</tt> that works better for\nus: <tt>shutdown_waits_for()</tt>. If you\u2019ve got a coroutine that must <strong>not</strong> be\ncancelled during the shutdown sequence, just wrap it in\n<tt>shutdown_waits_for()</tt>!</p>\n<p>Here\u2019s an example:</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">asyncio</span>\n<span class=\"kn\">from</span> <span class=\"nn\">aiorun</span> <span class=\"kn\">import</span> <span class=\"n\">run</span><span class=\"p\">,</span> <span class=\"n\">shutdown_waits_for</span>\n\n<span class=\"k\">async</span> <span class=\"k\">def</span> <span class=\"nf\">corofn</span><span class=\"p\">():</span>\n    <span class=\"k\">await</span> <span class=\"n\">asyncio</span><span class=\"o\">.</span><span class=\"n\">sleep</span><span class=\"p\">(</span><span class=\"mi\">60</span><span class=\"p\">)</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">'done!'</span><span class=\"p\">)</span>\n\n<span class=\"k\">async</span> <span class=\"k\">def</span> <span class=\"nf\">main</span><span class=\"p\">():</span>\n    <span class=\"k\">try</span><span class=\"p\">:</span>\n        <span class=\"k\">await</span> <span class=\"n\">shutdown_waits_for</span><span class=\"p\">(</span><span class=\"n\">corofn</span><span class=\"p\">())</span>\n    <span class=\"k\">except</span> <span class=\"n\">asyncio</span><span class=\"o\">.</span><span class=\"n\">CancelledError</span>\n        <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">'oh noes!'</span><span class=\"p\">)</span>\n\n<span class=\"n\">run</span><span class=\"p\">(</span><span class=\"n\">main</span><span class=\"p\">())</span>\n</pre>\n<p>If you hit <tt><span class=\"pre\">CTRL-C</span></tt> <em>before</em> 60 seconds has passed, you will see\n<tt>oh noes!</tt> printed immediately, and then after 60 seconds (since start),\n<tt>done!</tt> is printed, and thereafter the program exits.</p>\n<p>Behind the scenes, <tt>all_tasks()</tt> would have been cancelled by <tt><span class=\"pre\">CTRL-C</span></tt>,\n<em>except</em> ones wrapped in <tt>shutdown_waits_for()</tt> calls.  In this respect, it\nis loosely similar to <tt>asyncio.shield()</tt>, but with special applicability\nto our shutdown scenario in <tt>aiorun()</tt>.</p>\n<p>Be careful with this: the coroutine should still finish up at some point.\nThe main use case for this is short-lived tasks that you don\u2019t want to\nwrite explicit cancellation handling.</p>\n<p>Oh, and you can use <tt>shutdown_waits_for()</tt> as if it were <tt>asyncio.shield()</tt>\ntoo. For that use-case it works the same.  If you\u2019re using <tt>aiorun</tt>, there\nis no reason to use <tt>shield()</tt>.</p>\n</div>\n</div>\n\n          </div>"}, "last_serial": 4968159, "releases": {"2018.9.1": [{"comment_text": "", "digests": {"md5": "cfda4ac86ab6b03f157cebce0c684c5a", "sha256": "e451a9f1f0976ff59d90a30830a70a85a104e70577137daa182bd78e6888c049"}, "downloads": -1, "filename": "graingert_aiorun-2018.9.1-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "cfda4ac86ab6b03f157cebce0c684c5a", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 25088, "upload_time": "2019-03-21T13:43:12", "upload_time_iso_8601": "2019-03-21T13:43:12.911909Z", "url": "https://files.pythonhosted.org/packages/eb/40/e15e0c6ab4f9506e87d26548e5cac05b68ea1da8545cdc95cde553746f79/graingert_aiorun-2018.9.1-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "fb34b653c44fc2198c1c3628233bec3c", "sha256": "4859e4b13807af55fb9c467d523e949c54379cd848f9702d95438500982b5f67"}, "downloads": -1, "filename": "graingert-aiorun-2018.9.1.tar.gz", "has_sig": false, "md5_digest": "fb34b653c44fc2198c1c3628233bec3c", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 14447, "upload_time": "2019-03-21T13:43:15", "upload_time_iso_8601": "2019-03-21T13:43:15.968272Z", "url": "https://files.pythonhosted.org/packages/b2/66/7e05c65f246e7adfd6bec3215e969a79d30836b5765208cf4d32ca897c91/graingert-aiorun-2018.9.1.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "cfda4ac86ab6b03f157cebce0c684c5a", "sha256": "e451a9f1f0976ff59d90a30830a70a85a104e70577137daa182bd78e6888c049"}, "downloads": -1, "filename": "graingert_aiorun-2018.9.1-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "cfda4ac86ab6b03f157cebce0c684c5a", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 25088, "upload_time": "2019-03-21T13:43:12", "upload_time_iso_8601": "2019-03-21T13:43:12.911909Z", "url": "https://files.pythonhosted.org/packages/eb/40/e15e0c6ab4f9506e87d26548e5cac05b68ea1da8545cdc95cde553746f79/graingert_aiorun-2018.9.1-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "fb34b653c44fc2198c1c3628233bec3c", "sha256": "4859e4b13807af55fb9c467d523e949c54379cd848f9702d95438500982b5f67"}, "downloads": -1, "filename": "graingert-aiorun-2018.9.1.tar.gz", "has_sig": false, "md5_digest": "fb34b653c44fc2198c1c3628233bec3c", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 14447, "upload_time": "2019-03-21T13:43:15", "upload_time_iso_8601": "2019-03-21T13:43:15.968272Z", "url": "https://files.pythonhosted.org/packages/b2/66/7e05c65f246e7adfd6bec3215e969a79d30836b5765208cf4d32ca897c91/graingert-aiorun-2018.9.1.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:54:54 2020"}