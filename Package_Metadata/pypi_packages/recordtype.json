{"info": {"author": "Eric V. Smith", "author_email": "eric@trueblade.com", "bugtrack_url": null, "classifiers": ["Development Status :: 5 - Production/Stable", "Intended Audience :: Developers", "License :: OSI Approved :: Apache Software License", "Programming Language :: Python :: 2.6", "Programming Language :: Python :: 2.7", "Programming Language :: Python :: 3", "Topic :: Software Development :: Libraries :: Python Modules"], "description": "===========\nrecordtype\n===========\n\nNOTE\n====\n\nI have switched active development to my `namedlist project\n<https://bitbucket.org/ericvsmith/namedlist>`_. It has a better\nimplementation that makes it easier to modify the code. It should be\nfully compatible with recordtype.\n\nOverview\n========\n\nrecordtype provides a factory function, named\nrecordtype.recordtype. It is similar to collections.namedtuple, with\nthe following differences:\n\n* recordtype instances are mutable.\n\n* recordtype supports per-field default values.\n\n* recordtype supports an optional default value, to be used by all\n  fields do not have an explicit default value.\n\nTypical usage\n=============\n\nYou can use recordtype like a mutable namedtuple::\n\n    >>> from recordtype import recordtype\n\n    >>> Point = recordtype('Point', 'x y')\n    >>> p = Point(1, 3)\n    >>> p.x = 2\n    >>> assert p.x == 2\n    >>> assert p.y == 3\n\nOr, you can specify a default value for all fields::\n\n    >>> Point = recordtype('Point', 'x y', default=3)\n    >>> p = Point(y=2)\n    >>> assert p.x == 3\n    >>> assert p.y == 2\n\nOr, you can specify per-field default values::\n\n    >>> Point = recordtype('Point', [('x', 0), ('y', 100)])\n    >>> p = Point()\n    >>> assert p.x == 0\n    >>> assert p.y == 100\n\nYou can also specify a the per-field defaults with a mapping, instead\nof an interable. Note that this is only useful with an ordered\nmapping, such as an OrderedDict::\n\n    >>> from collections import OrderedDict\n    >>> Point = recordtype('Point', OrderedDict((('y', 0),\n    ...                                          ('x', 100))))\n    >>> p = Point()\n    >>> assert p.x == 100\n    >>> assert p.y == 0\n\nThe default value will only be used if it is provided and a per-field\ndefault is not used::\n\n    >>> Point = recordtype('Point', ['x', ('y', 100)], default=10)\n    >>> p = Point()\n    >>> assert p.x == 10\n    >>> assert p.y == 100\n\nIf you use a mapping, the value NO_DEFAULT is convenient to specify\nthat a field uses the default value::\n\n    >>> from recordtype import NO_DEFAULT\n    >>> Point = recordtype('Point', OrderedDict((('y', NO_DEFAULT),\n    ...                                          ('x', 100))),\n    ...                             default=5)\n    >>> p = Point()\n    >>> assert p.x == 100\n    >>> assert p.y == 5\n\n\nCreating types\n==============\n\nSpecifying Fields\n-----------------\n\nFields can be specified as in namedtuple: as either a string specifing\nthe field names, or as a iterable of field names. These two uses are\nequivalent::\n\n    >>> Point = recordtype('Point', 'x y')\n    >>> Point = recordtype('Point', ['x', 'y'])\n\nIf using a string, commas are first converted to spaces. So these are\nequivalent::\n\n    >>> Point = recordtype('Point', 'x y')\n    >>> Point = recordtype('Point', 'x,y')\n\n\nSpecifying Defaults\n-------------------\n\nPer-field defaults can be specified by supplying a 2-tuple (name,\ndefault_value) instead of just a string for the field name. This is\nonly supported when you specify a list of field names::\n\n    >>> Point = recordtype('Point', [('x', 0), ('y', 0)])\n    >>> p = Point(3)\n    >>> assert p.x == 3\n    >>> assert p.y == 0\n\nIn addition to, or instead of, these per-field defaults, you can also\nspecify a default value which is used when no per-field default value\nis specified::\n\n    >>> Point = recordtype('Point', 'x y z', default=0)\n    >>> p = Point(y=3)\n    >>> assert p.x == 0\n    >>> assert p.y == 3\n    >>> assert p.z == 0\n\n    >>> Point = recordtype('Point', [('x', 0), 'y', ('z', 0)], default=4)\n    >>> p = Point(z=2)\n    >>> assert p.x == 0\n    >>> assert p.y == 4\n    >>> assert p.z == 2\n\nIn addition to supplying the field names as an iterable of 2-tuples,\nyou can also specify a mapping. The keys will be the field names, and\nthe values will be the per-field default values. This is most useful\nwith an OrderedDict, as the order of the fields will then be\ndeterministic.  The module variable NO_DEFAULT can be specified if you\nwant a field to use the per-type default value instead of specifying\nit with a field::\n\n    >>> Point = recordtype('Point', OrderedDict((('x', 0),\n    ...                                          ('y', NO_DEFAULT),\n    ...                                          ('z', 0),\n    ...                                          )),\n    ...                             default=4)\n    >>> p = Point(z=2)\n    >>> assert p.x == 0\n    >>> assert p.y == 4\n    >>> assert p.z == 2\n\nWriting to values\n-----------------\n\nThe objects retured by the factory function are fully writable, unlike\nthe tuple-derived classes returned by namedtuple::\n\n    >>> Point = recordtype('Point', 'x y')\n    >>> p = Point(1, 2)\n    >>> p.y = 4\n    >>> assert p.x == 1\n    >>> assert p.y == 4\n\n\nSpecifying __slots__\n--------------------\n\nBy default, the returned class sets __slots__, which is initialized to\nthe field names. While this decreases memory usage by eliminating the\ninstance dict, it also means that you cannot create new instance\nmembers.\n\nTo change this behavior, specify use_slots=False when creating the\nrecordtype::\n\n    >>> Point = recordtype('Point', 'x y', use_slots=False)\n    >>> p = Point(0, 1)\n    >>> p.z = 2\n    >>> assert p.x == 0\n    >>> assert p.y == 1\n    >>> assert p.z == 2\n\n\nAdditional class members\n------------------------\n\nrecordtype classes contain these members:\n\n* _asdict(): Returns a dict which maps field names to their\n  corresponding values.\n\n* _source: A string with the pure Python source code used to create\n  the recordtype class. The source makes the recordtype\n  self-documenting. It can be printed, executed using exec(), or saved\n  to a file and imported.\n\n* _fields: Tuple of strings listing the field names. Useful for introspection.\n\n\nRenaming invalid field names\n----------------------------\n\nThis functionality is identical to namedtuple. If you specify\nrename=True, then any invalid field names are changed to _0, _1,\netc. Reasons for a field name to be invalid are:\n\n* Zero length strings.\n\n* Containing characters other than alphanumerics and underscores.\n\n* A conflict with a Python reserved identifier.\n\n* Beginning with a digit.\n\n* Beginning with an underscore.\n\n* Using the same field name more than once.\n\nFor example::\n\n    >>> Point = recordtype('Point', 'x x for', rename=True)\n    >>> assert Point._fields == ('x', '_1', '_2')\n\n\nMutable default values\n----------------------\n\nBe aware of creating mutable default values. Due to the way Python\nhandles default values, each instance of a recordtype will share the\ndefault. This is especially problematic with default values that are\nlists. For example::\n\n    >>> A = recordtype('A', [('x', [])])\n    >>> a = A()\n    >>> a.x.append(4)\n    >>> b = A()\n    >>> assert b.x == [4]\n\nThis is probably not the desired behavior.\n\nCreating and using instances\n============================\n\nBecause the type returned by recordtype is a normal Python class, you\ncreate instances as you would with any Python class.\n\n\nChange log\n==========\n\n1.3 2018-08-03 Eric V. Smith\n----------------------------\n* Python 3 support (thanks Jakob Stasiak).\n* Reformat with black.\n\n1.2 <unreleased> Eric V. Smith\n------------------------------\n* Switch README.txt to support doctest.\n* Add tests for mutable default values.\n* Add warning for mutable default values.\n\n1.1 2011-11-14 Eric V. Smith\n----------------------------\n* No API or code changes.\n* Fixed project URL in setup.py.\n* Fixed license description in setup.py.\n\n1.0 2011-10-23 Eric V. Smith\n----------------------------\n* Stabilize API, move to version 1.0.\n* Added \"python setup.py test\" support to run unittests.\n* Improve documentation examples.\n* Renamed \"default_default\" to just \"default\".\n* Expose \"NO_DEFAULT\".\n* Support mapping objects in addition to strings and lists for field_names.\n* Add tests for iterables, not just lists, for field_names.\n\n0.2 2011-10-13 Eric V. Smith\n----------------------------\n* Fix a typo in the documentation, no code changes.\n\n0.1 2011-10-12 Eric V. Smith\n----------------------------\n* Initial release.", "description_content_type": "", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://bitbucket.org/ericvsmith/recordtype", "keywords": "", "license": "Apache License Version 2.0", "maintainer": "", "maintainer_email": "", "name": "recordtype", "package_url": "https://pypi.org/project/recordtype/", "platform": "", "project_url": "https://pypi.org/project/recordtype/", "project_urls": {"Homepage": "https://bitbucket.org/ericvsmith/recordtype"}, "release_url": "https://pypi.org/project/recordtype/1.3/", "requires_dist": null, "requires_python": "", "summary": "Similar to namedtuple, but instances are mutable.", "version": "1.3", "yanked": false, "html_description": "<div class=\"project-description\">\n            <div id=\"note\">\n<h2>NOTE</h2>\n<p>I have switched active development to my <a href=\"https://bitbucket.org/ericvsmith/namedlist\" rel=\"nofollow\">namedlist project</a>. It has a better\nimplementation that makes it easier to modify the code. It should be\nfully compatible with recordtype.</p>\n</div>\n<div id=\"overview\">\n<h2>Overview</h2>\n<p>recordtype provides a factory function, named\nrecordtype.recordtype. It is similar to collections.namedtuple, with\nthe following differences:</p>\n<ul>\n<li>recordtype instances are mutable.</li>\n<li>recordtype supports per-field default values.</li>\n<li>recordtype supports an optional default value, to be used by all\nfields do not have an explicit default value.</li>\n</ul>\n</div>\n<div id=\"typical-usage\">\n<h2>Typical usage</h2>\n<p>You can use recordtype like a mutable namedtuple:</p>\n<pre>&gt;&gt;&gt; from recordtype import recordtype\n\n&gt;&gt;&gt; Point = recordtype('Point', 'x y')\n&gt;&gt;&gt; p = Point(1, 3)\n&gt;&gt;&gt; p.x = 2\n&gt;&gt;&gt; assert p.x == 2\n&gt;&gt;&gt; assert p.y == 3\n</pre>\n<p>Or, you can specify a default value for all fields:</p>\n<pre>&gt;&gt;&gt; Point = recordtype('Point', 'x y', default=3)\n&gt;&gt;&gt; p = Point(y=2)\n&gt;&gt;&gt; assert p.x == 3\n&gt;&gt;&gt; assert p.y == 2\n</pre>\n<p>Or, you can specify per-field default values:</p>\n<pre>&gt;&gt;&gt; Point = recordtype('Point', [('x', 0), ('y', 100)])\n&gt;&gt;&gt; p = Point()\n&gt;&gt;&gt; assert p.x == 0\n&gt;&gt;&gt; assert p.y == 100\n</pre>\n<p>You can also specify a the per-field defaults with a mapping, instead\nof an interable. Note that this is only useful with an ordered\nmapping, such as an OrderedDict:</p>\n<pre>&gt;&gt;&gt; from collections import OrderedDict\n&gt;&gt;&gt; Point = recordtype('Point', OrderedDict((('y', 0),\n...                                          ('x', 100))))\n&gt;&gt;&gt; p = Point()\n&gt;&gt;&gt; assert p.x == 100\n&gt;&gt;&gt; assert p.y == 0\n</pre>\n<p>The default value will only be used if it is provided and a per-field\ndefault is not used:</p>\n<pre>&gt;&gt;&gt; Point = recordtype('Point', ['x', ('y', 100)], default=10)\n&gt;&gt;&gt; p = Point()\n&gt;&gt;&gt; assert p.x == 10\n&gt;&gt;&gt; assert p.y == 100\n</pre>\n<p>If you use a mapping, the value NO_DEFAULT is convenient to specify\nthat a field uses the default value:</p>\n<pre>&gt;&gt;&gt; from recordtype import NO_DEFAULT\n&gt;&gt;&gt; Point = recordtype('Point', OrderedDict((('y', NO_DEFAULT),\n...                                          ('x', 100))),\n...                             default=5)\n&gt;&gt;&gt; p = Point()\n&gt;&gt;&gt; assert p.x == 100\n&gt;&gt;&gt; assert p.y == 5\n</pre>\n</div>\n<div id=\"creating-types\">\n<h2>Creating types</h2>\n<div id=\"specifying-fields\">\n<h3>Specifying Fields</h3>\n<p>Fields can be specified as in namedtuple: as either a string specifing\nthe field names, or as a iterable of field names. These two uses are\nequivalent:</p>\n<pre>&gt;&gt;&gt; Point = recordtype('Point', 'x y')\n&gt;&gt;&gt; Point = recordtype('Point', ['x', 'y'])\n</pre>\n<p>If using a string, commas are first converted to spaces. So these are\nequivalent:</p>\n<pre>&gt;&gt;&gt; Point = recordtype('Point', 'x y')\n&gt;&gt;&gt; Point = recordtype('Point', 'x,y')\n</pre>\n</div>\n<div id=\"specifying-defaults\">\n<h3>Specifying Defaults</h3>\n<p>Per-field defaults can be specified by supplying a 2-tuple (name,\ndefault_value) instead of just a string for the field name. This is\nonly supported when you specify a list of field names:</p>\n<pre>&gt;&gt;&gt; Point = recordtype('Point', [('x', 0), ('y', 0)])\n&gt;&gt;&gt; p = Point(3)\n&gt;&gt;&gt; assert p.x == 3\n&gt;&gt;&gt; assert p.y == 0\n</pre>\n<p>In addition to, or instead of, these per-field defaults, you can also\nspecify a default value which is used when no per-field default value\nis specified:</p>\n<pre>&gt;&gt;&gt; Point = recordtype('Point', 'x y z', default=0)\n&gt;&gt;&gt; p = Point(y=3)\n&gt;&gt;&gt; assert p.x == 0\n&gt;&gt;&gt; assert p.y == 3\n&gt;&gt;&gt; assert p.z == 0\n\n&gt;&gt;&gt; Point = recordtype('Point', [('x', 0), 'y', ('z', 0)], default=4)\n&gt;&gt;&gt; p = Point(z=2)\n&gt;&gt;&gt; assert p.x == 0\n&gt;&gt;&gt; assert p.y == 4\n&gt;&gt;&gt; assert p.z == 2\n</pre>\n<p>In addition to supplying the field names as an iterable of 2-tuples,\nyou can also specify a mapping. The keys will be the field names, and\nthe values will be the per-field default values. This is most useful\nwith an OrderedDict, as the order of the fields will then be\ndeterministic.  The module variable NO_DEFAULT can be specified if you\nwant a field to use the per-type default value instead of specifying\nit with a field:</p>\n<pre>&gt;&gt;&gt; Point = recordtype('Point', OrderedDict((('x', 0),\n...                                          ('y', NO_DEFAULT),\n...                                          ('z', 0),\n...                                          )),\n...                             default=4)\n&gt;&gt;&gt; p = Point(z=2)\n&gt;&gt;&gt; assert p.x == 0\n&gt;&gt;&gt; assert p.y == 4\n&gt;&gt;&gt; assert p.z == 2\n</pre>\n</div>\n<div id=\"writing-to-values\">\n<h3>Writing to values</h3>\n<p>The objects retured by the factory function are fully writable, unlike\nthe tuple-derived classes returned by namedtuple:</p>\n<pre>&gt;&gt;&gt; Point = recordtype('Point', 'x y')\n&gt;&gt;&gt; p = Point(1, 2)\n&gt;&gt;&gt; p.y = 4\n&gt;&gt;&gt; assert p.x == 1\n&gt;&gt;&gt; assert p.y == 4\n</pre>\n</div>\n<div id=\"specifying-slots\">\n<h3>Specifying __slots__</h3>\n<p>By default, the returned class sets __slots__, which is initialized to\nthe field names. While this decreases memory usage by eliminating the\ninstance dict, it also means that you cannot create new instance\nmembers.</p>\n<p>To change this behavior, specify use_slots=False when creating the\nrecordtype:</p>\n<pre>&gt;&gt;&gt; Point = recordtype('Point', 'x y', use_slots=False)\n&gt;&gt;&gt; p = Point(0, 1)\n&gt;&gt;&gt; p.z = 2\n&gt;&gt;&gt; assert p.x == 0\n&gt;&gt;&gt; assert p.y == 1\n&gt;&gt;&gt; assert p.z == 2\n</pre>\n</div>\n<div id=\"additional-class-members\">\n<h3>Additional class members</h3>\n<p>recordtype classes contain these members:</p>\n<ul>\n<li>_asdict(): Returns a dict which maps field names to their\ncorresponding values.</li>\n<li>_source: A string with the pure Python source code used to create\nthe recordtype class. The source makes the recordtype\nself-documenting. It can be printed, executed using exec(), or saved\nto a file and imported.</li>\n<li>_fields: Tuple of strings listing the field names. Useful for introspection.</li>\n</ul>\n</div>\n<div id=\"renaming-invalid-field-names\">\n<h3>Renaming invalid field names</h3>\n<p>This functionality is identical to namedtuple. If you specify\nrename=True, then any invalid field names are changed to _0, _1,\netc. Reasons for a field name to be invalid are:</p>\n<ul>\n<li>Zero length strings.</li>\n<li>Containing characters other than alphanumerics and underscores.</li>\n<li>A conflict with a Python reserved identifier.</li>\n<li>Beginning with a digit.</li>\n<li>Beginning with an underscore.</li>\n<li>Using the same field name more than once.</li>\n</ul>\n<p>For example:</p>\n<pre>&gt;&gt;&gt; Point = recordtype('Point', 'x x for', rename=True)\n&gt;&gt;&gt; assert Point._fields == ('x', '_1', '_2')\n</pre>\n</div>\n<div id=\"mutable-default-values\">\n<h3>Mutable default values</h3>\n<p>Be aware of creating mutable default values. Due to the way Python\nhandles default values, each instance of a recordtype will share the\ndefault. This is especially problematic with default values that are\nlists. For example:</p>\n<pre>&gt;&gt;&gt; A = recordtype('A', [('x', [])])\n&gt;&gt;&gt; a = A()\n&gt;&gt;&gt; a.x.append(4)\n&gt;&gt;&gt; b = A()\n&gt;&gt;&gt; assert b.x == [4]\n</pre>\n<p>This is probably not the desired behavior.</p>\n</div>\n</div>\n<div id=\"creating-and-using-instances\">\n<h2>Creating and using instances</h2>\n<p>Because the type returned by recordtype is a normal Python class, you\ncreate instances as you would with any Python class.</p>\n</div>\n<div id=\"change-log\">\n<h2>Change log</h2>\n<div id=\"eric-v-smith\">\n<h3>1.3 2018-08-03 Eric V. Smith</h3>\n<ul>\n<li>Python 3 support (thanks Jakob Stasiak).</li>\n<li>Reformat with black.</li>\n</ul>\n</div>\n<div id=\"unreleased-eric-v-smith\">\n<h3>1.2 &lt;unreleased&gt; Eric V. Smith</h3>\n<ul>\n<li>Switch README.txt to support doctest.</li>\n<li>Add tests for mutable default values.</li>\n<li>Add warning for mutable default values.</li>\n</ul>\n</div>\n<div id=\"id1\">\n<h3>1.1 2011-11-14 Eric V. Smith</h3>\n<ul>\n<li>No API or code changes.</li>\n<li>Fixed project URL in setup.py.</li>\n<li>Fixed license description in setup.py.</li>\n</ul>\n</div>\n<div id=\"id2\">\n<h3>1.0 2011-10-23 Eric V. Smith</h3>\n<ul>\n<li>Stabilize API, move to version 1.0.</li>\n<li>Added \u201cpython setup.py test\u201d support to run unittests.</li>\n<li>Improve documentation examples.</li>\n<li>Renamed \u201cdefault_default\u201d to just \u201cdefault\u201d.</li>\n<li>Expose \u201cNO_DEFAULT\u201d.</li>\n<li>Support mapping objects in addition to strings and lists for field_names.</li>\n<li>Add tests for iterables, not just lists, for field_names.</li>\n</ul>\n</div>\n<div id=\"id3\">\n<h3>0.2 2011-10-13 Eric V. Smith</h3>\n<ul>\n<li>Fix a typo in the documentation, no code changes.</li>\n</ul>\n</div>\n<div id=\"id4\">\n<h3>0.1 2011-10-12 Eric V. Smith</h3>\n<ul>\n<li>Initial release.</li>\n</ul>\n</div>\n</div>\n\n          </div>"}, "last_serial": 4134614, "releases": {"0.1": [{"comment_text": "", "digests": {"md5": "e101d3ff68c6a989717a064279b23d08", "sha256": "70cdbc773307cfb9f40aae39f7f5fc98a2650579156bb524da1df3b5042c5764"}, "downloads": -1, "filename": "recordtype-0.1.tar.gz", "has_sig": false, "md5_digest": "e101d3ff68c6a989717a064279b23d08", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 10681, "upload_time": "2011-10-12T22:25:59", "upload_time_iso_8601": "2011-10-12T22:25:59.521087Z", "url": "https://files.pythonhosted.org/packages/7a/b7/a86210d1c9f5eef340283be8c97d833fbb125a3e551209d46f094eb94624/recordtype-0.1.tar.gz", "yanked": false}], "0.2": [{"comment_text": "", "digests": {"md5": "f031d3f418ff91bf192ef479fdceeb79", "sha256": "64efaba5b87d8c98f695b9a2bec673061996bb0cf4d6bd277a06b00c12cc87a2"}, "downloads": -1, "filename": "recordtype-0.2.tar.gz", "has_sig": false, "md5_digest": "f031d3f418ff91bf192ef479fdceeb79", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 10732, "upload_time": "2011-10-13T15:00:36", "upload_time_iso_8601": "2011-10-13T15:00:36.195447Z", "url": "https://files.pythonhosted.org/packages/c8/34/dd833b95d54c80fcce2aef91e12f00d7fa634555516e26f5fc6ad5473c4a/recordtype-0.2.tar.gz", "yanked": false}], "1.0": [{"comment_text": "", "digests": {"md5": "1f9c7fca3b39e026928926bfad45249a", "sha256": "79acf287aacbdfe9eaf3ee4566943bbbff54ce7985d8f3b5361743c32d6dcc4c"}, "downloads": -1, "filename": "recordtype-1.0.tar.gz", "has_sig": false, "md5_digest": "1f9c7fca3b39e026928926bfad45249a", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 11863, "upload_time": "2011-10-23T16:35:54", "upload_time_iso_8601": "2011-10-23T16:35:54.974311Z", "url": "https://files.pythonhosted.org/packages/9c/10/64472e75dc723533d5cd693180a62cfbd99161a59feb3118331e3374633e/recordtype-1.0.tar.gz", "yanked": false}], "1.1": [{"comment_text": "", "digests": {"md5": "8133256b9c62baa2019ec16db3b14115", "sha256": "bb82d9c27c9e48fc06f55ea461102440e7a6b05cbb9c75016079b6fb3bf7fc59"}, "downloads": -1, "filename": "recordtype-1.1.tar.gz", "has_sig": false, "md5_digest": "8133256b9c62baa2019ec16db3b14115", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 11978, "upload_time": "2011-11-15T00:08:20", "upload_time_iso_8601": "2011-11-15T00:08:20.840688Z", "url": "https://files.pythonhosted.org/packages/cc/1c/7ff90f4379110d6ef92a7f44ce487f235dbb3243f17c5294a73e0156b6f4/recordtype-1.1.tar.gz", "yanked": false}], "1.3": [{"comment_text": "", "digests": {"md5": "af2a388575083b17bf5e0bff93f83da5", "sha256": "9bbe8a217690bc1acb7ec0c2d9e12e65bf99cf08d43df3a621012ff2b88a1979"}, "downloads": -1, "filename": "recordtype-1.3.cygwin-2.10.0-x86_64.tar.gz", "has_sig": false, "md5_digest": "af2a388575083b17bf5e0bff93f83da5", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 14264, "upload_time": "2018-08-04T01:11:40", "upload_time_iso_8601": "2018-08-04T01:11:40.112824Z", "url": "https://files.pythonhosted.org/packages/9f/fd/66d22ef0aadd1fc339e52f4789aa80aef1d15778ebea0ee033a3033b81ea/recordtype-1.3.cygwin-2.10.0-x86_64.tar.gz", "yanked": false}, {"comment_text": "", "digests": {"md5": "ac86162d0e6dfc02615b765304c5198d", "sha256": "69525cdb75b7240f7aa353aa340bfdda128528de24e2a7700ba375687382a8d1"}, "downloads": -1, "filename": "recordtype-1.3-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "ac86162d0e6dfc02615b765304c5198d", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 8970, "upload_time": "2018-08-04T01:14:09", "upload_time_iso_8601": "2018-08-04T01:14:09.673254Z", "url": "https://files.pythonhosted.org/packages/60/9a/835ba329e31aa471a5597c733f7ca0136b3a0622ce01b9e66b40f5909da4/recordtype-1.3-py2.py3-none-any.whl", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "af2a388575083b17bf5e0bff93f83da5", "sha256": "9bbe8a217690bc1acb7ec0c2d9e12e65bf99cf08d43df3a621012ff2b88a1979"}, "downloads": -1, "filename": "recordtype-1.3.cygwin-2.10.0-x86_64.tar.gz", "has_sig": false, "md5_digest": "af2a388575083b17bf5e0bff93f83da5", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 14264, "upload_time": "2018-08-04T01:11:40", "upload_time_iso_8601": "2018-08-04T01:11:40.112824Z", "url": "https://files.pythonhosted.org/packages/9f/fd/66d22ef0aadd1fc339e52f4789aa80aef1d15778ebea0ee033a3033b81ea/recordtype-1.3.cygwin-2.10.0-x86_64.tar.gz", "yanked": false}, {"comment_text": "", "digests": {"md5": "ac86162d0e6dfc02615b765304c5198d", "sha256": "69525cdb75b7240f7aa353aa340bfdda128528de24e2a7700ba375687382a8d1"}, "downloads": -1, "filename": "recordtype-1.3-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "ac86162d0e6dfc02615b765304c5198d", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 8970, "upload_time": "2018-08-04T01:14:09", "upload_time_iso_8601": "2018-08-04T01:14:09.673254Z", "url": "https://files.pythonhosted.org/packages/60/9a/835ba329e31aa471a5597c733f7ca0136b3a0622ce01b9e66b40f5909da4/recordtype-1.3-py2.py3-none-any.whl", "yanked": false}], "timestamp": "Fri May  8 03:06:06 2020"}