{"info": {"author": "grwlf", "author_email": "grrwlf@gmail.com", "bugtrack_url": null, "classifiers": ["Development Status :: 3 - Alpha", "Intended Audience :: Developers", "License :: OSI Approved :: Apache Software License", "Operating System :: POSIX :: Linux", "Programming Language :: Python :: 3", "Topic :: Software Development :: Build Tools", "Topic :: System :: Software Distribution"], "description": "![coverage](https://codecov.io/gh/stagedml/pylightnix/branch/master/graph/badge.svg)\n\nPylightnix\n==========\n\nPylightnix is a Python-based DSL library for manipulating filesystem-based\nimmutable data objects, inspired by the [Nix](https://nixos.org) package\nmanager.\n\nPylightnix provides a generic Python API, allowing programmers to:\n\n* Define linked immutable data objects by specifying how to create them\n  and how to operate on them.\n* Actually create (build) such objects in a filesystem-based storage, access\n  their data, inspect dependencies, and remove them as needed.\n* Special attention is paid to the support of non-deterministic build processes.\n\nPylightnix originally appeared as a core module of\n[StagedML](https://github.com/stagedml/stagedml) library, later it was moved\ninto a separate project.\n\nContents\n--------\n\n1. [Features](#Features)\n2. [Related work](#Related-work)\n3. [Install](#Install)\n4. [Documentation](#Documentation)\n5. [Quick start](#Quick-start)\n6. [Rational](#Rational)\n\n\nFeatures\n--------\n\nLogic:\n\n* Pylightnix allows us to Create, query and maintain linked objects, called here\n  **stages**.\n* Creation of stages includes two passes: At the **instantiation** pass we check\n  configurations of the whole graph of linked objects. At the **realization**\n  pass we decide whether to take existing realization or to run the constructors\n  to get new ones.\n* Pylightnix is focused on non-deterministic build processes such as machine\n  learning. We formalize comparison and selection of competing results of such\n  processes.\n* The possible applications of Pylightnix include:\n  - Data science / Machine learning experiments (see [StagedML](https://github.com/stagedml/stagedml))\n  - Domain-specific package managers\n  - Other applications which fit into blackboard design pattern\n    ([wiki](https://en.wikipedia.org/wiki/Blackboard_design_pattern)).\n\nImplementation:\n\n* Written in Python 3.6, [mypy](http://mypy-lang.org/) typing information is\n  provided.\n* Tested with Pytest and [hypothesis](https://hypothesis.works).\n* No non-standard Python dependencies. We do require\n  [wget](https://www.gnu.org/software/wget/) and\n  [atool](https://www.nongnu.org/atool/) system packages.\n* Alas, Pylightnix is not a production-ready yet! Nor parallelism, neither\n  network synchronization are supported out of the box. Also, we didn't check it\n  on any operating system besides Linux.\n  - We tried our best to make Pylightnix' operations on storage atomic. Among\n    other benefits, this design allows running multiple instances of the library\n    on a single storage at once.\n  - Synchronization of different machines should be possible by exclusively\n    running `rsync` tool on their storages.\n\n\nRelated work\n------------\n\n* [Nix](https://nixos.org) ([repo](https://github.com/nixos/nix),\n  [comparison](./docs/Comparison.md#Pylightnix-vs-Nix))\n* [Spack](https://spack.io) ([repo](https://github.com/spack/spack))\n* [Popper](https://falsifiable.us) ([repo](https://github.com/systemslab/popper))\n* [CK](https://cknowledge.org) ([repo](https://github.com/ctuning/ck))\n\n\nInstall\n-------\n\n#### Install with Pip\n\nPylightnix is not yet released on Pypi, the only way to install it with pip\nis to use the git link:\n\n ```sh\n $ pip3 install git+https://github.com/stagedml/pylightnix\n ```\n\n#### Build from source\n\n1. Clone the repo\n   ```sh\n   $ git clone https://github.com/stagedml/pylightnix\n   $ cd pylightnix\n   ```\n2. Either\n   - (a) Setup `PYTHONPATH` to point to the sources.\n     ```sh\n     export PYTHONPATH=\"`pwd`/src:$PYTHONPATH\"\n     ```\n     Now you could import pylightnix from your applications.\n\n   - (b) Build and install pylightnix wheel.\n     ```sh\n     $ make wheels\n     $ sudo -H pip3 install --force dist/*whl\n     ```\n   - (c) Nix users may refer to [default.nix](./default.nix) and\n     [shell.nix](./shell.nix) expressions.\n3. (Optional) Run the tests and make docs\n   ```sh\n   $ make coverage\n   $ make docs\n   ```\n4. (Optional) Demos require `pweave` package.\n   ```sh\n   $ make demos\n   ```\n\nDocumentation\n-------------\n\nDemos:\n\n* [Hello](./docs/demos/HELLO.md), building GNU Hello with a toy package manager.\n* [Ultimatum tutorial](https://github.com/grwlf/ultimatum-game/blob/master/docs/Pylightnix.md),\n  managing experiments.\n* [MNIST demo](./docs/demos/MNIST.md) shows machine learning specifics.\n* [REPL demo](./docs/demos/REPL.md) illustrates how to debug stages using\n  Read-Eval-Print-friendly routines\n  [(wiki)](https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop).\n\nReference:\n\n* [API Reference](./docs/Reference.md)\n* [Tests](./tests)\n\n\nQuick start\n-----------\n\nPylightnix could be used as a lightweight build system (but rather unsafe,\nbecause of the lack of built-in build isolation). This quick start illustrates\nthis use-case by defining a couple of objects (\"stages\") required to build the\nGNU Hello program.\n\nThe below operations require pure Python environment with Pylightnix library\ninstalled.\n\n1. Install the development version of pylightnix and run IPython.\n\n   ```sh\n   $ pip install ipython git+https://github.com/stagedml/pylightnix\n   $ ipython\n   ```\n\n   Subsequent steps may be copypasted into the IPython shell\n\n2. Make sure that the storage is initialized\n\n   ```python\n   from pylightnix import store_initialize\n   store_initialize()\n   ```\n\n3. Define the process of  `fetchurl` stage. We use `_inplace` subset of\n   Pylightnix API for simplicity. It relies on a single global variable for\n   storing tracking the build plan.\n\n   ```python\n   from pylightnix import DRef, instantiate_inplace, fetchurl\n   from pylightnix import RRef, realize_inplace\n\n   hello_version = '2.10'\n\n   # Phase 1, create the derivation\n   hello_src:DRef = \\\n     instantiate_inplace(\n       fetchurl,\n       name='hello-src',\n       url=f'http://ftp.gnu.org/gnu/hello/hello-{hello_version}.tar.gz',\n       sha256='31e066137a962676e89f69d1b65382de95a7ef7d914b8cb956f41ea72e0f516b')\n\n   # Phase 2, realize the derivation into actual object\n   hello_rref:RRef = realize_inplace(hello_src)\n   print(hello_rref)\n   ```\n\n4. Define how to create an object containing GNU Hello binary, that is, a\n   Hello-builder stage\n\n   ```python\n   from tempfile import TemporaryDirectory\n   from shutil import copytree\n   from os import getcwd, chdir, system\n   from os.path import join\n   from pylightnix import Config, mkconfig\n   from pylightnix import Path, Build, build_cattrs, build_outpath, build_path\n   from pylightnix import mkdrv, build_wrapper, match_latest, dirrw\n\n   def hello_config()->Config:\n     name:str = 'hello-bin'\n     src:RefPath = [hello_src, f'hello-{hello_version}']\n     return mkconfig(locals())\n\n   def hello_realize(b:Build)->None:\n     c:Any = build_cattrs(b)\n     o:Path = build_outpath(b)\n     with TemporaryDirectory() as tmp:\n       copytree(build_path(b,c.src),join(tmp,'src'))\n       dirrw(Path(join(tmp,'src')))\n       cwd = getcwd()\n       try:\n         chdir(join(tmp,'src'))\n         system(f'./configure --prefix=/usr')\n         system(f'make')\n         system(f'make install DESTDIR={o}')\n       finally:\n         chdir(cwd)\n\n   # Phase 1, create the derivation. Note, we reference previous stage's\n   # derivation in the configuration of this derivation.\n   hello_dref:DRef = \\\n       instantiate_inplace(mkdrv, hello_config(), match_latest(), build_wrapper(hello_realize))\n\n   # Phase 2, realize the derivation\n   hello_rref:RRef = realize_inplace(hello_dref)\n\n   print(hello_rref)\n   ```\n\n   We now have a [realization\n   reference](./docs/Reference.md#pylightnix.types.RRef) which describes the\n   concrete folder in the filesystem storage, which contains the binary\n   artifacts we put there during the realization. Next calls to `realize` would\n   simply return the same reference unless we ask it to produce another\n   realization by passing `force_rebuild=[hello_dref]` argument (and unless the\n   build process really produces a different data).\n\n5. We now access our hello-binary object, and run the GNU Hello program it\n   contains.\n\n   ```python\n   from pylightnix import rref2path\n\n   path=rref2path(hello_rref)\n   system(join(path,'usr/bin/hello'))\n   ```\n\n   Output:\n\n   ```\n   Hello World!\n   ```\n\n6. Pylightnix provides a set of bash-like functions for inspecting the storage.\n\n   ```python\n   from pylightnix import lsref, catref, shellref, rmref, du\n   ```\n\n   We could list the contents of the realization, cat some of it's text files,\n   open an interactive Unix shell as set by the `SHELL` environment variable.\n   `rmref` may be used to completely remove the realization or derivation from\n   the storage (safety checks are up to the user for now). `du` stands for\n   'disk usage' and calculates the size of realizations stored.\n\n\nRational\n--------\n\n* Q: Why based on Nix ideas?\n* A: There are many solutions in the area of software deployment. Besides Nix,\n  we know all the traditional package managers, Docker, AppImage, VirtualBox,\n  other virtualizers. One property of Nix we want to highlight is it's low\n  system requirements. Basically, Nix' core may work on a system which has only\n  a filestorage and symlinks. Here we try to follow this trend by keeping the\n  number of dependencies low while providing a competitive set of features.\n\n\n\n* Q: Why does the API contain mostly functions and almost no classes?\n* A: Several reasones: a) This would allow us to keep users informed about the\n  API changes. We are trying to avoid changes in functions which are already\n  published. By importing functions explicitly, users will notice such changes\n  quickly. b) Typical class-based APIs of Python often let users think that they\n  could extend it by sub-classing. Here we don't want to misinform users. c)\n  Class-based wrapper API may be created as a standalone module, see\n  [Lens](./docs/Reference.md#pylightnix.lens.Lens).\n\n\n( TODO )\n\n\n\n\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/stagedml/pylightnix", "keywords": "", "license": "", "maintainer": "", "maintainer_email": "", "name": "pylightnix", "package_url": "https://pypi.org/project/pylightnix/", "platform": "", "project_url": "https://pypi.org/project/pylightnix/", "project_urls": {"Homepage": "https://github.com/stagedml/pylightnix"}, "release_url": "https://pypi.org/project/pylightnix/0.2.0/", "requires_dist": null, "requires_python": ">=3.6", "summary": "A Nix-style immutable data management library in Python", "version": "0.2.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p><img alt=\"coverage\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/d8c1f9695d9eb803c958e4b13d33b5cc90194c5d/68747470733a2f2f636f6465636f762e696f2f67682f7374616765646d6c2f70796c696768746e69782f6272616e63682f6d61737465722f67726170682f62616467652e737667\"></p>\n<h1>Pylightnix</h1>\n<p>Pylightnix is a Python-based DSL library for manipulating filesystem-based\nimmutable data objects, inspired by the <a href=\"https://nixos.org\" rel=\"nofollow\">Nix</a> package\nmanager.</p>\n<p>Pylightnix provides a generic Python API, allowing programmers to:</p>\n<ul>\n<li>Define linked immutable data objects by specifying how to create them\nand how to operate on them.</li>\n<li>Actually create (build) such objects in a filesystem-based storage, access\ntheir data, inspect dependencies, and remove them as needed.</li>\n<li>Special attention is paid to the support of non-deterministic build processes.</li>\n</ul>\n<p>Pylightnix originally appeared as a core module of\n<a href=\"https://github.com/stagedml/stagedml\" rel=\"nofollow\">StagedML</a> library, later it was moved\ninto a separate project.</p>\n<h2>Contents</h2>\n<ol>\n<li><a href=\"#Features\" rel=\"nofollow\">Features</a></li>\n<li><a href=\"#Related-work\" rel=\"nofollow\">Related work</a></li>\n<li><a href=\"#Install\" rel=\"nofollow\">Install</a></li>\n<li><a href=\"#Documentation\" rel=\"nofollow\">Documentation</a></li>\n<li><a href=\"#Quick-start\" rel=\"nofollow\">Quick start</a></li>\n<li><a href=\"#Rational\" rel=\"nofollow\">Rational</a></li>\n</ol>\n<h2>Features</h2>\n<p>Logic:</p>\n<ul>\n<li>Pylightnix allows us to Create, query and maintain linked objects, called here\n<strong>stages</strong>.</li>\n<li>Creation of stages includes two passes: At the <strong>instantiation</strong> pass we check\nconfigurations of the whole graph of linked objects. At the <strong>realization</strong>\npass we decide whether to take existing realization or to run the constructors\nto get new ones.</li>\n<li>Pylightnix is focused on non-deterministic build processes such as machine\nlearning. We formalize comparison and selection of competing results of such\nprocesses.</li>\n<li>The possible applications of Pylightnix include:\n<ul>\n<li>Data science / Machine learning experiments (see <a href=\"https://github.com/stagedml/stagedml\" rel=\"nofollow\">StagedML</a>)</li>\n<li>Domain-specific package managers</li>\n<li>Other applications which fit into blackboard design pattern\n(<a href=\"https://en.wikipedia.org/wiki/Blackboard_design_pattern\" rel=\"nofollow\">wiki</a>).</li>\n</ul>\n</li>\n</ul>\n<p>Implementation:</p>\n<ul>\n<li>Written in Python 3.6, <a href=\"http://mypy-lang.org/\" rel=\"nofollow\">mypy</a> typing information is\nprovided.</li>\n<li>Tested with Pytest and <a href=\"https://hypothesis.works\" rel=\"nofollow\">hypothesis</a>.</li>\n<li>No non-standard Python dependencies. We do require\n<a href=\"https://www.gnu.org/software/wget/\" rel=\"nofollow\">wget</a> and\n<a href=\"https://www.nongnu.org/atool/\" rel=\"nofollow\">atool</a> system packages.</li>\n<li>Alas, Pylightnix is not a production-ready yet! Nor parallelism, neither\nnetwork synchronization are supported out of the box. Also, we didn't check it\non any operating system besides Linux.\n<ul>\n<li>We tried our best to make Pylightnix' operations on storage atomic. Among\nother benefits, this design allows running multiple instances of the library\non a single storage at once.</li>\n<li>Synchronization of different machines should be possible by exclusively\nrunning <code>rsync</code> tool on their storages.</li>\n</ul>\n</li>\n</ul>\n<h2>Related work</h2>\n<ul>\n<li><a href=\"https://nixos.org\" rel=\"nofollow\">Nix</a> (<a href=\"https://github.com/nixos/nix\" rel=\"nofollow\">repo</a>,\n<a href=\"./docs/Comparison.md#Pylightnix-vs-Nix\" rel=\"nofollow\">comparison</a>)</li>\n<li><a href=\"https://spack.io\" rel=\"nofollow\">Spack</a> (<a href=\"https://github.com/spack/spack\" rel=\"nofollow\">repo</a>)</li>\n<li><a href=\"https://falsifiable.us\" rel=\"nofollow\">Popper</a> (<a href=\"https://github.com/systemslab/popper\" rel=\"nofollow\">repo</a>)</li>\n<li><a href=\"https://cknowledge.org\" rel=\"nofollow\">CK</a> (<a href=\"https://github.com/ctuning/ck\" rel=\"nofollow\">repo</a>)</li>\n</ul>\n<h2>Install</h2>\n<h4>Install with Pip</h4>\n<p>Pylightnix is not yet released on Pypi, the only way to install it with pip\nis to use the git link:</p>\n<pre>$ pip3 install git+https://github.com/stagedml/pylightnix\n</pre>\n<h4>Build from source</h4>\n<ol>\n<li>Clone the repo\n<pre>$ git clone https://github.com/stagedml/pylightnix\n$ <span class=\"nb\">cd</span> pylightnix\n</pre>\n</li>\n<li>Either\n<ul>\n<li>\n<p>(a) Setup <code>PYTHONPATH</code> to point to the sources.</p>\n<pre><span class=\"nb\">export</span> <span class=\"nv\">PYTHONPATH</span><span class=\"o\">=</span><span class=\"s2\">\"`pwd`/src:</span><span class=\"nv\">$PYTHONPATH</span><span class=\"s2\">\"</span>\n</pre>\n<p>Now you could import pylightnix from your applications.</p>\n</li>\n<li>\n<p>(b) Build and install pylightnix wheel.</p>\n<pre>$ make wheels\n$ sudo -H pip3 install --force dist/*whl\n</pre>\n</li>\n<li>\n<p>(c) Nix users may refer to <a href=\"./default.nix\" rel=\"nofollow\">default.nix</a> and\n<a href=\"./shell.nix\" rel=\"nofollow\">shell.nix</a> expressions.</p>\n</li>\n</ul>\n</li>\n<li>(Optional) Run the tests and make docs\n<pre>$ make coverage\n$ make docs\n</pre>\n</li>\n<li>(Optional) Demos require <code>pweave</code> package.\n<pre>$ make demos\n</pre>\n</li>\n</ol>\n<h2>Documentation</h2>\n<p>Demos:</p>\n<ul>\n<li><a href=\"./docs/demos/HELLO.md\" rel=\"nofollow\">Hello</a>, building GNU Hello with a toy package manager.</li>\n<li><a href=\"https://github.com/grwlf/ultimatum-game/blob/master/docs/Pylightnix.md\" rel=\"nofollow\">Ultimatum tutorial</a>,\nmanaging experiments.</li>\n<li><a href=\"./docs/demos/MNIST.md\" rel=\"nofollow\">MNIST demo</a> shows machine learning specifics.</li>\n<li><a href=\"./docs/demos/REPL.md\" rel=\"nofollow\">REPL demo</a> illustrates how to debug stages using\nRead-Eval-Print-friendly routines\n<a href=\"https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop\" rel=\"nofollow\">(wiki)</a>.</li>\n</ul>\n<p>Reference:</p>\n<ul>\n<li><a href=\"./docs/Reference.md\" rel=\"nofollow\">API Reference</a></li>\n<li><a href=\"./tests\" rel=\"nofollow\">Tests</a></li>\n</ul>\n<h2>Quick start</h2>\n<p>Pylightnix could be used as a lightweight build system (but rather unsafe,\nbecause of the lack of built-in build isolation). This quick start illustrates\nthis use-case by defining a couple of objects (\"stages\") required to build the\nGNU Hello program.</p>\n<p>The below operations require pure Python environment with Pylightnix library\ninstalled.</p>\n<ol>\n<li>\n<p>Install the development version of pylightnix and run IPython.</p>\n<pre>$ pip install ipython git+https://github.com/stagedml/pylightnix\n$ ipython\n</pre>\n<p>Subsequent steps may be copypasted into the IPython shell</p>\n</li>\n<li>\n<p>Make sure that the storage is initialized</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">pylightnix</span> <span class=\"kn\">import</span> <span class=\"n\">store_initialize</span>\n<span class=\"n\">store_initialize</span><span class=\"p\">()</span>\n</pre>\n</li>\n<li>\n<p>Define the process of  <code>fetchurl</code> stage. We use <code>_inplace</code> subset of\nPylightnix API for simplicity. It relies on a single global variable for\nstoring tracking the build plan.</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">pylightnix</span> <span class=\"kn\">import</span> <span class=\"n\">DRef</span><span class=\"p\">,</span> <span class=\"n\">instantiate_inplace</span><span class=\"p\">,</span> <span class=\"n\">fetchurl</span>\n<span class=\"kn\">from</span> <span class=\"nn\">pylightnix</span> <span class=\"kn\">import</span> <span class=\"n\">RRef</span><span class=\"p\">,</span> <span class=\"n\">realize_inplace</span>\n\n<span class=\"n\">hello_version</span> <span class=\"o\">=</span> <span class=\"s1\">'2.10'</span>\n\n<span class=\"c1\"># Phase 1, create the derivation</span>\n<span class=\"n\">hello_src</span><span class=\"p\">:</span><span class=\"n\">DRef</span> <span class=\"o\">=</span> \\\n  <span class=\"n\">instantiate_inplace</span><span class=\"p\">(</span>\n    <span class=\"n\">fetchurl</span><span class=\"p\">,</span>\n    <span class=\"n\">name</span><span class=\"o\">=</span><span class=\"s1\">'hello-src'</span><span class=\"p\">,</span>\n    <span class=\"n\">url</span><span class=\"o\">=</span><span class=\"sa\">f</span><span class=\"s1\">'http://ftp.gnu.org/gnu/hello/hello-</span><span class=\"si\">{</span><span class=\"n\">hello_version</span><span class=\"si\">}</span><span class=\"s1\">.tar.gz'</span><span class=\"p\">,</span>\n    <span class=\"n\">sha256</span><span class=\"o\">=</span><span class=\"s1\">'31e066137a962676e89f69d1b65382de95a7ef7d914b8cb956f41ea72e0f516b'</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Phase 2, realize the derivation into actual object</span>\n<span class=\"n\">hello_rref</span><span class=\"p\">:</span><span class=\"n\">RRef</span> <span class=\"o\">=</span> <span class=\"n\">realize_inplace</span><span class=\"p\">(</span><span class=\"n\">hello_src</span><span class=\"p\">)</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">hello_rref</span><span class=\"p\">)</span>\n</pre>\n</li>\n<li>\n<p>Define how to create an object containing GNU Hello binary, that is, a\nHello-builder stage</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">tempfile</span> <span class=\"kn\">import</span> <span class=\"n\">TemporaryDirectory</span>\n<span class=\"kn\">from</span> <span class=\"nn\">shutil</span> <span class=\"kn\">import</span> <span class=\"n\">copytree</span>\n<span class=\"kn\">from</span> <span class=\"nn\">os</span> <span class=\"kn\">import</span> <span class=\"n\">getcwd</span><span class=\"p\">,</span> <span class=\"n\">chdir</span><span class=\"p\">,</span> <span class=\"n\">system</span>\n<span class=\"kn\">from</span> <span class=\"nn\">os.path</span> <span class=\"kn\">import</span> <span class=\"n\">join</span>\n<span class=\"kn\">from</span> <span class=\"nn\">pylightnix</span> <span class=\"kn\">import</span> <span class=\"n\">Config</span><span class=\"p\">,</span> <span class=\"n\">mkconfig</span>\n<span class=\"kn\">from</span> <span class=\"nn\">pylightnix</span> <span class=\"kn\">import</span> <span class=\"n\">Path</span><span class=\"p\">,</span> <span class=\"n\">Build</span><span class=\"p\">,</span> <span class=\"n\">build_cattrs</span><span class=\"p\">,</span> <span class=\"n\">build_outpath</span><span class=\"p\">,</span> <span class=\"n\">build_path</span>\n<span class=\"kn\">from</span> <span class=\"nn\">pylightnix</span> <span class=\"kn\">import</span> <span class=\"n\">mkdrv</span><span class=\"p\">,</span> <span class=\"n\">build_wrapper</span><span class=\"p\">,</span> <span class=\"n\">match_latest</span><span class=\"p\">,</span> <span class=\"n\">dirrw</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">hello_config</span><span class=\"p\">()</span><span class=\"o\">-&gt;</span><span class=\"n\">Config</span><span class=\"p\">:</span>\n  <span class=\"n\">name</span><span class=\"p\">:</span><span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">'hello-bin'</span>\n  <span class=\"n\">src</span><span class=\"p\">:</span><span class=\"n\">RefPath</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">hello_src</span><span class=\"p\">,</span> <span class=\"sa\">f</span><span class=\"s1\">'hello-</span><span class=\"si\">{</span><span class=\"n\">hello_version</span><span class=\"si\">}</span><span class=\"s1\">'</span><span class=\"p\">]</span>\n  <span class=\"k\">return</span> <span class=\"n\">mkconfig</span><span class=\"p\">(</span><span class=\"nb\">locals</span><span class=\"p\">())</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">hello_realize</span><span class=\"p\">(</span><span class=\"n\">b</span><span class=\"p\">:</span><span class=\"n\">Build</span><span class=\"p\">)</span><span class=\"o\">-&gt;</span><span class=\"kc\">None</span><span class=\"p\">:</span>\n  <span class=\"n\">c</span><span class=\"p\">:</span><span class=\"n\">Any</span> <span class=\"o\">=</span> <span class=\"n\">build_cattrs</span><span class=\"p\">(</span><span class=\"n\">b</span><span class=\"p\">)</span>\n  <span class=\"n\">o</span><span class=\"p\">:</span><span class=\"n\">Path</span> <span class=\"o\">=</span> <span class=\"n\">build_outpath</span><span class=\"p\">(</span><span class=\"n\">b</span><span class=\"p\">)</span>\n  <span class=\"k\">with</span> <span class=\"n\">TemporaryDirectory</span><span class=\"p\">()</span> <span class=\"k\">as</span> <span class=\"n\">tmp</span><span class=\"p\">:</span>\n    <span class=\"n\">copytree</span><span class=\"p\">(</span><span class=\"n\">build_path</span><span class=\"p\">(</span><span class=\"n\">b</span><span class=\"p\">,</span><span class=\"n\">c</span><span class=\"o\">.</span><span class=\"n\">src</span><span class=\"p\">),</span><span class=\"n\">join</span><span class=\"p\">(</span><span class=\"n\">tmp</span><span class=\"p\">,</span><span class=\"s1\">'src'</span><span class=\"p\">))</span>\n    <span class=\"n\">dirrw</span><span class=\"p\">(</span><span class=\"n\">Path</span><span class=\"p\">(</span><span class=\"n\">join</span><span class=\"p\">(</span><span class=\"n\">tmp</span><span class=\"p\">,</span><span class=\"s1\">'src'</span><span class=\"p\">)))</span>\n    <span class=\"n\">cwd</span> <span class=\"o\">=</span> <span class=\"n\">getcwd</span><span class=\"p\">()</span>\n    <span class=\"k\">try</span><span class=\"p\">:</span>\n      <span class=\"n\">chdir</span><span class=\"p\">(</span><span class=\"n\">join</span><span class=\"p\">(</span><span class=\"n\">tmp</span><span class=\"p\">,</span><span class=\"s1\">'src'</span><span class=\"p\">))</span>\n      <span class=\"n\">system</span><span class=\"p\">(</span><span class=\"sa\">f</span><span class=\"s1\">'./configure --prefix=/usr'</span><span class=\"p\">)</span>\n      <span class=\"n\">system</span><span class=\"p\">(</span><span class=\"sa\">f</span><span class=\"s1\">'make'</span><span class=\"p\">)</span>\n      <span class=\"n\">system</span><span class=\"p\">(</span><span class=\"sa\">f</span><span class=\"s1\">'make install DESTDIR=</span><span class=\"si\">{</span><span class=\"n\">o</span><span class=\"si\">}</span><span class=\"s1\">'</span><span class=\"p\">)</span>\n    <span class=\"k\">finally</span><span class=\"p\">:</span>\n      <span class=\"n\">chdir</span><span class=\"p\">(</span><span class=\"n\">cwd</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Phase 1, create the derivation. Note, we reference previous stage's</span>\n<span class=\"c1\"># derivation in the configuration of this derivation.</span>\n<span class=\"n\">hello_dref</span><span class=\"p\">:</span><span class=\"n\">DRef</span> <span class=\"o\">=</span> \\\n    <span class=\"n\">instantiate_inplace</span><span class=\"p\">(</span><span class=\"n\">mkdrv</span><span class=\"p\">,</span> <span class=\"n\">hello_config</span><span class=\"p\">(),</span> <span class=\"n\">match_latest</span><span class=\"p\">(),</span> <span class=\"n\">build_wrapper</span><span class=\"p\">(</span><span class=\"n\">hello_realize</span><span class=\"p\">))</span>\n\n<span class=\"c1\"># Phase 2, realize the derivation</span>\n<span class=\"n\">hello_rref</span><span class=\"p\">:</span><span class=\"n\">RRef</span> <span class=\"o\">=</span> <span class=\"n\">realize_inplace</span><span class=\"p\">(</span><span class=\"n\">hello_dref</span><span class=\"p\">)</span>\n\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">hello_rref</span><span class=\"p\">)</span>\n</pre>\n<p>We now have a <a href=\"./docs/Reference.md#pylightnix.types.RRef\" rel=\"nofollow\">realization\nreference</a> which describes the\nconcrete folder in the filesystem storage, which contains the binary\nartifacts we put there during the realization. Next calls to <code>realize</code> would\nsimply return the same reference unless we ask it to produce another\nrealization by passing <code>force_rebuild=[hello_dref]</code> argument (and unless the\nbuild process really produces a different data).</p>\n</li>\n<li>\n<p>We now access our hello-binary object, and run the GNU Hello program it\ncontains.</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">pylightnix</span> <span class=\"kn\">import</span> <span class=\"n\">rref2path</span>\n\n<span class=\"n\">path</span><span class=\"o\">=</span><span class=\"n\">rref2path</span><span class=\"p\">(</span><span class=\"n\">hello_rref</span><span class=\"p\">)</span>\n<span class=\"n\">system</span><span class=\"p\">(</span><span class=\"n\">join</span><span class=\"p\">(</span><span class=\"n\">path</span><span class=\"p\">,</span><span class=\"s1\">'usr/bin/hello'</span><span class=\"p\">))</span>\n</pre>\n<p>Output:</p>\n<pre><code>Hello World!\n</code></pre>\n</li>\n<li>\n<p>Pylightnix provides a set of bash-like functions for inspecting the storage.</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">pylightnix</span> <span class=\"kn\">import</span> <span class=\"n\">lsref</span><span class=\"p\">,</span> <span class=\"n\">catref</span><span class=\"p\">,</span> <span class=\"n\">shellref</span><span class=\"p\">,</span> <span class=\"n\">rmref</span><span class=\"p\">,</span> <span class=\"n\">du</span>\n</pre>\n<p>We could list the contents of the realization, cat some of it's text files,\nopen an interactive Unix shell as set by the <code>SHELL</code> environment variable.\n<code>rmref</code> may be used to completely remove the realization or derivation from\nthe storage (safety checks are up to the user for now). <code>du</code> stands for\n'disk usage' and calculates the size of realizations stored.</p>\n</li>\n</ol>\n<h2>Rational</h2>\n<ul>\n<li>\n<p>Q: Why based on Nix ideas?</p>\n</li>\n<li>\n<p>A: There are many solutions in the area of software deployment. Besides Nix,\nwe know all the traditional package managers, Docker, AppImage, VirtualBox,\nother virtualizers. One property of Nix we want to highlight is it's low\nsystem requirements. Basically, Nix' core may work on a system which has only\na filestorage and symlinks. Here we try to follow this trend by keeping the\nnumber of dependencies low while providing a competitive set of features.</p>\n</li>\n<li>\n<p>Q: Why does the API contain mostly functions and almost no classes?</p>\n</li>\n<li>\n<p>A: Several reasones: a) This would allow us to keep users informed about the\nAPI changes. We are trying to avoid changes in functions which are already\npublished. By importing functions explicitly, users will notice such changes\nquickly. b) Typical class-based APIs of Python often let users think that they\ncould extend it by sub-classing. Here we don't want to misinform users. c)\nClass-based wrapper API may be created as a standalone module, see\n<a href=\"./docs/Reference.md#pylightnix.lens.Lens\" rel=\"nofollow\">Lens</a>.</p>\n</li>\n</ul>\n<p>( TODO )</p>\n\n          </div>"}, "last_serial": 7159688, "releases": {"0.1.0": [{"comment_text": "", "digests": {"md5": "7bd8f3a1f30886dd4bc35cfaf1b1963f", "sha256": "9849e1071fe24441b820207fde96ef8682f82f04f038e8e35e88f70d013717c4"}, "downloads": -1, "filename": "pylightnix-0.1.0-py3-none-any.whl", "has_sig": false, "md5_digest": "7bd8f3a1f30886dd4bc35cfaf1b1963f", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 49792, "upload_time": "2020-03-21T18:17:10", "upload_time_iso_8601": "2020-03-21T18:17:10.785791Z", "url": "https://files.pythonhosted.org/packages/ff/eb/5c29bee7b62e1579f4990509415ab03ab9dc052fd5a9a2f12e8daf60e436/pylightnix-0.1.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "695b594712ccc3da315c9b83bb955f79", "sha256": "4d35a254c8d85c38d48d90f23dfa12701543127423dc76fb8edd9f206a51ec17"}, "downloads": -1, "filename": "pylightnix-0.1.0.tar.gz", "has_sig": false, "md5_digest": "695b594712ccc3da315c9b83bb955f79", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 41503, "upload_time": "2020-03-21T18:17:13", "upload_time_iso_8601": "2020-03-21T18:17:13.447989Z", "url": "https://files.pythonhosted.org/packages/7c/bf/5b38a9384ea555df4e60f504d7a531bf1b672409d1d86cbd5b3d5a0a5b8c/pylightnix-0.1.0.tar.gz", "yanked": false}], "0.2.0": [{"comment_text": "", "digests": {"md5": "c197a958fb9e3e0ad34c4ab48ef1595c", "sha256": "bde5b23add819e62a509a83795bcba3d90e2b2813b1ad7440ea696c339122ecf"}, "downloads": -1, "filename": "pylightnix-0.2.0-py3-none-any.whl", "has_sig": false, "md5_digest": "c197a958fb9e3e0ad34c4ab48ef1595c", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 54677, "upload_time": "2020-05-03T20:58:03", "upload_time_iso_8601": "2020-05-03T20:58:03.788821Z", "url": "https://files.pythonhosted.org/packages/fd/37/418d1a2d0812f8676d25d77b4470b1bb463c1c726c52bdccf4d159445b2e/pylightnix-0.2.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "ce29b98247fda40e2d5157ca297cbda6", "sha256": "989ed89d1d2f78b583e8cc43dfc5f7a77ea292b809057978682660be05daae3d"}, "downloads": -1, "filename": "pylightnix-0.2.0.tar.gz", "has_sig": false, "md5_digest": "ce29b98247fda40e2d5157ca297cbda6", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 45419, "upload_time": "2020-05-03T20:58:05", "upload_time_iso_8601": "2020-05-03T20:58:05.634705Z", "url": "https://files.pythonhosted.org/packages/07/ec/7cac44371f965422c2a59a493f8516bfb2abf16356063acb64970b2899bd/pylightnix-0.2.0.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "c197a958fb9e3e0ad34c4ab48ef1595c", "sha256": "bde5b23add819e62a509a83795bcba3d90e2b2813b1ad7440ea696c339122ecf"}, "downloads": -1, "filename": "pylightnix-0.2.0-py3-none-any.whl", "has_sig": false, "md5_digest": "c197a958fb9e3e0ad34c4ab48ef1595c", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 54677, "upload_time": "2020-05-03T20:58:03", "upload_time_iso_8601": "2020-05-03T20:58:03.788821Z", "url": "https://files.pythonhosted.org/packages/fd/37/418d1a2d0812f8676d25d77b4470b1bb463c1c726c52bdccf4d159445b2e/pylightnix-0.2.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "ce29b98247fda40e2d5157ca297cbda6", "sha256": "989ed89d1d2f78b583e8cc43dfc5f7a77ea292b809057978682660be05daae3d"}, "downloads": -1, "filename": "pylightnix-0.2.0.tar.gz", "has_sig": false, "md5_digest": "ce29b98247fda40e2d5157ca297cbda6", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 45419, "upload_time": "2020-05-03T20:58:05", "upload_time_iso_8601": "2020-05-03T20:58:05.634705Z", "url": "https://files.pythonhosted.org/packages/07/ec/7cac44371f965422c2a59a493f8516bfb2abf16356063acb64970b2899bd/pylightnix-0.2.0.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:03:05 2020"}