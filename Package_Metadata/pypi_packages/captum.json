{"info": {"author": "PyTorch Team", "author_email": "", "bugtrack_url": null, "classifiers": ["Development Status :: 4 - Beta", "Intended Audience :: Developers", "Intended Audience :: Education", "Intended Audience :: Science/Research", "License :: OSI Approved :: BSD License", "Programming Language :: Python :: 3 :: Only", "Topic :: Scientific/Engineering"], "description": "![Captum Logo](./website/static/img/captum_logo.png)\n\n<hr/>\n\n[![Conda](https://img.shields.io/conda/v/pytorch/captum.svg)](https://anaconda.org/pytorch/captum)\n[![PyPI](https://img.shields.io/pypi/v/captum.svg)](https://pypi.org/project/captum)\n[![CircleCI](https://circleci.com/gh/pytorch/captum.svg?style=shield)](https://circleci.com/gh/pytorch/captum)\n\nCaptum is a model interpretability and understanding library for PyTorch.\nCaptum means comprehension in latin and contains general purpose implementations\nof integrated gradients, saliency maps, smoothgrad, vargrad and others for\nPyTorch models. It has quick integration for models built with domain-specific\nlibraries such as torchvision, torchtext, and others.\n\n*Captum is currently in beta and under active development!*\n\n\n#### About Captum\n\nWith the increase in model complexity and the resulting lack of transparency, model interpretability methods have become increasingly important. Model understanding is both an active area of research as well as an area of focus for practical applications across industries using machine learning. Captum provides state-of-the-art algorithms, including Integrated Gradients, to provide researchers and developers with an easy way to understand which features are contributing to a model\u2019s output.\n\nFor model developers, Captum can be used to improve and troubleshoot models by facilitating the identification of different features that contribute to a model\u2019s output in order to design better models and troubleshoot unexpected model outputs.\n\nCaptum helps ML researchers more easily implement interpretability algorithms that can interact with PyTorch models. Captum also allows researchers to quickly benchmark their work against other existing algorithms available in the library.\n\n#### Target Audience\n\nThe primary audiences for Captum are model developers who are looking to improve their models and understand which features are important and interpretability researchers focused on identifying algorithms that can better interpret many types of models.\n\nCaptum can also be used by application engineers who are using trained models in production. Captum provides easier troubleshooting through improved model interpretability, and the potential for delivering better explanations to end users on why they\u2019re seeing a specific piece of content, such as a movie recommendation.\n\n## Installation\n\n**Installation Requirements**\n- Python >= 3.6\n- PyTorch >= 1.2\n\n\n##### Installing the latest release\n\nThe latest release of Captum is easily installed either via\n[Anaconda](https://www.anaconda.com/distribution/#download-section) (recommended):\n```bash\nconda install captum -c pytorch\n```\nor via `pip`:\n```bash\npip install captum\n```\n\n**Manual / Dev install**\n\nIf you'd like to try our bleeding edge features (and don't mind potentially\nrunning into the occasional bug here or there), you can install the latest\nmaster directly from GitHub. For a basic install, run:\n```bash\ngit clone https://github.com/pytorch/captum.git\ncd captum\npip install -e .\n```\n\nTo customize the installation, you can also run the following variants of the\nabove:\n* `pip install -e .[insights]`: Also installs all packages necessary for running Captum Insights.\n* `pip install -e .[dev]`: Also installs all tools necessary for development\n  (testing, linting, docs building; see [Contributing](#contributing) below).\n* `pip install -e .[tutorials]`: Also installs all packages necessary for running the tutorial notebooks.\n\nTo execute unit tests from a manual install, run:\n```bash\n# running a single unit test\npython -m unittest -v tests.attr.test_saliency\n# running all unit tests\npytest -ra\n```\n\n## Getting Started\nCaptum helps you interpret and understand predictions of PyTorch models by\nexploring features that contribute to a prediction the model makes.\nIt also helps understand which neurons and layers are important for\nmodel predictions.\n\nCurrently, the library uses gradient-based interpretability algorithms\nand attributes contributions to each input of the model with respect to\ndifferent neurons and layers, both intermediate and final.\n\nLet's apply some of those algorithms to a toy model we have created for\ndemonstration purposes.\nFor simplicity, we will use the following architecture, but users are welcome\nto use any PyTorch model of their choice.\n\n\n```python\nimport numpy as np\n\nimport torch\nimport torch.nn as nn\n\nfrom captum.attr import (\n    GradientShap,\n    DeepLift,\n    DeepLiftShap,\n    IntegratedGradients,\n    LayerConductance,\n    NeuronConductance,\n    NoiseTunnel,\n)\n\nclass ToyModel(nn.Module):\n    def __init__(self):\n        super().__init__()\n        self.lin1 = nn.Linear(3, 3)\n        self.relu = nn.ReLU()\n        self.lin2 = nn.Linear(3, 2)\n\n        # initialize weights and biases\n        self.lin1.weight = nn.Parameter(torch.arange(-4.0, 5.0).view(3, 3))\n        self.lin1.bias = nn.Parameter(torch.zeros(1,3))\n        self.lin2.weight = nn.Parameter(torch.arange(-3.0, 3.0).view(2, 3))\n        self.lin2.bias = nn.Parameter(torch.ones(1,2))\n\n    def forward(self, input):\n        return self.lin2(self.relu(self.lin1(input)))\n```\n\nLet's create an instance of our model and set it to eval mode.\n```python\nmodel = ToyModel()\nmodel.eval()\n```\n\nNext, we need to define simple input and baseline tensors.\nBaselines belong to the input space and often carry no predictive signal.\nZero tensor can serve as a baseline for many tasks.\nSome interpretability algorithms such as `Integrated\nGradients`, `Deeplift` and `GradientShap` are designed to attribute the change\nbetween the input and baseline to a predictive class or a value that the neural\nnetwork outputs.\n\nWe will apply model interpretability algorithms on the network\nmentioned above in order to understand the importance of individual\nneurons/layers and the parts of the input that play an important role in the\nfinal prediction.\n\nTo make computations deterministic, let's fix random seeds.\n\n```python\ntorch.manual_seed(123)\nnp.random.seed(123)\n```\n\nLet's define our input and baseline tensors. Baselines are used in some\ninterpretability algorithms such as `IntegratedGradients, DeepLift,\nGradientShap, NeuronConductance, LayerConductance, InternalInfluence` and\n`NeuronIntegratedGradients`.\n\n```python\ninput = torch.rand(2, 3)\nbaseline = torch.zeros(2, 3)\n```\nNext we will use `IntegratedGradients` algorithms to assign attribution\nscores to each input feature with respect to the first target output.\n```python\nig = IntegratedGradients(model)\nattributions, delta = ig.attribute(input, baseline, target=0, return_convergence_delta=True)\nprint('IG Attributions:', attributions)\nprint('Convergence Delta:', delta)\n```\nOutput:\n```\nIG Attributions: tensor([[-0.5922, -1.5497, -1.0067],\n                         [ 0.0000, -0.2219, -5.1991]])\nConvergence Delta: tensor([2.3842e-07, -4.7684e-07])\n```\nThe algorithm outputs an attribution score for each input element and a\nconvergence delta. The lower the absolute value of the convergence delta the better\nis the approximation. If we choose not to return delta,\nwe can simply not provide `return_convergence_delta` input\nargument. The absolute value of the returned deltas can be interpreted as an\napproximation error for each input sample.\nIt can also serve as a proxy of how accurate the integral approximation for given\ninputs and baselines is.\nIf the approximation error is large, we can try larger number of integral\napproximation steps by setting `n_steps` to a larger value. Not all algorithms\nreturn approximation error. Those which do, though, compute it based on the\ncompleteness property of the algorithms.\n\nPositive attribution score means that the input in that particular position\npositively contributed to the final prediction and negative means the opposite.\nThe magnitude of the attribution score signifies the strength of the contribution.\nZero attribution score means no contribution from that particular feature.\n\nSimilarly, we can apply `GradientShap`, `DeepLift` and other attribution algorithms to the model.\n\n`GradientShap` first chooses a random baseline from baselines' distribution, then\n adds gaussian noise with std=0.09 to each input example `n_samples` times.\nAfterwards, it chooses a random point between each example-baseline pair and\ncomputes the gradients with respect to target class (in this case target=0). Resulting\nattribution is the mean of gradients * (inputs - baselines)\n```python\ngs = GradientShap(model)\n\n# We define a distribution of baselines and draw `n_samples` from that\n# distribution in order to estimate the expectations of gradients across all baselines\nbaseline_dist = torch.randn(10, 3) * 0.001\nattributions, delta = gs.attribute(input, stdevs=0.09, n_samples=4, baselines=baseline_dist,\n                                   target=0, return_convergence_delta=True)\nprint('GradientShap Attributions:', attributions)\nprint('Convergence Delta:', delta)\n```\nOutput\n```\nGradientShap Attributions: tensor([[-0.1542, -1.6229, -1.5835],\n                                   [-0.3916, -0.2836, -4.6851]])\nConvergence Delta: tensor([ 0.0000, -0.0005, -0.0029, -0.0084, -0.0087, -0.0405,  0.0000, -0.0084])\n\n```\nDeltas are computed for each `n_samples * input.shape[0]` example. The user can,\nfor instance, average them:\n```python\ndeltas_per_example = torch.mean(delta.reshape(input.shape[0], -1), dim=1)\n```\nin order to get per example average delta.\n\n\nBelow is an example of how we can apply `DeepLift` and `DeepLiftShap` on the\n`ToyModel` described above. Current implementation of DeepLift supports only\n`Rescale` rule.\nFor more details on alternative implementations, please see the [DeepLift paper](https://arxiv.org/abs/1704.02685).\n\n```python\ndl = DeepLift(model)\nattributions, delta = dl.attribute(input, baseline, target=0, return_convergence_delta=True)\nprint('DeepLift Attributions:', attributions)\nprint('Convergence Delta:', delta)\n```\nOutput\n```\nDeepLift Attributions: tensor([[-0.5922, -1.5497, -1.0067],\n                               [ 0.0000, -0.2219, -5.1991])\nConvergence Delta: tensor([0., 0.])\n```\n`DeepLift` assigns similar attribution scores as `IntegratedGradients` to inputs,\nhowever it has lower execution time. Another important thing to remember about\nDeepLift is that it currently doesn't support all non-linear activation types.\nFor more details on limitations of the current implementation, please see the\n[DeepLift paper](https://arxiv.org/abs/1704.02685).\n\nSimilar to integrated gradients, DeepLift returns a convergence delta score\nper input example. The approximation error is then the absolute\nvalue of the convergence deltas and can serve as a proxy of how accurate the\nalgorithm's approximation is.\n\nNow let's look into `DeepLiftShap`. Similar to `GradientShap`, `DeepLiftShap` uses\nbaseline distribution. In the example below, we use the same baseline distribution\nas for `GradientShap`.\n\n```python\ndl = DeepLiftShap(model)\nattributions, delta = dl.attribute(input, baseline_dist, target=0, return_convergence_delta=True)\nprint('DeepLiftSHAP Attributions:', attributions)\nprint('Convergence Delta:', delta)\n```\nOutput\n```\nDeepLiftShap Attributions: tensor([[-5.9169e-01, -1.5491e+00, -1.0076e+00],\n                                   [-4.7101e-03, -2.2300e-01, -5.1926e+00]], grad_fn=<MeanBackward1>)\nConvergence Delta: tensor([-4.6120e-03, -1.6267e-03, -5.1045e-04, -1.4184e-03, -6.8886e-03,\n                           -2.2224e-02,  0.0000e+00, -2.8790e-02, -4.1285e-03, -2.7295e-02,\n                           -3.2349e-03, -1.6265e-03, -4.7684e-07, -1.4191e-03, -6.8889e-03,\n                           -2.2224e-02,  0.0000e+00, -2.4792e-02, -4.1289e-03, -2.7296e-02])\n```\n`DeepLiftShap` uses `DeepLift` to compute attribution score for each\ninput-baseline pair and averages it for each input across all baselines.\n\nIt computes deltas for each input example-baseline pair, thus resulting to\n`input.shape[0] * baseline.shape[0]` delta values.\n\nSimilar to GradientShap in order to compute example-based deltas we can average them per example:\n```python\ndeltas_per_example = torch.mean(delta.reshape(input.shape[0], -1), dim=1)\n```\nIn order to smooth and improve the quality of the attributions we can run\n`IntegratedGradients` and other attribution methods through a `NoiseTunnel`.\n`NoiseTunnel` allows us to use `SmoothGrad`, `SmoothGrad_Sq` and `VarGrad` techniques\nto smoothen the attributions by aggregating them for multiple noisy\nsamples that were generated by adding gaussian noise.\n\nHere is an example how we can use `NoiseTunnel` with `IntegratedGradients`.\n\n```python\nig = IntegratedGradients(model)\nnt = NoiseTunnel(ig)\nattributions, delta = nt.attribute(input, nt_type='smoothgrad', stdevs=0.02, n_samples=4,\n      baselines=baseline, target=0, return_convergence_delta=True)\nprint('IG + SmoothGrad Attributions:', attributions)\nprint('Convergence Delta:', delta)\n```\nOutput\n```\nIG + SmoothGrad Attributions: tensor([[-0.4574, -1.5493, -1.0893],\n                                      [ 0.0000, -0.2647, -5.1619]])\nConvergence Delta: tensor([ 0.0000e+00,  2.3842e-07,  0.0000e+00, -2.3842e-07,  0.0000e+00,\n        -4.7684e-07,  0.0000e+00, -4.7684e-07])\n\n```\nThe number of elements in the `delta` tensor is equal to: `n_samples * input.shape[0]`\nIn order to get a example-based delta, we can, for example, average them:\n```python\ndeltas_per_example = torch.mean(delta.reshape(input.shape[0], -1), dim=1)\n```\n\nLet's look into the internals of our network and understand which layers\nand neurons are important for the predictions.\n\nWe will start with the `NeuronConductance`. `NeuronConductance` helps us to identify\ninput features that are important for a particular neuron in a given\nlayer. It decomposes the computation of integrated gradients via the chain rule by\ndefining the importance of a neuron as path integral of the derivative of the output\nwith respect to the neuron times the derivatives of the neuron with respect to the\ninputs of the model.\n\nIn this case, we choose to analyze the first neuron in the linear layer.\n\n```python\nnc = NeuronConductance(model, model.lin1)\nattributions = nc.attribute(input, neuron_index=1, target=0)\nprint('Neuron Attributions:', attributions)\n```\nOutput\n```\nNeuron Attributions: tensor([[ 0.0000,  0.0000,  0.0000],\n                             [ 1.3358,  0.0000, -1.6811]])\n```\n\nLayer conductance shows the importance of neurons for a layer and given input.\nIt is an extension of path integrated gradients for hidden layers and holds the\ncompleteness property as well.\n\nIt doesn't attribute the contribution scores to the input features\nbut shows the importance of each neuron in selected layer.\n```python\nlc = LayerConductance(model, model.lin1)\nattributions, delta = lc.attribute(input, baselines=baseline, target=0, return_convergence_delta=True)\nprint('Layer Attributions:', attributions)\nprint('Convergence Delta:', delta)\n```\nOutputs\n```\nLayer Attributions: tensor([[ 0.0000,  0.0000, -3.0856],\n                            [ 0.0000, -0.3488, -4.9638]], grad_fn=<SumBackward1>)\nConvergence Delta: tensor([0.0630, 0.1084])\n```\n\nSimilar to other attribution algorithms that return convergence delta, `LayerConductance`\nreturns the deltas for each example. The approximation error is then the absolute\nvalue of the convergence deltas and can serve as a proxy of how accurate integral\napproximation for given inputs and baselines is.\n\nMore details on the list of supported algorithms and how to apply\nCaptum on different types of models can be found in our tutorials.\n\n\n## Captum Insights\n\nCaptum provides a web interface called Insights for easy visualization and\naccess to a number of our interpretability algorithms.\n\nTo analyze a sample model on CIFAR10 via Captum Insights run\n\n```\npython -m captum.insights.example\n```\n\nand navigate to the URL specified in the output.\n\n![Captum Insights Screenshot](./website/static/img/captum_insights_screenshot.png)\n\nTo build Insights you will need [Node](https://nodejs.org/en/) >= 8.x\nand [Yarn](https://yarnpkg.com/en/) >= 1.5.\n\nTo build and launch from a checkout in a conda environment run\n\n```\nconda install -c conda-forge yarn\nBUILD_INSIGHTS=1 python setup.py develop\npython captum/insights/example.py\n```\n\n### Captum Insights Jupyter Widget\nCaptum Insights also has a Jupyter widget providing the same user interface as the web app.\nTo install and enable the widget, run\n\n```\njupyter nbextension install --py --symlink --sys-prefix captum.insights.widget\njupyter nbextension enable captum.insights.widget --py --sys-prefix\n```\n\nTo build the widget from a checkout in a conda environment run\n\n```\nconda install -c conda-forge yarn\nBUILD_INSIGHTS=1 python setup.py develop\n```\n\n\n## Contributing\nSee the [CONTRIBUTING](CONTRIBUTING.md) file for how to help out.\n\n## Talks and Papers\nThe slides of our presentation from NeurIPS 2019 can be found [here](docs/presentations/Captum_NeurIPS_2019_final.key)\n\n## References of Algorithms\n\n* `IntegratedGradients`, `LayerIntegratedGradients`: [Axiomatic Attribution for Deep Networks, Mukund Sundararajan et al. 2017](https://arxiv.org/abs/1703.01365) and [Did the Model Understand the Question?, Pramod K. Mudrakarta, et al. 2018](https://arxiv.org/abs/1805.05492)\n* `InputXGradient`: [Investigating the influence of noise and distractors on the interpretation of neural networks, Pieter-Jan Kindermans et al. 2016](https://arxiv.org/abs/1611.07270)\n* `SmoothGrad`: [SmoothGrad: removing noise by adding noise, Daniel Smilkov et al. 2017](https://arxiv.org/abs/1706.03825)\n* `NoiseTunnel`: [Sanity Checks for Saliency Maps, Julius Adebayo et al. 2018](https://arxiv.org/abs/1810.03292)\n* `NeuronConductance`: [How Important is a neuron?, Kedar Dhamdhere et al. 2018](https://arxiv.org/abs/1805.12233)\n* `LayerConductance`: [Computationally Efficient Measures of Internal Neuron Importance, Avanti Shrikumar et al. 2018](https://arxiv.org/pdf/1807.09946.pdf)\n* `DeepLift`, `NeuronDeepLift`, `LayerDeepLift`: [Learning Important Features Through Propagating Activation Differences, Avanti Shrikumar et al. 2017](https://arxiv.org/pdf/1704.02685.pdf) and [Towards better understanding of gradient-based attribution methods for deep neural networks, Marco Ancona et al. 2018](https://openreview.net/pdf?id=Sy21R9JAW)\n* `NeuronIntegratedGradients`: [Computationally Efficient Measures of Internal Neuron Importance, Avanti Shrikumar et al. 2018](https://arxiv.org/pdf/1807.09946.pdf)\n* `GradientShap`, `NeuronGradientShap`, `LayerGradientShap`, `DeepLiftShap`, `NeuronDeepLiftShap`, `LayerDeepLiftShap`: [A Unified Approach to Interpreting Model Predictions, Scott M. Lundberg et al. 2017](http://papers.nips.cc/paper/7062-a-unified-approach-to-interpreting-model-predictions)\n* `InternalInfluence`: [Influence-Directed Explanations for Deep Convolutional Networks, Klas Leino et al. 2018](https://arxiv.org/pdf/1802.03788.pdf)\n* `Saliency`, `NeuronGradient`: [Deep Inside Convolutional Networks: Visualising\nImage Classification Models and Saliency Maps, K. Simonyan, et. al. 2014](https://arxiv.org/pdf/1312.6034.pdf)\n* `GradCAM`, `Guided GradCAM`: [Grad-CAM: Visual Explanations from Deep Networks via Gradient-based Localization, Ramprasaath R. Selvaraju et al. 2017](https://arxiv.org/abs/1610.02391.pdf)\n* `Deconvolution`, `Neuron Deconvolution`: [Visualizing and Understanding Convolutional Networks, Matthew D Zeiler et al. 2014](https://arxiv.org/pdf/1311.2901.pdf)\n* `Guided Backpropagation`, `Neuron Guided Backpropagation`: [Striving for Simplicity: The All Convolutional Net, Jost Tobias Springenberg et al. 2015](https://arxiv.org/pdf/1412.6806.pdf)\n* `Feature Permutation`: [Permutation Feature Importance](https://christophm.github.io/interpretable-ml-book/feature-importance.html)\n* `Occlusion`: [Visualizing and Understanding Convolutional Networks](https://arxiv.org/abs/1311.2901)\n* `Shapely Value`: [A value for n-person games. Contributions to the Theory of Games 2.28 (1953): 307-317](https://apps.dtic.mil/dtic/tr/fulltext/u2/604084.pdf)\n* `Shapely Value Sampling`: [Polynomial calculation of the Shapley value based on sampling](https://www.sciencedirect.com/science/article/pii/S0305054808000804)\n\nMore details about the above mentioned [algorithms](https://captum.ai/docs/algorithms) and their pros and cons can be found on our [web-site](https://captum.ai/docs/algorithms_comparison_matrix).\n\n## License\nCaptum is BSD licensed, as found in the [LICENSE](LICENSE) file.\n\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://captum.ai", "keywords": "Model Interpretability,Model Understanding,Feature Importance,Neuron Importance,PyTorch", "license": "BSD-3", "maintainer": "", "maintainer_email": "", "name": "captum", "package_url": "https://pypi.org/project/captum/", "platform": "", "project_url": "https://pypi.org/project/captum/", "project_urls": {"Documentation": "https://captum.ai", "Homepage": "https://captum.ai", "Source": "https://github.com/pytorch/captum", "conda": "https://anaconda.org/pytorch/captum"}, "release_url": "https://pypi.org/project/captum/0.2.0/", "requires_dist": ["matplotlib", "numpy", "torch (>=1.2)", "flask ; extra == 'dev'", "ipython ; extra == 'dev'", "ipywidgets ; extra == 'dev'", "jupyter ; extra == 'dev'", "pytest ; extra == 'dev'", "pytest-cov ; extra == 'dev'", "black ; extra == 'dev'", "flake8 ; extra == 'dev'", "sphinx ; extra == 'dev'", "sphinx-autodoc-typehints ; extra == 'dev'", "mypy (>=0.760) ; extra == 'dev'", "isort ; extra == 'dev'", "flask ; extra == 'insights'", "ipython ; extra == 'insights'", "ipywidgets ; extra == 'insights'", "jupyter ; extra == 'insights'", "pytest ; extra == 'test'", "pytest-cov ; extra == 'test'", "flask ; extra == 'tutorials'", "ipython ; extra == 'tutorials'", "ipywidgets ; extra == 'tutorials'", "jupyter ; extra == 'tutorials'", "torchtext ; extra == 'tutorials'", "torchvision ; extra == 'tutorials'"], "requires_python": ">=3.6", "summary": "Model interpretability for PyTorch", "version": "0.2.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p><img alt=\"Captum Logo\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/92c05490d60e82cba866755f5f73a71a2f659897/2e2f776562736974652f7374617469632f696d672f63617074756d5f6c6f676f2e706e67\"></p>\n<hr>\n<p><a href=\"https://anaconda.org/pytorch/captum\" rel=\"nofollow\"><img alt=\"Conda\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/09ab67cdc60a2ffd86e4383ec4388249a02e2857/68747470733a2f2f696d672e736869656c64732e696f2f636f6e64612f762f7079746f7263682f63617074756d2e737667\"></a>\n<a href=\"https://pypi.org/project/captum\" rel=\"nofollow\"><img alt=\"PyPI\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/a7ca67f789e3a0798254b186cdeb08eb04864c61/68747470733a2f2f696d672e736869656c64732e696f2f707970692f762f63617074756d2e737667\"></a>\n<a href=\"https://circleci.com/gh/pytorch/captum\" rel=\"nofollow\"><img alt=\"CircleCI\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/ca193aa41c0ce28c8ee1701b6701b12fa50def92/68747470733a2f2f636972636c6563692e636f6d2f67682f7079746f7263682f63617074756d2e7376673f7374796c653d736869656c64\"></a></p>\n<p>Captum is a model interpretability and understanding library for PyTorch.\nCaptum means comprehension in latin and contains general purpose implementations\nof integrated gradients, saliency maps, smoothgrad, vargrad and others for\nPyTorch models. It has quick integration for models built with domain-specific\nlibraries such as torchvision, torchtext, and others.</p>\n<p><em>Captum is currently in beta and under active development!</em></p>\n<h4>About Captum</h4>\n<p>With the increase in model complexity and the resulting lack of transparency, model interpretability methods have become increasingly important. Model understanding is both an active area of research as well as an area of focus for practical applications across industries using machine learning. Captum provides state-of-the-art algorithms, including Integrated Gradients, to provide researchers and developers with an easy way to understand which features are contributing to a model\u2019s output.</p>\n<p>For model developers, Captum can be used to improve and troubleshoot models by facilitating the identification of different features that contribute to a model\u2019s output in order to design better models and troubleshoot unexpected model outputs.</p>\n<p>Captum helps ML researchers more easily implement interpretability algorithms that can interact with PyTorch models. Captum also allows researchers to quickly benchmark their work against other existing algorithms available in the library.</p>\n<h4>Target Audience</h4>\n<p>The primary audiences for Captum are model developers who are looking to improve their models and understand which features are important and interpretability researchers focused on identifying algorithms that can better interpret many types of models.</p>\n<p>Captum can also be used by application engineers who are using trained models in production. Captum provides easier troubleshooting through improved model interpretability, and the potential for delivering better explanations to end users on why they\u2019re seeing a specific piece of content, such as a movie recommendation.</p>\n<h2>Installation</h2>\n<p><strong>Installation Requirements</strong></p>\n<ul>\n<li>Python &gt;= 3.6</li>\n<li>PyTorch &gt;= 1.2</li>\n</ul>\n<h5>Installing the latest release</h5>\n<p>The latest release of Captum is easily installed either via\n<a href=\"https://www.anaconda.com/distribution/#download-section\" rel=\"nofollow\">Anaconda</a> (recommended):</p>\n<pre>conda install captum -c pytorch\n</pre>\n<p>or via <code>pip</code>:</p>\n<pre>pip install captum\n</pre>\n<p><strong>Manual / Dev install</strong></p>\n<p>If you'd like to try our bleeding edge features (and don't mind potentially\nrunning into the occasional bug here or there), you can install the latest\nmaster directly from GitHub. For a basic install, run:</p>\n<pre>git clone https://github.com/pytorch/captum.git\n<span class=\"nb\">cd</span> captum\npip install -e .\n</pre>\n<p>To customize the installation, you can also run the following variants of the\nabove:</p>\n<ul>\n<li><code>pip install -e .[insights]</code>: Also installs all packages necessary for running Captum Insights.</li>\n<li><code>pip install -e .[dev]</code>: Also installs all tools necessary for development\n(testing, linting, docs building; see <a href=\"#contributing\" rel=\"nofollow\">Contributing</a> below).</li>\n<li><code>pip install -e .[tutorials]</code>: Also installs all packages necessary for running the tutorial notebooks.</li>\n</ul>\n<p>To execute unit tests from a manual install, run:</p>\n<pre><span class=\"c1\"># running a single unit test</span>\npython -m unittest -v tests.attr.test_saliency\n<span class=\"c1\"># running all unit tests</span>\npytest -ra\n</pre>\n<h2>Getting Started</h2>\n<p>Captum helps you interpret and understand predictions of PyTorch models by\nexploring features that contribute to a prediction the model makes.\nIt also helps understand which neurons and layers are important for\nmodel predictions.</p>\n<p>Currently, the library uses gradient-based interpretability algorithms\nand attributes contributions to each input of the model with respect to\ndifferent neurons and layers, both intermediate and final.</p>\n<p>Let's apply some of those algorithms to a toy model we have created for\ndemonstration purposes.\nFor simplicity, we will use the following architecture, but users are welcome\nto use any PyTorch model of their choice.</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">numpy</span> <span class=\"k\">as</span> <span class=\"nn\">np</span>\n\n<span class=\"kn\">import</span> <span class=\"nn\">torch</span>\n<span class=\"kn\">import</span> <span class=\"nn\">torch.nn</span> <span class=\"k\">as</span> <span class=\"nn\">nn</span>\n\n<span class=\"kn\">from</span> <span class=\"nn\">captum.attr</span> <span class=\"kn\">import</span> <span class=\"p\">(</span>\n    <span class=\"n\">GradientShap</span><span class=\"p\">,</span>\n    <span class=\"n\">DeepLift</span><span class=\"p\">,</span>\n    <span class=\"n\">DeepLiftShap</span><span class=\"p\">,</span>\n    <span class=\"n\">IntegratedGradients</span><span class=\"p\">,</span>\n    <span class=\"n\">LayerConductance</span><span class=\"p\">,</span>\n    <span class=\"n\">NeuronConductance</span><span class=\"p\">,</span>\n    <span class=\"n\">NoiseTunnel</span><span class=\"p\">,</span>\n<span class=\"p\">)</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">ToyModel</span><span class=\"p\">(</span><span class=\"n\">nn</span><span class=\"o\">.</span><span class=\"n\">Module</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"nb\">super</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"fm\">__init__</span><span class=\"p\">()</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">lin1</span> <span class=\"o\">=</span> <span class=\"n\">nn</span><span class=\"o\">.</span><span class=\"n\">Linear</span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">)</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">relu</span> <span class=\"o\">=</span> <span class=\"n\">nn</span><span class=\"o\">.</span><span class=\"n\">ReLU</span><span class=\"p\">()</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">lin2</span> <span class=\"o\">=</span> <span class=\"n\">nn</span><span class=\"o\">.</span><span class=\"n\">Linear</span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">)</span>\n\n        <span class=\"c1\"># initialize weights and biases</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">lin1</span><span class=\"o\">.</span><span class=\"n\">weight</span> <span class=\"o\">=</span> <span class=\"n\">nn</span><span class=\"o\">.</span><span class=\"n\">Parameter</span><span class=\"p\">(</span><span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">arange</span><span class=\"p\">(</span><span class=\"o\">-</span><span class=\"mf\">4.0</span><span class=\"p\">,</span> <span class=\"mf\">5.0</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">view</span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">))</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">lin1</span><span class=\"o\">.</span><span class=\"n\">bias</span> <span class=\"o\">=</span> <span class=\"n\">nn</span><span class=\"o\">.</span><span class=\"n\">Parameter</span><span class=\"p\">(</span><span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">zeros</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">3</span><span class=\"p\">))</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">lin2</span><span class=\"o\">.</span><span class=\"n\">weight</span> <span class=\"o\">=</span> <span class=\"n\">nn</span><span class=\"o\">.</span><span class=\"n\">Parameter</span><span class=\"p\">(</span><span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">arange</span><span class=\"p\">(</span><span class=\"o\">-</span><span class=\"mf\">3.0</span><span class=\"p\">,</span> <span class=\"mf\">3.0</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">view</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">))</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">lin2</span><span class=\"o\">.</span><span class=\"n\">bias</span> <span class=\"o\">=</span> <span class=\"n\">nn</span><span class=\"o\">.</span><span class=\"n\">Parameter</span><span class=\"p\">(</span><span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">ones</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">2</span><span class=\"p\">))</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">forward</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"nb\">input</span><span class=\"p\">):</span>\n        <span class=\"k\">return</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">lin2</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">relu</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">lin1</span><span class=\"p\">(</span><span class=\"nb\">input</span><span class=\"p\">)))</span>\n</pre>\n<p>Let's create an instance of our model and set it to eval mode.</p>\n<pre><span class=\"n\">model</span> <span class=\"o\">=</span> <span class=\"n\">ToyModel</span><span class=\"p\">()</span>\n<span class=\"n\">model</span><span class=\"o\">.</span><span class=\"n\">eval</span><span class=\"p\">()</span>\n</pre>\n<p>Next, we need to define simple input and baseline tensors.\nBaselines belong to the input space and often carry no predictive signal.\nZero tensor can serve as a baseline for many tasks.\nSome interpretability algorithms such as <code>Integrated Gradients</code>, <code>Deeplift</code> and <code>GradientShap</code> are designed to attribute the change\nbetween the input and baseline to a predictive class or a value that the neural\nnetwork outputs.</p>\n<p>We will apply model interpretability algorithms on the network\nmentioned above in order to understand the importance of individual\nneurons/layers and the parts of the input that play an important role in the\nfinal prediction.</p>\n<p>To make computations deterministic, let's fix random seeds.</p>\n<pre><span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">manual_seed</span><span class=\"p\">(</span><span class=\"mi\">123</span><span class=\"p\">)</span>\n<span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">random</span><span class=\"o\">.</span><span class=\"n\">seed</span><span class=\"p\">(</span><span class=\"mi\">123</span><span class=\"p\">)</span>\n</pre>\n<p>Let's define our input and baseline tensors. Baselines are used in some\ninterpretability algorithms such as <code>IntegratedGradients, DeepLift, GradientShap, NeuronConductance, LayerConductance, InternalInfluence</code> and\n<code>NeuronIntegratedGradients</code>.</p>\n<pre><span class=\"nb\">input</span> <span class=\"o\">=</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">rand</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">)</span>\n<span class=\"n\">baseline</span> <span class=\"o\">=</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">zeros</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">)</span>\n</pre>\n<p>Next we will use <code>IntegratedGradients</code> algorithms to assign attribution\nscores to each input feature with respect to the first target output.</p>\n<pre><span class=\"n\">ig</span> <span class=\"o\">=</span> <span class=\"n\">IntegratedGradients</span><span class=\"p\">(</span><span class=\"n\">model</span><span class=\"p\">)</span>\n<span class=\"n\">attributions</span><span class=\"p\">,</span> <span class=\"n\">delta</span> <span class=\"o\">=</span> <span class=\"n\">ig</span><span class=\"o\">.</span><span class=\"n\">attribute</span><span class=\"p\">(</span><span class=\"nb\">input</span><span class=\"p\">,</span> <span class=\"n\">baseline</span><span class=\"p\">,</span> <span class=\"n\">target</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">return_convergence_delta</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">'IG Attributions:'</span><span class=\"p\">,</span> <span class=\"n\">attributions</span><span class=\"p\">)</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">'Convergence Delta:'</span><span class=\"p\">,</span> <span class=\"n\">delta</span><span class=\"p\">)</span>\n</pre>\n<p>Output:</p>\n<pre><code>IG Attributions: tensor([[-0.5922, -1.5497, -1.0067],\n                         [ 0.0000, -0.2219, -5.1991]])\nConvergence Delta: tensor([2.3842e-07, -4.7684e-07])\n</code></pre>\n<p>The algorithm outputs an attribution score for each input element and a\nconvergence delta. The lower the absolute value of the convergence delta the better\nis the approximation. If we choose not to return delta,\nwe can simply not provide <code>return_convergence_delta</code> input\nargument. The absolute value of the returned deltas can be interpreted as an\napproximation error for each input sample.\nIt can also serve as a proxy of how accurate the integral approximation for given\ninputs and baselines is.\nIf the approximation error is large, we can try larger number of integral\napproximation steps by setting <code>n_steps</code> to a larger value. Not all algorithms\nreturn approximation error. Those which do, though, compute it based on the\ncompleteness property of the algorithms.</p>\n<p>Positive attribution score means that the input in that particular position\npositively contributed to the final prediction and negative means the opposite.\nThe magnitude of the attribution score signifies the strength of the contribution.\nZero attribution score means no contribution from that particular feature.</p>\n<p>Similarly, we can apply <code>GradientShap</code>, <code>DeepLift</code> and other attribution algorithms to the model.</p>\n<p><code>GradientShap</code> first chooses a random baseline from baselines' distribution, then\nadds gaussian noise with std=0.09 to each input example <code>n_samples</code> times.\nAfterwards, it chooses a random point between each example-baseline pair and\ncomputes the gradients with respect to target class (in this case target=0). Resulting\nattribution is the mean of gradients * (inputs - baselines)</p>\n<pre><span class=\"n\">gs</span> <span class=\"o\">=</span> <span class=\"n\">GradientShap</span><span class=\"p\">(</span><span class=\"n\">model</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># We define a distribution of baselines and draw `n_samples` from that</span>\n<span class=\"c1\"># distribution in order to estimate the expectations of gradients across all baselines</span>\n<span class=\"n\">baseline_dist</span> <span class=\"o\">=</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">randn</span><span class=\"p\">(</span><span class=\"mi\">10</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">)</span> <span class=\"o\">*</span> <span class=\"mf\">0.001</span>\n<span class=\"n\">attributions</span><span class=\"p\">,</span> <span class=\"n\">delta</span> <span class=\"o\">=</span> <span class=\"n\">gs</span><span class=\"o\">.</span><span class=\"n\">attribute</span><span class=\"p\">(</span><span class=\"nb\">input</span><span class=\"p\">,</span> <span class=\"n\">stdevs</span><span class=\"o\">=</span><span class=\"mf\">0.09</span><span class=\"p\">,</span> <span class=\"n\">n_samples</span><span class=\"o\">=</span><span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"n\">baselines</span><span class=\"o\">=</span><span class=\"n\">baseline_dist</span><span class=\"p\">,</span>\n                                   <span class=\"n\">target</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">return_convergence_delta</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">'GradientShap Attributions:'</span><span class=\"p\">,</span> <span class=\"n\">attributions</span><span class=\"p\">)</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">'Convergence Delta:'</span><span class=\"p\">,</span> <span class=\"n\">delta</span><span class=\"p\">)</span>\n</pre>\n<p>Output</p>\n<pre><code>GradientShap Attributions: tensor([[-0.1542, -1.6229, -1.5835],\n                                   [-0.3916, -0.2836, -4.6851]])\nConvergence Delta: tensor([ 0.0000, -0.0005, -0.0029, -0.0084, -0.0087, -0.0405,  0.0000, -0.0084])\n\n</code></pre>\n<p>Deltas are computed for each <code>n_samples * input.shape[0]</code> example. The user can,\nfor instance, average them:</p>\n<pre><span class=\"n\">deltas_per_example</span> <span class=\"o\">=</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">mean</span><span class=\"p\">(</span><span class=\"n\">delta</span><span class=\"o\">.</span><span class=\"n\">reshape</span><span class=\"p\">(</span><span class=\"nb\">input</span><span class=\"o\">.</span><span class=\"n\">shape</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">],</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">),</span> <span class=\"n\">dim</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n</pre>\n<p>in order to get per example average delta.</p>\n<p>Below is an example of how we can apply <code>DeepLift</code> and <code>DeepLiftShap</code> on the\n<code>ToyModel</code> described above. Current implementation of DeepLift supports only\n<code>Rescale</code> rule.\nFor more details on alternative implementations, please see the <a href=\"https://arxiv.org/abs/1704.02685\" rel=\"nofollow\">DeepLift paper</a>.</p>\n<pre><span class=\"n\">dl</span> <span class=\"o\">=</span> <span class=\"n\">DeepLift</span><span class=\"p\">(</span><span class=\"n\">model</span><span class=\"p\">)</span>\n<span class=\"n\">attributions</span><span class=\"p\">,</span> <span class=\"n\">delta</span> <span class=\"o\">=</span> <span class=\"n\">dl</span><span class=\"o\">.</span><span class=\"n\">attribute</span><span class=\"p\">(</span><span class=\"nb\">input</span><span class=\"p\">,</span> <span class=\"n\">baseline</span><span class=\"p\">,</span> <span class=\"n\">target</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">return_convergence_delta</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">'DeepLift Attributions:'</span><span class=\"p\">,</span> <span class=\"n\">attributions</span><span class=\"p\">)</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">'Convergence Delta:'</span><span class=\"p\">,</span> <span class=\"n\">delta</span><span class=\"p\">)</span>\n</pre>\n<p>Output</p>\n<pre><code>DeepLift Attributions: tensor([[-0.5922, -1.5497, -1.0067],\n                               [ 0.0000, -0.2219, -5.1991])\nConvergence Delta: tensor([0., 0.])\n</code></pre>\n<p><code>DeepLift</code> assigns similar attribution scores as <code>IntegratedGradients</code> to inputs,\nhowever it has lower execution time. Another important thing to remember about\nDeepLift is that it currently doesn't support all non-linear activation types.\nFor more details on limitations of the current implementation, please see the\n<a href=\"https://arxiv.org/abs/1704.02685\" rel=\"nofollow\">DeepLift paper</a>.</p>\n<p>Similar to integrated gradients, DeepLift returns a convergence delta score\nper input example. The approximation error is then the absolute\nvalue of the convergence deltas and can serve as a proxy of how accurate the\nalgorithm's approximation is.</p>\n<p>Now let's look into <code>DeepLiftShap</code>. Similar to <code>GradientShap</code>, <code>DeepLiftShap</code> uses\nbaseline distribution. In the example below, we use the same baseline distribution\nas for <code>GradientShap</code>.</p>\n<pre><span class=\"n\">dl</span> <span class=\"o\">=</span> <span class=\"n\">DeepLiftShap</span><span class=\"p\">(</span><span class=\"n\">model</span><span class=\"p\">)</span>\n<span class=\"n\">attributions</span><span class=\"p\">,</span> <span class=\"n\">delta</span> <span class=\"o\">=</span> <span class=\"n\">dl</span><span class=\"o\">.</span><span class=\"n\">attribute</span><span class=\"p\">(</span><span class=\"nb\">input</span><span class=\"p\">,</span> <span class=\"n\">baseline_dist</span><span class=\"p\">,</span> <span class=\"n\">target</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">return_convergence_delta</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">'DeepLiftSHAP Attributions:'</span><span class=\"p\">,</span> <span class=\"n\">attributions</span><span class=\"p\">)</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">'Convergence Delta:'</span><span class=\"p\">,</span> <span class=\"n\">delta</span><span class=\"p\">)</span>\n</pre>\n<p>Output</p>\n<pre><code>DeepLiftShap Attributions: tensor([[-5.9169e-01, -1.5491e+00, -1.0076e+00],\n                                   [-4.7101e-03, -2.2300e-01, -5.1926e+00]], grad_fn=&lt;MeanBackward1&gt;)\nConvergence Delta: tensor([-4.6120e-03, -1.6267e-03, -5.1045e-04, -1.4184e-03, -6.8886e-03,\n                           -2.2224e-02,  0.0000e+00, -2.8790e-02, -4.1285e-03, -2.7295e-02,\n                           -3.2349e-03, -1.6265e-03, -4.7684e-07, -1.4191e-03, -6.8889e-03,\n                           -2.2224e-02,  0.0000e+00, -2.4792e-02, -4.1289e-03, -2.7296e-02])\n</code></pre>\n<p><code>DeepLiftShap</code> uses <code>DeepLift</code> to compute attribution score for each\ninput-baseline pair and averages it for each input across all baselines.</p>\n<p>It computes deltas for each input example-baseline pair, thus resulting to\n<code>input.shape[0] * baseline.shape[0]</code> delta values.</p>\n<p>Similar to GradientShap in order to compute example-based deltas we can average them per example:</p>\n<pre><span class=\"n\">deltas_per_example</span> <span class=\"o\">=</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">mean</span><span class=\"p\">(</span><span class=\"n\">delta</span><span class=\"o\">.</span><span class=\"n\">reshape</span><span class=\"p\">(</span><span class=\"nb\">input</span><span class=\"o\">.</span><span class=\"n\">shape</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">],</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">),</span> <span class=\"n\">dim</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n</pre>\n<p>In order to smooth and improve the quality of the attributions we can run\n<code>IntegratedGradients</code> and other attribution methods through a <code>NoiseTunnel</code>.\n<code>NoiseTunnel</code> allows us to use <code>SmoothGrad</code>, <code>SmoothGrad_Sq</code> and <code>VarGrad</code> techniques\nto smoothen the attributions by aggregating them for multiple noisy\nsamples that were generated by adding gaussian noise.</p>\n<p>Here is an example how we can use <code>NoiseTunnel</code> with <code>IntegratedGradients</code>.</p>\n<pre><span class=\"n\">ig</span> <span class=\"o\">=</span> <span class=\"n\">IntegratedGradients</span><span class=\"p\">(</span><span class=\"n\">model</span><span class=\"p\">)</span>\n<span class=\"n\">nt</span> <span class=\"o\">=</span> <span class=\"n\">NoiseTunnel</span><span class=\"p\">(</span><span class=\"n\">ig</span><span class=\"p\">)</span>\n<span class=\"n\">attributions</span><span class=\"p\">,</span> <span class=\"n\">delta</span> <span class=\"o\">=</span> <span class=\"n\">nt</span><span class=\"o\">.</span><span class=\"n\">attribute</span><span class=\"p\">(</span><span class=\"nb\">input</span><span class=\"p\">,</span> <span class=\"n\">nt_type</span><span class=\"o\">=</span><span class=\"s1\">'smoothgrad'</span><span class=\"p\">,</span> <span class=\"n\">stdevs</span><span class=\"o\">=</span><span class=\"mf\">0.02</span><span class=\"p\">,</span> <span class=\"n\">n_samples</span><span class=\"o\">=</span><span class=\"mi\">4</span><span class=\"p\">,</span>\n      <span class=\"n\">baselines</span><span class=\"o\">=</span><span class=\"n\">baseline</span><span class=\"p\">,</span> <span class=\"n\">target</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">return_convergence_delta</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">'IG + SmoothGrad Attributions:'</span><span class=\"p\">,</span> <span class=\"n\">attributions</span><span class=\"p\">)</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">'Convergence Delta:'</span><span class=\"p\">,</span> <span class=\"n\">delta</span><span class=\"p\">)</span>\n</pre>\n<p>Output</p>\n<pre><code>IG + SmoothGrad Attributions: tensor([[-0.4574, -1.5493, -1.0893],\n                                      [ 0.0000, -0.2647, -5.1619]])\nConvergence Delta: tensor([ 0.0000e+00,  2.3842e-07,  0.0000e+00, -2.3842e-07,  0.0000e+00,\n        -4.7684e-07,  0.0000e+00, -4.7684e-07])\n\n</code></pre>\n<p>The number of elements in the <code>delta</code> tensor is equal to: <code>n_samples * input.shape[0]</code>\nIn order to get a example-based delta, we can, for example, average them:</p>\n<pre><span class=\"n\">deltas_per_example</span> <span class=\"o\">=</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">mean</span><span class=\"p\">(</span><span class=\"n\">delta</span><span class=\"o\">.</span><span class=\"n\">reshape</span><span class=\"p\">(</span><span class=\"nb\">input</span><span class=\"o\">.</span><span class=\"n\">shape</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">],</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">),</span> <span class=\"n\">dim</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n</pre>\n<p>Let's look into the internals of our network and understand which layers\nand neurons are important for the predictions.</p>\n<p>We will start with the <code>NeuronConductance</code>. <code>NeuronConductance</code> helps us to identify\ninput features that are important for a particular neuron in a given\nlayer. It decomposes the computation of integrated gradients via the chain rule by\ndefining the importance of a neuron as path integral of the derivative of the output\nwith respect to the neuron times the derivatives of the neuron with respect to the\ninputs of the model.</p>\n<p>In this case, we choose to analyze the first neuron in the linear layer.</p>\n<pre><span class=\"n\">nc</span> <span class=\"o\">=</span> <span class=\"n\">NeuronConductance</span><span class=\"p\">(</span><span class=\"n\">model</span><span class=\"p\">,</span> <span class=\"n\">model</span><span class=\"o\">.</span><span class=\"n\">lin1</span><span class=\"p\">)</span>\n<span class=\"n\">attributions</span> <span class=\"o\">=</span> <span class=\"n\">nc</span><span class=\"o\">.</span><span class=\"n\">attribute</span><span class=\"p\">(</span><span class=\"nb\">input</span><span class=\"p\">,</span> <span class=\"n\">neuron_index</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">target</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">)</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">'Neuron Attributions:'</span><span class=\"p\">,</span> <span class=\"n\">attributions</span><span class=\"p\">)</span>\n</pre>\n<p>Output</p>\n<pre><code>Neuron Attributions: tensor([[ 0.0000,  0.0000,  0.0000],\n                             [ 1.3358,  0.0000, -1.6811]])\n</code></pre>\n<p>Layer conductance shows the importance of neurons for a layer and given input.\nIt is an extension of path integrated gradients for hidden layers and holds the\ncompleteness property as well.</p>\n<p>It doesn't attribute the contribution scores to the input features\nbut shows the importance of each neuron in selected layer.</p>\n<pre><span class=\"n\">lc</span> <span class=\"o\">=</span> <span class=\"n\">LayerConductance</span><span class=\"p\">(</span><span class=\"n\">model</span><span class=\"p\">,</span> <span class=\"n\">model</span><span class=\"o\">.</span><span class=\"n\">lin1</span><span class=\"p\">)</span>\n<span class=\"n\">attributions</span><span class=\"p\">,</span> <span class=\"n\">delta</span> <span class=\"o\">=</span> <span class=\"n\">lc</span><span class=\"o\">.</span><span class=\"n\">attribute</span><span class=\"p\">(</span><span class=\"nb\">input</span><span class=\"p\">,</span> <span class=\"n\">baselines</span><span class=\"o\">=</span><span class=\"n\">baseline</span><span class=\"p\">,</span> <span class=\"n\">target</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">return_convergence_delta</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">'Layer Attributions:'</span><span class=\"p\">,</span> <span class=\"n\">attributions</span><span class=\"p\">)</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">'Convergence Delta:'</span><span class=\"p\">,</span> <span class=\"n\">delta</span><span class=\"p\">)</span>\n</pre>\n<p>Outputs</p>\n<pre><code>Layer Attributions: tensor([[ 0.0000,  0.0000, -3.0856],\n                            [ 0.0000, -0.3488, -4.9638]], grad_fn=&lt;SumBackward1&gt;)\nConvergence Delta: tensor([0.0630, 0.1084])\n</code></pre>\n<p>Similar to other attribution algorithms that return convergence delta, <code>LayerConductance</code>\nreturns the deltas for each example. The approximation error is then the absolute\nvalue of the convergence deltas and can serve as a proxy of how accurate integral\napproximation for given inputs and baselines is.</p>\n<p>More details on the list of supported algorithms and how to apply\nCaptum on different types of models can be found in our tutorials.</p>\n<h2>Captum Insights</h2>\n<p>Captum provides a web interface called Insights for easy visualization and\naccess to a number of our interpretability algorithms.</p>\n<p>To analyze a sample model on CIFAR10 via Captum Insights run</p>\n<pre><code>python -m captum.insights.example\n</code></pre>\n<p>and navigate to the URL specified in the output.</p>\n<p><img alt=\"Captum Insights Screenshot\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/31214a00772e77abaf25ded76d97c4d88aa3c0aa/2e2f776562736974652f7374617469632f696d672f63617074756d5f696e7369676874735f73637265656e73686f742e706e67\"></p>\n<p>To build Insights you will need <a href=\"https://nodejs.org/en/\" rel=\"nofollow\">Node</a> &gt;= 8.x\nand <a href=\"https://yarnpkg.com/en/\" rel=\"nofollow\">Yarn</a> &gt;= 1.5.</p>\n<p>To build and launch from a checkout in a conda environment run</p>\n<pre><code>conda install -c conda-forge yarn\nBUILD_INSIGHTS=1 python setup.py develop\npython captum/insights/example.py\n</code></pre>\n<h3>Captum Insights Jupyter Widget</h3>\n<p>Captum Insights also has a Jupyter widget providing the same user interface as the web app.\nTo install and enable the widget, run</p>\n<pre><code>jupyter nbextension install --py --symlink --sys-prefix captum.insights.widget\njupyter nbextension enable captum.insights.widget --py --sys-prefix\n</code></pre>\n<p>To build the widget from a checkout in a conda environment run</p>\n<pre><code>conda install -c conda-forge yarn\nBUILD_INSIGHTS=1 python setup.py develop\n</code></pre>\n<h2>Contributing</h2>\n<p>See the <a href=\"CONTRIBUTING.md\" rel=\"nofollow\">CONTRIBUTING</a> file for how to help out.</p>\n<h2>Talks and Papers</h2>\n<p>The slides of our presentation from NeurIPS 2019 can be found <a href=\"docs/presentations/Captum_NeurIPS_2019_final.key\" rel=\"nofollow\">here</a></p>\n<h2>References of Algorithms</h2>\n<ul>\n<li><code>IntegratedGradients</code>, <code>LayerIntegratedGradients</code>: <a href=\"https://arxiv.org/abs/1703.01365\" rel=\"nofollow\">Axiomatic Attribution for Deep Networks, Mukund Sundararajan et al. 2017</a> and <a href=\"https://arxiv.org/abs/1805.05492\" rel=\"nofollow\">Did the Model Understand the Question?, Pramod K. Mudrakarta, et al. 2018</a></li>\n<li><code>InputXGradient</code>: <a href=\"https://arxiv.org/abs/1611.07270\" rel=\"nofollow\">Investigating the influence of noise and distractors on the interpretation of neural networks, Pieter-Jan Kindermans et al. 2016</a></li>\n<li><code>SmoothGrad</code>: <a href=\"https://arxiv.org/abs/1706.03825\" rel=\"nofollow\">SmoothGrad: removing noise by adding noise, Daniel Smilkov et al. 2017</a></li>\n<li><code>NoiseTunnel</code>: <a href=\"https://arxiv.org/abs/1810.03292\" rel=\"nofollow\">Sanity Checks for Saliency Maps, Julius Adebayo et al. 2018</a></li>\n<li><code>NeuronConductance</code>: <a href=\"https://arxiv.org/abs/1805.12233\" rel=\"nofollow\">How Important is a neuron?, Kedar Dhamdhere et al. 2018</a></li>\n<li><code>LayerConductance</code>: <a href=\"https://arxiv.org/pdf/1807.09946.pdf\" rel=\"nofollow\">Computationally Efficient Measures of Internal Neuron Importance, Avanti Shrikumar et al. 2018</a></li>\n<li><code>DeepLift</code>, <code>NeuronDeepLift</code>, <code>LayerDeepLift</code>: <a href=\"https://arxiv.org/pdf/1704.02685.pdf\" rel=\"nofollow\">Learning Important Features Through Propagating Activation Differences, Avanti Shrikumar et al. 2017</a> and <a href=\"https://openreview.net/pdf?id=Sy21R9JAW\" rel=\"nofollow\">Towards better understanding of gradient-based attribution methods for deep neural networks, Marco Ancona et al. 2018</a></li>\n<li><code>NeuronIntegratedGradients</code>: <a href=\"https://arxiv.org/pdf/1807.09946.pdf\" rel=\"nofollow\">Computationally Efficient Measures of Internal Neuron Importance, Avanti Shrikumar et al. 2018</a></li>\n<li><code>GradientShap</code>, <code>NeuronGradientShap</code>, <code>LayerGradientShap</code>, <code>DeepLiftShap</code>, <code>NeuronDeepLiftShap</code>, <code>LayerDeepLiftShap</code>: <a href=\"http://papers.nips.cc/paper/7062-a-unified-approach-to-interpreting-model-predictions\" rel=\"nofollow\">A Unified Approach to Interpreting Model Predictions, Scott M. Lundberg et al. 2017</a></li>\n<li><code>InternalInfluence</code>: <a href=\"https://arxiv.org/pdf/1802.03788.pdf\" rel=\"nofollow\">Influence-Directed Explanations for Deep Convolutional Networks, Klas Leino et al. 2018</a></li>\n<li><code>Saliency</code>, <code>NeuronGradient</code>: <a href=\"https://arxiv.org/pdf/1312.6034.pdf\" rel=\"nofollow\">Deep Inside Convolutional Networks: Visualising\nImage Classification Models and Saliency Maps, K. Simonyan, et. al. 2014</a></li>\n<li><code>GradCAM</code>, <code>Guided GradCAM</code>: <a href=\"https://arxiv.org/abs/1610.02391.pdf\" rel=\"nofollow\">Grad-CAM: Visual Explanations from Deep Networks via Gradient-based Localization, Ramprasaath R. Selvaraju et al. 2017</a></li>\n<li><code>Deconvolution</code>, <code>Neuron Deconvolution</code>: <a href=\"https://arxiv.org/pdf/1311.2901.pdf\" rel=\"nofollow\">Visualizing and Understanding Convolutional Networks, Matthew D Zeiler et al. 2014</a></li>\n<li><code>Guided Backpropagation</code>, <code>Neuron Guided Backpropagation</code>: <a href=\"https://arxiv.org/pdf/1412.6806.pdf\" rel=\"nofollow\">Striving for Simplicity: The All Convolutional Net, Jost Tobias Springenberg et al. 2015</a></li>\n<li><code>Feature Permutation</code>: <a href=\"https://christophm.github.io/interpretable-ml-book/feature-importance.html\" rel=\"nofollow\">Permutation Feature Importance</a></li>\n<li><code>Occlusion</code>: <a href=\"https://arxiv.org/abs/1311.2901\" rel=\"nofollow\">Visualizing and Understanding Convolutional Networks</a></li>\n<li><code>Shapely Value</code>: <a href=\"https://apps.dtic.mil/dtic/tr/fulltext/u2/604084.pdf\" rel=\"nofollow\">A value for n-person games. Contributions to the Theory of Games 2.28 (1953): 307-317</a></li>\n<li><code>Shapely Value Sampling</code>: <a href=\"https://www.sciencedirect.com/science/article/pii/S0305054808000804\" rel=\"nofollow\">Polynomial calculation of the Shapley value based on sampling</a></li>\n</ul>\n<p>More details about the above mentioned <a href=\"https://captum.ai/docs/algorithms\" rel=\"nofollow\">algorithms</a> and their pros and cons can be found on our <a href=\"https://captum.ai/docs/algorithms_comparison_matrix\" rel=\"nofollow\">web-site</a>.</p>\n<h2>License</h2>\n<p>Captum is BSD licensed, as found in the <a href=\"LICENSE\" rel=\"nofollow\">LICENSE</a> file.</p>\n\n          </div>"}, "last_serial": 6757665, "releases": {"0.0.1": [{"comment_text": "", "digests": {"md5": "ae42d04c09c0635350724f4382a5692d", "sha256": "08b9934239b9e89f99855105a3432e358ecadcbb9f777fb2e16e1aba1cdba500"}, "downloads": -1, "filename": "captum-0.0.1-py3-none-any.whl", "has_sig": false, "md5_digest": "ae42d04c09c0635350724f4382a5692d", "packagetype": "bdist_wheel", "python_version": "3.7", "requires_python": null, "size": 1052, "upload_time": "2019-09-03T17:33:18", "upload_time_iso_8601": "2019-09-03T17:33:18.109239Z", "url": "https://files.pythonhosted.org/packages/db/bd/6505d86e42cbe5ad7b96607447237ea368b20f98a6959dc7e73582bf5aaf/captum-0.0.1-py3-none-any.whl", "yanked": false}], "0.1.0": [{"comment_text": "", "digests": {"md5": "36f6d2becfbeecec5cf0cd8538d0981a", "sha256": "698cd12c2d055c229ddce338597fa73061daf914ea035de048e5824e04ce962a"}, "downloads": -1, "filename": "captum-0.1.0-py3-none-any.whl", "has_sig": false, "md5_digest": "36f6d2becfbeecec5cf0cd8538d0981a", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 532185, "upload_time": "2019-10-09T20:48:00", "upload_time_iso_8601": "2019-10-09T20:48:00.908341Z", "url": "https://files.pythonhosted.org/packages/f7/a2/fe37944a50633ffc048918ec0d1e9aafb6ad1e189deb09caae4a6270f2e6/captum-0.1.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "4f42e6803bb4ec8bf76e2a934e9bb548", "sha256": "15d1bd8adaa05edcf7ea31569bb21f625b1859cd326e910178a000b7aeb623b3"}, "downloads": -1, "filename": "captum-0.1.0.tar.gz", "has_sig": false, "md5_digest": "4f42e6803bb4ec8bf76e2a934e9bb548", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 492669, "upload_time": "2019-10-09T20:48:02", "upload_time_iso_8601": "2019-10-09T20:48:02.879340Z", "url": "https://files.pythonhosted.org/packages/af/cd/737d392edbb04a411f43d366e758dcd3bcd450547b1a9d2eab3746ea23c9/captum-0.1.0.tar.gz", "yanked": false}], "0.2.0": [{"comment_text": "", "digests": {"md5": "fa4dd4a975be5507bc122ce91c99892f", "sha256": "e78dc4c076468666e3542fb30aeb33836c6492f2e7a4b3272038bfbf2c323c0a"}, "downloads": -1, "filename": "captum-0.2.0-py3-none-any.whl", "has_sig": false, "md5_digest": "fa4dd4a975be5507bc122ce91c99892f", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 1370370, "upload_time": "2020-03-05T21:16:52", "upload_time_iso_8601": "2020-03-05T21:16:52.488087Z", "url": "https://files.pythonhosted.org/packages/42/de/c018e206d463d9975444c28b0a4f103c9ca4b2faedf943df727e402a1a1e/captum-0.2.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "d7055f528a9f30c4524bfc46b44fb41c", "sha256": "5ce7a037af0dd04b4c13ca851327353791dbab50f2864937ca4298370892b639"}, "downloads": -1, "filename": "captum-0.2.0.tar.gz", "has_sig": false, "md5_digest": "d7055f528a9f30c4524bfc46b44fb41c", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 935805, "upload_time": "2020-03-05T21:16:54", "upload_time_iso_8601": "2020-03-05T21:16:54.422150Z", "url": "https://files.pythonhosted.org/packages/7e/7d/7d670cc14a5d0d031a2226f82cd0bfd3771a23c6f215496658ba6e3b90dc/captum-0.2.0.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "fa4dd4a975be5507bc122ce91c99892f", "sha256": "e78dc4c076468666e3542fb30aeb33836c6492f2e7a4b3272038bfbf2c323c0a"}, "downloads": -1, "filename": "captum-0.2.0-py3-none-any.whl", "has_sig": false, "md5_digest": "fa4dd4a975be5507bc122ce91c99892f", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 1370370, "upload_time": "2020-03-05T21:16:52", "upload_time_iso_8601": "2020-03-05T21:16:52.488087Z", "url": "https://files.pythonhosted.org/packages/42/de/c018e206d463d9975444c28b0a4f103c9ca4b2faedf943df727e402a1a1e/captum-0.2.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "d7055f528a9f30c4524bfc46b44fb41c", "sha256": "5ce7a037af0dd04b4c13ca851327353791dbab50f2864937ca4298370892b639"}, "downloads": -1, "filename": "captum-0.2.0.tar.gz", "has_sig": false, "md5_digest": "d7055f528a9f30c4524bfc46b44fb41c", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 935805, "upload_time": "2020-03-05T21:16:54", "upload_time_iso_8601": "2020-03-05T21:16:54.422150Z", "url": "https://files.pythonhosted.org/packages/7e/7d/7d670cc14a5d0d031a2226f82cd0bfd3771a23c6f215496658ba6e3b90dc/captum-0.2.0.tar.gz", "yanked": false}], "timestamp": "Thu May  7 22:35:27 2020"}