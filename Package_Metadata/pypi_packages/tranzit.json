{"info": {"author": "Art Krasnyy", "author_email": "artkrasnyy@gmail.com", "bugtrack_url": null, "classifiers": [], "description": "# What's that?\n\n_**TRANZIT**_ is an asynchronous micro web framework supporting websockets\n(full duplex socket communication). With **tranzit** you can easily maintain\nboth push & pull websocket messaging.\n\nIn fact, **tranzit** is a just a tiny wrapper for wonderful\n**aiohttp** lib providing async websocket server (which can be run\nseparately) and a little *CLI* tool.\n <!-- TODO: all the rest of README-->\n## Installation\n\nYou can install **tranzit** via pip:\n\n    $ pip install tranzit\n\n## Quickstart\n\nYou can use *CLI* tool for that:\n\n    $ tranzit project <PROJECT_NAME>\n    $ cd <PROJECT_NAME>\n    $ tranzit run\n\nNow your project runs on http://0.0.0.0:3000/ .\n\nThe first command creates a skeleton project:\n\n```\n<PROJECT_NAME>/\n    __init__.py\n    apps/\n        __init__.py\n        hello/\n            __init__.py\n            static/\n                camel.html\n    common/\n        static/\n            tz.js\n    main.py\n    server.yml\n```\n\nThe main.py file starts the whole thing. It gets configs from\n*server.yml* such as:\n\n* HTTP server host\n* HTTP server port\n* To start websocket server or not\n* Websocket server host\n* Websocket server port\n* Which apps to run\n* Is this a production start or not (not meaningful yet)\n\n> **Info:** You should always pass PROJECT_DIR to *MainServer()*\nconstructor\n\n## Routing and Views\n\nAll routing (for both http requests and websocket requests) is\nhandled by *apps/\\<app_name>/routes.py* file.\n\n`PATH_PREFIX` variable contains prefix for urls handled by this\napplication (like [http://0.0.0.0:3000/\\<PATH_PREFIX>/some_url]).\n\n`APP_STATIC_DIR` variable contains absolute path to the static\nfolder for this application.\n\nAll views for http requests are dispatched by *routes* dict.\nHttp views are ordinary **aiohttp** views.\n\nAll websocket views are dispatched by *ws_rules* dict.\nSee explanation below.\n\n## Middlewares\n\nYou can pass a list of your middlewares in *main.py*:\n```python\nMainServer(\n    'server.yml', PROJECT_DIR, middlewares=[my_middleware]\n)\n```\n\nMore on **aiohttp** middlewares [here](https://docs.aiohttp.org/en/stable/web_advanced.html#middlewares).\n\n## Staticfiles\n\nThere are two types of static files directories in the project skeleton.\n\nThe first is _**\\<PROJECT_NAME>/common/static/**_ . It contains\ncommon project static files and is available via\n\nhttp://0.0.0.0:3000/static/common/YOUR_GLORIOUS.js\n\nThe second type is app-specific:\n_**\\<PROJECT_NAME>/apps/\\<APP_NAME>/static**_ .\nAs you may suggest, it can be found here:\n\nhttp://0.0.0.0:3000/static/APP_NAME/ANOTHER_GLORIOUS.js\n\n## Few words about websockets\n\nTo establish websocket messaging you must add websocket rule in\napps/\\<app_name>/routes.py file just like that:\n\n```python\nws_rules = {\n    'get_hello': WSPushHandle.get_hello\n}\n```\n\nNow this view is available via websockets.\nTo call this view function, do something like this on the\nclient side:\n\n```javascript\nvar ws = new WebSocket('ws://0.0.0.0:19719');\n\nws.onmessage = function(response) {\n    console.log(response.data);\n};\n\nws.send('get_hello|');\n```\n\nWe send message to call the view.\nHere is an ugly syntax for that message:\n\n`<function_name>|arg1, arg2, arg3, ... `\n\nNow take a look at the websocket view:\n\n```python\nclass WSPushHandle(object):\n\n    @staticmethod\n    async def get_hello(*args, **kwargs):\n        send_func = kwargs['send_func']\n        writer = kwargs['writer']\n\n        while True:\n            await asyncio.sleep(1)\n            await send_func(writer, 'HELLO!')\n```\n\nLast line is a way to send message back to the client:\n\n```python\n            await send_func(writer, 'HELLO!')\n```\n\nAs you can see, `send_func` and `writer` instances are accessible via `**kwargs`.\n\n\n> **Warning:** ~~beware of yellow snow!~~ all websocket routes are\nin the same namespace! Avoid collisions.\n\n> **Another warning:** No security provided! Be sure to verify\nwebsocket request (e.g. pass user session key in WS view parameters)\n\n\n\n## Using aiohttp module\n\nAll of `aiohttp.web` module is accessible via `tranzit.web`.\n\n## Starting stand alone websocket server\n\nYou can use websocket server without http server.\n\nAll you need is an instance of:\n\n*tranzit.web.WebSocketServer(host, port, api)*\n\n*api* is a handler class instance which implements 3 functions\nas shown below:\n\n```python\nclass TranzitWSHandler(object):\n\n    async def handle_text(self, loop, writer, msg):\n        pass\n\n    async def handle_binary(self, loop, writer, msg):\n        pass\n\n    async def handle_buffered(self, loop, reader, writer, first_msg):\n        pass\n```\n\nExample starting stand alone websocket server:\n\n```python\nfrom tranzit.web import WebSocketServer\n\n\nclass MyHandler():\n    def __init__(self, rules={}):\n        self.rules = rules\n\n    async def handle_text(self, loop, writer, msg):\n        response = msg.upper()\n\n        await WebSocketServer.send_text(writer, response)\n\n    async def handle_binary(self, loop, writer, msg):\n        pass\n\n    async def handle_buffered(self, loop, reader, writer, first_msg):\n        pass\n\nws_server = WebSocketServer(\n    host='0.0.0.0', port=19719, api=MyHandler()\n)\n\nws_server.run_forever()\n```", "description_content_type": "", "docs_url": null, "download_url": "https://github.com/artkra/tranzit/archive/0.1.tar.gz", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/artkra/tranzit", "keywords": "async http web framework websocket server", "license": "GPL-2.0", "maintainer": "", "maintainer_email": "", "name": "tranzit", "package_url": "https://pypi.org/project/tranzit/", "platform": "", "project_url": "https://pypi.org/project/tranzit/", "project_urls": {"Download": "https://github.com/artkra/tranzit/archive/0.1.tar.gz", "Homepage": "https://github.com/artkra/tranzit"}, "release_url": "https://pypi.org/project/tranzit/0.1.1/", "requires_dist": null, "requires_python": "", "summary": "asynchronous http web framework based on aiohttp providing websocket server functionality", "version": "0.1.1", "yanked": false, "html_description": "<div class=\"project-description\">\n            # What's that?<br><br>_**TRANZIT**_ is an asynchronous micro web framework supporting websockets<br>(full duplex socket communication). With **tranzit** you can easily maintain<br>both push &amp; pull websocket messaging.<br><br>In fact, **tranzit** is a just a tiny wrapper for wonderful<br>**aiohttp** lib providing async websocket server (which can be run<br>separately) and a little *CLI* tool.<br> &lt;!-- TODO: all the rest of README--&gt;<br>## Installation<br><br>You can install **tranzit** via pip:<br><br>    $ pip install tranzit<br><br>## Quickstart<br><br>You can use *CLI* tool for that:<br><br>    $ tranzit project &lt;PROJECT_NAME&gt;<br>    $ cd &lt;PROJECT_NAME&gt;<br>    $ tranzit run<br><br>Now your project runs on http://0.0.0.0:3000/ .<br><br>The first command creates a skeleton project:<br><br>```<br>&lt;PROJECT_NAME&gt;/<br>    __init__.py<br>    apps/<br>        __init__.py<br>        hello/<br>            __init__.py<br>            static/<br>                camel.html<br>    common/<br>        static/<br>            tz.js<br>    main.py<br>    server.yml<br>```<br><br>The main.py file starts the whole thing. It gets configs from<br>*server.yml* such as:<br><br>* HTTP server host<br>* HTTP server port<br>* To start websocket server or not<br>* Websocket server host<br>* Websocket server port<br>* Which apps to run<br>* Is this a production start or not (not meaningful yet)<br><br>&gt; **Info:** You should always pass PROJECT_DIR to *MainServer()*<br>constructor<br><br>## Routing and Views<br><br>All routing (for both http requests and websocket requests) is<br>handled by *apps/\\&lt;app_name&gt;/routes.py* file.<br><br>`PATH_PREFIX` variable contains prefix for urls handled by this<br>application (like [http://0.0.0.0:3000/\\&lt;PATH_PREFIX&gt;/some_url]).<br><br>`APP_STATIC_DIR` variable contains absolute path to the static<br>folder for this application.<br><br>All views for http requests are dispatched by *routes* dict.<br>Http views are ordinary **aiohttp** views.<br><br>All websocket views are dispatched by *ws_rules* dict.<br>See explanation below.<br><br>## Middlewares<br><br>You can pass a list of your middlewares in *main.py*:<br>```python<br>MainServer(<br>    'server.yml', PROJECT_DIR, middlewares=[my_middleware]<br>)<br>```<br><br>More on **aiohttp** middlewares [here](https://docs.aiohttp.org/en/stable/web_advanced.html#middlewares).<br><br>## Staticfiles<br><br>There are two types of static files directories in the project skeleton.<br><br>The first is _**\\&lt;PROJECT_NAME&gt;/common/static/**_ . It contains<br>common project static files and is available via<br><br>http://0.0.0.0:3000/static/common/YOUR_GLORIOUS.js<br><br>The second type is app-specific:<br>_**\\&lt;PROJECT_NAME&gt;/apps/\\&lt;APP_NAME&gt;/static**_ .<br>As you may suggest, it can be found here:<br><br>http://0.0.0.0:3000/static/APP_NAME/ANOTHER_GLORIOUS.js<br><br>## Few words about websockets<br><br>To establish websocket messaging you must add websocket rule in<br>apps/\\&lt;app_name&gt;/routes.py file just like that:<br><br>```python<br>ws_rules = {<br>    'get_hello': WSPushHandle.get_hello<br>}<br>```<br><br>Now this view is available via websockets.<br>To call this view function, do something like this on the<br>client side:<br><br>```javascript<br>var ws = new WebSocket('ws://0.0.0.0:19719');<br><br>ws.onmessage = function(response) {<br>    console.log(response.data);<br>};<br><br>ws.send('get_hello|');<br>```<br><br>We send message to call the view.<br>Here is an ugly syntax for that message:<br><br>`&lt;function_name&gt;|arg1, arg2, arg3, ... `<br><br>Now take a look at the websocket view:<br><br>```python<br>class WSPushHandle(object):<br><br>    @staticmethod<br>    async def get_hello(*args, **kwargs):<br>        send_func = kwargs['send_func']<br>        writer = kwargs['writer']<br><br>        while True:<br>            await asyncio.sleep(1)<br>            await send_func(writer, 'HELLO!')<br>```<br><br>Last line is a way to send message back to the client:<br><br>```python<br>            await send_func(writer, 'HELLO!')<br>```<br><br>As you can see, `send_func` and `writer` instances are accessible via `**kwargs`.<br><br><br>&gt; **Warning:** ~~beware of yellow snow!~~ all websocket routes are<br>in the same namespace! Avoid collisions.<br><br>&gt; **Another warning:** No security provided! Be sure to verify<br>websocket request (e.g. pass user session key in WS view parameters)<br><br><br><br>## Using aiohttp module<br><br>All of `aiohttp.web` module is accessible via `tranzit.web`.<br><br>## Starting stand alone websocket server<br><br>You can use websocket server without http server.<br><br>All you need is an instance of:<br><br>*tranzit.web.WebSocketServer(host, port, api)*<br><br>*api* is a handler class instance which implements 3 functions<br>as shown below:<br><br>```python<br>class TranzitWSHandler(object):<br><br>    async def handle_text(self, loop, writer, msg):<br>        pass<br><br>    async def handle_binary(self, loop, writer, msg):<br>        pass<br><br>    async def handle_buffered(self, loop, reader, writer, first_msg):<br>        pass<br>```<br><br>Example starting stand alone websocket server:<br><br>```python<br>from tranzit.web import WebSocketServer<br><br><br>class MyHandler():<br>    def __init__(self, rules={}):<br>        self.rules = rules<br><br>    async def handle_text(self, loop, writer, msg):<br>        response = msg.upper()<br><br>        await WebSocketServer.send_text(writer, response)<br><br>    async def handle_binary(self, loop, writer, msg):<br>        pass<br><br>    async def handle_buffered(self, loop, reader, writer, first_msg):<br>        pass<br><br>ws_server = WebSocketServer(<br>    host='0.0.0.0', port=19719, api=MyHandler()<br>)<br><br>ws_server.run_forever()<br>```\n          </div>"}, "last_serial": 3958952, "releases": {"0.1": [{"comment_text": "", "digests": {"md5": "cb90ebda68ad08b51c3ee6e41c426400", "sha256": "ccae3deecd966ae9f21206ed98a81462c38e822849f8249eeab842618b6079de"}, "downloads": -1, "filename": "tranzit-0.1-py3.5.egg", "has_sig": false, "md5_digest": "cb90ebda68ad08b51c3ee6e41c426400", "packagetype": "bdist_egg", "python_version": "3.5", "requires_python": null, "size": 156082, "upload_time": "2018-05-30T20:02:37", "upload_time_iso_8601": "2018-05-30T20:02:37.689319Z", "url": "https://files.pythonhosted.org/packages/ca/51/a42e57deec284978c6141423c563b4e4b7cb9d2927d1944f09742c8585e8/tranzit-0.1-py3.5.egg", "yanked": false}, {"comment_text": "", "digests": {"md5": "8683275f435d21745124930ad58db478", "sha256": "126c677eaf05f3650a30ca94714bf1371267e3c3304dfbf28d0316372d1d3f9c"}, "downloads": -1, "filename": "tranzit-0.1-py3-none-any.whl", "has_sig": false, "md5_digest": "8683275f435d21745124930ad58db478", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 146951, "upload_time": "2018-05-30T20:09:51", "upload_time_iso_8601": "2018-05-30T20:09:51.874023Z", "url": "https://files.pythonhosted.org/packages/42/5c/e7f2e16fd4a8d8d5637ed998dd3b2eadddfe878657ccf5d8d75a2151cd42/tranzit-0.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "60dc79404ff70413f0f853aa3f9be580", "sha256": "cd2a2ea8989de0992d57f1064869b144e16196a7224e89f1ee54e6fa20929164"}, "downloads": -1, "filename": "tranzit-0.1.tar.gz", "has_sig": false, "md5_digest": "60dc79404ff70413f0f853aa3f9be580", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 152428, "upload_time": "2018-05-30T19:43:39", "upload_time_iso_8601": "2018-05-30T19:43:39.989239Z", "url": "https://files.pythonhosted.org/packages/9c/f9/e1032a3d07a8db8d73b5eda3b62f324f8c5bdcbc3727fff284a1986a5309/tranzit-0.1.tar.gz", "yanked": false}], "0.1.1": [{"comment_text": "", "digests": {"md5": "d20c7178e086ebb10850a4205a641bfb", "sha256": "bd728c08e8c0456496e5be12b679a9d391e1dca41414d57b0f407caa69613726"}, "downloads": -1, "filename": "tranzit-0.1.1.tar.gz", "has_sig": false, "md5_digest": "d20c7178e086ebb10850a4205a641bfb", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 156346, "upload_time": "2018-06-13T19:46:37", "upload_time_iso_8601": "2018-06-13T19:46:37.564460Z", "url": "https://files.pythonhosted.org/packages/d6/5d/5b1e1f3b31852e91b40fb80c81fdabbca353b75afdd8104212c8762438bc/tranzit-0.1.1.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "d20c7178e086ebb10850a4205a641bfb", "sha256": "bd728c08e8c0456496e5be12b679a9d391e1dca41414d57b0f407caa69613726"}, "downloads": -1, "filename": "tranzit-0.1.1.tar.gz", "has_sig": false, "md5_digest": "d20c7178e086ebb10850a4205a641bfb", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 156346, "upload_time": "2018-06-13T19:46:37", "upload_time_iso_8601": "2018-06-13T19:46:37.564460Z", "url": "https://files.pythonhosted.org/packages/d6/5d/5b1e1f3b31852e91b40fb80c81fdabbca353b75afdd8104212c8762438bc/tranzit-0.1.1.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:47:53 2020"}