{"info": {"author": "Pedro Werneck", "author_email": "pjwerneck@gmail.com", "bugtrack_url": null, "classifiers": ["License :: OSI Approved :: MIT License", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.5", "Programming Language :: Python :: 3.6", "Programming Language :: Python :: 3.7"], "description": "# RQLAlchemy\n\n[![Build Status](https://travis-ci.org/pjwerneck/rqlalchemy.svg?branch=develop)](https://travis-ci.org/pjwerneck/rqlalchemy)\n\nResource Query Language extension for SQLAlchemy\n\n## Overview\n\nResource Query Language (RQL) is a query language designed for use in URIs, with object-style data structures.\n\nrqlalchemy is an RQL extension for SQLAlchemy. It easily allows exposing SQLAlchemy tables or models as an HTTP API endpoint and performing complex queries using only querystring parameters.\n\n## Installing\n\n```\npip install rqlalchemy\n```\n\n## Usage\n\nRQL queries can be supported by an application using SQLAlchemy by adding the `rqlalchemy.RQLQueryMixIn` class as a mix-in class to your base `Query` class:\n\n```python\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import Query as BaseQuery\n\nfrom rqlalchemy import RQLQueryMixIn\n\n# create the declarative base\nBase = declarative_base()\n\n# create the custom query class\nclass RQLQuery(BaseQuery, RQLQueryMixIn):\n    _rql_default_limit = 10\n    _rql_max_limit = 100\n\n# assign the custom query class to the declarative base\nBase.query_class = RQLQuery\n```\n\nWith that in place, you can perform RQL queries by passing the querystring to the query `rql()` method. For example, if you have a Flask HTTP API with an users collection endpoint querying your `User` model:\n\n```python\nfrom urllib.parse import unquote\n\nfrom flask import request\n\n@app.route('/users')\ndef get_users_collection():\n    qs = unquote(request.query_string.decode(request.charset))\n    query = session.query(User).rql(qs)\n    users = query.rql_all()\n\n    return render_response(users)\n```\n\n### Aggregates\n\nAs with the base SQLAlchemy Query class, you can retrieve results with the `all()` method, or by iterating over the query, however, if you want to support RQL expressions with aggregate functions or querying functions that result in a subset of columns, you must retrieve the results with `rql_all()`.\n\n### Pagination\n\nRQLAlchemy offers limit/offset pagination with the `rql_paginate()` method, which returns the requested page, the RQL expressions for previous and next pages if available, and the total number of items.\n\n```python\nfrom urllib.parse import unquote\n\nfrom flask import request\n\n@app.route('/users')\ndef get_users_collection():\n    qs = unquote(request.query_string.decode(request.charset))\n    query = session.query(User).rql(qs)\n    page, previous_page, next_page, total = query.rql_paginate()\n\n    response = {\"data\": page,\n                \"total\": total,\n               }\n\n    if previous_page:\n        response[\"previous\"] = '/users?' + previous_page\n\n    if next_page:\n        response[\"next\"] = '/users?' + next_page\n\n    return render_response(response)\n```\n\nKeep in mind that pagination requires a limit, either a `_rql_default_limit` value, a querystring `limit(x)`, or the `limit` parameter to the `rql()` method. Calling `rql_paginate()` without a limit will raise `RQLQueryError`.\n\n\n## Reference Table\n\n| RQL                     | SQLAlchemy                                         | Obs.                                                                                                                            |\n|-------------------------|----------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------|\n| QUERYING                |                                                    |                                                                                                                                 |\n| select(a,b,c,...)       | .query(Model.a, Model.b, Model.c,...)              |                                                                                                                                 |\n| values(a)               | [o.a for o in query.from_self(a)]                  |                                                                                                                                 |\n| limit(count,start?)     | .limit(count).offset(start)                        |                                                                                                                                 |\n| sort(attr1)             | .order_by(attr)                                    |                                                                                                                                 |\n| sort(-attr1)            | .order_by(attr.desc())                             |                                                                                                                                 |\n| distinct()              | .distinct()                                        |                                                                                                                                 |\n| first()                 | .limit(1)                                          |                                                                                                                                 |\n| one()                   | [query.one()]                                      |                                                                                                                                 |\n| FILTERING               |                                                    |                                                                                                                                 |\n| eq(attr,value)          | .filter(Model.attr == value)                       |                                                                                                                                 |\n| ne(attr,value)          | .filter(Model.attr != value)                       |                                                                                                                                 |\n| lt(attr,value)          | .filter(Model.attr < value)                        |                                                                                                                                 |\n| le(attr,value)          | .filter(Model.attr <= value)                       |                                                                                                                                 |\n| gt(attr,value)          | .filter(Model.attr > value)                        |                                                                                                                                 |\n| ge(attr,value)          | .filter(Model.attr >= value)                       |                                                                                                                                 |\n| in(attr,value)          | .filter(Model.attr.in_(value)                      |                                                                                                                                 |\n| out(attr,value)         | .filter(not_(Model.attr.in_(value)))               |                                                                                                                                 |\n| contains(attr,value)    | .filter(Model.contains(value))                     | Produces a LIKE expression when filtering against a string, or an IN expression when filtering against an iterable relationship |\n| excludes(attr,value)    | .filter(not_(Model.contains(value)))               | See above.                                                                                                                      |\n| and(expr1,expr2,...)    | .filter(and_(expr1, expr2, ...))                   |                                                                                                                                 |\n| or(expr1,expr2,...)     | .filter(or_(expr1, expr2, ...))                    |                                                                                                                                 |\n| AGGREGATING             |                                                    | All aggregation functions return scalar results.                                                                                |\n| aggregate(a,b\\(c\\),...) | .query(Model.a, func.b(Model.c)).group_by(Model.a) |                                                                                                                                 |\n| sum(attr)               | .query(func.sum(Model.attr))                       |                                                                                                                                 |\n| mean(attr)              | .query(func.avg(Model.attr))                       |                                                                                                                                 |\n| max(attr)               | .query(func.max(Model.attr))                       |                                                                                                                                 |\n| min(attr)               | .query(func.min(Model.attr))                       |                                                                                                                                 |\n| count()                 | .query(func.count())                               |                                                                                                                                 |\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/pjwerneck/rqlalchemy", "keywords": "sqlachemy,sql,rql,querying,httpapi", "license": "MIT", "maintainer": "Pedro Werneck", "maintainer_email": "pjwerneck@gmail.com", "name": "rqlalchemy", "package_url": "https://pypi.org/project/rqlalchemy/", "platform": "", "project_url": "https://pypi.org/project/rqlalchemy/", "project_urls": {"Homepage": "https://github.com/pjwerneck/rqlalchemy", "Repository": "https://github.com/pjwerneck/rqlalchemy"}, "release_url": "https://pypi.org/project/rqlalchemy/0.4.1/", "requires_dist": ["pyrql (>=0.6.0,<0.7.0)", "sqlalchemy (>=1.2,<2.0)"], "requires_python": ">=3.5,<4.0", "summary": "\"Resource Query Language for SQLAlchemy\"", "version": "0.4.1", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>RQLAlchemy</h1>\n<p><a href=\"https://travis-ci.org/pjwerneck/rqlalchemy\" rel=\"nofollow\"><img alt=\"Build Status\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/b90927f3ace457fbffbbc0a87efc3fb20c5fadb1/68747470733a2f2f7472617669732d63692e6f72672f706a7765726e65636b2f72716c616c6368656d792e7376673f6272616e63683d646576656c6f70\"></a></p>\n<p>Resource Query Language extension for SQLAlchemy</p>\n<h2>Overview</h2>\n<p>Resource Query Language (RQL) is a query language designed for use in URIs, with object-style data structures.</p>\n<p>rqlalchemy is an RQL extension for SQLAlchemy. It easily allows exposing SQLAlchemy tables or models as an HTTP API endpoint and performing complex queries using only querystring parameters.</p>\n<h2>Installing</h2>\n<pre><code>pip install rqlalchemy\n</code></pre>\n<h2>Usage</h2>\n<p>RQL queries can be supported by an application using SQLAlchemy by adding the <code>rqlalchemy.RQLQueryMixIn</code> class as a mix-in class to your base <code>Query</code> class:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">sqlalchemy.ext.declarative</span> <span class=\"kn\">import</span> <span class=\"n\">declarative_base</span>\n<span class=\"kn\">from</span> <span class=\"nn\">sqlalchemy.orm</span> <span class=\"kn\">import</span> <span class=\"n\">Query</span> <span class=\"k\">as</span> <span class=\"n\">BaseQuery</span>\n\n<span class=\"kn\">from</span> <span class=\"nn\">rqlalchemy</span> <span class=\"kn\">import</span> <span class=\"n\">RQLQueryMixIn</span>\n\n<span class=\"c1\"># create the declarative base</span>\n<span class=\"n\">Base</span> <span class=\"o\">=</span> <span class=\"n\">declarative_base</span><span class=\"p\">()</span>\n\n<span class=\"c1\"># create the custom query class</span>\n<span class=\"k\">class</span> <span class=\"nc\">RQLQuery</span><span class=\"p\">(</span><span class=\"n\">BaseQuery</span><span class=\"p\">,</span> <span class=\"n\">RQLQueryMixIn</span><span class=\"p\">):</span>\n    <span class=\"n\">_rql_default_limit</span> <span class=\"o\">=</span> <span class=\"mi\">10</span>\n    <span class=\"n\">_rql_max_limit</span> <span class=\"o\">=</span> <span class=\"mi\">100</span>\n\n<span class=\"c1\"># assign the custom query class to the declarative base</span>\n<span class=\"n\">Base</span><span class=\"o\">.</span><span class=\"n\">query_class</span> <span class=\"o\">=</span> <span class=\"n\">RQLQuery</span>\n</pre>\n<p>With that in place, you can perform RQL queries by passing the querystring to the query <code>rql()</code> method. For example, if you have a Flask HTTP API with an users collection endpoint querying your <code>User</code> model:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">urllib.parse</span> <span class=\"kn\">import</span> <span class=\"n\">unquote</span>\n\n<span class=\"kn\">from</span> <span class=\"nn\">flask</span> <span class=\"kn\">import</span> <span class=\"n\">request</span>\n\n<span class=\"nd\">@app</span><span class=\"o\">.</span><span class=\"n\">route</span><span class=\"p\">(</span><span class=\"s1\">'/users'</span><span class=\"p\">)</span>\n<span class=\"k\">def</span> <span class=\"nf\">get_users_collection</span><span class=\"p\">():</span>\n    <span class=\"n\">qs</span> <span class=\"o\">=</span> <span class=\"n\">unquote</span><span class=\"p\">(</span><span class=\"n\">request</span><span class=\"o\">.</span><span class=\"n\">query_string</span><span class=\"o\">.</span><span class=\"n\">decode</span><span class=\"p\">(</span><span class=\"n\">request</span><span class=\"o\">.</span><span class=\"n\">charset</span><span class=\"p\">))</span>\n    <span class=\"n\">query</span> <span class=\"o\">=</span> <span class=\"n\">session</span><span class=\"o\">.</span><span class=\"n\">query</span><span class=\"p\">(</span><span class=\"n\">User</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">rql</span><span class=\"p\">(</span><span class=\"n\">qs</span><span class=\"p\">)</span>\n    <span class=\"n\">users</span> <span class=\"o\">=</span> <span class=\"n\">query</span><span class=\"o\">.</span><span class=\"n\">rql_all</span><span class=\"p\">()</span>\n\n    <span class=\"k\">return</span> <span class=\"n\">render_response</span><span class=\"p\">(</span><span class=\"n\">users</span><span class=\"p\">)</span>\n</pre>\n<h3>Aggregates</h3>\n<p>As with the base SQLAlchemy Query class, you can retrieve results with the <code>all()</code> method, or by iterating over the query, however, if you want to support RQL expressions with aggregate functions or querying functions that result in a subset of columns, you must retrieve the results with <code>rql_all()</code>.</p>\n<h3>Pagination</h3>\n<p>RQLAlchemy offers limit/offset pagination with the <code>rql_paginate()</code> method, which returns the requested page, the RQL expressions for previous and next pages if available, and the total number of items.</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">urllib.parse</span> <span class=\"kn\">import</span> <span class=\"n\">unquote</span>\n\n<span class=\"kn\">from</span> <span class=\"nn\">flask</span> <span class=\"kn\">import</span> <span class=\"n\">request</span>\n\n<span class=\"nd\">@app</span><span class=\"o\">.</span><span class=\"n\">route</span><span class=\"p\">(</span><span class=\"s1\">'/users'</span><span class=\"p\">)</span>\n<span class=\"k\">def</span> <span class=\"nf\">get_users_collection</span><span class=\"p\">():</span>\n    <span class=\"n\">qs</span> <span class=\"o\">=</span> <span class=\"n\">unquote</span><span class=\"p\">(</span><span class=\"n\">request</span><span class=\"o\">.</span><span class=\"n\">query_string</span><span class=\"o\">.</span><span class=\"n\">decode</span><span class=\"p\">(</span><span class=\"n\">request</span><span class=\"o\">.</span><span class=\"n\">charset</span><span class=\"p\">))</span>\n    <span class=\"n\">query</span> <span class=\"o\">=</span> <span class=\"n\">session</span><span class=\"o\">.</span><span class=\"n\">query</span><span class=\"p\">(</span><span class=\"n\">User</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">rql</span><span class=\"p\">(</span><span class=\"n\">qs</span><span class=\"p\">)</span>\n    <span class=\"n\">page</span><span class=\"p\">,</span> <span class=\"n\">previous_page</span><span class=\"p\">,</span> <span class=\"n\">next_page</span><span class=\"p\">,</span> <span class=\"n\">total</span> <span class=\"o\">=</span> <span class=\"n\">query</span><span class=\"o\">.</span><span class=\"n\">rql_paginate</span><span class=\"p\">()</span>\n\n    <span class=\"n\">response</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"s2\">\"data\"</span><span class=\"p\">:</span> <span class=\"n\">page</span><span class=\"p\">,</span>\n                <span class=\"s2\">\"total\"</span><span class=\"p\">:</span> <span class=\"n\">total</span><span class=\"p\">,</span>\n               <span class=\"p\">}</span>\n\n    <span class=\"k\">if</span> <span class=\"n\">previous_page</span><span class=\"p\">:</span>\n        <span class=\"n\">response</span><span class=\"p\">[</span><span class=\"s2\">\"previous\"</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"s1\">'/users?'</span> <span class=\"o\">+</span> <span class=\"n\">previous_page</span>\n\n    <span class=\"k\">if</span> <span class=\"n\">next_page</span><span class=\"p\">:</span>\n        <span class=\"n\">response</span><span class=\"p\">[</span><span class=\"s2\">\"next\"</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"s1\">'/users?'</span> <span class=\"o\">+</span> <span class=\"n\">next_page</span>\n\n    <span class=\"k\">return</span> <span class=\"n\">render_response</span><span class=\"p\">(</span><span class=\"n\">response</span><span class=\"p\">)</span>\n</pre>\n<p>Keep in mind that pagination requires a limit, either a <code>_rql_default_limit</code> value, a querystring <code>limit(x)</code>, or the <code>limit</code> parameter to the <code>rql()</code> method. Calling <code>rql_paginate()</code> without a limit will raise <code>RQLQueryError</code>.</p>\n<h2>Reference Table</h2>\n<table>\n<thead>\n<tr>\n<th>RQL</th>\n<th>SQLAlchemy</th>\n<th>Obs.</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>QUERYING</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>select(a,b,c,...)</td>\n<td>.query(Model.a, Model.b, Model.c,...)</td>\n<td></td>\n</tr>\n<tr>\n<td>values(a)</td>\n<td>[o.a for o in query.from_self(a)]</td>\n<td></td>\n</tr>\n<tr>\n<td>limit(count,start?)</td>\n<td>.limit(count).offset(start)</td>\n<td></td>\n</tr>\n<tr>\n<td>sort(attr1)</td>\n<td>.order_by(attr)</td>\n<td></td>\n</tr>\n<tr>\n<td>sort(-attr1)</td>\n<td>.order_by(attr.desc())</td>\n<td></td>\n</tr>\n<tr>\n<td>distinct()</td>\n<td>.distinct()</td>\n<td></td>\n</tr>\n<tr>\n<td>first()</td>\n<td>.limit(1)</td>\n<td></td>\n</tr>\n<tr>\n<td>one()</td>\n<td>[query.one()]</td>\n<td></td>\n</tr>\n<tr>\n<td>FILTERING</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>eq(attr,value)</td>\n<td>.filter(Model.attr == value)</td>\n<td></td>\n</tr>\n<tr>\n<td>ne(attr,value)</td>\n<td>.filter(Model.attr != value)</td>\n<td></td>\n</tr>\n<tr>\n<td>lt(attr,value)</td>\n<td>.filter(Model.attr &lt; value)</td>\n<td></td>\n</tr>\n<tr>\n<td>le(attr,value)</td>\n<td>.filter(Model.attr &lt;= value)</td>\n<td></td>\n</tr>\n<tr>\n<td>gt(attr,value)</td>\n<td>.filter(Model.attr &gt; value)</td>\n<td></td>\n</tr>\n<tr>\n<td>ge(attr,value)</td>\n<td>.filter(Model.attr &gt;= value)</td>\n<td></td>\n</tr>\n<tr>\n<td>in(attr,value)</td>\n<td>.filter(Model.attr.in_(value)</td>\n<td></td>\n</tr>\n<tr>\n<td>out(attr,value)</td>\n<td>.filter(not_(Model.attr.in_(value)))</td>\n<td></td>\n</tr>\n<tr>\n<td>contains(attr,value)</td>\n<td>.filter(Model.contains(value))</td>\n<td>Produces a LIKE expression when filtering against a string, or an IN expression when filtering against an iterable relationship</td>\n</tr>\n<tr>\n<td>excludes(attr,value)</td>\n<td>.filter(not_(Model.contains(value)))</td>\n<td>See above.</td>\n</tr>\n<tr>\n<td>and(expr1,expr2,...)</td>\n<td>.filter(and_(expr1, expr2, ...))</td>\n<td></td>\n</tr>\n<tr>\n<td>or(expr1,expr2,...)</td>\n<td>.filter(or_(expr1, expr2, ...))</td>\n<td></td>\n</tr>\n<tr>\n<td>AGGREGATING</td>\n<td></td>\n<td>All aggregation functions return scalar results.</td>\n</tr>\n<tr>\n<td>aggregate(a,b(c),...)</td>\n<td>.query(Model.a, func.b(Model.c)).group_by(Model.a)</td>\n<td></td>\n</tr>\n<tr>\n<td>sum(attr)</td>\n<td>.query(func.sum(Model.attr))</td>\n<td></td>\n</tr>\n<tr>\n<td>mean(attr)</td>\n<td>.query(func.avg(Model.attr))</td>\n<td></td>\n</tr>\n<tr>\n<td>max(attr)</td>\n<td>.query(func.max(Model.attr))</td>\n<td></td>\n</tr>\n<tr>\n<td>min(attr)</td>\n<td>.query(func.min(Model.attr))</td>\n<td></td>\n</tr>\n<tr>\n<td>count()</td>\n<td>.query(func.count())</td>\n<td></td>\n</tr></tbody></table>\n\n          </div>"}, "last_serial": 7012176, "releases": {"0.2.0": [{"comment_text": "", "digests": {"md5": "94aabd7d9ac831d8d70911dd24fed318", "sha256": "2c55483789ef7aab5fbfba2b4c715dc80ded539d6ae294272c8b1c4d57cd5de2"}, "downloads": -1, "filename": "rqlalchemy-0.2.0-py3-none-any.whl", "has_sig": false, "md5_digest": "94aabd7d9ac831d8d70911dd24fed318", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 4056, "upload_time": "2019-04-19T15:42:45", "upload_time_iso_8601": "2019-04-19T15:42:45.147636Z", "url": "https://files.pythonhosted.org/packages/92/0e/9a6db65156e850e01d1d771f666c1d88c602fc95dda8a4defb6d0f9b647e/rqlalchemy-0.2.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "78962480803424c0d2db2178c5825bec", "sha256": "63b2c441bff6ce09b6a2634249d8c2552ba91bcbaa69779976fdb792b4afe5e5"}, "downloads": -1, "filename": "rqlalchemy-0.2.0.tar.gz", "has_sig": false, "md5_digest": "78962480803424c0d2db2178c5825bec", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 2961, "upload_time": "2019-04-19T15:42:47", "upload_time_iso_8601": "2019-04-19T15:42:47.373766Z", "url": "https://files.pythonhosted.org/packages/f8/1e/21d6e98cd138cbb0674682d40d3626b27030c84997f6e90914f06bc09371/rqlalchemy-0.2.0.tar.gz", "yanked": false}], "0.2.1": [{"comment_text": "", "digests": {"md5": "2eea8a60f7ff8463388c6c78ef713fa9", "sha256": "dc9f8bdfb576ea177472b98840f12f8510efda7e38ef52ebf313d7a615f9b176"}, "downloads": -1, "filename": "rqlalchemy-0.2.1-py3-none-any.whl", "has_sig": false, "md5_digest": "2eea8a60f7ff8463388c6c78ef713fa9", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 4053, "upload_time": "2019-04-19T16:27:19", "upload_time_iso_8601": "2019-04-19T16:27:19.173996Z", "url": "https://files.pythonhosted.org/packages/af/7f/78ca12b75fdd0c7fd87dcee5f2e64140b10134d1c8626f98b2047e1d60a4/rqlalchemy-0.2.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "75fb630bae1d34a1b6c73b996dfbf545", "sha256": "930ae17bfa8942d21b0944ed685f19b6da596c7805c88621be07ca5875f00693"}, "downloads": -1, "filename": "rqlalchemy-0.2.1.tar.gz", "has_sig": false, "md5_digest": "75fb630bae1d34a1b6c73b996dfbf545", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 2961, "upload_time": "2019-04-19T16:27:21", "upload_time_iso_8601": "2019-04-19T16:27:21.482190Z", "url": "https://files.pythonhosted.org/packages/95/99/f9d0a564923522c319c495555ee1d136dae9639f6e6c886f2d27e44cabbb/rqlalchemy-0.2.1.tar.gz", "yanked": false}], "0.3.0": [{"comment_text": "", "digests": {"md5": "a78a3c2d36b8d4a9543b5160957b9eb6", "sha256": "a1e26077be8c1263c74b4cfee4effc3e9ef3ea096e9412dab2c3cc0fb3f3e5de"}, "downloads": -1, "filename": "rqlalchemy-0.3.0-py3-none-any.whl", "has_sig": false, "md5_digest": "a78a3c2d36b8d4a9543b5160957b9eb6", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 4196, "upload_time": "2019-04-26T00:37:11", "upload_time_iso_8601": "2019-04-26T00:37:11.647181Z", "url": "https://files.pythonhosted.org/packages/5e/bf/7c5f061ac785cc92a556657c9b0ff638d9b8c4880957134e0b9d8143a763/rqlalchemy-0.3.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "ef1337f12df0a5192e6e527cb5b700ca", "sha256": "e797a8dfa864d2701cf120f5b9e8bb3236abb8ed0aa16ac989a862c28460fb8b"}, "downloads": -1, "filename": "rqlalchemy-0.3.0.tar.gz", "has_sig": false, "md5_digest": "ef1337f12df0a5192e6e527cb5b700ca", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 3096, "upload_time": "2019-04-26T00:37:14", "upload_time_iso_8601": "2019-04-26T00:37:14.142780Z", "url": "https://files.pythonhosted.org/packages/94/4a/c94b079fb8647ace50ecec04dcb07d75e8d9a0a4a2849db6e485f4b9adb5/rqlalchemy-0.3.0.tar.gz", "yanked": false}], "0.4.0": [{"comment_text": "", "digests": {"md5": "d19f11d7c0e3006ef7fcc903d9cecf0e", "sha256": "59ded40f4b5b4007a5b208a6fed2c787a5ad827e60f64aa08d67089d4caa678d"}, "downloads": -1, "filename": "rqlalchemy-0.4.0-py3-none-any.whl", "has_sig": false, "md5_digest": "d19f11d7c0e3006ef7fcc903d9cecf0e", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.5,<4.0", "size": 6721, "upload_time": "2019-11-16T02:20:43", "upload_time_iso_8601": "2019-11-16T02:20:43.489951Z", "url": "https://files.pythonhosted.org/packages/a0/3b/cbfe23954b766ec93d6de673616b8934ea269aca313caae0de5795ca0c60/rqlalchemy-0.4.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "1fc66837afed8c6b8bfe3c7b4486acad", "sha256": "1b3c7de05b3beba3f3af4d650ac7b94b7f3858f65bc4f89ac33166e13a9bfe69"}, "downloads": -1, "filename": "rqlalchemy-0.4.0.tar.gz", "has_sig": false, "md5_digest": "1fc66837afed8c6b8bfe3c7b4486acad", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.5,<4.0", "size": 6994, "upload_time": "2019-11-16T02:20:44", "upload_time_iso_8601": "2019-11-16T02:20:44.973755Z", "url": "https://files.pythonhosted.org/packages/79/2b/30779d1cf7c6d64db968a616f9cfa8657ce86b1fabe15e1fcfe6f7a4a14c/rqlalchemy-0.4.0.tar.gz", "yanked": false}], "0.4.1": [{"comment_text": "", "digests": {"md5": "d270267ed16de2e691f4f6d44dcf78ca", "sha256": "e6319465e1fde175c834e73930a4b0c81c9dd3bac0cd6af9fe0023a7b9bcd6d7"}, "downloads": -1, "filename": "rqlalchemy-0.4.1-py3-none-any.whl", "has_sig": false, "md5_digest": "d270267ed16de2e691f4f6d44dcf78ca", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.5,<4.0", "size": 6723, "upload_time": "2020-04-13T19:10:03", "upload_time_iso_8601": "2020-04-13T19:10:03.792121Z", "url": "https://files.pythonhosted.org/packages/cb/45/c2d848c985d1a98ec9b90569bb6a58bc18798254020d40edeacbf5161972/rqlalchemy-0.4.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "6f720c2e68cb8b8e5aa7b5ba6d4b7f37", "sha256": "4e1bc8d98e311df38986f87e3e30bc102ce96b4b005542158e862215e3f92849"}, "downloads": -1, "filename": "rqlalchemy-0.4.1.tar.gz", "has_sig": false, "md5_digest": "6f720c2e68cb8b8e5aa7b5ba6d4b7f37", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.5,<4.0", "size": 7035, "upload_time": "2020-04-13T19:10:05", "upload_time_iso_8601": "2020-04-13T19:10:05.277023Z", "url": "https://files.pythonhosted.org/packages/7c/fa/755e4c3776fe1de63c6c9b5a2cf66b9f6b6f019956323d22a562cb60fb5a/rqlalchemy-0.4.1.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "d270267ed16de2e691f4f6d44dcf78ca", "sha256": "e6319465e1fde175c834e73930a4b0c81c9dd3bac0cd6af9fe0023a7b9bcd6d7"}, "downloads": -1, "filename": "rqlalchemy-0.4.1-py3-none-any.whl", "has_sig": false, "md5_digest": "d270267ed16de2e691f4f6d44dcf78ca", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.5,<4.0", "size": 6723, "upload_time": "2020-04-13T19:10:03", "upload_time_iso_8601": "2020-04-13T19:10:03.792121Z", "url": "https://files.pythonhosted.org/packages/cb/45/c2d848c985d1a98ec9b90569bb6a58bc18798254020d40edeacbf5161972/rqlalchemy-0.4.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "6f720c2e68cb8b8e5aa7b5ba6d4b7f37", "sha256": "4e1bc8d98e311df38986f87e3e30bc102ce96b4b005542158e862215e3f92849"}, "downloads": -1, "filename": "rqlalchemy-0.4.1.tar.gz", "has_sig": false, "md5_digest": "6f720c2e68cb8b8e5aa7b5ba6d4b7f37", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.5,<4.0", "size": 7035, "upload_time": "2020-04-13T19:10:05", "upload_time_iso_8601": "2020-04-13T19:10:05.277023Z", "url": "https://files.pythonhosted.org/packages/7c/fa/755e4c3776fe1de63c6c9b5a2cf66b9f6b6f019956323d22a562cb60fb5a/rqlalchemy-0.4.1.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:00:47 2020"}