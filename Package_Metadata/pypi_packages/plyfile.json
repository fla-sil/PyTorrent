{"info": {"author": "Darsh Ranjan", "author_email": "dranjan@berkeley.edu", "bugtrack_url": null, "classifiers": ["Development Status :: 4 - Beta", "License :: OSI Approved :: GNU General Public License v3 or later (GPLv3+)", "Operating System :: OS Independent", "Programming Language :: Python :: 2", "Programming Language :: Python :: 2.7", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.4", "Programming Language :: Python :: 3.5", "Programming Language :: Python :: 3.6", "Topic :: Scientific/Engineering"], "description": "[![Build Status](https://travis-ci.org/dranjan/python-plyfile.svg?branch=master)](https://travis-ci.org/dranjan/python-plyfile)\n\nWelcome to the `plyfile` Python module, which provides a simple facility\nfor reading and writing ASCII and binary PLY files.\n\nThe PLY format is documented\n[elsewhere](https://web.archive.org/web/20161221115231/http://www.cs.virginia.edu/~gfx/Courses/2001/Advanced.spring.01/plylib/Ply.txt).\n\n# Installation\n\n## Dependencies\n\n- python2 >= 2.7 or python3\n- numpy >= 1.8\n\n**Note:** `numpy` 1.9 before version 1.9.2 has a bug that breaks byte\nswapping by manipulating the `byte_order` field of a `PlyData` instance.\nAs a workaround, you can manually byte-swap your arrays using `el.data =\nel.data.byteswap().newbyteorder()` in addition to changing the\n`byte_order` attribute.\n\n### Optional dependencies\n\n- setuptools (for installation via setup.py)\n- tox (for test suite)\n- py.test and py (for test suite)\n\n## Installing plyfile\n\nQuick way:\n\n    pip install plyfile\n\nOr clone the repository and run from the project root:\n\n    python setup.py install\n\nOr just copy `plyfile.py` into your GPL-compatible project.\n\n## Running test suite\n\nPreferred (more comprehensive; requires tox and setuptools):\n\n    tox -v\n\nAlternate (requires py.test and py):\n\n    py.test test -v\n\n# Usage\n\nBoth deserialization and serialization of PLY file data is done through\n`PlyData` and `PlyElement` instances.\n\n    >>> from plyfile import PlyData, PlyElement\n\nFor the code examples that follow, assume the file `tet.ply` contains\nthe following text:\n\n    ply\n    format ascii 1.0\n    comment single tetrahedron with colored faces\n    element vertex 4\n    comment tetrahedron vertices\n    property float x\n    property float y\n    property float z\n    element face 4\n    property list uchar int vertex_indices\n    property uchar red\n    property uchar green\n    property uchar blue\n    end_header\n    0 0 0\n    0 1 1\n    1 0 1\n    1 1 0\n    3 0 1 2 255 255 255\n    3 0 2 3 255 0 0\n    3 0 1 3 0 255 0\n    3 1 2 3 0 0 255\n\n(This file is available under the `examples` directory.)\n\n## Reading a PLY file\n\n    >>> plydata = PlyData.read('tet.ply')\n\nor\n\n    >>> with open('tet.ply', 'rb') as f:\n    ...     plydata = PlyData.read(f)\n\nThe static method `PlyData.read` returns a `PlyData` instance, which is\n`plyfile`'s representation of the data in a PLY file.  A `PlyData`\ninstance has an attribute `elements`, which is a list of `PlyElement`\ninstances, each of which has a `data` attribute which is a `numpy`\nstructured array containing the numerical data.  PLY file elements map\nonto `numpy` structured arrays in a pretty obvious way.  For a list\nproperty in an element, the corresponding `numpy` field type\nis `object`, with the members being `numpy` arrays (see the\n`vertex_indices` example below).\n\nConcretely:\n\n    >>> plydata.elements[0].name\n    'vertex'\n    >>> plydata.elements[0].data[0]\n    (0.0, 0.0, 0.0)\n    >>> plydata.elements[0].data['x']\n    array([ 0.,  0.,  1.,  1.], dtype=float32)\n    >>> plydata['face'].data['vertex_indices'][0]\n    array([0, 1, 2], dtype=int32)\n\nFor convenience, elements and properties can be looked up by name:\n\n    >>> plydata['vertex']['x']\n    array([ 0.,  0.,  1.,  1.], dtype=float32)\n\nand elements can be indexed directly without explicitly going through\nthe `data` attribute:\n\n    >>> plydata['vertex'][0]\n    (0.0, 0.0, 0.0)\n\nThe above expression is equivalent to `plydata['vertex'].data[0]`.\n\n`PlyElement` instances also contain metadata:\n\n    >>> plydata.elements[0].properties\n    (PlyProperty('x', 'float'), PlyProperty('y', 'float'),\n     PlyProperty('z', 'float'))\n    >>> plydata.elements[0].count\n    4\n\n`PlyProperty` and `PlyListProperty` instances are used internally as a\nconvenient intermediate representation of PLY element properties that\ncan easily be serialized to a PLY header (using `str`) or converted to\n`numpy`-compatible type descriptions (via the `dtype` method).  It's not\nextremely common to manipulate them directly, but if needed, the\nproperty metadata of an element can be accessed as a tuple via the\n`properties` attribute (as illustrated above) or looked up by name:\n\n    >>> plydata.elements[0].ply_property('x')\n    PlyProperty('x', 'float')\n\nMany (but not necessarily all) types of malformed input files will raise\n`PlyParseError` when `PlyData.read` is called.  The string value of the\n`PlyParseError` instance (as well as attributes `element`, `row`, and\n`prop`) provides additional context for the error if applicable.\n\n## Creating a PLY file\n\nThe first step is to get your data into `numpy` structured arrays.  Note\nthat there are some restrictions: generally speaking, if you know the\ntypes of properties a PLY file element can contain, you can easily\ndeduce the restrictions.  For example, PLY files don't contain 64-bit\ninteger or complex data, so these aren't allowed.\n\nFor convenience, non-scalar fields **are** allowed; they will be\nserialized as list properties.  For example, when constructing a \"face\"\nelement, if all the faces are triangles (a common occurrence), it's okay\nto have a  \"vertex_indices\" field of type `'i4'` and shape `(3,)`\ninstead of type `object` and shape `()`.  However, if the serialized PLY\nfile is read back in using `plyfile`, the \"vertex_indices\" property will\nbe represented as an `object`-typed field, each of whose values is an\narray of type `'i4'` and length 3.  The reason is simply that the PLY\nformat provides no way to find out that each \"vertex_indices\" field has\nlength 3 without actually reading all the data, so `plyfile` has to\nassume that this is a variable-length property.  However, see below (and\n`examples/plot.py`) for an easy way to recover a two-dimensional array\nfrom a list property.\n\nFor example, if we wanted to create the \"vertex\" and \"face\" PLY elements\nof the `tet.ply` data directly as `numpy` arrays for the purpose of\nserialization, we could do (as in `test/test.py`):\n\n    >>> vertex = numpy.array([(0, 0, 0),\n    ...                       (0, 1, 1),\n    ...                       (1, 0, 1),\n    ...                       (1, 1, 0)],\n    ...                      dtype=[('x', 'f4'), ('y', 'f4'),\n    ...                             ('z', 'f4')])\n    >>> face = numpy.array([([0, 1, 2], 255, 255, 255),\n    ...                     ([0, 2, 3], 255,   0,   0),\n    ...                     ([0, 1, 3],   0, 255,   0),\n    ...                     ([1, 2, 3],   0,   0, 255)],\n    ...                    dtype=[('vertex_indices', 'i4', (3,)),\n    ...                           ('red', 'u1'), ('green', 'u1'),\n    ...                           ('blue', 'u1')])\n\nOnce you have suitably structured array, the static method\n`PlyElement.describe` can then be used to create the necessary\n`PlyElement` instances:\n\n    >>> el = PlyElement.describe(some_array, 'some_name')\n\nor\n\n    >>> el = PlyElement.describe(some_array, 'some_name',\n    ...                          comments=['comment1',\n    ...                                    'comment2'])\n\nNote that there's no need to create `PlyProperty` instances explicitly.\nThis is all done behind the scenes by examining `some_array.dtype.descr`.\nOne slight hiccup here is that variable-length fields in a `numpy` array\n(i.e., our representation of PLY list properties)\nmust have a type of `object`, so the types of the list length and values\nin the serialized PLY file can't be obtained from the array's `dtype`\nattribute alone.  For simplicity and predictability, the length\ndefaults to 8-bit unsigned integer, and the value defaults to 32-bit\nsigned integer, which covers the majority of use cases.  Exceptions must\nbe stated explicitly:\n\n    >>> el = PlyElement.describe(some_array, 'some_name',\n    ...                          val_dtypes={'some_property': 'f8'},\n    ...                          len_dtypes={'some_property': 'u4'})\n\nNow you can instantiate `PlyData` and serialize:\n\n    >>> PlyData([el]).write('some_binary.ply')\n    >>> PlyData([el], text=True).write('some_ascii.ply')\n\n    # Force the byte order of the output to big-endian, independently of\n    # the machine's native byte order\n    >>> PlyData([el],\n    ...         byte_order='>').write('some_big_endian_binary.ply')\n\n    # Use a file object.  Binary mode is used here, which will cause\n    # Unix-style line endings to be written on all systems.\n    >>> with open('some_ascii.ply', mode='wb') as f:\n    ...     PlyData([el], text=True).write(f)\n\n## Miscellaneous\n\n### Comments\n\nHeader comments are supported:\n\n    >>> ply = PlyData([el], comments=['header comment'])\n    >>> ply.comments\n    ['header comment']\n\nAs of version 0.3, \"obj_info\" comments are supported as well:\n\n    >>> ply = PlyData([el], obj_info=['obj_info1', 'obj_info2'])\n    >>> ply.obj_info\n    ['obj_info1', 'obj_info2']\n\nWhen written, they will be placed after regular comments after the\n\"format\" line.\n\nComments can have leading whitespace, but trailing whitespace may be\nstripped and should not be relied upon.  Comments may not contain\nembedded newlines.\n\n### Getting a two-dimensional array from a list property\n\nThe PLY format provides no way to assert that all the data for a given\nlist property is of the same length, yet this is a relatively common\noccurrence.  For example, all the \"vertex_indices\" data on a \"face\"\nelement will have length three for a triangular mesh.  In such cases,\nit's usually much more convenient to have the data in a two-dimensional\narray, as opposed to a one-dimensional array of type `object`.  Here's a\npretty easy way to obtain a two dimensional array, assuming we know the\nrow length in advance:\n\n    >>> plydata = PlyData.read('tet.ply')\n    >>> tri_data = plydata['face'].data['vertex_indices']\n    >>> triangles = numpy.vstack(tri_data)\n\n### Instance mutability\n\nA plausible code pattern is to read a PLY file into a `PlyData`\ninstance, perform some operations on it, possibly modifying data and\nmetadata in place, and write the result to a new file.  This pattern is\npartially supported.  As of version 0.4, the following in-place\nmutations are supported:\n\n- Modifying numerical array data only.\n- Assigning directly to a `PlyData` instance's `elements`.\n- Switching format by changing the `text` and `byte_order` attributes of\n  a `PlyData` instance.   This will switch between `ascii`,\n  `binary_little_endian`, and `binary_big_endian` PLY formats.\n- Modifying a `PlyData` instance's `comments` and `obj_info`, and\n  modifying a `PlyElement` instance's `comments`.\n- Assigning to an element's `data`.  Note that the property metadata in\n  `properties` is not touched by this, so for every property in the\n  `properties` list of the `PlyElement` instance, the `data` array must\n  have a field with the same name (but possibly different type, and\n  possibly in different order).  The array can have additional fields as\n  well, but they won't be output when writing the element to a PLY file.\n  The properties in the output file will appear as they are in the\n  `properties` list.  If an array field has a different type than the\n  corresponding `PlyProperty` instance, then it will be cast when\n  writing.\n- Assigning directly to an element's `properties`.  Note that the\n  `data` array is not touched, and the previous note regarding the\n  relationship between `properties` and `data` still applies: the field\n  names of `data` must be a subset of the property names in\n  `properties`, but they can be in a different order and specify\n  different types.\n- Changing a `PlyProperty` or `PlyListProperty` instance's `val_dtype`\n  or a `PlyListProperty` instance's `len_dtype`, which will perform\n  casting when writing.\n\nModifying the `name` of a `PlyElement`, `PlyProperty`, or\n`PlyListProperty` instance is not supported and will raise an error.  To\nrename a property of a `PlyElement` instance, you can remove the\nproperty from `properties`, rename the field in `data`, and re-add the\nproperty to `properties` with the new name by creating a new\n`PlyProperty` or `PlyListProperty` instance:\n\n    >>> from plyfile import PlyProperty, PlyListProperty\n    >>> face = plydata['face']\n    >>> face.properties = ()\n    >>> face.data.dtype.names = ['idx', 'r', 'g', 'b']\n    >>> face.properties = (PlyListProperty('idx', 'uchar', 'int'),\n    ...                    PlyProperty('r', 'uchar'),\n    ...                    PlyProperty('g', 'uchar'),\n    ...                    PlyProperty('b', 'uchar'))\n\nNote that it is always safe to create a new `PlyElement` or `PlyData`\ninstance instead of modifying one in place, and this is the recommended\nstyle:\n\n    >>> # Recommended:\n    >>> plydata = PlyData([plydata['face'], plydata['vertex']],\n                          text=False, byte_order='<')\n\n    >>> # Also supported:\n    >>> plydata.elements = [plydata['face'], plydata['vertex']]\n    >>> plydata.text = False\n    >>> plydata.byte_order = '<'\n    >>> plydata.comments = []\n    >>> plydata.obj_info = []\n\nObjects created by this library don't claim ownership of the other\nobjects they refer to, which has implications for both styles (creating\nnew instances and modifying in place).  For example, a single\n`PlyElement` instance can be contained by multiple `PlyData` instances,\nbut modifying that instance will then affect all of those containing\n`PlyData` instances.\n\n# Design philosophy and rationale\n\nAt the time that I wrote this, I didn't know of any simple and\nself-contained Python PLY file module using `numpy` as its data\nrepresentation medium.  Considering the increasing prevalence of Python\nas a tool for scientific programming with NumPy as the _lingua franca_\nfor numerical data, such a module seemed desirable; hence, `plyfile` was\nborn.\n\n## Familiarity\n\nI opted to use existing Python and NumPy constructs whenever they\nmatched the data.  Thus, the `elements` attribute of a `PlyData`\ninstance is simply a `list` of `PlyElement` instances, and the `data`\nattribute of a `PlyElement` instance is a `numpy` array, and a list\nproperty field of a PLY element datum is referred to in the `data`\nattribute by a type of `object` with the value being another `numpy`\narray, etc.  In the last case, this is certainly not the most-efficient\nin-memory representation of the data, since it contains a lot of\nindirection.  However, it is arguably the most obvious and natural\nunless NumPy adds explicit support for \"ragged\" arrays in its type\nsystem.  The design goal was to represent data in a form familiar to\nusers of `numpy`.\n\n## Simplicity\n\nWhen the two were at odds, I decided to favor simplicity over power or\nuser-friendliness.  Thus, list property types in `PlyElement.describe`\nalways default to the same, rather than, say, being obtained by looking\nat an array element.  (Which element?  What if the array has length\nzero?  Whatever default we could choose in that case could lead to\nsubtle edge-case bugs if the user isn't vigilant.)  Also, all input and\noutput is done in \"one shot\": all the arrays must be created up front\nrather than being processed in a streaming fashion.  (That said, I have\nnothing against streamability, and I considered it at one point.  I\ndecided against it for now in order to have a consistent and\nmaintainable interface at least for the first usable version.)\n\n## Interpretation issues\n\nThere doesn't seem to be a single complete and consistent description of\nthe PLY format.  Even the \"authoritative\"\n[Ply.txt](https://web.archive.org/web/20161221115231/http://www.cs.virginia.edu/~gfx/Courses/2001/Advanced.spring.01/plylib/Ply.txt)\nby Greg Turk has some issues.\n\n### Comment placement\n\nWhere can comments appear in the header?  It appears that in all the\n\"official\" examples, all comments immediately follow the \"format\" line,\nbut the language of the document neither places any such restrictions\nnor explicitly allows comments to be placed anywhere else.  Thus, it\nisn't clear whether comments can appear anywhere in the header or must\nimmediately follow the \"format\" line.  At least one popular reader of\nPLY files chokes on comments before the \"format\" line.  `plyfile`\naccepts comments anywhere in the header in input but only places them in\na few limited places in output, namely immediately after \"format\" and\n\"element\" lines.\n\n### Element and property names\n\nAnother ambiguity is names: what strings are allowed as PLY element and\nproperty names?  `plyfile` accepts as input any name that doesn't\ncontain spaces, but this is surely too generous.  This may not be such\na big deal, though: although names are theoretically arbitrary, in\npractice, the majority of PLY element and property names probably come\nfrom a small finite set (\"face\", \"x\", \"nx\", \"green\", etc.).\n\n### Property syntax\n\nA more serious problem is that the PLY format specification appears to\nbe inconsistent regarding the syntax of property definitions.  In\nsome examples, it uses the syntax\n\n    property {type} {name}\n\nand in others,\n\n    property {name} {type}\n\n`plyfile` only supports the former, which appears to be standard _de\nfacto_.\n\n### Header line endings\n\nThe specification explicitly states that lines in the header must\nend with carriage returns, but this rule doesn't seem to be followed by\nanyone, including the C-language PLY implementation by Greg Turk, the\nauthor of the format.  Here, we stick to common practice and output\nUnix-style line endings (with no carriage returns) but accept any line\nending style in input files.\n\n# More examples\n\nExamples beyond the scope of this document and the tests are in the\n`examples` directory.\n\n# Credits\n\nAuthor: Darsh Ranjan\n\n# License\n\nThis software is released under the terms of the GNU General Public\nLicense, version 3.  See the file `COPYING` for details.\n\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "https://github.com/dranjan/python-plyfile/archive/v0.7.2.tar.gz", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/dranjan/python-plyfile", "keywords": "ply,numpy", "license": "", "maintainer": "", "maintainer_email": "", "name": "plyfile", "package_url": "https://pypi.org/project/plyfile/", "platform": "", "project_url": "https://pypi.org/project/plyfile/", "project_urls": {"Download": "https://github.com/dranjan/python-plyfile/archive/v0.7.2.tar.gz", "Homepage": "https://github.com/dranjan/python-plyfile"}, "release_url": "https://pypi.org/project/plyfile/0.7.2/", "requires_dist": ["numpy (>=1.8)"], "requires_python": "", "summary": "PLY file reader/writer", "version": "0.7.2", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p><a href=\"https://travis-ci.org/dranjan/python-plyfile\" rel=\"nofollow\"><img alt=\"Build Status\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/d7dde545d79244fbad4597fc8a7bf51acf1b5d2b/68747470733a2f2f7472617669732d63692e6f72672f6472616e6a616e2f707974686f6e2d706c7966696c652e7376673f6272616e63683d6d6173746572\"></a></p>\n<p>Welcome to the <code>plyfile</code> Python module, which provides a simple facility\nfor reading and writing ASCII and binary PLY files.</p>\n<p>The PLY format is documented\n<a href=\"https://web.archive.org/web/20161221115231/http://www.cs.virginia.edu/%7Egfx/Courses/2001/Advanced.spring.01/plylib/Ply.txt\" rel=\"nofollow\">elsewhere</a>.</p>\n<h1>Installation</h1>\n<h2>Dependencies</h2>\n<ul>\n<li>python2 &gt;= 2.7 or python3</li>\n<li>numpy &gt;= 1.8</li>\n</ul>\n<p><strong>Note:</strong> <code>numpy</code> 1.9 before version 1.9.2 has a bug that breaks byte\nswapping by manipulating the <code>byte_order</code> field of a <code>PlyData</code> instance.\nAs a workaround, you can manually byte-swap your arrays using <code>el.data = el.data.byteswap().newbyteorder()</code> in addition to changing the\n<code>byte_order</code> attribute.</p>\n<h3>Optional dependencies</h3>\n<ul>\n<li>setuptools (for installation via setup.py)</li>\n<li>tox (for test suite)</li>\n<li>py.test and py (for test suite)</li>\n</ul>\n<h2>Installing plyfile</h2>\n<p>Quick way:</p>\n<pre><code>pip install plyfile\n</code></pre>\n<p>Or clone the repository and run from the project root:</p>\n<pre><code>python setup.py install\n</code></pre>\n<p>Or just copy <code>plyfile.py</code> into your GPL-compatible project.</p>\n<h2>Running test suite</h2>\n<p>Preferred (more comprehensive; requires tox and setuptools):</p>\n<pre><code>tox -v\n</code></pre>\n<p>Alternate (requires py.test and py):</p>\n<pre><code>py.test test -v\n</code></pre>\n<h1>Usage</h1>\n<p>Both deserialization and serialization of PLY file data is done through\n<code>PlyData</code> and <code>PlyElement</code> instances.</p>\n<pre><code>&gt;&gt;&gt; from plyfile import PlyData, PlyElement\n</code></pre>\n<p>For the code examples that follow, assume the file <code>tet.ply</code> contains\nthe following text:</p>\n<pre><code>ply\nformat ascii 1.0\ncomment single tetrahedron with colored faces\nelement vertex 4\ncomment tetrahedron vertices\nproperty float x\nproperty float y\nproperty float z\nelement face 4\nproperty list uchar int vertex_indices\nproperty uchar red\nproperty uchar green\nproperty uchar blue\nend_header\n0 0 0\n0 1 1\n1 0 1\n1 1 0\n3 0 1 2 255 255 255\n3 0 2 3 255 0 0\n3 0 1 3 0 255 0\n3 1 2 3 0 0 255\n</code></pre>\n<p>(This file is available under the <code>examples</code> directory.)</p>\n<h2>Reading a PLY file</h2>\n<pre><code>&gt;&gt;&gt; plydata = PlyData.read('tet.ply')\n</code></pre>\n<p>or</p>\n<pre><code>&gt;&gt;&gt; with open('tet.ply', 'rb') as f:\n...     plydata = PlyData.read(f)\n</code></pre>\n<p>The static method <code>PlyData.read</code> returns a <code>PlyData</code> instance, which is\n<code>plyfile</code>'s representation of the data in a PLY file.  A <code>PlyData</code>\ninstance has an attribute <code>elements</code>, which is a list of <code>PlyElement</code>\ninstances, each of which has a <code>data</code> attribute which is a <code>numpy</code>\nstructured array containing the numerical data.  PLY file elements map\nonto <code>numpy</code> structured arrays in a pretty obvious way.  For a list\nproperty in an element, the corresponding <code>numpy</code> field type\nis <code>object</code>, with the members being <code>numpy</code> arrays (see the\n<code>vertex_indices</code> example below).</p>\n<p>Concretely:</p>\n<pre><code>&gt;&gt;&gt; plydata.elements[0].name\n'vertex'\n&gt;&gt;&gt; plydata.elements[0].data[0]\n(0.0, 0.0, 0.0)\n&gt;&gt;&gt; plydata.elements[0].data['x']\narray([ 0.,  0.,  1.,  1.], dtype=float32)\n&gt;&gt;&gt; plydata['face'].data['vertex_indices'][0]\narray([0, 1, 2], dtype=int32)\n</code></pre>\n<p>For convenience, elements and properties can be looked up by name:</p>\n<pre><code>&gt;&gt;&gt; plydata['vertex']['x']\narray([ 0.,  0.,  1.,  1.], dtype=float32)\n</code></pre>\n<p>and elements can be indexed directly without explicitly going through\nthe <code>data</code> attribute:</p>\n<pre><code>&gt;&gt;&gt; plydata['vertex'][0]\n(0.0, 0.0, 0.0)\n</code></pre>\n<p>The above expression is equivalent to <code>plydata['vertex'].data[0]</code>.</p>\n<p><code>PlyElement</code> instances also contain metadata:</p>\n<pre><code>&gt;&gt;&gt; plydata.elements[0].properties\n(PlyProperty('x', 'float'), PlyProperty('y', 'float'),\n PlyProperty('z', 'float'))\n&gt;&gt;&gt; plydata.elements[0].count\n4\n</code></pre>\n<p><code>PlyProperty</code> and <code>PlyListProperty</code> instances are used internally as a\nconvenient intermediate representation of PLY element properties that\ncan easily be serialized to a PLY header (using <code>str</code>) or converted to\n<code>numpy</code>-compatible type descriptions (via the <code>dtype</code> method).  It's not\nextremely common to manipulate them directly, but if needed, the\nproperty metadata of an element can be accessed as a tuple via the\n<code>properties</code> attribute (as illustrated above) or looked up by name:</p>\n<pre><code>&gt;&gt;&gt; plydata.elements[0].ply_property('x')\nPlyProperty('x', 'float')\n</code></pre>\n<p>Many (but not necessarily all) types of malformed input files will raise\n<code>PlyParseError</code> when <code>PlyData.read</code> is called.  The string value of the\n<code>PlyParseError</code> instance (as well as attributes <code>element</code>, <code>row</code>, and\n<code>prop</code>) provides additional context for the error if applicable.</p>\n<h2>Creating a PLY file</h2>\n<p>The first step is to get your data into <code>numpy</code> structured arrays.  Note\nthat there are some restrictions: generally speaking, if you know the\ntypes of properties a PLY file element can contain, you can easily\ndeduce the restrictions.  For example, PLY files don't contain 64-bit\ninteger or complex data, so these aren't allowed.</p>\n<p>For convenience, non-scalar fields <strong>are</strong> allowed; they will be\nserialized as list properties.  For example, when constructing a \"face\"\nelement, if all the faces are triangles (a common occurrence), it's okay\nto have a  \"vertex_indices\" field of type <code>'i4'</code> and shape <code>(3,)</code>\ninstead of type <code>object</code> and shape <code>()</code>.  However, if the serialized PLY\nfile is read back in using <code>plyfile</code>, the \"vertex_indices\" property will\nbe represented as an <code>object</code>-typed field, each of whose values is an\narray of type <code>'i4'</code> and length 3.  The reason is simply that the PLY\nformat provides no way to find out that each \"vertex_indices\" field has\nlength 3 without actually reading all the data, so <code>plyfile</code> has to\nassume that this is a variable-length property.  However, see below (and\n<code>examples/plot.py</code>) for an easy way to recover a two-dimensional array\nfrom a list property.</p>\n<p>For example, if we wanted to create the \"vertex\" and \"face\" PLY elements\nof the <code>tet.ply</code> data directly as <code>numpy</code> arrays for the purpose of\nserialization, we could do (as in <code>test/test.py</code>):</p>\n<pre><code>&gt;&gt;&gt; vertex = numpy.array([(0, 0, 0),\n...                       (0, 1, 1),\n...                       (1, 0, 1),\n...                       (1, 1, 0)],\n...                      dtype=[('x', 'f4'), ('y', 'f4'),\n...                             ('z', 'f4')])\n&gt;&gt;&gt; face = numpy.array([([0, 1, 2], 255, 255, 255),\n...                     ([0, 2, 3], 255,   0,   0),\n...                     ([0, 1, 3],   0, 255,   0),\n...                     ([1, 2, 3],   0,   0, 255)],\n...                    dtype=[('vertex_indices', 'i4', (3,)),\n...                           ('red', 'u1'), ('green', 'u1'),\n...                           ('blue', 'u1')])\n</code></pre>\n<p>Once you have suitably structured array, the static method\n<code>PlyElement.describe</code> can then be used to create the necessary\n<code>PlyElement</code> instances:</p>\n<pre><code>&gt;&gt;&gt; el = PlyElement.describe(some_array, 'some_name')\n</code></pre>\n<p>or</p>\n<pre><code>&gt;&gt;&gt; el = PlyElement.describe(some_array, 'some_name',\n...                          comments=['comment1',\n...                                    'comment2'])\n</code></pre>\n<p>Note that there's no need to create <code>PlyProperty</code> instances explicitly.\nThis is all done behind the scenes by examining <code>some_array.dtype.descr</code>.\nOne slight hiccup here is that variable-length fields in a <code>numpy</code> array\n(i.e., our representation of PLY list properties)\nmust have a type of <code>object</code>, so the types of the list length and values\nin the serialized PLY file can't be obtained from the array's <code>dtype</code>\nattribute alone.  For simplicity and predictability, the length\ndefaults to 8-bit unsigned integer, and the value defaults to 32-bit\nsigned integer, which covers the majority of use cases.  Exceptions must\nbe stated explicitly:</p>\n<pre><code>&gt;&gt;&gt; el = PlyElement.describe(some_array, 'some_name',\n...                          val_dtypes={'some_property': 'f8'},\n...                          len_dtypes={'some_property': 'u4'})\n</code></pre>\n<p>Now you can instantiate <code>PlyData</code> and serialize:</p>\n<pre><code>&gt;&gt;&gt; PlyData([el]).write('some_binary.ply')\n&gt;&gt;&gt; PlyData([el], text=True).write('some_ascii.ply')\n\n# Force the byte order of the output to big-endian, independently of\n# the machine's native byte order\n&gt;&gt;&gt; PlyData([el],\n...         byte_order='&gt;').write('some_big_endian_binary.ply')\n\n# Use a file object.  Binary mode is used here, which will cause\n# Unix-style line endings to be written on all systems.\n&gt;&gt;&gt; with open('some_ascii.ply', mode='wb') as f:\n...     PlyData([el], text=True).write(f)\n</code></pre>\n<h2>Miscellaneous</h2>\n<h3>Comments</h3>\n<p>Header comments are supported:</p>\n<pre><code>&gt;&gt;&gt; ply = PlyData([el], comments=['header comment'])\n&gt;&gt;&gt; ply.comments\n['header comment']\n</code></pre>\n<p>As of version 0.3, \"obj_info\" comments are supported as well:</p>\n<pre><code>&gt;&gt;&gt; ply = PlyData([el], obj_info=['obj_info1', 'obj_info2'])\n&gt;&gt;&gt; ply.obj_info\n['obj_info1', 'obj_info2']\n</code></pre>\n<p>When written, they will be placed after regular comments after the\n\"format\" line.</p>\n<p>Comments can have leading whitespace, but trailing whitespace may be\nstripped and should not be relied upon.  Comments may not contain\nembedded newlines.</p>\n<h3>Getting a two-dimensional array from a list property</h3>\n<p>The PLY format provides no way to assert that all the data for a given\nlist property is of the same length, yet this is a relatively common\noccurrence.  For example, all the \"vertex_indices\" data on a \"face\"\nelement will have length three for a triangular mesh.  In such cases,\nit's usually much more convenient to have the data in a two-dimensional\narray, as opposed to a one-dimensional array of type <code>object</code>.  Here's a\npretty easy way to obtain a two dimensional array, assuming we know the\nrow length in advance:</p>\n<pre><code>&gt;&gt;&gt; plydata = PlyData.read('tet.ply')\n&gt;&gt;&gt; tri_data = plydata['face'].data['vertex_indices']\n&gt;&gt;&gt; triangles = numpy.vstack(tri_data)\n</code></pre>\n<h3>Instance mutability</h3>\n<p>A plausible code pattern is to read a PLY file into a <code>PlyData</code>\ninstance, perform some operations on it, possibly modifying data and\nmetadata in place, and write the result to a new file.  This pattern is\npartially supported.  As of version 0.4, the following in-place\nmutations are supported:</p>\n<ul>\n<li>Modifying numerical array data only.</li>\n<li>Assigning directly to a <code>PlyData</code> instance's <code>elements</code>.</li>\n<li>Switching format by changing the <code>text</code> and <code>byte_order</code> attributes of\na <code>PlyData</code> instance.   This will switch between <code>ascii</code>,\n<code>binary_little_endian</code>, and <code>binary_big_endian</code> PLY formats.</li>\n<li>Modifying a <code>PlyData</code> instance's <code>comments</code> and <code>obj_info</code>, and\nmodifying a <code>PlyElement</code> instance's <code>comments</code>.</li>\n<li>Assigning to an element's <code>data</code>.  Note that the property metadata in\n<code>properties</code> is not touched by this, so for every property in the\n<code>properties</code> list of the <code>PlyElement</code> instance, the <code>data</code> array must\nhave a field with the same name (but possibly different type, and\npossibly in different order).  The array can have additional fields as\nwell, but they won't be output when writing the element to a PLY file.\nThe properties in the output file will appear as they are in the\n<code>properties</code> list.  If an array field has a different type than the\ncorresponding <code>PlyProperty</code> instance, then it will be cast when\nwriting.</li>\n<li>Assigning directly to an element's <code>properties</code>.  Note that the\n<code>data</code> array is not touched, and the previous note regarding the\nrelationship between <code>properties</code> and <code>data</code> still applies: the field\nnames of <code>data</code> must be a subset of the property names in\n<code>properties</code>, but they can be in a different order and specify\ndifferent types.</li>\n<li>Changing a <code>PlyProperty</code> or <code>PlyListProperty</code> instance's <code>val_dtype</code>\nor a <code>PlyListProperty</code> instance's <code>len_dtype</code>, which will perform\ncasting when writing.</li>\n</ul>\n<p>Modifying the <code>name</code> of a <code>PlyElement</code>, <code>PlyProperty</code>, or\n<code>PlyListProperty</code> instance is not supported and will raise an error.  To\nrename a property of a <code>PlyElement</code> instance, you can remove the\nproperty from <code>properties</code>, rename the field in <code>data</code>, and re-add the\nproperty to <code>properties</code> with the new name by creating a new\n<code>PlyProperty</code> or <code>PlyListProperty</code> instance:</p>\n<pre><code>&gt;&gt;&gt; from plyfile import PlyProperty, PlyListProperty\n&gt;&gt;&gt; face = plydata['face']\n&gt;&gt;&gt; face.properties = ()\n&gt;&gt;&gt; face.data.dtype.names = ['idx', 'r', 'g', 'b']\n&gt;&gt;&gt; face.properties = (PlyListProperty('idx', 'uchar', 'int'),\n...                    PlyProperty('r', 'uchar'),\n...                    PlyProperty('g', 'uchar'),\n...                    PlyProperty('b', 'uchar'))\n</code></pre>\n<p>Note that it is always safe to create a new <code>PlyElement</code> or <code>PlyData</code>\ninstance instead of modifying one in place, and this is the recommended\nstyle:</p>\n<pre><code>&gt;&gt;&gt; # Recommended:\n&gt;&gt;&gt; plydata = PlyData([plydata['face'], plydata['vertex']],\n                      text=False, byte_order='&lt;')\n\n&gt;&gt;&gt; # Also supported:\n&gt;&gt;&gt; plydata.elements = [plydata['face'], plydata['vertex']]\n&gt;&gt;&gt; plydata.text = False\n&gt;&gt;&gt; plydata.byte_order = '&lt;'\n&gt;&gt;&gt; plydata.comments = []\n&gt;&gt;&gt; plydata.obj_info = []\n</code></pre>\n<p>Objects created by this library don't claim ownership of the other\nobjects they refer to, which has implications for both styles (creating\nnew instances and modifying in place).  For example, a single\n<code>PlyElement</code> instance can be contained by multiple <code>PlyData</code> instances,\nbut modifying that instance will then affect all of those containing\n<code>PlyData</code> instances.</p>\n<h1>Design philosophy and rationale</h1>\n<p>At the time that I wrote this, I didn't know of any simple and\nself-contained Python PLY file module using <code>numpy</code> as its data\nrepresentation medium.  Considering the increasing prevalence of Python\nas a tool for scientific programming with NumPy as the <em>lingua franca</em>\nfor numerical data, such a module seemed desirable; hence, <code>plyfile</code> was\nborn.</p>\n<h2>Familiarity</h2>\n<p>I opted to use existing Python and NumPy constructs whenever they\nmatched the data.  Thus, the <code>elements</code> attribute of a <code>PlyData</code>\ninstance is simply a <code>list</code> of <code>PlyElement</code> instances, and the <code>data</code>\nattribute of a <code>PlyElement</code> instance is a <code>numpy</code> array, and a list\nproperty field of a PLY element datum is referred to in the <code>data</code>\nattribute by a type of <code>object</code> with the value being another <code>numpy</code>\narray, etc.  In the last case, this is certainly not the most-efficient\nin-memory representation of the data, since it contains a lot of\nindirection.  However, it is arguably the most obvious and natural\nunless NumPy adds explicit support for \"ragged\" arrays in its type\nsystem.  The design goal was to represent data in a form familiar to\nusers of <code>numpy</code>.</p>\n<h2>Simplicity</h2>\n<p>When the two were at odds, I decided to favor simplicity over power or\nuser-friendliness.  Thus, list property types in <code>PlyElement.describe</code>\nalways default to the same, rather than, say, being obtained by looking\nat an array element.  (Which element?  What if the array has length\nzero?  Whatever default we could choose in that case could lead to\nsubtle edge-case bugs if the user isn't vigilant.)  Also, all input and\noutput is done in \"one shot\": all the arrays must be created up front\nrather than being processed in a streaming fashion.  (That said, I have\nnothing against streamability, and I considered it at one point.  I\ndecided against it for now in order to have a consistent and\nmaintainable interface at least for the first usable version.)</p>\n<h2>Interpretation issues</h2>\n<p>There doesn't seem to be a single complete and consistent description of\nthe PLY format.  Even the \"authoritative\"\n<a href=\"https://web.archive.org/web/20161221115231/http://www.cs.virginia.edu/%7Egfx/Courses/2001/Advanced.spring.01/plylib/Ply.txt\" rel=\"nofollow\">Ply.txt</a>\nby Greg Turk has some issues.</p>\n<h3>Comment placement</h3>\n<p>Where can comments appear in the header?  It appears that in all the\n\"official\" examples, all comments immediately follow the \"format\" line,\nbut the language of the document neither places any such restrictions\nnor explicitly allows comments to be placed anywhere else.  Thus, it\nisn't clear whether comments can appear anywhere in the header or must\nimmediately follow the \"format\" line.  At least one popular reader of\nPLY files chokes on comments before the \"format\" line.  <code>plyfile</code>\naccepts comments anywhere in the header in input but only places them in\na few limited places in output, namely immediately after \"format\" and\n\"element\" lines.</p>\n<h3>Element and property names</h3>\n<p>Another ambiguity is names: what strings are allowed as PLY element and\nproperty names?  <code>plyfile</code> accepts as input any name that doesn't\ncontain spaces, but this is surely too generous.  This may not be such\na big deal, though: although names are theoretically arbitrary, in\npractice, the majority of PLY element and property names probably come\nfrom a small finite set (\"face\", \"x\", \"nx\", \"green\", etc.).</p>\n<h3>Property syntax</h3>\n<p>A more serious problem is that the PLY format specification appears to\nbe inconsistent regarding the syntax of property definitions.  In\nsome examples, it uses the syntax</p>\n<pre><code>property {type} {name}\n</code></pre>\n<p>and in others,</p>\n<pre><code>property {name} {type}\n</code></pre>\n<p><code>plyfile</code> only supports the former, which appears to be standard <em>de\nfacto</em>.</p>\n<h3>Header line endings</h3>\n<p>The specification explicitly states that lines in the header must\nend with carriage returns, but this rule doesn't seem to be followed by\nanyone, including the C-language PLY implementation by Greg Turk, the\nauthor of the format.  Here, we stick to common practice and output\nUnix-style line endings (with no carriage returns) but accept any line\nending style in input files.</p>\n<h1>More examples</h1>\n<p>Examples beyond the scope of this document and the tests are in the\n<code>examples</code> directory.</p>\n<h1>Credits</h1>\n<p>Author: Darsh Ranjan</p>\n<h1>License</h1>\n<p>This software is released under the terms of the GNU General Public\nLicense, version 3.  See the file <code>COPYING</code> for details.</p>\n\n          </div>"}, "last_serial": 6857940, "releases": {"0.4": [{"comment_text": "", "digests": {"md5": "8e068c527908d1c2b91e59bee5ab7af2", "sha256": "8bae3eb27db1e211de285695f43de5241ab2bac3ac0217ebbf55a7f6c785625a"}, "downloads": -1, "filename": "plyfile-0.4.tar.gz", "has_sig": false, "md5_digest": "8e068c527908d1c2b91e59bee5ab7af2", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 10721, "upload_time": "2015-04-19T00:21:07", "upload_time_iso_8601": "2015-04-19T00:21:07.588027Z", "url": "https://files.pythonhosted.org/packages/f7/0f/bb87082d8576dfdc3d90bc25d0a93395c79d58914328a9fab87a81007abf/plyfile-0.4.tar.gz", "yanked": false}], "0.5": [{"comment_text": "", "digests": {"md5": "ec5a5cedd2a1d5369cad52d982363ca0", "sha256": "f1fb84b0985b1c345bbdfce2cf49a6cc2cf0274fa6e57db9cb815be11ddc57b3"}, "downloads": -1, "filename": "plyfile-0.5.tar.gz", "has_sig": false, "md5_digest": "ec5a5cedd2a1d5369cad52d982363ca0", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 12197, "upload_time": "2017-02-28T07:04:57", "upload_time_iso_8601": "2017-02-28T07:04:57.056833Z", "url": "https://files.pythonhosted.org/packages/51/20/cd2d20e6936c31587738f05ec7f96fceeed8e6eb3732f541f760267e8cdb/plyfile-0.5.tar.gz", "yanked": false}], "0.6": [{"comment_text": "", "digests": {"md5": "aba0b8cda9a8f059a61cc99b9172d7f1", "sha256": "067e384e3723f28dbbd8e8f976a9712dadf6761b2d62c4c1a90821e3c5310bce"}, "downloads": -1, "filename": "plyfile-0.6.tar.gz", "has_sig": false, "md5_digest": "aba0b8cda9a8f059a61cc99b9172d7f1", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 18219, "upload_time": "2018-07-28T23:38:19", "upload_time_iso_8601": "2018-07-28T23:38:19.209031Z", "url": "https://files.pythonhosted.org/packages/fb/1b/8caed71e07e5240644f205844b72dd8ee1ec203f65f50b63a5d4c27ce57e/plyfile-0.6.tar.gz", "yanked": false}], "0.7": [{"comment_text": "", "digests": {"md5": "96748d771ecc16d311aec7e567e060a1", "sha256": "84ba5ee8c70a4924f64aa7edff5764b929f3b7842d53a3197d0b753818ad7089"}, "downloads": -1, "filename": "plyfile-0.7.tar.gz", "has_sig": false, "md5_digest": "96748d771ecc16d311aec7e567e060a1", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 18495, "upload_time": "2018-12-26T05:37:14", "upload_time_iso_8601": "2018-12-26T05:37:14.545335Z", "url": "https://files.pythonhosted.org/packages/9b/82/d4069cbb49954d44087c37ff616cb423d3e2c0dd276378cdb4af3e3ef2ee/plyfile-0.7.tar.gz", "yanked": false}], "0.7.1": [{"comment_text": "", "digests": {"md5": "b35e94427a198a117b2efe86f60c22ba", "sha256": "b119705dec157314cf504e9d2d6f7d5a76606495a778b673c2864ac92895dced"}, "downloads": -1, "filename": "plyfile-0.7.1.tar.gz", "has_sig": false, "md5_digest": "b35e94427a198a117b2efe86f60c22ba", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 30508, "upload_time": "2019-10-09T07:09:03", "upload_time_iso_8601": "2019-10-09T07:09:03.638828Z", "url": "https://files.pythonhosted.org/packages/4c/15/434d1d96f9a41fea56cb3290718123d651c56c4b7e53f0249acaf1bf34b6/plyfile-0.7.1.tar.gz", "yanked": false}], "0.7.2": [{"comment_text": "", "digests": {"md5": "b1408890f8890ebd496c347bbb964066", "sha256": "5010d57edf4971287bab71610bdf8df7f600efdbe08b3dcc596328f83cb80550"}, "downloads": -1, "filename": "plyfile-0.7.2-py3-none-any.whl", "has_sig": false, "md5_digest": "b1408890f8890ebd496c347bbb964066", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 39219, "upload_time": "2020-03-22T01:29:51", "upload_time_iso_8601": "2020-03-22T01:29:51.439613Z", "url": "https://files.pythonhosted.org/packages/93/c8/cf47848cd4d661850e4a8e7f0fc4f7298515e06d0da7255ed08e5312d4aa/plyfile-0.7.2-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "02fbd4f30aa8a685579d52d0ce90e6f3", "sha256": "59a25845d00a51098e6c9147c3c96ce89ad97395e256a4fabb4aed7cf7db5541"}, "downloads": -1, "filename": "plyfile-0.7.2.tar.gz", "has_sig": false, "md5_digest": "02fbd4f30aa8a685579d52d0ce90e6f3", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 38511, "upload_time": "2020-03-22T01:29:53", "upload_time_iso_8601": "2020-03-22T01:29:53.219549Z", "url": "https://files.pythonhosted.org/packages/b4/bd/e9c77d26b00474e12b06c8cfd9665e09566ccd4719dfbd7d00fd2df82aa1/plyfile-0.7.2.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "b1408890f8890ebd496c347bbb964066", "sha256": "5010d57edf4971287bab71610bdf8df7f600efdbe08b3dcc596328f83cb80550"}, "downloads": -1, "filename": "plyfile-0.7.2-py3-none-any.whl", "has_sig": false, "md5_digest": "b1408890f8890ebd496c347bbb964066", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 39219, "upload_time": "2020-03-22T01:29:51", "upload_time_iso_8601": "2020-03-22T01:29:51.439613Z", "url": "https://files.pythonhosted.org/packages/93/c8/cf47848cd4d661850e4a8e7f0fc4f7298515e06d0da7255ed08e5312d4aa/plyfile-0.7.2-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "02fbd4f30aa8a685579d52d0ce90e6f3", "sha256": "59a25845d00a51098e6c9147c3c96ce89ad97395e256a4fabb4aed7cf7db5541"}, "downloads": -1, "filename": "plyfile-0.7.2.tar.gz", "has_sig": false, "md5_digest": "02fbd4f30aa8a685579d52d0ce90e6f3", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 38511, "upload_time": "2020-03-22T01:29:53", "upload_time_iso_8601": "2020-03-22T01:29:53.219549Z", "url": "https://files.pythonhosted.org/packages/b4/bd/e9c77d26b00474e12b06c8cfd9665e09566ccd4719dfbd7d00fd2df82aa1/plyfile-0.7.2.tar.gz", "yanked": false}], "timestamp": "Fri May  8 02:52:23 2020"}