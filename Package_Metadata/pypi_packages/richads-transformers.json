{"info": {"author": "Thomas Wolf, Lysandre Debut, Victor Sanh, Julien Chaumond, Google AI Language Team Authors, Open AI team Authors, Facebook AI Authors, Carnegie Mellon University Authors", "author_email": "thomas@huggingface.co", "bugtrack_url": null, "classifiers": ["Development Status :: 5 - Production/Stable", "Intended Audience :: Developers", "Intended Audience :: Education", "Intended Audience :: Science/Research", "License :: OSI Approved :: Apache Software License", "Operating System :: OS Independent", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.5", "Programming Language :: Python :: 3.6", "Programming Language :: Python :: 3.7", "Topic :: Scientific/Engineering :: Artificial Intelligence"], "description": "<p align=\"center\">\n    <br>\n    <img src=\"https://raw.githubusercontent.com/huggingface/transformers/master/docs/source/imgs/transformers_logo_name.png\" width=\"400\"/>\n    <br>\n<p>\n<p align=\"center\">\n    <a href=\"https://circleci.com/gh/huggingface/transformers\">\n        <img alt=\"Build\" src=\"https://img.shields.io/circleci/build/github/huggingface/transformers/master\">\n    </a>\n    <a href=\"https://github.com/huggingface/transformers/blob/master/LICENSE\">\n        <img alt=\"GitHub\" src=\"https://img.shields.io/github/license/huggingface/transformers.svg?color=blue\">\n    </a>\n    <a href=\"https://huggingface.co/transformers/index.html\">\n        <img alt=\"Documentation\" src=\"https://img.shields.io/website/http/huggingface.co/transformers/index.html.svg?down_color=red&down_message=offline&up_message=online\">\n    </a>\n    <a href=\"https://github.com/huggingface/transformers/releases\">\n        <img alt=\"GitHub release\" src=\"https://img.shields.io/github/release/huggingface/transformers.svg\">\n    </a>\n</p>\n\n<h3 align=\"center\">\n<p>State-of-the-art Natural Language Processing for TensorFlow 2.0 and PyTorch\n</h3>\n\n\ud83e\udd17 Transformers (formerly known as `pytorch-transformers` and `pytorch-pretrained-bert`) provides state-of-the-art general-purpose architectures (BERT, GPT-2, RoBERTa, XLM, DistilBert, XLNet, CTRL...) for Natural Language Understanding (NLU) and Natural Language Generation (NLG) with over 32+ pretrained models in 100+ languages and deep interoperability between TensorFlow 2.0 and PyTorch.\n\n### Features\n\n- As easy to use as pytorch-transformers\n- As powerful and concise as Keras\n- High performance on NLU and NLG tasks\n- Low barrier to entry for educators and practitioners\n\nState-of-the-art NLP for everyone\n- Deep learning researchers\n- Hands-on practitioners\n- AI/ML/NLP teachers and educators\n\nLower compute costs, smaller carbon footprint\n- Researchers can share trained models instead of always retraining\n- Practitioners can reduce compute time and production costs\n- 10 architectures with over 30 pretrained models, some in more than 100 languages\n\nChoose the right framework for every part of a model's lifetime\n- Train state-of-the-art models in 3 lines of code\n- Deep interoperability between TensorFlow 2.0 and PyTorch models\n- Move a single model between TF2.0/PyTorch frameworks at will\n- Seamlessly pick the right framework for training, evaluation, production\n\n\n| Section | Description |\n|-|-|\n| [Installation](#installation) | How to install the package |\n| [Model architectures](#model-architectures) | Architectures (with pretrained weights) |\n| [Online demo](#online-demo) | Experimenting with this repo\u2019s text generation capabilities |\n| [Quick tour: Usage](#quick-tour) | Tokenizers & models usage: Bert and GPT-2 |\n| [Quick tour: TF 2.0 and PyTorch ](#Quick-tour-TF-20-training-and-PyTorch-interoperability) | Train a TF 2.0 model in 10 lines of code, load it in PyTorch |\n| [Quick tour: pipelines](#quick-tour-of-pipelines) | Using Pipelines: Wrapper around tokenizer and models to use finetuned models |\n| [Quick tour: Fine-tuning/usage scripts](#quick-tour-of-the-fine-tuningusage-scripts) | Using provided scripts: GLUE, SQuAD and Text generation |\n| [Quick tour: Share your models ](#Quick-tour-of-model-sharing) | Upload and share your fine-tuned models with the community |\n| [Migrating from pytorch-transformers to transformers](#Migrating-from-pytorch-transformers-to-transformers) | Migrating your code from pytorch-transformers to transformers |\n| [Migrating from pytorch-pretrained-bert to pytorch-transformers](#Migrating-from-pytorch-pretrained-bert-to-transformers) | Migrating your code from pytorch-pretrained-bert to transformers |\n| [Documentation][(v2.3.0)](https://huggingface.co/transformers/v2.3.0)[(v2.2.0/v2.2.1/v2.2.2)](https://huggingface.co/transformers/v2.2.0) [(v2.1.1)](https://huggingface.co/transformers/v2.1.1) [(v2.0.0)](https://huggingface.co/transformers/v2.0.0) [(v1.2.0)](https://huggingface.co/transformers/v1.2.0) [(v1.1.0)](https://huggingface.co/transformers/v1.1.0) [(v1.0.0)](https://huggingface.co/transformers/v1.0.0) [(master)](https://huggingface.co/transformers) | Full API documentation and more |\n\n## Installation\n\nThis repo is tested on Python 3.5+, PyTorch 1.0.0+ and TensorFlow 2.0.0-rc1\n\nYou should install \ud83e\udd17 Transformers in a [virtual environment](https://docs.python.org/3/library/venv.html). If you're unfamiliar with Python virtual environments, check out the [user guide](https://packaging.python.org/guides/installing-using-pip-and-virtual-environments/).\n\nCreate a virtual environment with the version of Python you're going to use and activate it.\n\nNow, if you want to use \ud83e\udd17 Transformers, you can install it with pip. If you'd like to play with the examples, you must install it from source.\n\n### With pip\n\nFirst you need to install one of, or both, TensorFlow 2.0 and PyTorch.\nPlease refer to [TensorFlow installation page](https://www.tensorflow.org/install/pip#tensorflow-2.0-rc-is-available) and/or [PyTorch installation page](https://pytorch.org/get-started/locally/#start-locally) regarding the specific install command for your platform.\n\nWhen TensorFlow 2.0 and/or PyTorch has been installed, \ud83e\udd17 Transformers can be installed using pip as follows:\n\n```bash\npip install transformers\n```\n\n### From source\n\nHere also, you first need to install one of, or both, TensorFlow 2.0 and PyTorch.\nPlease refer to [TensorFlow installation page](https://www.tensorflow.org/install/pip#tensorflow-2.0-rc-is-available) and/or [PyTorch installation page](https://pytorch.org/get-started/locally/#start-locally) regarding the specific install command for your platform.\n\nWhen TensorFlow 2.0 and/or PyTorch has been installed, you can install from source by cloning the repository and running:\n\n```bash\ngit clone https://github.com/huggingface/transformers\ncd transformers\npip install .\n```\n\nWhen you update the repository, you should upgrade the transformers installation and its dependencies as follows:\n\n```bash\ngit pull\npip install --upgrade .\n```\n\n### Run the examples\n\nExamples are included in the repository but are not shipped with the library.\n\nTherefore, in order to run the latest versions of the examples, you need to install from source, as described above.\n\nLook at the [README](https://github.com/huggingface/transformers/blob/master/examples/README.md) for how to run examples.\n\n### Tests\n\nA series of tests are included for the library and for some example scripts. Library tests can be found in the [tests folder](https://github.com/huggingface/transformers/tree/master/tests) and examples tests in the [examples folder](https://github.com/huggingface/transformers/tree/master/examples).\n\nDepending on which framework is installed (TensorFlow 2.0 and/or PyTorch), the irrelevant tests will be skipped. Ensure that both frameworks are installed if you want to execute all tests.\n\nHere's the easiest way to run tests for the library:\n\n```bash\npip install -e \".[testing]\"\nmake test\n```\n\nand for the examples:\n\n```bash\npip install -e \".[testing]\"\npip install -r examples/requirements.txt\nmake test-examples\n```\n\nFor details, refer to the [contributing guide](https://github.com/huggingface/transformers/blob/master/CONTRIBUTING.md#tests).\n\n### Do you want to run a Transformer model on a mobile device?\n\nYou should check out our [`swift-coreml-transformers`](https://github.com/huggingface/swift-coreml-transformers) repo.\n\nIt contains a set of tools to convert PyTorch or TensorFlow 2.0 trained Transformer models (currently contains `GPT-2`, `DistilGPT-2`, `BERT`, and `DistilBERT`) to CoreML models that run on iOS devices.\n\nAt some point in the future, you'll be able to seamlessly move from pre-training or fine-tuning models to productizing them in CoreML, or prototype a model or an app in CoreML then research its hyperparameters or architecture from TensorFlow 2.0 and/or PyTorch. Super exciting!\n\n## Model architectures\n\n\ud83e\udd17 Transformers currently provides the following NLU/NLG architectures:\n\n1. **[BERT](https://github.com/google-research/bert)** (from Google) released with the paper [BERT: Pre-training of Deep Bidirectional Transformers for Language Understanding](https://arxiv.org/abs/1810.04805) by Jacob Devlin, Ming-Wei Chang, Kenton Lee and Kristina Toutanova.\n2. **[GPT](https://github.com/openai/finetune-transformer-lm)** (from OpenAI) released with the paper [Improving Language Understanding by Generative Pre-Training](https://blog.openai.com/language-unsupervised/) by Alec Radford, Karthik Narasimhan, Tim Salimans and Ilya Sutskever.\n3. **[GPT-2](https://blog.openai.com/better-language-models/)** (from OpenAI) released with the paper [Language Models are Unsupervised Multitask Learners](https://blog.openai.com/better-language-models/) by Alec Radford*, Jeffrey Wu*, Rewon Child, David Luan, Dario Amodei** and Ilya Sutskever**.\n4. **[Transformer-XL](https://github.com/kimiyoung/transformer-xl)** (from Google/CMU) released with the paper [Transformer-XL: Attentive Language Models Beyond a Fixed-Length Context](https://arxiv.org/abs/1901.02860) by Zihang Dai*, Zhilin Yang*, Yiming Yang, Jaime Carbonell, Quoc V. Le, Ruslan Salakhutdinov.\n5. **[XLNet](https://github.com/zihangdai/xlnet/)** (from Google/CMU) released with the paper [\u200bXLNet: Generalized Autoregressive Pretraining for Language Understanding](https://arxiv.org/abs/1906.08237) by Zhilin Yang*, Zihang Dai*, Yiming Yang, Jaime Carbonell, Ruslan Salakhutdinov, Quoc V. Le.\n6. **[XLM](https://github.com/facebookresearch/XLM/)** (from Facebook) released together with the paper [Cross-lingual Language Model Pretraining](https://arxiv.org/abs/1901.07291) by Guillaume Lample and Alexis Conneau.\n7. **[RoBERTa](https://github.com/pytorch/fairseq/tree/master/examples/roberta)** (from Facebook), released together with the paper a [Robustly Optimized BERT Pretraining Approach](https://arxiv.org/abs/1907.11692) by Yinhan Liu, Myle Ott, Naman Goyal, Jingfei Du, Mandar Joshi, Danqi Chen, Omer Levy, Mike Lewis, Luke Zettlemoyer, Veselin Stoyanov.\n8. **[DistilBERT](https://github.com/huggingface/transformers/tree/master/examples/distillation)** (from HuggingFace), released together with the paper [DistilBERT, a distilled version of BERT: smaller, faster, cheaper and lighter](https://arxiv.org/abs/1910.01108) by Victor Sanh, Lysandre Debut and Thomas Wolf. The same method has been applied to compress GPT2 into [DistilGPT2](https://github.com/huggingface/transformers/tree/master/examples/distillation), RoBERTa into [DistilRoBERTa](https://github.com/huggingface/transformers/tree/master/examples/distillation), Multilingual BERT into [DistilmBERT](https://github.com/huggingface/transformers/tree/master/examples/distillation) and a German version of DistilBERT.\n9. **[CTRL](https://github.com/salesforce/ctrl/)** (from Salesforce) released with the paper [CTRL: A Conditional Transformer Language Model for Controllable Generation](https://arxiv.org/abs/1909.05858) by Nitish Shirish Keskar*, Bryan McCann*, Lav R. Varshney, Caiming Xiong and Richard Socher.\n10. **[CamemBERT](https://camembert-model.fr)** (from Inria/Facebook/Sorbonne) released with the paper [CamemBERT: a Tasty French Language Model](https://arxiv.org/abs/1911.03894) by Louis Martin*, Benjamin Muller*, Pedro Javier Ortiz Su\u00e1rez*, Yoann Dupont, Laurent Romary, \u00c9ric Villemonte de la Clergerie, Djam\u00e9 Seddah and Beno\u00eet Sagot.\n11. **[ALBERT](https://github.com/google-research/ALBERT)** (from Google Research and the Toyota Technological Institute at Chicago) released with the paper [ALBERT: A Lite BERT for Self-supervised Learning of Language Representations](https://arxiv.org/abs/1909.11942), by Zhenzhong Lan, Mingda Chen, Sebastian Goodman, Kevin Gimpel, Piyush Sharma, Radu Soricut.\n12. **[T5](https://github.com/google-research/text-to-text-transfer-transformer)** (from Google AI) released with the paper [Exploring the Limits of Transfer Learning with a Unified Text-to-Text Transformer](https://arxiv.org/abs/1910.10683) by Colin Raffel and Noam Shazeer and Adam Roberts and Katherine Lee and Sharan Narang and Michael Matena and Yanqi Zhou and Wei Li and Peter J. Liu.\n13. **[XLM-RoBERTa](https://github.com/pytorch/fairseq/tree/master/examples/xlmr)** (from Facebook AI), released together with the paper [Unsupervised Cross-lingual Representation Learning at Scale](https://arxiv.org/abs/1911.02116) by Alexis Conneau*, Kartikay Khandelwal*, Naman Goyal, Vishrav Chaudhary, Guillaume Wenzek, Francisco Guzm\u00e1n, Edouard Grave, Myle Ott, Luke Zettlemoyer and Veselin Stoyanov.\n14. **[MMBT](https://github.com/facebookresearch/mmbt/)** (from Facebook), released together with the paper a [Supervised Multimodal Bitransformers for Classifying Images and Text](https://arxiv.org/pdf/1909.02950.pdf) by Douwe Kiela, Suvrat Bhooshan, Hamed Firooz, Davide Testuggine.\n15. **[Other community models](https://huggingface.co/models)**, contributed by the [community](https://huggingface.co/users).\n16. Want to contribute a new model? We have added a **detailed guide and templates** to guide you in the process of adding a new model. You can find them in the [`templates`](./templates) folder of the repository. Be sure to check the [contributing guidelines](./CONTRIBUTING.md) and contact the maintainers or open an issue to collect feedbacks before starting your PR.\n\nThese implementations have been tested on several datasets (see the example scripts) and should match the performances of the original implementations (e.g. ~93 F1 on SQuAD for BERT Whole-Word-Masking, ~88 F1 on RocStories for OpenAI GPT, ~18.3 perplexity on WikiText 103 for Transformer-XL, ~0.916 Peason R coefficient on STS-B for XLNet). You can find more details on the performances in the Examples section of the [documentation](https://huggingface.co/transformers/examples.html).\n\n## Online demo\n\n**[Write With Transformer](https://transformer.huggingface.co)**, built by the Hugging Face team at transformer.huggingface.co, is the official demo of this repo\u2019s text generation capabilities.\nYou can use it to experiment with completions generated by `GPT2Model`, `TransfoXLModel`, and `XLNetModel`.\n\n> \u201c\ud83e\udd84 Write with transformer is to writing what calculators are to calculus.\u201d\n\n![write_with_transformer](https://transformer.huggingface.co/front/assets/thumbnail-large.png)\n\n## Quick tour\n\nLet's do a very quick overview of the model architectures in \ud83e\udd17 Transformers. Detailed examples for each model architecture (Bert, GPT, GPT-2, Transformer-XL, XLNet and XLM) can be found in the [full documentation](https://huggingface.co/transformers/).\n\n```python\nimport torch\nfrom transformers import *\n\n# Transformers has a unified API\n# for 10 transformer architectures and 30 pretrained weights.\n#          Model          | Tokenizer          | Pretrained weights shortcut\nMODELS = [(BertModel,       BertTokenizer,       'bert-base-uncased'),\n          (OpenAIGPTModel,  OpenAIGPTTokenizer,  'openai-gpt'),\n          (GPT2Model,       GPT2Tokenizer,       'gpt2'),\n          (CTRLModel,       CTRLTokenizer,       'ctrl'),\n          (TransfoXLModel,  TransfoXLTokenizer,  'transfo-xl-wt103'),\n          (XLNetModel,      XLNetTokenizer,      'xlnet-base-cased'),\n          (XLMModel,        XLMTokenizer,        'xlm-mlm-enfr-1024'),\n          (DistilBertModel, DistilBertTokenizer, 'distilbert-base-uncased'),\n          (RobertaModel,    RobertaTokenizer,    'roberta-base'),\n          (XLMRobertaModel, XLMRobertaTokenizer, 'xlm-roberta-base'),\n         ]\n\n# To use TensorFlow 2.0 versions of the models, simply prefix the class names with 'TF', e.g. `TFRobertaModel` is the TF 2.0 counterpart of the PyTorch model `RobertaModel`\n\n# Let's encode some text in a sequence of hidden-states using each model:\nfor model_class, tokenizer_class, pretrained_weights in MODELS:\n    # Load pretrained model/tokenizer\n    tokenizer = tokenizer_class.from_pretrained(pretrained_weights)\n    model = model_class.from_pretrained(pretrained_weights)\n\n    # Encode text\n    input_ids = torch.tensor([tokenizer.encode(\"Here is some text to encode\", add_special_tokens=True)])  # Add special tokens takes care of adding [CLS], [SEP], <s>... tokens in the right way for each model.\n    with torch.no_grad():\n        last_hidden_states = model(input_ids)[0]  # Models outputs are now tuples\n\n# Each architecture is provided with several class for fine-tuning on down-stream tasks, e.g.\nBERT_MODEL_CLASSES = [BertModel, BertForPreTraining, BertForMaskedLM, BertForNextSentencePrediction,\n                      BertForSequenceClassification, BertForTokenClassification, BertForQuestionAnswering]\n\n# All the classes for an architecture can be initiated from pretrained weights for this architecture\n# Note that additional weights added for fine-tuning are only initialized\n# and need to be trained on the down-stream task\npretrained_weights = 'bert-base-uncased'\ntokenizer = BertTokenizer.from_pretrained(pretrained_weights)\nfor model_class in BERT_MODEL_CLASSES:\n    # Load pretrained model/tokenizer\n    model = model_class.from_pretrained(pretrained_weights)\n\n    # Models can return full list of hidden-states & attentions weights at each layer\n    model = model_class.from_pretrained(pretrained_weights,\n                                        output_hidden_states=True,\n                                        output_attentions=True)\n    input_ids = torch.tensor([tokenizer.encode(\"Let's see all hidden-states and attentions on this text\")])\n    all_hidden_states, all_attentions = model(input_ids)[-2:]\n\n    # Models are compatible with Torchscript\n    model = model_class.from_pretrained(pretrained_weights, torchscript=True)\n    traced_model = torch.jit.trace(model, (input_ids,))\n\n    # Simple serialization for models and tokenizers\n    model.save_pretrained('./directory/to/save/')  # save\n    model = model_class.from_pretrained('./directory/to/save/')  # re-load\n    tokenizer.save_pretrained('./directory/to/save/')  # save\n    tokenizer = BertTokenizer.from_pretrained('./directory/to/save/')  # re-load\n\n    # SOTA examples for GLUE, SQUAD, text generation...\n```\n\n## Quick tour TF 2.0 training and PyTorch interoperability\n\nLet's do a quick example of how a TensorFlow 2.0 model can be trained in 12 lines of code with \ud83e\udd17 Transformers and then loaded in PyTorch for fast inspection/tests.\n\n```python\nimport tensorflow as tf\nimport tensorflow_datasets\nfrom transformers import *\n\n# Load dataset, tokenizer, model from pretrained model/vocabulary\ntokenizer = BertTokenizer.from_pretrained('bert-base-cased')\nmodel = TFBertForSequenceClassification.from_pretrained('bert-base-cased')\ndata = tensorflow_datasets.load('glue/mrpc')\n\n# Prepare dataset for GLUE as a tf.data.Dataset instance\ntrain_dataset = glue_convert_examples_to_features(data['train'], tokenizer, max_length=128, task='mrpc')\nvalid_dataset = glue_convert_examples_to_features(data['validation'], tokenizer, max_length=128, task='mrpc')\ntrain_dataset = train_dataset.shuffle(100).batch(32).repeat(2)\nvalid_dataset = valid_dataset.batch(64)\n\n# Prepare training: Compile tf.keras model with optimizer, loss and learning rate schedule\noptimizer = tf.keras.optimizers.Adam(learning_rate=3e-5, epsilon=1e-08, clipnorm=1.0)\nloss = tf.keras.losses.SparseCategoricalCrossentropy(from_logits=True)\nmetric = tf.keras.metrics.SparseCategoricalAccuracy('accuracy')\nmodel.compile(optimizer=optimizer, loss=loss, metrics=[metric])\n\n# Train and evaluate using tf.keras.Model.fit()\nhistory = model.fit(train_dataset, epochs=2, steps_per_epoch=115,\n                    validation_data=valid_dataset, validation_steps=7)\n\n# Load the TensorFlow model in PyTorch for inspection\nmodel.save_pretrained('./save/')\npytorch_model = BertForSequenceClassification.from_pretrained('./save/', from_tf=True)\n\n# Quickly test a few predictions - MRPC is a paraphrasing task, let's see if our model learned the task\nsentence_0 = \"This research was consistent with his findings.\"\nsentence_1 = \"His findings were compatible with this research.\"\nsentence_2 = \"His findings were not compatible with this research.\"\ninputs_1 = tokenizer.encode_plus(sentence_0, sentence_1, add_special_tokens=True, return_tensors='pt')\ninputs_2 = tokenizer.encode_plus(sentence_0, sentence_2, add_special_tokens=True, return_tensors='pt')\n\npred_1 = pytorch_model(inputs_1['input_ids'], token_type_ids=inputs_1['token_type_ids'])[0].argmax().item()\npred_2 = pytorch_model(inputs_2['input_ids'], token_type_ids=inputs_2['token_type_ids'])[0].argmax().item()\n\nprint(\"sentence_1 is\", \"a paraphrase\" if pred_1 else \"not a paraphrase\", \"of sentence_0\")\nprint(\"sentence_2 is\", \"a paraphrase\" if pred_2 else \"not a paraphrase\", \"of sentence_0\")\n```\n\n## Quick tour of the fine-tuning/usage scripts\n\n**Important**\nBefore running the fine-tuning scripts, please read the\n[instructions](#run-the-examples) on how to\nsetup your environment to run the examples.\n\nThe library comprises several example scripts with SOTA performances for NLU and NLG tasks:\n\n- `run_glue.py`: an example fine-tuning Bert, XLNet and XLM on nine different GLUE tasks (*sequence-level classification*)\n- `run_squad.py`: an example fine-tuning Bert, XLNet and XLM on the question answering dataset SQuAD 2.0 (*token-level classification*)\n- `run_generation.py`: an example using GPT, GPT-2, CTRL, Transformer-XL and XLNet for conditional language generation\n- other model-specific examples (see the documentation).\n\nHere are three quick usage examples for these scripts:\n\n### `run_glue.py`: Fine-tuning on GLUE tasks for sequence classification\n\nThe [General Language Understanding Evaluation (GLUE) benchmark](https://gluebenchmark.com/) is a collection of nine sentence- or sentence-pair language understanding tasks for evaluating and analyzing natural language understanding systems.\n\nBefore running anyone of these GLUE tasks you should download the\n[GLUE data](https://gluebenchmark.com/tasks) by running\n[this script](https://gist.github.com/W4ngatang/60c2bdb54d156a41194446737ce03e2e)\nand unpack it to some directory `$GLUE_DIR`.\n\nYou should also install the additional packages required by the examples:\n\n```shell\npip install -r ./examples/requirements.txt\n```\n\n```shell\nexport GLUE_DIR=/path/to/glue\nexport TASK_NAME=MRPC\n\npython ./examples/run_glue.py \\\n    --model_type bert \\\n    --model_name_or_path bert-base-uncased \\\n    --task_name $TASK_NAME \\\n    --do_train \\\n    --do_eval \\\n    --do_lower_case \\\n    --data_dir $GLUE_DIR/$TASK_NAME \\\n    --max_seq_length 128 \\\n    --per_gpu_eval_batch_size=8   \\\n    --per_gpu_train_batch_size=8   \\\n    --learning_rate 2e-5 \\\n    --num_train_epochs 3.0 \\\n    --output_dir /tmp/$TASK_NAME/\n```\n\nwhere task name can be one of CoLA, SST-2, MRPC, STS-B, QQP, MNLI, QNLI, RTE, WNLI.\n\nThe dev set results will be present within the text file 'eval_results.txt' in the specified output_dir. In case of MNLI, since there are two separate dev sets, matched and mismatched, there will be a separate output folder called '/tmp/MNLI-MM/' in addition to '/tmp/MNLI/'.\n\n#### Fine-tuning XLNet model on the STS-B regression task\n\nThis example code fine-tunes XLNet on the STS-B corpus using parallel training on a server with 4 V100 GPUs.\nParallel training is a simple way to use several GPUs (but is slower and less flexible than distributed training, see below).\n\n```shell\nexport GLUE_DIR=/path/to/glue\n\npython ./examples/run_glue.py \\\n    --model_type xlnet \\\n    --model_name_or_path xlnet-large-cased \\\n    --do_train  \\\n    --do_eval   \\\n    --task_name=sts-b     \\\n    --data_dir=${GLUE_DIR}/STS-B  \\\n    --output_dir=./proc_data/sts-b-110   \\\n    --max_seq_length=128   \\\n    --per_gpu_eval_batch_size=8   \\\n    --per_gpu_train_batch_size=8   \\\n    --gradient_accumulation_steps=1 \\\n    --max_steps=1200  \\\n    --model_name=xlnet-large-cased   \\\n    --overwrite_output_dir   \\\n    --overwrite_cache \\\n    --warmup_steps=120\n```\n\nOn this machine we thus have a batch size of 32, please increase `gradient_accumulation_steps` to reach the same batch size if you have a smaller machine. These hyper-parameters should result in a Pearson correlation coefficient of `+0.917` on the development set.\n\n#### Fine-tuning Bert model on the MRPC classification task\n\nThis example code fine-tunes the Bert Whole Word Masking model on the Microsoft Research Paraphrase Corpus (MRPC) corpus using distributed training on 8 V100 GPUs to reach a F1 > 92.\n\n```bash\npython -m torch.distributed.launch --nproc_per_node 8 ./examples/run_glue.py   \\\n    --model_type bert \\\n    --model_name_or_path bert-large-uncased-whole-word-masking \\\n    --task_name MRPC \\\n    --do_train   \\\n    --do_eval   \\\n    --do_lower_case   \\\n    --data_dir $GLUE_DIR/MRPC/   \\\n    --max_seq_length 128   \\\n    --per_gpu_eval_batch_size=8   \\\n    --per_gpu_train_batch_size=8   \\\n    --learning_rate 2e-5   \\\n    --num_train_epochs 3.0  \\\n    --output_dir /tmp/mrpc_output/ \\\n    --overwrite_output_dir   \\\n    --overwrite_cache \\\n```\n\nTraining with these hyper-parameters gave us the following results:\n\n```bash\n  acc = 0.8823529411764706\n  acc_and_f1 = 0.901702786377709\n  eval_loss = 0.3418912578906332\n  f1 = 0.9210526315789473\n  global_step = 174\n  loss = 0.07231863956341798\n```\n\n### `run_squad.py`: Fine-tuning on SQuAD for question-answering\n\nThis example code fine-tunes BERT on the SQuAD dataset using distributed training on 8 V100 GPUs and Bert Whole Word Masking uncased model to reach a F1 > 93 on SQuAD:\n\n```bash\npython -m torch.distributed.launch --nproc_per_node=8 ./examples/run_squad.py \\\n    --model_type bert \\\n    --model_name_or_path bert-large-uncased-whole-word-masking \\\n    --do_train \\\n    --do_eval \\\n    --do_lower_case \\\n    --train_file $SQUAD_DIR/train-v1.1.json \\\n    --predict_file $SQUAD_DIR/dev-v1.1.json \\\n    --learning_rate 3e-5 \\\n    --num_train_epochs 2 \\\n    --max_seq_length 384 \\\n    --doc_stride 128 \\\n    --output_dir ../models/wwm_uncased_finetuned_squad/ \\\n    --per_gpu_eval_batch_size=3   \\\n    --per_gpu_train_batch_size=3   \\\n```\n\nTraining with these hyper-parameters gave us the following results:\n\n```bash\npython $SQUAD_DIR/evaluate-v1.1.py $SQUAD_DIR/dev-v1.1.json ../models/wwm_uncased_finetuned_squad/predictions.json\n{\"exact_match\": 86.91579943235573, \"f1\": 93.1532499015869}\n```\n\nThis is the model provided as `bert-large-uncased-whole-word-masking-finetuned-squad`.\n\n### `run_generation.py`: Text generation with GPT, GPT-2, CTRL, Transformer-XL and XLNet\n\nA conditional generation script is also included to generate text from a prompt.\nThe generation script includes the [tricks](https://github.com/rusiaaman/XLNet-gen#methodology) proposed by Aman Rusia to get high-quality generation with memory models like Transformer-XL and XLNet (include a predefined text to make short inputs longer).\n\nHere is how to run the script with the small version of OpenAI GPT-2 model:\n\n```shell\npython ./examples/run_generation.py \\\n    --model_type=gpt2 \\\n    --length=20 \\\n    --model_name_or_path=gpt2 \\\n```\n\nand from the Salesforce CTRL model:\n```shell\npython ./examples/run_generation.py \\\n    --model_type=ctrl \\\n    --length=20 \\\n    --model_name_or_path=ctrl \\\n    --temperature=0 \\\n    --repetition_penalty=1.2 \\\n```\n\n## Quick tour of model sharing\n\nNew in `v2.2.2`: you can now upload and share your fine-tuned models with the community, using the <abbr title=\"Command-line interface\">CLI</abbr> that's built-in to the library.\n\n**First, create an account on [https://huggingface.co/join](https://huggingface.co/join)**. Then:\n\n```shell\ntransformers-cli login\n# log in using the same credentials as on huggingface.co\n```\nUpload your model:\n```shell\ntransformers-cli upload ./path/to/pretrained_model/\n\n# ^^ Upload folder containing weights/tokenizer/config\n# saved via `.save_pretrained()`\n\ntransformers-cli upload ./config.json [--filename folder/foobar.json]\n\n# ^^ Upload a single file\n# (you can optionally override its filename, which can be nested inside a folder)\n```\n\nYour model will then be accessible through its identifier, a concatenation of your username and the folder name above:\n```python\n\"username/model_name\"\n```\n\nAnyone can load it from code:\n```python\ntokenizer = AutoTokenizer.from_pretrained(\"username/pretrained_model\")\nmodel = AutoModel.from_pretrained(\"username/pretrained_model\")\n```\n\nFinally, list all your files on S3:\n```shell\ntransformers-cli s3 ls\n# List all your S3 objects.\n```\n\n## Quick tour of pipelines\n\nNew in version `v2.3`: `Pipeline` are high-level objects which automatically handle tokenization, running your data through a transformers model\nand outputting the result in a structured object.\n\nYou can create `Pipeline` objects for the following down-stream tasks:\n\n - `feature-extraction`: Generates a tensor representation for the input sequence\n - `ner`: Generates named entity mapping for each word in the input sequence.\n - `sentiment-analysis`: Gives the polarity (positive / negative) of the whole input sequence.\n - `question-answering`: Provided some context and a question refering to the context, it will extract the answer to the question\n in the context.\n\n```python\nfrom transformers import pipeline\n\n# Allocate a pipeline for sentiment-analysis\nnlp = pipeline('sentiment-analysis')\nnlp('We are very happy to include pipeline into the transformers repository.')\n>>> {'label': 'POSITIVE', 'score': 0.99893874}\n\n# Allocate a pipeline for question-answering\nnlp = pipeline('question-answering')\nnlp({\n    'question': 'What is the name of the repository ?',\n    'context': 'Pipeline have been included in the huggingface/transformers repository'\n})\n>>> {'score': 0.28756016668193496, 'start': 35, 'end': 59, 'answer': 'huggingface/transformers'}\n```\n\n## Migrating from pytorch-transformers to transformers\n\nHere is a quick summary of what you should take care of when migrating from `pytorch-transformers` to `transformers`.\n\n### Positional order of some models' keywords inputs (`attention_mask`, `token_type_ids`...) changed\n\nTo be able to use Torchscript (see #1010, #1204 and #1195) the specific order of some models **keywords inputs** (`attention_mask`, `token_type_ids`...) has been changed.\n\nIf you used to call the models with keyword names for keyword arguments, e.g. `model(inputs_ids, attention_mask=attention_mask, token_type_ids=token_type_ids)`, this should not cause any change.\n\nIf you used to call the models with positional inputs for keyword arguments, e.g. `model(inputs_ids, attention_mask, token_type_ids)`, you may have to double check the exact order of input arguments.\n\n\n## Migrating from pytorch-pretrained-bert to transformers\n\nHere is a quick summary of what you should take care of when migrating from `pytorch-pretrained-bert` to `transformers`.\n\n### Models always output `tuples`\n\nThe main breaking change when migrating from `pytorch-pretrained-bert` to `transformers` is that every model's forward method always outputs a `tuple` with various elements depending on the model and the configuration parameters.\n\nThe exact content of the tuples for each model is detailed in the models' docstrings and the [documentation](https://huggingface.co/transformers/).\n\nIn pretty much every case, you will be fine by taking the first element of the output as the output you previously used in `pytorch-pretrained-bert`.\n\nHere is a `pytorch-pretrained-bert` to `transformers` conversion example for a `BertForSequenceClassification` classification model:\n\n```python\n# Let's load our model\nmodel = BertForSequenceClassification.from_pretrained('bert-base-uncased')\n\n# If you used to have this line in pytorch-pretrained-bert:\nloss = model(input_ids, labels=labels)\n\n# Now just use this line in transformers to extract the loss from the output tuple:\noutputs = model(input_ids, labels=labels)\nloss = outputs[0]\n\n# In transformers you can also have access to the logits:\nloss, logits = outputs[:2]\n\n# And even the attention weights if you configure the model to output them (and other outputs too, see the docstrings and documentation)\nmodel = BertForSequenceClassification.from_pretrained('bert-base-uncased', output_attentions=True)\noutputs = model(input_ids, labels=labels)\nloss, logits, attentions = outputs\n```\n\n### Using hidden states\n\nBy enabling the configuration option `output_hidden_states`, it was possible to retrieve the last hidden states of the encoder. In `pytorch-transformers` as well as `transformers` the return value has changed slightly: `all_hidden_states` now also includes the hidden state of the embeddings in addition to those of the encoding layers. This allows users to easily access the embeddings final state.\n\n### Serialization\n\nBreaking change in the `from_pretrained()` method:\n\n1. Models are now set in evaluation mode by default when instantiated with the `from_pretrained()` method. To train them, don't forget to set them back in training mode (`model.train()`) to activate the dropout modules.\n\n2. The additional `*input` and `**kwargs` arguments supplied to the `from_pretrained()` method used to be directly passed to the underlying model's class `__init__()` method. They are now used to update the model configuration attribute instead, which can break derived model classes built based on the previous `BertForSequenceClassification` examples. We are working on a way to mitigate this breaking change in [#866](https://github.com/huggingface/transformers/pull/866) by forwarding the the model's `__init__()` method (i) the provided positional arguments and (ii) the keyword arguments which do not match any configuration class attributes.\n\nAlso, while not a breaking change, the serialization methods have been standardized and you probably should switch to the new method `save_pretrained(save_directory)` if you were using any other serialization method before.\n\nHere is an example:\n\n```python\n### Let's load a model and tokenizer\nmodel = BertForSequenceClassification.from_pretrained('bert-base-uncased')\ntokenizer = BertTokenizer.from_pretrained('bert-base-uncased')\n\n### Do some stuff to our model and tokenizer\n# Ex: add new tokens to the vocabulary and embeddings of our model\ntokenizer.add_tokens(['[SPECIAL_TOKEN_1]', '[SPECIAL_TOKEN_2]'])\nmodel.resize_token_embeddings(len(tokenizer))\n# Train our model\ntrain(model)\n\n### Now let's save our model and tokenizer to a directory\nmodel.save_pretrained('./my_saved_model_directory/')\ntokenizer.save_pretrained('./my_saved_model_directory/')\n\n### Reload the model and the tokenizer\nmodel = BertForSequenceClassification.from_pretrained('./my_saved_model_directory/')\ntokenizer = BertTokenizer.from_pretrained('./my_saved_model_directory/')\n```\n\n### Optimizers: BertAdam & OpenAIAdam are now AdamW, schedules are standard PyTorch schedules\n\nThe two optimizers previously included, `BertAdam` and `OpenAIAdam`, have been replaced by a single `AdamW` optimizer which has a few differences:\n\n- it only implements weights decay correction,\n- schedules are now externals (see below),\n- gradient clipping is now also external (see below).\n\nThe new optimizer `AdamW` matches PyTorch `Adam` optimizer API and let you use standard PyTorch or apex methods for the schedule and clipping.\n\nThe schedules are now standard [PyTorch learning rate schedulers](https://pytorch.org/docs/stable/optim.html#how-to-adjust-learning-rate) and not part of the optimizer anymore.\n\nHere is a conversion examples from `BertAdam` with a linear warmup and decay schedule to `AdamW` and the same schedule:\n\n```python\n# Parameters:\nlr = 1e-3\nmax_grad_norm = 1.0\nnum_training_steps = 1000\nnum_warmup_steps = 100\nwarmup_proportion = float(num_warmup_steps) / float(num_training_steps)  # 0.1\n\n### Previously BertAdam optimizer was instantiated like this:\noptimizer = BertAdam(model.parameters(), lr=lr, schedule='warmup_linear', warmup=warmup_proportion, t_total=num_training_steps)\n### and used like this:\nfor batch in train_data:\n    loss = model(batch)\n    loss.backward()\n    optimizer.step()\n\n### In Transformers, optimizer and schedules are splitted and instantiated like this:\noptimizer = AdamW(model.parameters(), lr=lr, correct_bias=False)  # To reproduce BertAdam specific behavior set correct_bias=False\nscheduler = get_linear_schedule_with_warmup(optimizer, num_warmup_steps=num_warmup_steps, num_training_steps=num_training_steps)  # PyTorch scheduler\n### and used like this:\nfor batch in train_data:\n    model.train()\n    loss = model(batch)\n    loss.backward()\n    torch.nn.utils.clip_grad_norm_(model.parameters(), max_grad_norm)  # Gradient clipping is not in AdamW anymore (so you can use amp without issue)\n    optimizer.step()\n    scheduler.step()\n    optimizer.zero_grad()\n```\n\n## Citation\n\nWe now have a paper you can cite for the \ud83e\udd17 Transformers library:\n```\n@article{Wolf2019HuggingFacesTS,\n  title={HuggingFace's Transformers: State-of-the-art Natural Language Processing},\n  author={Thomas Wolf and Lysandre Debut and Victor Sanh and Julien Chaumond and Clement Delangue and Anthony Moi and Pierric Cistac and Tim Rault and R'emi Louf and Morgan Funtowicz and Jamie Brew},\n  journal={ArXiv},\n  year={2019},\n  volume={abs/1910.03771}\n}\n```\n\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/huggingface/transformers", "keywords": "NLP deep learning transformer pytorch tensorflow BERT GPT GPT-2 google openai CMU", "license": "Apache", "maintainer": "", "maintainer_email": "", "name": "richads-transformers", "package_url": "https://pypi.org/project/richads-transformers/", "platform": "", "project_url": "https://pypi.org/project/richads-transformers/", "project_urls": {"Homepage": "https://github.com/huggingface/transformers"}, "release_url": "https://pypi.org/project/richads-transformers/2.3.0/", "requires_dist": ["numpy", "tokenizers (==0.0.11)", "boto3", "filelock", "requests", "tqdm", "regex (!=2019.12.17)", "sentencepiece", "sacremoses", "pydantic ; extra == 'all'", "uvicorn ; extra == 'all'", "fastapi ; extra == 'all'", "tensorflow ; extra == 'all'", "torch ; extra == 'all'", "pytest ; extra == 'dev'", "pytest-xdist ; extra == 'dev'", "black ; extra == 'dev'", "isort ; extra == 'dev'", "flake8 ; extra == 'dev'", "mecab-python3 ; extra == 'dev'", "scikit-learn ; extra == 'dev'", "tensorflow ; extra == 'dev'", "torch ; extra == 'dev'", "recommonmark ; extra == 'docs'", "sphinx ; extra == 'docs'", "sphinx-markdown-tables ; extra == 'docs'", "sphinx-rtd-theme ; extra == 'docs'", "mecab-python3 ; extra == 'mecab'", "black ; extra == 'quality'", "isort ; extra == 'quality'", "flake8 ; extra == 'quality'", "pydantic ; extra == 'serving'", "uvicorn ; extra == 'serving'", "fastapi ; extra == 'serving'", "scikit-learn ; extra == 'sklearn'", "pytest ; extra == 'testing'", "pytest-xdist ; extra == 'testing'", "tensorflow ; extra == 'tf'", "torch ; extra == 'torch'"], "requires_python": ">=3.5.0", "summary": "State-of-the-art Natural Language Processing for TensorFlow 2.0 and PyTorch", "version": "2.3.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p align=\"center\">\n    <br>\n    <img src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/05e1095f860ab23adec72cbf20477934954037bb/68747470733a2f2f7261772e67697468756275736572636f6e74656e742e636f6d2f68756767696e67666163652f7472616e73666f726d6572732f6d61737465722f646f63732f736f757263652f696d67732f7472616e73666f726d6572735f6c6f676f5f6e616d652e706e67\" width=\"400\">\n    <br>\n</p><p>\n</p><p align=\"center\">\n    <a href=\"https://circleci.com/gh/huggingface/transformers\" rel=\"nofollow\">\n        <img alt=\"Build\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/63c0f73ef5a4b771a62b1036bbf01c60cf303531/68747470733a2f2f696d672e736869656c64732e696f2f636972636c6563692f6275696c642f6769746875622f68756767696e67666163652f7472616e73666f726d6572732f6d6173746572\">\n    </a>\n    <a href=\"https://github.com/huggingface/transformers/blob/master/LICENSE\" rel=\"nofollow\">\n        <img alt=\"GitHub\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/9379cde850efc58968203b79be8f1fdb59280f8b/68747470733a2f2f696d672e736869656c64732e696f2f6769746875622f6c6963656e73652f68756767696e67666163652f7472616e73666f726d6572732e7376673f636f6c6f723d626c7565\">\n    </a>\n    <a href=\"https://huggingface.co/transformers/index.html\" rel=\"nofollow\">\n        <img alt=\"Documentation\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/cd42809f7fc8ebde0432e5e2d4906efc4c841ed9/68747470733a2f2f696d672e736869656c64732e696f2f776562736974652f687474702f68756767696e67666163652e636f2f7472616e73666f726d6572732f696e6465782e68746d6c2e7376673f646f776e5f636f6c6f723d72656426646f776e5f6d6573736167653d6f66666c696e652675705f6d6573736167653d6f6e6c696e65\">\n    </a>\n    <a href=\"https://github.com/huggingface/transformers/releases\" rel=\"nofollow\">\n        <img alt=\"GitHub release\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/be3f56d01d2f3442b1342c50a43e3252517b2a94/68747470733a2f2f696d672e736869656c64732e696f2f6769746875622f72656c656173652f68756767696e67666163652f7472616e73666f726d6572732e737667\">\n    </a>\n</p>\n<h3>\n</h3><p>State-of-the-art Natural Language Processing for TensorFlow 2.0 and PyTorch\n\n</p><p>\ud83e\udd17 Transformers (formerly known as <code>pytorch-transformers</code> and <code>pytorch-pretrained-bert</code>) provides state-of-the-art general-purpose architectures (BERT, GPT-2, RoBERTa, XLM, DistilBert, XLNet, CTRL...) for Natural Language Understanding (NLU) and Natural Language Generation (NLG) with over 32+ pretrained models in 100+ languages and deep interoperability between TensorFlow 2.0 and PyTorch.</p>\n<h3>Features</h3>\n<ul>\n<li>As easy to use as pytorch-transformers</li>\n<li>As powerful and concise as Keras</li>\n<li>High performance on NLU and NLG tasks</li>\n<li>Low barrier to entry for educators and practitioners</li>\n</ul>\n<p>State-of-the-art NLP for everyone</p>\n<ul>\n<li>Deep learning researchers</li>\n<li>Hands-on practitioners</li>\n<li>AI/ML/NLP teachers and educators</li>\n</ul>\n<p>Lower compute costs, smaller carbon footprint</p>\n<ul>\n<li>Researchers can share trained models instead of always retraining</li>\n<li>Practitioners can reduce compute time and production costs</li>\n<li>10 architectures with over 30 pretrained models, some in more than 100 languages</li>\n</ul>\n<p>Choose the right framework for every part of a model's lifetime</p>\n<ul>\n<li>Train state-of-the-art models in 3 lines of code</li>\n<li>Deep interoperability between TensorFlow 2.0 and PyTorch models</li>\n<li>Move a single model between TF2.0/PyTorch frameworks at will</li>\n<li>Seamlessly pick the right framework for training, evaluation, production</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>Section</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"#installation\" rel=\"nofollow\">Installation</a></td>\n<td>How to install the package</td>\n</tr>\n<tr>\n<td><a href=\"#model-architectures\" rel=\"nofollow\">Model architectures</a></td>\n<td>Architectures (with pretrained weights)</td>\n</tr>\n<tr>\n<td><a href=\"#online-demo\" rel=\"nofollow\">Online demo</a></td>\n<td>Experimenting with this repo\u2019s text generation capabilities</td>\n</tr>\n<tr>\n<td><a href=\"#quick-tour\" rel=\"nofollow\">Quick tour: Usage</a></td>\n<td>Tokenizers &amp; models usage: Bert and GPT-2</td>\n</tr>\n<tr>\n<td><a href=\"#Quick-tour-TF-20-training-and-PyTorch-interoperability\" rel=\"nofollow\">Quick tour: TF 2.0 and PyTorch </a></td>\n<td>Train a TF 2.0 model in 10 lines of code, load it in PyTorch</td>\n</tr>\n<tr>\n<td><a href=\"#quick-tour-of-pipelines\" rel=\"nofollow\">Quick tour: pipelines</a></td>\n<td>Using Pipelines: Wrapper around tokenizer and models to use finetuned models</td>\n</tr>\n<tr>\n<td><a href=\"#quick-tour-of-the-fine-tuningusage-scripts\" rel=\"nofollow\">Quick tour: Fine-tuning/usage scripts</a></td>\n<td>Using provided scripts: GLUE, SQuAD and Text generation</td>\n</tr>\n<tr>\n<td><a href=\"#Quick-tour-of-model-sharing\" rel=\"nofollow\">Quick tour: Share your models </a></td>\n<td>Upload and share your fine-tuned models with the community</td>\n</tr>\n<tr>\n<td><a href=\"#Migrating-from-pytorch-transformers-to-transformers\" rel=\"nofollow\">Migrating from pytorch-transformers to transformers</a></td>\n<td>Migrating your code from pytorch-transformers to transformers</td>\n</tr>\n<tr>\n<td><a href=\"#Migrating-from-pytorch-pretrained-bert-to-transformers\" rel=\"nofollow\">Migrating from pytorch-pretrained-bert to pytorch-transformers</a></td>\n<td>Migrating your code from pytorch-pretrained-bert to transformers</td>\n</tr>\n<tr>\n<td>[Documentation]<a href=\"https://huggingface.co/transformers/v2.3.0\" rel=\"nofollow\">(v2.3.0)</a><a href=\"https://huggingface.co/transformers/v2.2.0\" rel=\"nofollow\">(v2.2.0/v2.2.1/v2.2.2)</a> <a href=\"https://huggingface.co/transformers/v2.1.1\" rel=\"nofollow\">(v2.1.1)</a> <a href=\"https://huggingface.co/transformers/v2.0.0\" rel=\"nofollow\">(v2.0.0)</a> <a href=\"https://huggingface.co/transformers/v1.2.0\" rel=\"nofollow\">(v1.2.0)</a> <a href=\"https://huggingface.co/transformers/v1.1.0\" rel=\"nofollow\">(v1.1.0)</a> <a href=\"https://huggingface.co/transformers/v1.0.0\" rel=\"nofollow\">(v1.0.0)</a> <a href=\"https://huggingface.co/transformers\" rel=\"nofollow\">(master)</a></td>\n<td>Full API documentation and more</td>\n</tr></tbody></table>\n<h2>Installation</h2>\n<p>This repo is tested on Python 3.5+, PyTorch 1.0.0+ and TensorFlow 2.0.0-rc1</p>\n<p>You should install \ud83e\udd17 Transformers in a <a href=\"https://docs.python.org/3/library/venv.html\" rel=\"nofollow\">virtual environment</a>. If you're unfamiliar with Python virtual environments, check out the <a href=\"https://packaging.python.org/guides/installing-using-pip-and-virtual-environments/\" rel=\"nofollow\">user guide</a>.</p>\n<p>Create a virtual environment with the version of Python you're going to use and activate it.</p>\n<p>Now, if you want to use \ud83e\udd17 Transformers, you can install it with pip. If you'd like to play with the examples, you must install it from source.</p>\n<h3>With pip</h3>\n<p>First you need to install one of, or both, TensorFlow 2.0 and PyTorch.\nPlease refer to <a href=\"https://www.tensorflow.org/install/pip#tensorflow-2.0-rc-is-available\" rel=\"nofollow\">TensorFlow installation page</a> and/or <a href=\"https://pytorch.org/get-started/locally/#start-locally\" rel=\"nofollow\">PyTorch installation page</a> regarding the specific install command for your platform.</p>\n<p>When TensorFlow 2.0 and/or PyTorch has been installed, \ud83e\udd17 Transformers can be installed using pip as follows:</p>\n<pre>pip install transformers\n</pre>\n<h3>From source</h3>\n<p>Here also, you first need to install one of, or both, TensorFlow 2.0 and PyTorch.\nPlease refer to <a href=\"https://www.tensorflow.org/install/pip#tensorflow-2.0-rc-is-available\" rel=\"nofollow\">TensorFlow installation page</a> and/or <a href=\"https://pytorch.org/get-started/locally/#start-locally\" rel=\"nofollow\">PyTorch installation page</a> regarding the specific install command for your platform.</p>\n<p>When TensorFlow 2.0 and/or PyTorch has been installed, you can install from source by cloning the repository and running:</p>\n<pre>git clone https://github.com/huggingface/transformers\n<span class=\"nb\">cd</span> transformers\npip install .\n</pre>\n<p>When you update the repository, you should upgrade the transformers installation and its dependencies as follows:</p>\n<pre>git pull\npip install --upgrade .\n</pre>\n<h3>Run the examples</h3>\n<p>Examples are included in the repository but are not shipped with the library.</p>\n<p>Therefore, in order to run the latest versions of the examples, you need to install from source, as described above.</p>\n<p>Look at the <a href=\"https://github.com/huggingface/transformers/blob/master/examples/README.md\" rel=\"nofollow\">README</a> for how to run examples.</p>\n<h3>Tests</h3>\n<p>A series of tests are included for the library and for some example scripts. Library tests can be found in the <a href=\"https://github.com/huggingface/transformers/tree/master/tests\" rel=\"nofollow\">tests folder</a> and examples tests in the <a href=\"https://github.com/huggingface/transformers/tree/master/examples\" rel=\"nofollow\">examples folder</a>.</p>\n<p>Depending on which framework is installed (TensorFlow 2.0 and/or PyTorch), the irrelevant tests will be skipped. Ensure that both frameworks are installed if you want to execute all tests.</p>\n<p>Here's the easiest way to run tests for the library:</p>\n<pre>pip install -e <span class=\"s2\">\".[testing]\"</span>\nmake <span class=\"nb\">test</span>\n</pre>\n<p>and for the examples:</p>\n<pre>pip install -e <span class=\"s2\">\".[testing]\"</span>\npip install -r examples/requirements.txt\nmake test-examples\n</pre>\n<p>For details, refer to the <a href=\"https://github.com/huggingface/transformers/blob/master/CONTRIBUTING.md#tests\" rel=\"nofollow\">contributing guide</a>.</p>\n<h3>Do you want to run a Transformer model on a mobile device?</h3>\n<p>You should check out our <a href=\"https://github.com/huggingface/swift-coreml-transformers\" rel=\"nofollow\"><code>swift-coreml-transformers</code></a> repo.</p>\n<p>It contains a set of tools to convert PyTorch or TensorFlow 2.0 trained Transformer models (currently contains <code>GPT-2</code>, <code>DistilGPT-2</code>, <code>BERT</code>, and <code>DistilBERT</code>) to CoreML models that run on iOS devices.</p>\n<p>At some point in the future, you'll be able to seamlessly move from pre-training or fine-tuning models to productizing them in CoreML, or prototype a model or an app in CoreML then research its hyperparameters or architecture from TensorFlow 2.0 and/or PyTorch. Super exciting!</p>\n<h2>Model architectures</h2>\n<p>\ud83e\udd17 Transformers currently provides the following NLU/NLG architectures:</p>\n<ol>\n<li><strong><a href=\"https://github.com/google-research/bert\" rel=\"nofollow\">BERT</a></strong> (from Google) released with the paper <a href=\"https://arxiv.org/abs/1810.04805\" rel=\"nofollow\">BERT: Pre-training of Deep Bidirectional Transformers for Language Understanding</a> by Jacob Devlin, Ming-Wei Chang, Kenton Lee and Kristina Toutanova.</li>\n<li><strong><a href=\"https://github.com/openai/finetune-transformer-lm\" rel=\"nofollow\">GPT</a></strong> (from OpenAI) released with the paper <a href=\"https://blog.openai.com/language-unsupervised/\" rel=\"nofollow\">Improving Language Understanding by Generative Pre-Training</a> by Alec Radford, Karthik Narasimhan, Tim Salimans and Ilya Sutskever.</li>\n<li><strong><a href=\"https://blog.openai.com/better-language-models/\" rel=\"nofollow\">GPT-2</a></strong> (from OpenAI) released with the paper <a href=\"https://blog.openai.com/better-language-models/\" rel=\"nofollow\">Language Models are Unsupervised Multitask Learners</a> by Alec Radford*, Jeffrey Wu*, Rewon Child, David Luan, Dario Amodei** and Ilya Sutskever**.</li>\n<li><strong><a href=\"https://github.com/kimiyoung/transformer-xl\" rel=\"nofollow\">Transformer-XL</a></strong> (from Google/CMU) released with the paper <a href=\"https://arxiv.org/abs/1901.02860\" rel=\"nofollow\">Transformer-XL: Attentive Language Models Beyond a Fixed-Length Context</a> by Zihang Dai*, Zhilin Yang*, Yiming Yang, Jaime Carbonell, Quoc V. Le, Ruslan Salakhutdinov.</li>\n<li><strong><a href=\"https://github.com/zihangdai/xlnet/\" rel=\"nofollow\">XLNet</a></strong> (from Google/CMU) released with the paper <a href=\"https://arxiv.org/abs/1906.08237\" rel=\"nofollow\">\u200bXLNet: Generalized Autoregressive Pretraining for Language Understanding</a> by Zhilin Yang*, Zihang Dai*, Yiming Yang, Jaime Carbonell, Ruslan Salakhutdinov, Quoc V. Le.</li>\n<li><strong><a href=\"https://github.com/facebookresearch/XLM/\" rel=\"nofollow\">XLM</a></strong> (from Facebook) released together with the paper <a href=\"https://arxiv.org/abs/1901.07291\" rel=\"nofollow\">Cross-lingual Language Model Pretraining</a> by Guillaume Lample and Alexis Conneau.</li>\n<li><strong><a href=\"https://github.com/pytorch/fairseq/tree/master/examples/roberta\" rel=\"nofollow\">RoBERTa</a></strong> (from Facebook), released together with the paper a <a href=\"https://arxiv.org/abs/1907.11692\" rel=\"nofollow\">Robustly Optimized BERT Pretraining Approach</a> by Yinhan Liu, Myle Ott, Naman Goyal, Jingfei Du, Mandar Joshi, Danqi Chen, Omer Levy, Mike Lewis, Luke Zettlemoyer, Veselin Stoyanov.</li>\n<li><strong><a href=\"https://github.com/huggingface/transformers/tree/master/examples/distillation\" rel=\"nofollow\">DistilBERT</a></strong> (from HuggingFace), released together with the paper <a href=\"https://arxiv.org/abs/1910.01108\" rel=\"nofollow\">DistilBERT, a distilled version of BERT: smaller, faster, cheaper and lighter</a> by Victor Sanh, Lysandre Debut and Thomas Wolf. The same method has been applied to compress GPT2 into <a href=\"https://github.com/huggingface/transformers/tree/master/examples/distillation\" rel=\"nofollow\">DistilGPT2</a>, RoBERTa into <a href=\"https://github.com/huggingface/transformers/tree/master/examples/distillation\" rel=\"nofollow\">DistilRoBERTa</a>, Multilingual BERT into <a href=\"https://github.com/huggingface/transformers/tree/master/examples/distillation\" rel=\"nofollow\">DistilmBERT</a> and a German version of DistilBERT.</li>\n<li><strong><a href=\"https://github.com/salesforce/ctrl/\" rel=\"nofollow\">CTRL</a></strong> (from Salesforce) released with the paper <a href=\"https://arxiv.org/abs/1909.05858\" rel=\"nofollow\">CTRL: A Conditional Transformer Language Model for Controllable Generation</a> by Nitish Shirish Keskar*, Bryan McCann*, Lav R. Varshney, Caiming Xiong and Richard Socher.</li>\n<li><strong><a href=\"https://camembert-model.fr\" rel=\"nofollow\">CamemBERT</a></strong> (from Inria/Facebook/Sorbonne) released with the paper <a href=\"https://arxiv.org/abs/1911.03894\" rel=\"nofollow\">CamemBERT: a Tasty French Language Model</a> by Louis Martin*, Benjamin Muller*, Pedro Javier Ortiz Su\u00e1rez*, Yoann Dupont, Laurent Romary, \u00c9ric Villemonte de la Clergerie, Djam\u00e9 Seddah and Beno\u00eet Sagot.</li>\n<li><strong><a href=\"https://github.com/google-research/ALBERT\" rel=\"nofollow\">ALBERT</a></strong> (from Google Research and the Toyota Technological Institute at Chicago) released with the paper <a href=\"https://arxiv.org/abs/1909.11942\" rel=\"nofollow\">ALBERT: A Lite BERT for Self-supervised Learning of Language Representations</a>, by Zhenzhong Lan, Mingda Chen, Sebastian Goodman, Kevin Gimpel, Piyush Sharma, Radu Soricut.</li>\n<li><strong><a href=\"https://github.com/google-research/text-to-text-transfer-transformer\" rel=\"nofollow\">T5</a></strong> (from Google AI) released with the paper <a href=\"https://arxiv.org/abs/1910.10683\" rel=\"nofollow\">Exploring the Limits of Transfer Learning with a Unified Text-to-Text Transformer</a> by Colin Raffel and Noam Shazeer and Adam Roberts and Katherine Lee and Sharan Narang and Michael Matena and Yanqi Zhou and Wei Li and Peter J. Liu.</li>\n<li><strong><a href=\"https://github.com/pytorch/fairseq/tree/master/examples/xlmr\" rel=\"nofollow\">XLM-RoBERTa</a></strong> (from Facebook AI), released together with the paper <a href=\"https://arxiv.org/abs/1911.02116\" rel=\"nofollow\">Unsupervised Cross-lingual Representation Learning at Scale</a> by Alexis Conneau*, Kartikay Khandelwal*, Naman Goyal, Vishrav Chaudhary, Guillaume Wenzek, Francisco Guzm\u00e1n, Edouard Grave, Myle Ott, Luke Zettlemoyer and Veselin Stoyanov.</li>\n<li><strong><a href=\"https://github.com/facebookresearch/mmbt/\" rel=\"nofollow\">MMBT</a></strong> (from Facebook), released together with the paper a <a href=\"https://arxiv.org/pdf/1909.02950.pdf\" rel=\"nofollow\">Supervised Multimodal Bitransformers for Classifying Images and Text</a> by Douwe Kiela, Suvrat Bhooshan, Hamed Firooz, Davide Testuggine.</li>\n<li><strong><a href=\"https://huggingface.co/models\" rel=\"nofollow\">Other community models</a></strong>, contributed by the <a href=\"https://huggingface.co/users\" rel=\"nofollow\">community</a>.</li>\n<li>Want to contribute a new model? We have added a <strong>detailed guide and templates</strong> to guide you in the process of adding a new model. You can find them in the <a href=\"./templates\" rel=\"nofollow\"><code>templates</code></a> folder of the repository. Be sure to check the <a href=\"./CONTRIBUTING.md\" rel=\"nofollow\">contributing guidelines</a> and contact the maintainers or open an issue to collect feedbacks before starting your PR.</li>\n</ol>\n<p>These implementations have been tested on several datasets (see the example scripts) and should match the performances of the original implementations (e.g. ~93 F1 on SQuAD for BERT Whole-Word-Masking, ~88 F1 on RocStories for OpenAI GPT, ~18.3 perplexity on WikiText 103 for Transformer-XL, ~0.916 Peason R coefficient on STS-B for XLNet). You can find more details on the performances in the Examples section of the <a href=\"https://huggingface.co/transformers/examples.html\" rel=\"nofollow\">documentation</a>.</p>\n<h2>Online demo</h2>\n<p><strong><a href=\"https://transformer.huggingface.co\" rel=\"nofollow\">Write With Transformer</a></strong>, built by the Hugging Face team at transformer.huggingface.co, is the official demo of this repo\u2019s text generation capabilities.\nYou can use it to experiment with completions generated by <code>GPT2Model</code>, <code>TransfoXLModel</code>, and <code>XLNetModel</code>.</p>\n<blockquote>\n<p>\u201c\ud83e\udd84 Write with transformer is to writing what calculators are to calculus.\u201d</p>\n</blockquote>\n<p><img alt=\"write_with_transformer\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/27316509b07215207c093c49b7836d9baf4d6d74/68747470733a2f2f7472616e73666f726d65722e68756767696e67666163652e636f2f66726f6e742f6173736574732f7468756d626e61696c2d6c617267652e706e67\"></p>\n<h2>Quick tour</h2>\n<p>Let's do a very quick overview of the model architectures in \ud83e\udd17 Transformers. Detailed examples for each model architecture (Bert, GPT, GPT-2, Transformer-XL, XLNet and XLM) can be found in the <a href=\"https://huggingface.co/transformers/\" rel=\"nofollow\">full documentation</a>.</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">torch</span>\n<span class=\"kn\">from</span> <span class=\"nn\">transformers</span> <span class=\"kn\">import</span> <span class=\"o\">*</span>\n\n<span class=\"c1\"># Transformers has a unified API</span>\n<span class=\"c1\"># for 10 transformer architectures and 30 pretrained weights.</span>\n<span class=\"c1\">#          Model          | Tokenizer          | Pretrained weights shortcut</span>\n<span class=\"n\">MODELS</span> <span class=\"o\">=</span> <span class=\"p\">[(</span><span class=\"n\">BertModel</span><span class=\"p\">,</span>       <span class=\"n\">BertTokenizer</span><span class=\"p\">,</span>       <span class=\"s1\">'bert-base-uncased'</span><span class=\"p\">),</span>\n          <span class=\"p\">(</span><span class=\"n\">OpenAIGPTModel</span><span class=\"p\">,</span>  <span class=\"n\">OpenAIGPTTokenizer</span><span class=\"p\">,</span>  <span class=\"s1\">'openai-gpt'</span><span class=\"p\">),</span>\n          <span class=\"p\">(</span><span class=\"n\">GPT2Model</span><span class=\"p\">,</span>       <span class=\"n\">GPT2Tokenizer</span><span class=\"p\">,</span>       <span class=\"s1\">'gpt2'</span><span class=\"p\">),</span>\n          <span class=\"p\">(</span><span class=\"n\">CTRLModel</span><span class=\"p\">,</span>       <span class=\"n\">CTRLTokenizer</span><span class=\"p\">,</span>       <span class=\"s1\">'ctrl'</span><span class=\"p\">),</span>\n          <span class=\"p\">(</span><span class=\"n\">TransfoXLModel</span><span class=\"p\">,</span>  <span class=\"n\">TransfoXLTokenizer</span><span class=\"p\">,</span>  <span class=\"s1\">'transfo-xl-wt103'</span><span class=\"p\">),</span>\n          <span class=\"p\">(</span><span class=\"n\">XLNetModel</span><span class=\"p\">,</span>      <span class=\"n\">XLNetTokenizer</span><span class=\"p\">,</span>      <span class=\"s1\">'xlnet-base-cased'</span><span class=\"p\">),</span>\n          <span class=\"p\">(</span><span class=\"n\">XLMModel</span><span class=\"p\">,</span>        <span class=\"n\">XLMTokenizer</span><span class=\"p\">,</span>        <span class=\"s1\">'xlm-mlm-enfr-1024'</span><span class=\"p\">),</span>\n          <span class=\"p\">(</span><span class=\"n\">DistilBertModel</span><span class=\"p\">,</span> <span class=\"n\">DistilBertTokenizer</span><span class=\"p\">,</span> <span class=\"s1\">'distilbert-base-uncased'</span><span class=\"p\">),</span>\n          <span class=\"p\">(</span><span class=\"n\">RobertaModel</span><span class=\"p\">,</span>    <span class=\"n\">RobertaTokenizer</span><span class=\"p\">,</span>    <span class=\"s1\">'roberta-base'</span><span class=\"p\">),</span>\n          <span class=\"p\">(</span><span class=\"n\">XLMRobertaModel</span><span class=\"p\">,</span> <span class=\"n\">XLMRobertaTokenizer</span><span class=\"p\">,</span> <span class=\"s1\">'xlm-roberta-base'</span><span class=\"p\">),</span>\n         <span class=\"p\">]</span>\n\n<span class=\"c1\"># To use TensorFlow 2.0 versions of the models, simply prefix the class names with 'TF', e.g. `TFRobertaModel` is the TF 2.0 counterpart of the PyTorch model `RobertaModel`</span>\n\n<span class=\"c1\"># Let's encode some text in a sequence of hidden-states using each model:</span>\n<span class=\"k\">for</span> <span class=\"n\">model_class</span><span class=\"p\">,</span> <span class=\"n\">tokenizer_class</span><span class=\"p\">,</span> <span class=\"n\">pretrained_weights</span> <span class=\"ow\">in</span> <span class=\"n\">MODELS</span><span class=\"p\">:</span>\n    <span class=\"c1\"># Load pretrained model/tokenizer</span>\n    <span class=\"n\">tokenizer</span> <span class=\"o\">=</span> <span class=\"n\">tokenizer_class</span><span class=\"o\">.</span><span class=\"n\">from_pretrained</span><span class=\"p\">(</span><span class=\"n\">pretrained_weights</span><span class=\"p\">)</span>\n    <span class=\"n\">model</span> <span class=\"o\">=</span> <span class=\"n\">model_class</span><span class=\"o\">.</span><span class=\"n\">from_pretrained</span><span class=\"p\">(</span><span class=\"n\">pretrained_weights</span><span class=\"p\">)</span>\n\n    <span class=\"c1\"># Encode text</span>\n    <span class=\"n\">input_ids</span> <span class=\"o\">=</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">tensor</span><span class=\"p\">([</span><span class=\"n\">tokenizer</span><span class=\"o\">.</span><span class=\"n\">encode</span><span class=\"p\">(</span><span class=\"s2\">\"Here is some text to encode\"</span><span class=\"p\">,</span> <span class=\"n\">add_special_tokens</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)])</span>  <span class=\"c1\"># Add special tokens takes care of adding [CLS], [SEP], &lt;s&gt;... tokens in the right way for each model.</span>\n    <span class=\"k\">with</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">no_grad</span><span class=\"p\">():</span>\n        <span class=\"n\">last_hidden_states</span> <span class=\"o\">=</span> <span class=\"n\">model</span><span class=\"p\">(</span><span class=\"n\">input_ids</span><span class=\"p\">)[</span><span class=\"mi\">0</span><span class=\"p\">]</span>  <span class=\"c1\"># Models outputs are now tuples</span>\n\n<span class=\"c1\"># Each architecture is provided with several class for fine-tuning on down-stream tasks, e.g.</span>\n<span class=\"n\">BERT_MODEL_CLASSES</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">BertModel</span><span class=\"p\">,</span> <span class=\"n\">BertForPreTraining</span><span class=\"p\">,</span> <span class=\"n\">BertForMaskedLM</span><span class=\"p\">,</span> <span class=\"n\">BertForNextSentencePrediction</span><span class=\"p\">,</span>\n                      <span class=\"n\">BertForSequenceClassification</span><span class=\"p\">,</span> <span class=\"n\">BertForTokenClassification</span><span class=\"p\">,</span> <span class=\"n\">BertForQuestionAnswering</span><span class=\"p\">]</span>\n\n<span class=\"c1\"># All the classes for an architecture can be initiated from pretrained weights for this architecture</span>\n<span class=\"c1\"># Note that additional weights added for fine-tuning are only initialized</span>\n<span class=\"c1\"># and need to be trained on the down-stream task</span>\n<span class=\"n\">pretrained_weights</span> <span class=\"o\">=</span> <span class=\"s1\">'bert-base-uncased'</span>\n<span class=\"n\">tokenizer</span> <span class=\"o\">=</span> <span class=\"n\">BertTokenizer</span><span class=\"o\">.</span><span class=\"n\">from_pretrained</span><span class=\"p\">(</span><span class=\"n\">pretrained_weights</span><span class=\"p\">)</span>\n<span class=\"k\">for</span> <span class=\"n\">model_class</span> <span class=\"ow\">in</span> <span class=\"n\">BERT_MODEL_CLASSES</span><span class=\"p\">:</span>\n    <span class=\"c1\"># Load pretrained model/tokenizer</span>\n    <span class=\"n\">model</span> <span class=\"o\">=</span> <span class=\"n\">model_class</span><span class=\"o\">.</span><span class=\"n\">from_pretrained</span><span class=\"p\">(</span><span class=\"n\">pretrained_weights</span><span class=\"p\">)</span>\n\n    <span class=\"c1\"># Models can return full list of hidden-states &amp; attentions weights at each layer</span>\n    <span class=\"n\">model</span> <span class=\"o\">=</span> <span class=\"n\">model_class</span><span class=\"o\">.</span><span class=\"n\">from_pretrained</span><span class=\"p\">(</span><span class=\"n\">pretrained_weights</span><span class=\"p\">,</span>\n                                        <span class=\"n\">output_hidden_states</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">,</span>\n                                        <span class=\"n\">output_attentions</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n    <span class=\"n\">input_ids</span> <span class=\"o\">=</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">tensor</span><span class=\"p\">([</span><span class=\"n\">tokenizer</span><span class=\"o\">.</span><span class=\"n\">encode</span><span class=\"p\">(</span><span class=\"s2\">\"Let's see all hidden-states and attentions on this text\"</span><span class=\"p\">)])</span>\n    <span class=\"n\">all_hidden_states</span><span class=\"p\">,</span> <span class=\"n\">all_attentions</span> <span class=\"o\">=</span> <span class=\"n\">model</span><span class=\"p\">(</span><span class=\"n\">input_ids</span><span class=\"p\">)[</span><span class=\"o\">-</span><span class=\"mi\">2</span><span class=\"p\">:]</span>\n\n    <span class=\"c1\"># Models are compatible with Torchscript</span>\n    <span class=\"n\">model</span> <span class=\"o\">=</span> <span class=\"n\">model_class</span><span class=\"o\">.</span><span class=\"n\">from_pretrained</span><span class=\"p\">(</span><span class=\"n\">pretrained_weights</span><span class=\"p\">,</span> <span class=\"n\">torchscript</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n    <span class=\"n\">traced_model</span> <span class=\"o\">=</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">jit</span><span class=\"o\">.</span><span class=\"n\">trace</span><span class=\"p\">(</span><span class=\"n\">model</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"n\">input_ids</span><span class=\"p\">,))</span>\n\n    <span class=\"c1\"># Simple serialization for models and tokenizers</span>\n    <span class=\"n\">model</span><span class=\"o\">.</span><span class=\"n\">save_pretrained</span><span class=\"p\">(</span><span class=\"s1\">'./directory/to/save/'</span><span class=\"p\">)</span>  <span class=\"c1\"># save</span>\n    <span class=\"n\">model</span> <span class=\"o\">=</span> <span class=\"n\">model_class</span><span class=\"o\">.</span><span class=\"n\">from_pretrained</span><span class=\"p\">(</span><span class=\"s1\">'./directory/to/save/'</span><span class=\"p\">)</span>  <span class=\"c1\"># re-load</span>\n    <span class=\"n\">tokenizer</span><span class=\"o\">.</span><span class=\"n\">save_pretrained</span><span class=\"p\">(</span><span class=\"s1\">'./directory/to/save/'</span><span class=\"p\">)</span>  <span class=\"c1\"># save</span>\n    <span class=\"n\">tokenizer</span> <span class=\"o\">=</span> <span class=\"n\">BertTokenizer</span><span class=\"o\">.</span><span class=\"n\">from_pretrained</span><span class=\"p\">(</span><span class=\"s1\">'./directory/to/save/'</span><span class=\"p\">)</span>  <span class=\"c1\"># re-load</span>\n\n    <span class=\"c1\"># SOTA examples for GLUE, SQUAD, text generation...</span>\n</pre>\n<h2>Quick tour TF 2.0 training and PyTorch interoperability</h2>\n<p>Let's do a quick example of how a TensorFlow 2.0 model can be trained in 12 lines of code with \ud83e\udd17 Transformers and then loaded in PyTorch for fast inspection/tests.</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">tensorflow</span> <span class=\"k\">as</span> <span class=\"nn\">tf</span>\n<span class=\"kn\">import</span> <span class=\"nn\">tensorflow_datasets</span>\n<span class=\"kn\">from</span> <span class=\"nn\">transformers</span> <span class=\"kn\">import</span> <span class=\"o\">*</span>\n\n<span class=\"c1\"># Load dataset, tokenizer, model from pretrained model/vocabulary</span>\n<span class=\"n\">tokenizer</span> <span class=\"o\">=</span> <span class=\"n\">BertTokenizer</span><span class=\"o\">.</span><span class=\"n\">from_pretrained</span><span class=\"p\">(</span><span class=\"s1\">'bert-base-cased'</span><span class=\"p\">)</span>\n<span class=\"n\">model</span> <span class=\"o\">=</span> <span class=\"n\">TFBertForSequenceClassification</span><span class=\"o\">.</span><span class=\"n\">from_pretrained</span><span class=\"p\">(</span><span class=\"s1\">'bert-base-cased'</span><span class=\"p\">)</span>\n<span class=\"n\">data</span> <span class=\"o\">=</span> <span class=\"n\">tensorflow_datasets</span><span class=\"o\">.</span><span class=\"n\">load</span><span class=\"p\">(</span><span class=\"s1\">'glue/mrpc'</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Prepare dataset for GLUE as a tf.data.Dataset instance</span>\n<span class=\"n\">train_dataset</span> <span class=\"o\">=</span> <span class=\"n\">glue_convert_examples_to_features</span><span class=\"p\">(</span><span class=\"n\">data</span><span class=\"p\">[</span><span class=\"s1\">'train'</span><span class=\"p\">],</span> <span class=\"n\">tokenizer</span><span class=\"p\">,</span> <span class=\"n\">max_length</span><span class=\"o\">=</span><span class=\"mi\">128</span><span class=\"p\">,</span> <span class=\"n\">task</span><span class=\"o\">=</span><span class=\"s1\">'mrpc'</span><span class=\"p\">)</span>\n<span class=\"n\">valid_dataset</span> <span class=\"o\">=</span> <span class=\"n\">glue_convert_examples_to_features</span><span class=\"p\">(</span><span class=\"n\">data</span><span class=\"p\">[</span><span class=\"s1\">'validation'</span><span class=\"p\">],</span> <span class=\"n\">tokenizer</span><span class=\"p\">,</span> <span class=\"n\">max_length</span><span class=\"o\">=</span><span class=\"mi\">128</span><span class=\"p\">,</span> <span class=\"n\">task</span><span class=\"o\">=</span><span class=\"s1\">'mrpc'</span><span class=\"p\">)</span>\n<span class=\"n\">train_dataset</span> <span class=\"o\">=</span> <span class=\"n\">train_dataset</span><span class=\"o\">.</span><span class=\"n\">shuffle</span><span class=\"p\">(</span><span class=\"mi\">100</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">batch</span><span class=\"p\">(</span><span class=\"mi\">32</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">repeat</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">)</span>\n<span class=\"n\">valid_dataset</span> <span class=\"o\">=</span> <span class=\"n\">valid_dataset</span><span class=\"o\">.</span><span class=\"n\">batch</span><span class=\"p\">(</span><span class=\"mi\">64</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Prepare training: Compile tf.keras model with optimizer, loss and learning rate schedule</span>\n<span class=\"n\">optimizer</span> <span class=\"o\">=</span> <span class=\"n\">tf</span><span class=\"o\">.</span><span class=\"n\">keras</span><span class=\"o\">.</span><span class=\"n\">optimizers</span><span class=\"o\">.</span><span class=\"n\">Adam</span><span class=\"p\">(</span><span class=\"n\">learning_rate</span><span class=\"o\">=</span><span class=\"mf\">3e-5</span><span class=\"p\">,</span> <span class=\"n\">epsilon</span><span class=\"o\">=</span><span class=\"mf\">1e-08</span><span class=\"p\">,</span> <span class=\"n\">clipnorm</span><span class=\"o\">=</span><span class=\"mf\">1.0</span><span class=\"p\">)</span>\n<span class=\"n\">loss</span> <span class=\"o\">=</span> <span class=\"n\">tf</span><span class=\"o\">.</span><span class=\"n\">keras</span><span class=\"o\">.</span><span class=\"n\">losses</span><span class=\"o\">.</span><span class=\"n\">SparseCategoricalCrossentropy</span><span class=\"p\">(</span><span class=\"n\">from_logits</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n<span class=\"n\">metric</span> <span class=\"o\">=</span> <span class=\"n\">tf</span><span class=\"o\">.</span><span class=\"n\">keras</span><span class=\"o\">.</span><span class=\"n\">metrics</span><span class=\"o\">.</span><span class=\"n\">SparseCategoricalAccuracy</span><span class=\"p\">(</span><span class=\"s1\">'accuracy'</span><span class=\"p\">)</span>\n<span class=\"n\">model</span><span class=\"o\">.</span><span class=\"n\">compile</span><span class=\"p\">(</span><span class=\"n\">optimizer</span><span class=\"o\">=</span><span class=\"n\">optimizer</span><span class=\"p\">,</span> <span class=\"n\">loss</span><span class=\"o\">=</span><span class=\"n\">loss</span><span class=\"p\">,</span> <span class=\"n\">metrics</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"n\">metric</span><span class=\"p\">])</span>\n\n<span class=\"c1\"># Train and evaluate using tf.keras.Model.fit()</span>\n<span class=\"n\">history</span> <span class=\"o\">=</span> <span class=\"n\">model</span><span class=\"o\">.</span><span class=\"n\">fit</span><span class=\"p\">(</span><span class=\"n\">train_dataset</span><span class=\"p\">,</span> <span class=\"n\">epochs</span><span class=\"o\">=</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"n\">steps_per_epoch</span><span class=\"o\">=</span><span class=\"mi\">115</span><span class=\"p\">,</span>\n                    <span class=\"n\">validation_data</span><span class=\"o\">=</span><span class=\"n\">valid_dataset</span><span class=\"p\">,</span> <span class=\"n\">validation_steps</span><span class=\"o\">=</span><span class=\"mi\">7</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Load the TensorFlow model in PyTorch for inspection</span>\n<span class=\"n\">model</span><span class=\"o\">.</span><span class=\"n\">save_pretrained</span><span class=\"p\">(</span><span class=\"s1\">'./save/'</span><span class=\"p\">)</span>\n<span class=\"n\">pytorch_model</span> <span class=\"o\">=</span> <span class=\"n\">BertForSequenceClassification</span><span class=\"o\">.</span><span class=\"n\">from_pretrained</span><span class=\"p\">(</span><span class=\"s1\">'./save/'</span><span class=\"p\">,</span> <span class=\"n\">from_tf</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Quickly test a few predictions - MRPC is a paraphrasing task, let's see if our model learned the task</span>\n<span class=\"n\">sentence_0</span> <span class=\"o\">=</span> <span class=\"s2\">\"This research was consistent with his findings.\"</span>\n<span class=\"n\">sentence_1</span> <span class=\"o\">=</span> <span class=\"s2\">\"His findings were compatible with this research.\"</span>\n<span class=\"n\">sentence_2</span> <span class=\"o\">=</span> <span class=\"s2\">\"His findings were not compatible with this research.\"</span>\n<span class=\"n\">inputs_1</span> <span class=\"o\">=</span> <span class=\"n\">tokenizer</span><span class=\"o\">.</span><span class=\"n\">encode_plus</span><span class=\"p\">(</span><span class=\"n\">sentence_0</span><span class=\"p\">,</span> <span class=\"n\">sentence_1</span><span class=\"p\">,</span> <span class=\"n\">add_special_tokens</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">,</span> <span class=\"n\">return_tensors</span><span class=\"o\">=</span><span class=\"s1\">'pt'</span><span class=\"p\">)</span>\n<span class=\"n\">inputs_2</span> <span class=\"o\">=</span> <span class=\"n\">tokenizer</span><span class=\"o\">.</span><span class=\"n\">encode_plus</span><span class=\"p\">(</span><span class=\"n\">sentence_0</span><span class=\"p\">,</span> <span class=\"n\">sentence_2</span><span class=\"p\">,</span> <span class=\"n\">add_special_tokens</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">,</span> <span class=\"n\">return_tensors</span><span class=\"o\">=</span><span class=\"s1\">'pt'</span><span class=\"p\">)</span>\n\n<span class=\"n\">pred_1</span> <span class=\"o\">=</span> <span class=\"n\">pytorch_model</span><span class=\"p\">(</span><span class=\"n\">inputs_1</span><span class=\"p\">[</span><span class=\"s1\">'input_ids'</span><span class=\"p\">],</span> <span class=\"n\">token_type_ids</span><span class=\"o\">=</span><span class=\"n\">inputs_1</span><span class=\"p\">[</span><span class=\"s1\">'token_type_ids'</span><span class=\"p\">])[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">argmax</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">item</span><span class=\"p\">()</span>\n<span class=\"n\">pred_2</span> <span class=\"o\">=</span> <span class=\"n\">pytorch_model</span><span class=\"p\">(</span><span class=\"n\">inputs_2</span><span class=\"p\">[</span><span class=\"s1\">'input_ids'</span><span class=\"p\">],</span> <span class=\"n\">token_type_ids</span><span class=\"o\">=</span><span class=\"n\">inputs_2</span><span class=\"p\">[</span><span class=\"s1\">'token_type_ids'</span><span class=\"p\">])[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">argmax</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">item</span><span class=\"p\">()</span>\n\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">\"sentence_1 is\"</span><span class=\"p\">,</span> <span class=\"s2\">\"a paraphrase\"</span> <span class=\"k\">if</span> <span class=\"n\">pred_1</span> <span class=\"k\">else</span> <span class=\"s2\">\"not a paraphrase\"</span><span class=\"p\">,</span> <span class=\"s2\">\"of sentence_0\"</span><span class=\"p\">)</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">\"sentence_2 is\"</span><span class=\"p\">,</span> <span class=\"s2\">\"a paraphrase\"</span> <span class=\"k\">if</span> <span class=\"n\">pred_2</span> <span class=\"k\">else</span> <span class=\"s2\">\"not a paraphrase\"</span><span class=\"p\">,</span> <span class=\"s2\">\"of sentence_0\"</span><span class=\"p\">)</span>\n</pre>\n<h2>Quick tour of the fine-tuning/usage scripts</h2>\n<p><strong>Important</strong>\nBefore running the fine-tuning scripts, please read the\n<a href=\"#run-the-examples\" rel=\"nofollow\">instructions</a> on how to\nsetup your environment to run the examples.</p>\n<p>The library comprises several example scripts with SOTA performances for NLU and NLG tasks:</p>\n<ul>\n<li><code>run_glue.py</code>: an example fine-tuning Bert, XLNet and XLM on nine different GLUE tasks (<em>sequence-level classification</em>)</li>\n<li><code>run_squad.py</code>: an example fine-tuning Bert, XLNet and XLM on the question answering dataset SQuAD 2.0 (<em>token-level classification</em>)</li>\n<li><code>run_generation.py</code>: an example using GPT, GPT-2, CTRL, Transformer-XL and XLNet for conditional language generation</li>\n<li>other model-specific examples (see the documentation).</li>\n</ul>\n<p>Here are three quick usage examples for these scripts:</p>\n<h3><code>run_glue.py</code>: Fine-tuning on GLUE tasks for sequence classification</h3>\n<p>The <a href=\"https://gluebenchmark.com/\" rel=\"nofollow\">General Language Understanding Evaluation (GLUE) benchmark</a> is a collection of nine sentence- or sentence-pair language understanding tasks for evaluating and analyzing natural language understanding systems.</p>\n<p>Before running anyone of these GLUE tasks you should download the\n<a href=\"https://gluebenchmark.com/tasks\" rel=\"nofollow\">GLUE data</a> by running\n<a href=\"https://gist.github.com/W4ngatang/60c2bdb54d156a41194446737ce03e2e\" rel=\"nofollow\">this script</a>\nand unpack it to some directory <code>$GLUE_DIR</code>.</p>\n<p>You should also install the additional packages required by the examples:</p>\n<pre>pip install -r ./examples/requirements.txt\n</pre>\n<pre><span class=\"nb\">export</span> <span class=\"nv\">GLUE_DIR</span><span class=\"o\">=</span>/path/to/glue\n<span class=\"nb\">export</span> <span class=\"nv\">TASK_NAME</span><span class=\"o\">=</span>MRPC\n\npython ./examples/run_glue.py <span class=\"se\">\\</span>\n    --model_type bert <span class=\"se\">\\</span>\n    --model_name_or_path bert-base-uncased <span class=\"se\">\\</span>\n    --task_name <span class=\"nv\">$TASK_NAME</span> <span class=\"se\">\\</span>\n    --do_train <span class=\"se\">\\</span>\n    --do_eval <span class=\"se\">\\</span>\n    --do_lower_case <span class=\"se\">\\</span>\n    --data_dir <span class=\"nv\">$GLUE_DIR</span>/<span class=\"nv\">$TASK_NAME</span> <span class=\"se\">\\</span>\n    --max_seq_length <span class=\"m\">128</span> <span class=\"se\">\\</span>\n    --per_gpu_eval_batch_size<span class=\"o\">=</span><span class=\"m\">8</span>   <span class=\"se\">\\</span>\n    --per_gpu_train_batch_size<span class=\"o\">=</span><span class=\"m\">8</span>   <span class=\"se\">\\</span>\n    --learning_rate 2e-5 <span class=\"se\">\\</span>\n    --num_train_epochs <span class=\"m\">3</span>.0 <span class=\"se\">\\</span>\n    --output_dir /tmp/<span class=\"nv\">$TASK_NAME</span>/\n</pre>\n<p>where task name can be one of CoLA, SST-2, MRPC, STS-B, QQP, MNLI, QNLI, RTE, WNLI.</p>\n<p>The dev set results will be present within the text file 'eval_results.txt' in the specified output_dir. In case of MNLI, since there are two separate dev sets, matched and mismatched, there will be a separate output folder called '/tmp/MNLI-MM/' in addition to '/tmp/MNLI/'.</p>\n<h4>Fine-tuning XLNet model on the STS-B regression task</h4>\n<p>This example code fine-tunes XLNet on the STS-B corpus using parallel training on a server with 4 V100 GPUs.\nParallel training is a simple way to use several GPUs (but is slower and less flexible than distributed training, see below).</p>\n<pre><span class=\"nb\">export</span> <span class=\"nv\">GLUE_DIR</span><span class=\"o\">=</span>/path/to/glue\n\npython ./examples/run_glue.py <span class=\"se\">\\</span>\n    --model_type xlnet <span class=\"se\">\\</span>\n    --model_name_or_path xlnet-large-cased <span class=\"se\">\\</span>\n    --do_train  <span class=\"se\">\\</span>\n    --do_eval   <span class=\"se\">\\</span>\n    --task_name<span class=\"o\">=</span>sts-b     <span class=\"se\">\\</span>\n    --data_dir<span class=\"o\">=</span><span class=\"si\">${</span><span class=\"nv\">GLUE_DIR</span><span class=\"si\">}</span>/STS-B  <span class=\"se\">\\</span>\n    --output_dir<span class=\"o\">=</span>./proc_data/sts-b-110   <span class=\"se\">\\</span>\n    --max_seq_length<span class=\"o\">=</span><span class=\"m\">128</span>   <span class=\"se\">\\</span>\n    --per_gpu_eval_batch_size<span class=\"o\">=</span><span class=\"m\">8</span>   <span class=\"se\">\\</span>\n    --per_gpu_train_batch_size<span class=\"o\">=</span><span class=\"m\">8</span>   <span class=\"se\">\\</span>\n    --gradient_accumulation_steps<span class=\"o\">=</span><span class=\"m\">1</span> <span class=\"se\">\\</span>\n    --max_steps<span class=\"o\">=</span><span class=\"m\">1200</span>  <span class=\"se\">\\</span>\n    --model_name<span class=\"o\">=</span>xlnet-large-cased   <span class=\"se\">\\</span>\n    --overwrite_output_dir   <span class=\"se\">\\</span>\n    --overwrite_cache <span class=\"se\">\\</span>\n    --warmup_steps<span class=\"o\">=</span><span class=\"m\">120</span>\n</pre>\n<p>On this machine we thus have a batch size of 32, please increase <code>gradient_accumulation_steps</code> to reach the same batch size if you have a smaller machine. These hyper-parameters should result in a Pearson correlation coefficient of <code>+0.917</code> on the development set.</p>\n<h4>Fine-tuning Bert model on the MRPC classification task</h4>\n<p>This example code fine-tunes the Bert Whole Word Masking model on the Microsoft Research Paraphrase Corpus (MRPC) corpus using distributed training on 8 V100 GPUs to reach a F1 &gt; 92.</p>\n<pre>python -m torch.distributed.launch --nproc_per_node <span class=\"m\">8</span> ./examples/run_glue.py   <span class=\"se\">\\</span>\n    --model_type bert <span class=\"se\">\\</span>\n    --model_name_or_path bert-large-uncased-whole-word-masking <span class=\"se\">\\</span>\n    --task_name MRPC <span class=\"se\">\\</span>\n    --do_train   <span class=\"se\">\\</span>\n    --do_eval   <span class=\"se\">\\</span>\n    --do_lower_case   <span class=\"se\">\\</span>\n    --data_dir <span class=\"nv\">$GLUE_DIR</span>/MRPC/   <span class=\"se\">\\</span>\n    --max_seq_length <span class=\"m\">128</span>   <span class=\"se\">\\</span>\n    --per_gpu_eval_batch_size<span class=\"o\">=</span><span class=\"m\">8</span>   <span class=\"se\">\\</span>\n    --per_gpu_train_batch_size<span class=\"o\">=</span><span class=\"m\">8</span>   <span class=\"se\">\\</span>\n    --learning_rate 2e-5   <span class=\"se\">\\</span>\n    --num_train_epochs <span class=\"m\">3</span>.0  <span class=\"se\">\\</span>\n    --output_dir /tmp/mrpc_output/ <span class=\"se\">\\</span>\n    --overwrite_output_dir   <span class=\"se\">\\</span>\n    --overwrite_cache <span class=\"se\">\\</span>\n</pre>\n<p>Training with these hyper-parameters gave us the following results:</p>\n<pre>  <span class=\"nv\">acc</span> <span class=\"o\">=</span> <span class=\"m\">0</span>.8823529411764706\n  <span class=\"nv\">acc_and_f1</span> <span class=\"o\">=</span> <span class=\"m\">0</span>.901702786377709\n  <span class=\"nv\">eval_loss</span> <span class=\"o\">=</span> <span class=\"m\">0</span>.3418912578906332\n  <span class=\"nv\">f1</span> <span class=\"o\">=</span> <span class=\"m\">0</span>.9210526315789473\n  <span class=\"nv\">global_step</span> <span class=\"o\">=</span> <span class=\"m\">174</span>\n  <span class=\"nv\">loss</span> <span class=\"o\">=</span> <span class=\"m\">0</span>.07231863956341798\n</pre>\n<h3><code>run_squad.py</code>: Fine-tuning on SQuAD for question-answering</h3>\n<p>This example code fine-tunes BERT on the SQuAD dataset using distributed training on 8 V100 GPUs and Bert Whole Word Masking uncased model to reach a F1 &gt; 93 on SQuAD:</p>\n<pre>python -m torch.distributed.launch --nproc_per_node<span class=\"o\">=</span><span class=\"m\">8</span> ./examples/run_squad.py <span class=\"se\">\\</span>\n    --model_type bert <span class=\"se\">\\</span>\n    --model_name_or_path bert-large-uncased-whole-word-masking <span class=\"se\">\\</span>\n    --do_train <span class=\"se\">\\</span>\n    --do_eval <span class=\"se\">\\</span>\n    --do_lower_case <span class=\"se\">\\</span>\n    --train_file <span class=\"nv\">$SQUAD_DIR</span>/train-v1.1.json <span class=\"se\">\\</span>\n    --predict_file <span class=\"nv\">$SQUAD_DIR</span>/dev-v1.1.json <span class=\"se\">\\</span>\n    --learning_rate 3e-5 <span class=\"se\">\\</span>\n    --num_train_epochs <span class=\"m\">2</span> <span class=\"se\">\\</span>\n    --max_seq_length <span class=\"m\">384</span> <span class=\"se\">\\</span>\n    --doc_stride <span class=\"m\">128</span> <span class=\"se\">\\</span>\n    --output_dir ../models/wwm_uncased_finetuned_squad/ <span class=\"se\">\\</span>\n    --per_gpu_eval_batch_size<span class=\"o\">=</span><span class=\"m\">3</span>   <span class=\"se\">\\</span>\n    --per_gpu_train_batch_size<span class=\"o\">=</span><span class=\"m\">3</span>   <span class=\"se\">\\</span>\n</pre>\n<p>Training with these hyper-parameters gave us the following results:</p>\n<pre>python <span class=\"nv\">$SQUAD_DIR</span>/evaluate-v1.1.py <span class=\"nv\">$SQUAD_DIR</span>/dev-v1.1.json ../models/wwm_uncased_finetuned_squad/predictions.json\n<span class=\"o\">{</span><span class=\"s2\">\"exact_match\"</span>: <span class=\"m\">86</span>.91579943235573, <span class=\"s2\">\"f1\"</span>: <span class=\"m\">93</span>.1532499015869<span class=\"o\">}</span>\n</pre>\n<p>This is the model provided as <code>bert-large-uncased-whole-word-masking-finetuned-squad</code>.</p>\n<h3><code>run_generation.py</code>: Text generation with GPT, GPT-2, CTRL, Transformer-XL and XLNet</h3>\n<p>A conditional generation script is also included to generate text from a prompt.\nThe generation script includes the <a href=\"https://github.com/rusiaaman/XLNet-gen#methodology\" rel=\"nofollow\">tricks</a> proposed by Aman Rusia to get high-quality generation with memory models like Transformer-XL and XLNet (include a predefined text to make short inputs longer).</p>\n<p>Here is how to run the script with the small version of OpenAI GPT-2 model:</p>\n<pre>python ./examples/run_generation.py <span class=\"se\">\\</span>\n    --model_type<span class=\"o\">=</span>gpt2 <span class=\"se\">\\</span>\n    --length<span class=\"o\">=</span><span class=\"m\">20</span> <span class=\"se\">\\</span>\n    --model_name_or_path<span class=\"o\">=</span>gpt2 <span class=\"se\">\\</span>\n</pre>\n<p>and from the Salesforce CTRL model:</p>\n<pre>python ./examples/run_generation.py <span class=\"se\">\\</span>\n    --model_type<span class=\"o\">=</span>ctrl <span class=\"se\">\\</span>\n    --length<span class=\"o\">=</span><span class=\"m\">20</span> <span class=\"se\">\\</span>\n    --model_name_or_path<span class=\"o\">=</span>ctrl <span class=\"se\">\\</span>\n    --temperature<span class=\"o\">=</span><span class=\"m\">0</span> <span class=\"se\">\\</span>\n    --repetition_penalty<span class=\"o\">=</span><span class=\"m\">1</span>.2 <span class=\"se\">\\</span>\n</pre>\n<h2>Quick tour of model sharing</h2>\n<p>New in <code>v2.2.2</code>: you can now upload and share your fine-tuned models with the community, using the <abbr title=\"Command-line interface\">CLI</abbr> that's built-in to the library.</p>\n<p><strong>First, create an account on <a href=\"https://huggingface.co/join\" rel=\"nofollow\">https://huggingface.co/join</a></strong>. Then:</p>\n<pre>transformers-cli login\n<span class=\"c1\"># log in using the same credentials as on huggingface.co</span>\n</pre>\n<p>Upload your model:</p>\n<pre>transformers-cli upload ./path/to/pretrained_model/\n\n<span class=\"c1\"># ^^ Upload folder containing weights/tokenizer/config</span>\n<span class=\"c1\"># saved via `.save_pretrained()`</span>\n\ntransformers-cli upload ./config.json <span class=\"o\">[</span>--filename folder/foobar.json<span class=\"o\">]</span>\n\n<span class=\"c1\"># ^^ Upload a single file</span>\n<span class=\"c1\"># (you can optionally override its filename, which can be nested inside a folder)</span>\n</pre>\n<p>Your model will then be accessible through its identifier, a concatenation of your username and the folder name above:</p>\n<pre><span class=\"s2\">\"username/model_name\"</span>\n</pre>\n<p>Anyone can load it from code:</p>\n<pre><span class=\"n\">tokenizer</span> <span class=\"o\">=</span> <span class=\"n\">AutoTokenizer</span><span class=\"o\">.</span><span class=\"n\">from_pretrained</span><span class=\"p\">(</span><span class=\"s2\">\"username/pretrained_model\"</span><span class=\"p\">)</span>\n<span class=\"n\">model</span> <span class=\"o\">=</span> <span class=\"n\">AutoModel</span><span class=\"o\">.</span><span class=\"n\">from_pretrained</span><span class=\"p\">(</span><span class=\"s2\">\"username/pretrained_model\"</span><span class=\"p\">)</span>\n</pre>\n<p>Finally, list all your files on S3:</p>\n<pre>transformers-cli s3 ls\n<span class=\"c1\"># List all your S3 objects.</span>\n</pre>\n<h2>Quick tour of pipelines</h2>\n<p>New in version <code>v2.3</code>: <code>Pipeline</code> are high-level objects which automatically handle tokenization, running your data through a transformers model\nand outputting the result in a structured object.</p>\n<p>You can create <code>Pipeline</code> objects for the following down-stream tasks:</p>\n<ul>\n<li><code>feature-extraction</code>: Generates a tensor representation for the input sequence</li>\n<li><code>ner</code>: Generates named entity mapping for each word in the input sequence.</li>\n<li><code>sentiment-analysis</code>: Gives the polarity (positive / negative) of the whole input sequence.</li>\n<li><code>question-answering</code>: Provided some context and a question refering to the context, it will extract the answer to the question\nin the context.</li>\n</ul>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">transformers</span> <span class=\"kn\">import</span> <span class=\"n\">pipeline</span>\n\n<span class=\"c1\"># Allocate a pipeline for sentiment-analysis</span>\n<span class=\"n\">nlp</span> <span class=\"o\">=</span> <span class=\"n\">pipeline</span><span class=\"p\">(</span><span class=\"s1\">'sentiment-analysis'</span><span class=\"p\">)</span>\n<span class=\"n\">nlp</span><span class=\"p\">(</span><span class=\"s1\">'We are very happy to include pipeline into the transformers repository.'</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"p\">{</span><span class=\"s1\">'label'</span><span class=\"p\">:</span> <span class=\"s1\">'POSITIVE'</span><span class=\"p\">,</span> <span class=\"s1\">'score'</span><span class=\"p\">:</span> <span class=\"mf\">0.99893874</span><span class=\"p\">}</span>\n\n<span class=\"c1\"># Allocate a pipeline for question-answering</span>\n<span class=\"n\">nlp</span> <span class=\"o\">=</span> <span class=\"n\">pipeline</span><span class=\"p\">(</span><span class=\"s1\">'question-answering'</span><span class=\"p\">)</span>\n<span class=\"n\">nlp</span><span class=\"p\">({</span>\n    <span class=\"s1\">'question'</span><span class=\"p\">:</span> <span class=\"s1\">'What is the name of the repository ?'</span><span class=\"p\">,</span>\n    <span class=\"s1\">'context'</span><span class=\"p\">:</span> <span class=\"s1\">'Pipeline have been included in the huggingface/transformers repository'</span>\n<span class=\"p\">})</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"p\">{</span><span class=\"s1\">'score'</span><span class=\"p\">:</span> <span class=\"mf\">0.28756016668193496</span><span class=\"p\">,</span> <span class=\"s1\">'start'</span><span class=\"p\">:</span> <span class=\"mi\">35</span><span class=\"p\">,</span> <span class=\"s1\">'end'</span><span class=\"p\">:</span> <span class=\"mi\">59</span><span class=\"p\">,</span> <span class=\"s1\">'answer'</span><span class=\"p\">:</span> <span class=\"s1\">'huggingface/transformers'</span><span class=\"p\">}</span>\n</pre>\n<h2>Migrating from pytorch-transformers to transformers</h2>\n<p>Here is a quick summary of what you should take care of when migrating from <code>pytorch-transformers</code> to <code>transformers</code>.</p>\n<h3>Positional order of some models' keywords inputs (<code>attention_mask</code>, <code>token_type_ids</code>...) changed</h3>\n<p>To be able to use Torchscript (see #1010, #1204 and #1195) the specific order of some models <strong>keywords inputs</strong> (<code>attention_mask</code>, <code>token_type_ids</code>...) has been changed.</p>\n<p>If you used to call the models with keyword names for keyword arguments, e.g. <code>model(inputs_ids, attention_mask=attention_mask, token_type_ids=token_type_ids)</code>, this should not cause any change.</p>\n<p>If you used to call the models with positional inputs for keyword arguments, e.g. <code>model(inputs_ids, attention_mask, token_type_ids)</code>, you may have to double check the exact order of input arguments.</p>\n<h2>Migrating from pytorch-pretrained-bert to transformers</h2>\n<p>Here is a quick summary of what you should take care of when migrating from <code>pytorch-pretrained-bert</code> to <code>transformers</code>.</p>\n<h3>Models always output <code>tuples</code></h3>\n<p>The main breaking change when migrating from <code>pytorch-pretrained-bert</code> to <code>transformers</code> is that every model's forward method always outputs a <code>tuple</code> with various elements depending on the model and the configuration parameters.</p>\n<p>The exact content of the tuples for each model is detailed in the models' docstrings and the <a href=\"https://huggingface.co/transformers/\" rel=\"nofollow\">documentation</a>.</p>\n<p>In pretty much every case, you will be fine by taking the first element of the output as the output you previously used in <code>pytorch-pretrained-bert</code>.</p>\n<p>Here is a <code>pytorch-pretrained-bert</code> to <code>transformers</code> conversion example for a <code>BertForSequenceClassification</code> classification model:</p>\n<pre><span class=\"c1\"># Let's load our model</span>\n<span class=\"n\">model</span> <span class=\"o\">=</span> <span class=\"n\">BertForSequenceClassification</span><span class=\"o\">.</span><span class=\"n\">from_pretrained</span><span class=\"p\">(</span><span class=\"s1\">'bert-base-uncased'</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># If you used to have this line in pytorch-pretrained-bert:</span>\n<span class=\"n\">loss</span> <span class=\"o\">=</span> <span class=\"n\">model</span><span class=\"p\">(</span><span class=\"n\">input_ids</span><span class=\"p\">,</span> <span class=\"n\">labels</span><span class=\"o\">=</span><span class=\"n\">labels</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Now just use this line in transformers to extract the loss from the output tuple:</span>\n<span class=\"n\">outputs</span> <span class=\"o\">=</span> <span class=\"n\">model</span><span class=\"p\">(</span><span class=\"n\">input_ids</span><span class=\"p\">,</span> <span class=\"n\">labels</span><span class=\"o\">=</span><span class=\"n\">labels</span><span class=\"p\">)</span>\n<span class=\"n\">loss</span> <span class=\"o\">=</span> <span class=\"n\">outputs</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span>\n\n<span class=\"c1\"># In transformers you can also have access to the logits:</span>\n<span class=\"n\">loss</span><span class=\"p\">,</span> <span class=\"n\">logits</span> <span class=\"o\">=</span> <span class=\"n\">outputs</span><span class=\"p\">[:</span><span class=\"mi\">2</span><span class=\"p\">]</span>\n\n<span class=\"c1\"># And even the attention weights if you configure the model to output them (and other outputs too, see the docstrings and documentation)</span>\n<span class=\"n\">model</span> <span class=\"o\">=</span> <span class=\"n\">BertForSequenceClassification</span><span class=\"o\">.</span><span class=\"n\">from_pretrained</span><span class=\"p\">(</span><span class=\"s1\">'bert-base-uncased'</span><span class=\"p\">,</span> <span class=\"n\">output_attentions</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n<span class=\"n\">outputs</span> <span class=\"o\">=</span> <span class=\"n\">model</span><span class=\"p\">(</span><span class=\"n\">input_ids</span><span class=\"p\">,</span> <span class=\"n\">labels</span><span class=\"o\">=</span><span class=\"n\">labels</span><span class=\"p\">)</span>\n<span class=\"n\">loss</span><span class=\"p\">,</span> <span class=\"n\">logits</span><span class=\"p\">,</span> <span class=\"n\">attentions</span> <span class=\"o\">=</span> <span class=\"n\">outputs</span>\n</pre>\n<h3>Using hidden states</h3>\n<p>By enabling the configuration option <code>output_hidden_states</code>, it was possible to retrieve the last hidden states of the encoder. In <code>pytorch-transformers</code> as well as <code>transformers</code> the return value has changed slightly: <code>all_hidden_states</code> now also includes the hidden state of the embeddings in addition to those of the encoding layers. This allows users to easily access the embeddings final state.</p>\n<h3>Serialization</h3>\n<p>Breaking change in the <code>from_pretrained()</code> method:</p>\n<ol>\n<li>\n<p>Models are now set in evaluation mode by default when instantiated with the <code>from_pretrained()</code> method. To train them, don't forget to set them back in training mode (<code>model.train()</code>) to activate the dropout modules.</p>\n</li>\n<li>\n<p>The additional <code>*input</code> and <code>**kwargs</code> arguments supplied to the <code>from_pretrained()</code> method used to be directly passed to the underlying model's class <code>__init__()</code> method. They are now used to update the model configuration attribute instead, which can break derived model classes built based on the previous <code>BertForSequenceClassification</code> examples. We are working on a way to mitigate this breaking change in <a href=\"https://github.com/huggingface/transformers/pull/866\" rel=\"nofollow\">#866</a> by forwarding the the model's <code>__init__()</code> method (i) the provided positional arguments and (ii) the keyword arguments which do not match any configuration class attributes.</p>\n</li>\n</ol>\n<p>Also, while not a breaking change, the serialization methods have been standardized and you probably should switch to the new method <code>save_pretrained(save_directory)</code> if you were using any other serialization method before.</p>\n<p>Here is an example:</p>\n<pre><span class=\"c1\">### Let's load a model and tokenizer</span>\n<span class=\"n\">model</span> <span class=\"o\">=</span> <span class=\"n\">BertForSequenceClassification</span><span class=\"o\">.</span><span class=\"n\">from_pretrained</span><span class=\"p\">(</span><span class=\"s1\">'bert-base-uncased'</span><span class=\"p\">)</span>\n<span class=\"n\">tokenizer</span> <span class=\"o\">=</span> <span class=\"n\">BertTokenizer</span><span class=\"o\">.</span><span class=\"n\">from_pretrained</span><span class=\"p\">(</span><span class=\"s1\">'bert-base-uncased'</span><span class=\"p\">)</span>\n\n<span class=\"c1\">### Do some stuff to our model and tokenizer</span>\n<span class=\"c1\"># Ex: add new tokens to the vocabulary and embeddings of our model</span>\n<span class=\"n\">tokenizer</span><span class=\"o\">.</span><span class=\"n\">add_tokens</span><span class=\"p\">([</span><span class=\"s1\">'[SPECIAL_TOKEN_1]'</span><span class=\"p\">,</span> <span class=\"s1\">'[SPECIAL_TOKEN_2]'</span><span class=\"p\">])</span>\n<span class=\"n\">model</span><span class=\"o\">.</span><span class=\"n\">resize_token_embeddings</span><span class=\"p\">(</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">tokenizer</span><span class=\"p\">))</span>\n<span class=\"c1\"># Train our model</span>\n<span class=\"n\">train</span><span class=\"p\">(</span><span class=\"n\">model</span><span class=\"p\">)</span>\n\n<span class=\"c1\">### Now let's save our model and tokenizer to a directory</span>\n<span class=\"n\">model</span><span class=\"o\">.</span><span class=\"n\">save_pretrained</span><span class=\"p\">(</span><span class=\"s1\">'./my_saved_model_directory/'</span><span class=\"p\">)</span>\n<span class=\"n\">tokenizer</span><span class=\"o\">.</span><span class=\"n\">save_pretrained</span><span class=\"p\">(</span><span class=\"s1\">'./my_saved_model_directory/'</span><span class=\"p\">)</span>\n\n<span class=\"c1\">### Reload the model and the tokenizer</span>\n<span class=\"n\">model</span> <span class=\"o\">=</span> <span class=\"n\">BertForSequenceClassification</span><span class=\"o\">.</span><span class=\"n\">from_pretrained</span><span class=\"p\">(</span><span class=\"s1\">'./my_saved_model_directory/'</span><span class=\"p\">)</span>\n<span class=\"n\">tokenizer</span> <span class=\"o\">=</span> <span class=\"n\">BertTokenizer</span><span class=\"o\">.</span><span class=\"n\">from_pretrained</span><span class=\"p\">(</span><span class=\"s1\">'./my_saved_model_directory/'</span><span class=\"p\">)</span>\n</pre>\n<h3>Optimizers: BertAdam &amp; OpenAIAdam are now AdamW, schedules are standard PyTorch schedules</h3>\n<p>The two optimizers previously included, <code>BertAdam</code> and <code>OpenAIAdam</code>, have been replaced by a single <code>AdamW</code> optimizer which has a few differences:</p>\n<ul>\n<li>it only implements weights decay correction,</li>\n<li>schedules are now externals (see below),</li>\n<li>gradient clipping is now also external (see below).</li>\n</ul>\n<p>The new optimizer <code>AdamW</code> matches PyTorch <code>Adam</code> optimizer API and let you use standard PyTorch or apex methods for the schedule and clipping.</p>\n<p>The schedules are now standard <a href=\"https://pytorch.org/docs/stable/optim.html#how-to-adjust-learning-rate\" rel=\"nofollow\">PyTorch learning rate schedulers</a> and not part of the optimizer anymore.</p>\n<p>Here is a conversion examples from <code>BertAdam</code> with a linear warmup and decay schedule to <code>AdamW</code> and the same schedule:</p>\n<pre><span class=\"c1\"># Parameters:</span>\n<span class=\"n\">lr</span> <span class=\"o\">=</span> <span class=\"mf\">1e-3</span>\n<span class=\"n\">max_grad_norm</span> <span class=\"o\">=</span> <span class=\"mf\">1.0</span>\n<span class=\"n\">num_training_steps</span> <span class=\"o\">=</span> <span class=\"mi\">1000</span>\n<span class=\"n\">num_warmup_steps</span> <span class=\"o\">=</span> <span class=\"mi\">100</span>\n<span class=\"n\">warmup_proportion</span> <span class=\"o\">=</span> <span class=\"nb\">float</span><span class=\"p\">(</span><span class=\"n\">num_warmup_steps</span><span class=\"p\">)</span> <span class=\"o\">/</span> <span class=\"nb\">float</span><span class=\"p\">(</span><span class=\"n\">num_training_steps</span><span class=\"p\">)</span>  <span class=\"c1\"># 0.1</span>\n\n<span class=\"c1\">### Previously BertAdam optimizer was instantiated like this:</span>\n<span class=\"n\">optimizer</span> <span class=\"o\">=</span> <span class=\"n\">BertAdam</span><span class=\"p\">(</span><span class=\"n\">model</span><span class=\"o\">.</span><span class=\"n\">parameters</span><span class=\"p\">(),</span> <span class=\"n\">lr</span><span class=\"o\">=</span><span class=\"n\">lr</span><span class=\"p\">,</span> <span class=\"n\">schedule</span><span class=\"o\">=</span><span class=\"s1\">'warmup_linear'</span><span class=\"p\">,</span> <span class=\"n\">warmup</span><span class=\"o\">=</span><span class=\"n\">warmup_proportion</span><span class=\"p\">,</span> <span class=\"n\">t_total</span><span class=\"o\">=</span><span class=\"n\">num_training_steps</span><span class=\"p\">)</span>\n<span class=\"c1\">### and used like this:</span>\n<span class=\"k\">for</span> <span class=\"n\">batch</span> <span class=\"ow\">in</span> <span class=\"n\">train_data</span><span class=\"p\">:</span>\n    <span class=\"n\">loss</span> <span class=\"o\">=</span> <span class=\"n\">model</span><span class=\"p\">(</span><span class=\"n\">batch</span><span class=\"p\">)</span>\n    <span class=\"n\">loss</span><span class=\"o\">.</span><span class=\"n\">backward</span><span class=\"p\">()</span>\n    <span class=\"n\">optimizer</span><span class=\"o\">.</span><span class=\"n\">step</span><span class=\"p\">()</span>\n\n<span class=\"c1\">### In Transformers, optimizer and schedules are splitted and instantiated like this:</span>\n<span class=\"n\">optimizer</span> <span class=\"o\">=</span> <span class=\"n\">AdamW</span><span class=\"p\">(</span><span class=\"n\">model</span><span class=\"o\">.</span><span class=\"n\">parameters</span><span class=\"p\">(),</span> <span class=\"n\">lr</span><span class=\"o\">=</span><span class=\"n\">lr</span><span class=\"p\">,</span> <span class=\"n\">correct_bias</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">)</span>  <span class=\"c1\"># To reproduce BertAdam specific behavior set correct_bias=False</span>\n<span class=\"n\">scheduler</span> <span class=\"o\">=</span> <span class=\"n\">get_linear_schedule_with_warmup</span><span class=\"p\">(</span><span class=\"n\">optimizer</span><span class=\"p\">,</span> <span class=\"n\">num_warmup_steps</span><span class=\"o\">=</span><span class=\"n\">num_warmup_steps</span><span class=\"p\">,</span> <span class=\"n\">num_training_steps</span><span class=\"o\">=</span><span class=\"n\">num_training_steps</span><span class=\"p\">)</span>  <span class=\"c1\"># PyTorch scheduler</span>\n<span class=\"c1\">### and used like this:</span>\n<span class=\"k\">for</span> <span class=\"n\">batch</span> <span class=\"ow\">in</span> <span class=\"n\">train_data</span><span class=\"p\">:</span>\n    <span class=\"n\">model</span><span class=\"o\">.</span><span class=\"n\">train</span><span class=\"p\">()</span>\n    <span class=\"n\">loss</span> <span class=\"o\">=</span> <span class=\"n\">model</span><span class=\"p\">(</span><span class=\"n\">batch</span><span class=\"p\">)</span>\n    <span class=\"n\">loss</span><span class=\"o\">.</span><span class=\"n\">backward</span><span class=\"p\">()</span>\n    <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">nn</span><span class=\"o\">.</span><span class=\"n\">utils</span><span class=\"o\">.</span><span class=\"n\">clip_grad_norm_</span><span class=\"p\">(</span><span class=\"n\">model</span><span class=\"o\">.</span><span class=\"n\">parameters</span><span class=\"p\">(),</span> <span class=\"n\">max_grad_norm</span><span class=\"p\">)</span>  <span class=\"c1\"># Gradient clipping is not in AdamW anymore (so you can use amp without issue)</span>\n    <span class=\"n\">optimizer</span><span class=\"o\">.</span><span class=\"n\">step</span><span class=\"p\">()</span>\n    <span class=\"n\">scheduler</span><span class=\"o\">.</span><span class=\"n\">step</span><span class=\"p\">()</span>\n    <span class=\"n\">optimizer</span><span class=\"o\">.</span><span class=\"n\">zero_grad</span><span class=\"p\">()</span>\n</pre>\n<h2>Citation</h2>\n<p>We now have a paper you can cite for the \ud83e\udd17 Transformers library:</p>\n<pre><code>@article{Wolf2019HuggingFacesTS,\n  title={HuggingFace's Transformers: State-of-the-art Natural Language Processing},\n  author={Thomas Wolf and Lysandre Debut and Victor Sanh and Julien Chaumond and Clement Delangue and Anthony Moi and Pierric Cistac and Tim Rault and R'emi Louf and Morgan Funtowicz and Jamie Brew},\n  journal={ArXiv},\n  year={2019},\n  volume={abs/1910.03771}\n}\n</code></pre>\n\n          </div>"}, "last_serial": 6428624, "releases": {"2.3.0": [{"comment_text": "", "digests": {"md5": "2ca42807b9452819f5c524b5bac9f92c", "sha256": "52d6024c32049d20b35f5f0464fb1f05753c1b6e37effd67890b3982e358962f"}, "downloads": -1, "filename": "richads_transformers-2.3.0-py3-none-any.whl", "has_sig": false, "md5_digest": "2ca42807b9452819f5c524b5bac9f92c", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.5.0", "size": 458589, "upload_time": "2020-01-10T09:51:45", "upload_time_iso_8601": "2020-01-10T09:51:45.198557Z", "url": "https://files.pythonhosted.org/packages/6d/a6/a68dd05bcd3ef591aff9cee1035120d4fd4be7e13c1e1c433947e6b2219e/richads_transformers-2.3.0-py3-none-any.whl", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "2ca42807b9452819f5c524b5bac9f92c", "sha256": "52d6024c32049d20b35f5f0464fb1f05753c1b6e37effd67890b3982e358962f"}, "downloads": -1, "filename": "richads_transformers-2.3.0-py3-none-any.whl", "has_sig": false, "md5_digest": "2ca42807b9452819f5c524b5bac9f92c", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.5.0", "size": 458589, "upload_time": "2020-01-10T09:51:45", "upload_time_iso_8601": "2020-01-10T09:51:45.198557Z", "url": "https://files.pythonhosted.org/packages/6d/a6/a68dd05bcd3ef591aff9cee1035120d4fd4be7e13c1e1c433947e6b2219e/richads_transformers-2.3.0-py3-none-any.whl", "yanked": false}], "timestamp": "Fri May  8 03:02:47 2020"}