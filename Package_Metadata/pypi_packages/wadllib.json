{"info": {"author": "", "author_email": "", "bugtrack_url": null, "classifiers": ["Development Status :: 5 - Production/Stable", "Intended Audience :: Developers", "License :: OSI Approved :: GNU Library or Lesser General Public License (LGPL)", "Operating System :: OS Independent", "Programming Language :: Python", "Programming Language :: Python :: 2", "Programming Language :: Python :: 2.7", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.2", "Programming Language :: Python :: 3.3", "Programming Language :: Python :: 3.4", "Programming Language :: Python :: 3.5", "Programming Language :: Python :: 3.6", "Programming Language :: Python :: 3.7", "Programming Language :: Python :: 3.8"], "description": "..\n   Copyright (C) 2008-2013 Canonical Ltd.\n\n   This file is part of wadllib.\n\n   wadllib is free software: you can redistribute it and/or modify it under\n   the terms of the GNU Lesser General Public License as published by the\n   Free Software Foundation, version 3 of the License.\n\n   wadllib is distributed in the hope that it will be useful, but WITHOUT ANY\n   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n   FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for\n   more details.\n\n   You should have received a copy of the GNU Lesser General Public License\n   along with wadllib. If not, see <http://www.gnu.org/licenses/>.\n\n=======\nwadllib\n=======\n\nAn Application object represents a web service described by a WADL\nfile.\n\n   >>> import os\n   >>> import sys\n   >>> import pkg_resources\n   >>> from wadllib.application import Application\n\nThe first argument to the Application constructor is the URL at which\nthe WADL file was found. The second argument may be raw WADL markup.\n\n   >>> wadl_string = pkg_resources.resource_string(\n   ...     'wadllib.tests.data', 'launchpad-wadl.xml')\n   >>> wadl = Application(\"http://api.launchpad.dev/beta/\", wadl_string)\n\nOr the second argument may be an open filehandle containing the markup.\n\n   >>> cleanups = []\n   >>> def application_for(filename, url=\"http://www.example.com/\"):\n   ...    wadl_stream = pkg_resources.resource_stream(\n   ...    'wadllib.tests.data', filename)\n   ...    cleanups.append(wadl_stream)\n   ...    return Application(url, wadl_stream)\n   >>> wadl = application_for(\"launchpad-wadl.xml\",\n   ...                        \"http://api.launchpad.dev/beta/\")\n\n\nLink navigation\n===============\n\nThe preferred technique for finding a resource is to start at one of\nthe resources defined in the WADL file, and follow links. This code\nretrieves the definition of the root resource.\n\n   >>> service_root = wadl.get_resource_by_path('')\n   >>> service_root.url\n   'http://api.launchpad.dev/beta/'\n   >>> service_root.type_url\n   '#service-root'\n\nThe service root resource supports GET.\n\n   >>> get_method = service_root.get_method('get')\n   >>> get_method.id\n   'service-root-get'\n\n   >>> get_method = service_root.get_method('GET')\n   >>> get_method.id\n   'service-root-get'\n\nIf we want to invoke this method, we send a GET request to the service\nroot URL.\n\n   >>> get_method.name\n   'get'\n   >>> get_method.build_request_url()\n   'http://api.launchpad.dev/beta/'\n\nThe WADL description of a resource knows which representations are\navailable for that resource. In this case, the server root resource\nhas a a JSON representation, and it defines parameters like\n'people_collection_link', a link to a list of people in Launchpad. We\nshould be able to use the get_parameter() method to get the WADL\ndefinition of the 'people_collection_link' parameter and find out more\nabout it--for instance, is it a link to another resource?\n\n   >>> def test_raises(exc_class, method, *args, **kwargs):\n   ...     try:\n   ...         method(*args, **kwargs)\n   ...     except Exception:\n   ...         # Contortion to support Python < 2.6 and >= 3 simultaneously.\n   ...         e = sys.exc_info()[1]\n   ...         if isinstance(e, exc_class):\n   ...             print(e)\n   ...             return\n   ...         raise\n   ...     raise Exception(\"Expected exception %s not raised\" % exc_class)\n\n   >>> from wadllib.application import NoBoundRepresentationError\n   >>> link_name = 'people_collection_link'\n   >>> test_raises(\n   ...     NoBoundRepresentationError, service_root.get_parameter, link_name)\n   Resource is not bound to any representation, and no media media type was specified.\n\nOops. The code has no way to know whether 'people_collection_link' is\na parameter of the JSON representation or some other kind of\nrepresentation. We can pass a media type to get_parameter and let it\nknow which representation the parameter lives in.\n\n   >>> link_parameter = service_root.get_parameter(\n   ...     link_name, 'application/json')\n   >>> test_raises(NoBoundRepresentationError, link_parameter.get_value)\n   Resource is not bound to any representation.\n\nOops again. The parameter is available, but it has no value, because\nthere's no actual data associated with the resource. The browser can\nlook up the description of the GET method to make an actual GET\nrequest to the service root, and bind the resulting representation to\nthe WADL description of the service root.\n\nYou can't bind just any representation to a WADL resource description.\nIt has to be of a media type understood by the WADL description.\n\n   >>> from wadllib.application import UnsupportedMediaTypeError\n   >>> test_raises(\n   ...     UnsupportedMediaTypeError, service_root.bind,\n   ...     '<html>Some HTML</html>', 'text/html')\n   This resource doesn't define a representation for media type text/html\n\nThe WADL description of the service root resource has a JSON\nrepresentation. Here it is.\n\n   >>> json_representation = service_root.get_representation_definition(\n   ...     'application/json')\n   >>> json_representation.media_type\n   'application/json'\n\nWe already have a WADL representation of the service root resource, so\nlet's try binding it to that JSON representation. We use test JSON\ndata from a file to simulate the result of a GET request to the\nservice root.\n\n   >>> def get_testdata(filename):\n   ...     return pkg_resources.resource_string(\n   ...         'wadllib.tests.data', filename + '.json')\n\n   >>> def bind_to_testdata(resource, filename):\n   ...     return resource.bind(get_testdata(filename), 'application/json')\n\nThe return value is a new Resource object that's \"bound\" to that JSON\ntest data.\n\n   >>> bound_service_root = bind_to_testdata(service_root, 'root')\n   >>> sorted([param.name for param in bound_service_root.parameters()])\n   ['bugs_collection_link', 'people_collection_link']\n   >>> sorted(bound_service_root.parameter_names())\n   ['bugs_collection_link', 'people_collection_link']\n   >>> [method.id for method in bound_service_root.method_iter]\n   ['service-root-get']\n\nNow the bound resource object has a JSON representation, and now\n'people_collection_link' makes sense. We can follow the\n'people_collection_link' to a new Resource object.\n\n   >>> link_parameter = bound_service_root.get_parameter(link_name)\n   >>> link_parameter.style\n   'plain'\n   >>> print(link_parameter.get_value())\n   http://api.launchpad.dev/beta/people\n   >>> personset_resource = link_parameter.linked_resource\n   >>> personset_resource.__class__\n   <class 'wadllib.application.Resource'>\n   >>> print(personset_resource.url)\n   http://api.launchpad.dev/beta/people\n   >>> personset_resource.type_url\n   'http://api.launchpad.dev/beta/#people'\n\nThis new resource is a collection of people.\n\n   >>> personset_resource.id\n   'people'\n\nThe \"collection of people\" resource supports a standard GET request as\nwell as a special GET and an overloaded POST. The get_method() method\nis used to retrieve WADL definitions of the possible HTTP requests you\nmight make. Here's how to get the WADL definition of the standard GET\nrequest.\n\n   >>> get_method = personset_resource.get_method('get')\n   >>> get_method.id\n   'people-get'\n\nThe method name passed into get_method() is treated case-insensitively.\n\n   >>> personset_resource.get_method('GET').id\n   'people-get'\n\nTo invoke the special GET request, the client sets the 'ws.op' query\nparameter to the fixed string 'findPerson'.\n\n   >>> find_method = personset_resource.get_method(\n   ...     query_params={'ws.op' : 'findPerson'})\n   >>> find_method.id\n   'people-findPerson'\n\nGiven an end-user's values for the non-fixed parameters, it's possible\nto get the URL that should be used to invoke the method.\n\n   >>> print(find_method.build_request_url(text='foo'))\n   http://api.launchpad.dev/beta/people?text=foo&ws.op=findPerson\n\n   >>> print(find_method.build_request_url(\n   ...     {'ws.op' : 'findPerson', 'text' : 'bar'}))\n   http://api.launchpad.dev/beta/people?text=bar&ws.op=findPerson\n\nAn error occurs if the end-user gives an incorrect value for a fixed\nparameter value, or omits a required parameter.\n\n   >>> find_method.build_request_url()\n   Traceback (most recent call last):\n   ...\n   ValueError: No value for required parameter 'text'\n\n   >>> find_method.build_request_url(\n   ...     {'ws.op' : 'findAPerson', 'text' : 'foo'})\n   ... # doctest: +ELLIPSIS, +NORMALIZE_WHITESPACE\n   Traceback (most recent call last):\n   ...\n   ValueError: Value 'findAPerson' for parameter 'ws.op' conflicts\n   with fixed value 'findPerson'\n\nTo invoke the overloaded POST request, the client sets the 'ws.op'\nquery variable to the fixed string 'newTeam':\n\n   >>> create_team_method = personset_resource.get_method(\n   ...     'post', representation_params={'ws.op' : 'newTeam'})\n   >>> create_team_method.id\n   'people-newTeam'\n\nfindMethod() returns None when there's no WADL method matching the\nname or the fixed parameters.\n\n   >>> print(personset_resource.get_method('nosuchmethod'))\n   None\n\n   >>> print(personset_resource.get_method(\n   ...     'post', query_params={'ws_op' : 'nosuchparam'}))\n   None\n\nLet's say the browser makes a GET request to the person set resource\nand gets back a representation. We can bind that representation to our\ndescription of the person set resource.\n\n   >>> bound_personset = bind_to_testdata(personset_resource, 'personset')\n   >>> bound_personset.get_parameter(\"start\").get_value()\n   0\n   >>> bound_personset.get_parameter(\"total_size\").get_value()\n   63\n\nWe can keep following links indefinitely, so long as we bind to a\nrepresentation to each resource as we get it, and use the\nrepresentation to find the next link.\n\n   >>> next_page_link = bound_personset.get_parameter(\"next_collection_link\")\n   >>> print(next_page_link.get_value())\n   http://api.launchpad.dev/beta/people?ws.start=5&ws.size=5\n   >>> page_two = next_page_link.linked_resource\n   >>> bound_page_two = bind_to_testdata(page_two, 'personset-page2')\n   >>> print(bound_page_two.url)\n   http://api.launchpad.dev/beta/people?ws.start=5&ws.size=5\n   >>> bound_page_two.get_parameter(\"start\").get_value()\n   5\n   >>> print(bound_page_two.get_parameter(\"next_collection_link\").get_value())\n   http://api.launchpad.dev/beta/people?ws.start=10&ws.size=5\n\nLet's say the browser makes a POST request that invokes the 'newTeam'\nnamed operation. The response will include a number of HTTP headers,\nincluding 'Location', which points the way to the newly created team.\n\n   >>> headers = { 'Location' : 'http://api.launchpad.dev/~newteam' }\n   >>> response = create_team_method.response.bind(headers)\n   >>> location_parameter = response.get_parameter('Location')\n   >>> location_parameter.get_value()\n   'http://api.launchpad.dev/~newteam'\n   >>> new_team = location_parameter.linked_resource\n   >>> new_team.url\n   'http://api.launchpad.dev/~newteam'\n   >>> new_team.type_url\n   'http://api.launchpad.dev/beta/#team'\n\nExamining links\n---------------\n\nThe 'linked_resource' property of a parameter lets you follow a link\nto another object. The 'link' property of a parameter lets you examine\nlinks before following them.\n\n    >>> import json\n    >>> links_wadl = application_for('links-wadl.xml')\n    >>> service_root = links_wadl.get_resource_by_path('')\n    >>> representation = json.dumps(\n    ...     {'scalar_value': 'foo',\n    ...      'known_link': 'http://known/',\n    ...      'unknown_link': 'http://unknown/'})\n    >>> bound_root = service_root.bind(representation)\n\n    >>> print(bound_root.get_parameter(\"scalar_value\").link)\n    None\n\n    >>> known_resource = bound_root.get_parameter(\"known_link\")\n    >>> unknown_resource = bound_root.get_parameter(\"unknown_link\")\n\n    >>> print(known_resource.link.can_follow)\n    True\n    >>> print(unknown_resource.link.can_follow)\n    False\n\nA link whose type is unknown is a link to a resource not described by\nWADL. Following this link using .linked_resource or .link.follow will\ncause a wadllib error. You'll need to follow the link using a general\nHTTP library or some other tool.\n\n    >>> known_resource.link.follow\n    <wadllib.application.Resource object ...>\n    >>> known_resource.linked_resource\n    <wadllib.application.Resource object ...>\n\n    >>> from wadllib.application import WADLError\n    >>> test_raises(WADLError, getattr, unknown_resource.link, 'follow')\n    Cannot follow a link when the target has no WADL\n    description. Try using a general HTTP client instead.\n\n    >>> test_raises(WADLError, getattr, unknown_resource, 'linked_resource')\n    Cannot follow a link when the target has no WADL\n    description. Try using a general HTTP client instead.\n\nCreating a Resource from a representation definition\n====================================================\n\nAlthough every representation is a representation of some HTTP\nresource, an HTTP resource doesn't necessarily correspond directly to\na WADL <resource> or <resource_type> tag. Sometimes a representation\nis defined within a WADL <method> tag.\n\n   >>> find_method = personset_resource.get_method(\n   ...     query_params={'ws.op' : 'find'})\n   >>> find_method.id\n   'people-find'\n\n   >>> representation_definition = (\n   ...     find_method.response.get_representation_definition(\n   ...     'application/json'))\n\nThere may be no WADL <resource> or <resource_type> tag for the\nrepresentation defined here. That's why wadllib makes it possible to\ninstantiate an anonymous Resource object using only the representation\ndefinition.\n\n   >>> from wadllib.application import Resource\n   >>> anonymous_resource = Resource(\n   ...     wadl, \"http://foo/\", representation_definition.tag)\n\nWe can bind this resource to a representation, as long as we\nexplicitly pass in the representation definition.\n\n   >>> anonymous_resource = anonymous_resource.bind(\n   ...     get_testdata('personset'), 'application/json',\n   ...     representation_definition=representation_definition)\n\nOnce the resource is bound to a representation, we can get its\nparameter values.\n\n   >>> print(anonymous_resource.get_parameter(\n   ...     'total_size', 'application/json').get_value())\n   63\n\nResource instantiation\n======================\n\nIf you happen to have the URL to an object lying around, and you know\nits type, you can construct a Resource object directly instead of\nby following links.\n\n   >>> from wadllib.application import Resource\n   >>> limi_person = Resource(wadl, \"http://api.launchpad.dev/beta/~limi\",\n   ...     \"http://api.launchpad.dev/beta/#person\")\n   >>> sorted([method.id for method in limi_person.method_iter])[:3]\n   ['person-acceptInvitationToBeMemberOf', 'person-addMember', 'person-declineInvitationToBeMemberOf']\n\n   >>> bound_limi = bind_to_testdata(limi_person, 'person-limi')\n   >>> sorted(bound_limi.parameter_names())[:3]\n   ['admins_collection_link', 'confirmed_email_addresses_collection_link',\n    'date_created']\n   >>> languages_link = bound_limi.get_parameter(\"languages_collection_link\")\n   >>> print(languages_link.get_value())\n   http://api.launchpad.dev/beta/~limi/languages\n\nYou can bind a Resource to a representation when you create it.\n\n   >>> limi_data = get_testdata('person-limi')\n   >>> bound_limi = Resource(\n   ...     wadl, \"http://api.launchpad.dev/beta/~limi\",\n   ...     \"http://api.launchpad.dev/beta/#person\", limi_data,\n   ...     \"application/json\")\n   >>> print(bound_limi.get_parameter(\n   ...     \"languages_collection_link\").get_value())\n   http://api.launchpad.dev/beta/~limi/languages\n\nBy default the representation is treated as a string and processed\naccording to the media type you pass into the Resource constructor. If\nyou've already processed the representation, pass in False for the\n'representation_needs_processing' argument.\n\n   >>> from wadllib import _make_unicode\n   >>> processed_limi_data = json.loads(_make_unicode(limi_data))\n   >>> bound_limi = Resource(wadl, \"http://api.launchpad.dev/beta/~limi\",\n   ...     \"http://api.launchpad.dev/beta/#person\", processed_limi_data,\n   ...     \"application/json\", False)\n   >>> print(bound_limi.get_parameter(\n   ...     \"languages_collection_link\").get_value())\n   http://api.launchpad.dev/beta/~limi/languages\n\nMost of the time, the representation of a resource is of the type\nyou'd get by sending a standard GET to that resource. If that's not\nthe case, you can specify a RepresentationDefinition as the\n'representation_definition' argument to bind() or the Resource\nconstructor, to show what the representation really looks like. Here's\nan example.\n\nThere's a method on a person resource such as bound_limi that's\nidentified by a distinctive query argument: ws.op=getMembersByStatus.\n\n   >>> method = bound_limi.get_method(\n   ...     query_params={'ws.op' : 'findPathToTeam'})\n\nInvoke this method with a GET request and you'll get back a page from\na list of people.\n\n   >>> people_page_repr_definition = (\n   ...     method.response.get_representation_definition('application/json'))\n   >>> people_page_repr_definition.tag.attrib['href']\n   'http://api.launchpad.dev/beta/#person-page'\n\nAs it happens, we have a page from a list of people to use as test data.\n\n   >>> people_page_repr = get_testdata('personset')\n\nIf we bind the resource to the result of the method invocation as\nhappened above, we don't be able to access any of the parameters we'd\nexpect. wadllib will think the representation is of type\n'person-full', the default GET type for bound_limi.\n\n   >>> bad_people_page = bound_limi.bind(people_page_repr)\n   >>> print(bad_people_page.get_parameter('total_size'))\n   None\n\nSince we don't actually have a 'person-full' representation, we won't\nbe able to get values for the parameters of that kind of\nrepresentation.\n\n   >>> bad_people_page.get_parameter('name').get_value()\n   Traceback (most recent call last):\n   ...\n   KeyError: 'name'\n\nSo that's a dead end. *But*, if we pass the correct representation\ntype into bind(), we can access the parameters associated with a\n'person-page' representation.\n\n   >>> people_page = bound_limi.bind(\n   ...     people_page_repr,\n   ...     representation_definition=people_page_repr_definition)\n   >>> people_page.get_parameter('total_size').get_value()\n   63\n\nIf you invoke the method and ask for a media type other than JSON, you\nwon't get anything.\n\n   >>> print(method.response.get_representation_definition('text/html'))\n   None\n\nData type conversion\n--------------------\n\nThe values of date and dateTime parameters are automatically converted to\nPython datetime objects.\n\n   >>> data_type_wadl = application_for('data-types-wadl.xml')\n   >>> service_root = data_type_wadl.get_resource_by_path('')\n\n   >>> representation = json.dumps(\n   ...     {'a_date': '2007-10-20',\n   ...      'a_datetime': '2005-06-06T08:59:51.619713+00:00'})\n   >>> bound_root = service_root.bind(representation, 'application/json')\n\n   >>> bound_root.get_parameter('a_date').get_value()\n   datetime.datetime(2007, 10, 20, 0, 0)\n   >>> bound_root.get_parameter('a_datetime').get_value()\n   datetime.datetime(2005, 6, 6, 8, ...)\n\nA 'date' field can include a timestamp, and a 'datetime' field can\nomit one. wadllib will turn both into datetime objects.\n\n   >>> representation = json.dumps(\n   ...     {'a_date': '2005-06-06T08:59:51.619713+00:00',\n   ...      'a_datetime': '2007-10-20'})\n   >>> bound_root = service_root.bind(representation, 'application/json')\n\n   >>> bound_root.get_parameter('a_datetime').get_value()\n   datetime.datetime(2007, 10, 20, 0, 0)\n   >>> bound_root.get_parameter('a_date').get_value()\n   datetime.datetime(2005, 6, 6, 8, ...)\n\nIf a date or dateTime parameter has a null value, you get None. If the\nvalue is a string that can't be parsed to a datetime object, you get a\nValueError.\n\n   >>> representation = json.dumps(\n   ...     {'a_date': 'foo', 'a_datetime': None})\n   >>> bound_root = service_root.bind(representation, 'application/json')\n   >>> bound_root.get_parameter('a_date').get_value()\n   Traceback (most recent call last):\n   ...\n   ValueError: foo\n   >>> print(bound_root.get_parameter('a_datetime').get_value())\n   None\n\nRepresentation creation\n=======================\n\nYou must provide a representation when invoking certain methods. The\nrepresentation() method helps you build one without knowing the\ndetails of how a representation is put together.\n\n   >>> create_team_method.build_representation(\n   ...     display_name='Joe Bloggs', name='joebloggs')\n   ('application/x-www-form-urlencoded', 'display_name=Joe+Bloggs&name=joebloggs&ws.op=newTeam')\n\nThe return value of build_representation is a 2-tuple containing the\nmedia type of the built representation, and the string representation\nitself. Along with the resource's URL, this is all you need to send\nthe representation to a web server.\n\n   >>> bound_limi.get_method('patch').build_representation(name='limi2')\n   ('application/json', '{\"name\": \"limi2\"}')\n\nRepresentations may require values for certain parameters.\n\n   >>> create_team_method.build_representation()\n   Traceback (most recent call last):\n   ...\n   ValueError: No value for required parameter 'display_name'\n\n   >>> bound_limi.get_method('put').build_representation(name='limi2')\n   Traceback (most recent call last):\n   ...\n   ValueError: No value for required parameter 'mugshot_link'\n\nSome representations may safely include binary data.\n\n   >>> binary_stream = pkg_resources.resource_stream(\n   ...     'wadllib.tests.data', 'multipart-binary-wadl.xml')\n   >>> cleanups.append(binary_stream)\n   >>> binary_wadl = Application(\n   ...     \"http://www.example.com/\", binary_stream)\n   >>> service_root = binary_wadl.get_resource_by_path('')\n\nDefine a helper that processes the representation the same way\nzope.publisher would.\n\n   >>> import cgi\n   >>> import io\n   >>> def assert_message_parts(media_type, doc, expected):\n   ...     if sys.version_info[0] == 3 and sys.version_info[1] < 3:\n   ...         # We can't do much due to https://bugs.python.org/issue18013.\n   ...         for value in expected:\n   ...             if not isinstance(value, bytes):\n   ...                 value = value.encode('UTF-8')\n   ...             assert value in doc\n   ...         return\n   ...     environ = {\n   ...         'REQUEST_METHOD': 'POST',\n   ...         'CONTENT_TYPE': media_type,\n   ...         'CONTENT_LENGTH': str(len(doc)),\n   ...         }\n   ...     kwargs = (\n   ...         {'encoding': 'UTF-8'} if sys.version_info[0] >= 3 else {})\n   ...     fs = cgi.FieldStorage(\n   ...         fp=io.BytesIO(doc), environ=environ, keep_blank_values=1,\n   ...         **kwargs)\n   ...     values = []\n   ...     def append_values(fields):\n   ...         for field in fields:\n   ...             if field.list:\n   ...                 append_values(field.list)\n   ...             else:\n   ...                 values.append(field.value)\n   ...     append_values(fs.list)\n   ...     assert values == expected, (\n   ...         'Expected %s, got %s' % (expected, values))\n\n   >>> method = service_root.get_method('post', 'multipart/form-data')\n   >>> media_type, doc = method.build_representation(\n   ...     text_field=\"text\", binary_field=b\"\\x01\\x02\\r\\x81\\r\")\n   >>> print(media_type)\n   multipart/form-data; boundary=...\n   >>> assert_message_parts(media_type, doc, ['text', b'\\x01\\x02\\r\\x81\\r'])\n\n   >>> method = service_root.get_method('post', 'multipart/form-data')\n   >>> media_type, doc = method.build_representation(\n   ...     text_field=\"text\\n\", binary_field=b\"\\x01\\x02\\r\\x81\\n\\r\")\n   >>> print(media_type)\n   multipart/form-data; boundary=...\n   >>> assert_message_parts(\n   ...     media_type, doc, ['text\\r\\n', b'\\x01\\x02\\r\\x81\\n\\r'])\n\n   >>> method = service_root.get_method('post', 'multipart/form-data')\n   >>> media_type, doc = method.build_representation(\n   ...     text_field=\"text\\r\\nmore\\r\\n\",\n   ...     binary_field=b\"\\x01\\x02\\r\\n\\x81\\r\\x82\\n\")\n   >>> print(media_type)\n   multipart/form-data; boundary=...\n   >>> assert_message_parts(\n   ...     media_type, doc, ['text\\r\\nmore\\r\\n', b'\\x01\\x02\\r\\n\\x81\\r\\x82\\n'])\n\n   >>> method = service_root.get_method('post', 'text/unknown')\n   >>> method.build_representation(field=\"value\")\n   Traceback (most recent call last):\n   ...\n   ValueError: Unsupported media type: 'text/unknown'\n\nOptions\n=======\n\nSome parameters take values from a predefined list of options.\n\n   >>> option_wadl = application_for('options-wadl.xml')\n   >>> definitions = option_wadl.representation_definitions\n   >>> service_root = option_wadl.get_resource_by_path('')\n   >>> definition = definitions['service-root-json']\n   >>> param = definition.params(service_root)[0]\n   >>> print(param.name)\n   has_options\n   >>> sorted([option.value for option in param.options])\n   ['Value 1', 'Value 2']\n\nSuch parameters cannot take values that are not in the list.\n\n   >>> definition.validate_param_values(\n   ...     [param], {'has_options': 'Value 1'})\n   {'has_options': 'Value 1'}\n\n   >>> definition.validate_param_values(\n   ...     [param], {'has_options': 'Invalid value'})\n   Traceback (most recent call last):\n   ...\n   ValueError: Invalid value 'Invalid value' for parameter\n   'has_options': valid values are: \"Value 1\", \"Value 2\"\n\n\nError conditions\n================\n\nYou'll get None if you try to look up a nonexistent resource.\n\n   >>> print(wadl.get_resource_by_path('nosuchresource'))\n   None\n\nYou'll get an exception if you try to look up a nonexistent resource\ntype.\n\n   >>> print(wadl.get_resource_type('#nosuchtype'))\n   Traceback (most recent call last):\n   KeyError: 'No such XML ID: \"#nosuchtype\"'\n\nYou'll get None if you try to look up a method whose parameters don't\nmatch any defined method.\n\n   >>> print(bound_limi.get_method(\n   ...     'post', representation_params={ 'foo' : 'bar' }))\n   None\n\n.. cleanup\n   >>> for stream in cleanups:\n   ...    stream.close()\n\n\n\n================\nNEWS for wadllib\n================\n\n1.3.4 (2020-04-29)\n==================\n\n- Advertise support for Python 3.8.\n- Add Python 3.9 compatibility by using xml.etree.ElementTree if\n  xml.etree.cElementTree does not exist.  [bug=1870294]\n\n1.3.3 (2018-07-20)\n==================\n\n- Drop support for Python < 2.6.\n- Add tox testing support.\n- Implement a subset of MIME multipart/form-data encoding locally rather\n  than using the standard library's email module, which doesn't have good\n  handling of binary parts and corrupts bytes in them that look like line\n  endings in various ways depending on the Python version.  [bug=1729754]\n\n1.3.2 (2013-02-25)\n==================\n\n- Impose sort order to avoid test failures due to hash randomization.\n  LP: #1132125\n- Be sure to close streams opened by pkg_resources.resource_stream() to avoid\n  test suite complaints.\n\n\n1.3.1 (2012-03-22)\n==================\n\n- Correct the double pass through _from_string causing datetime issues\n\n\n1.3.0 (2012-01-27)\n==================\n\n- Add Python 3 compatibility\n\n- Add the ability to inspect links before following them.\n\n- Ensure that the sample data is packaged.\n\n1.2.0 (2011-02-03)\n==================\n\n- It's now possible to examine a link before following it, to see\n  whether it has a WADL description or whether it needs to be fetched\n  with a general HTTP client.\n\n- It's now possible to iterate over a resource's Parameter objects\n  with the .parameters() method.\n\n1.1.8 (2010-10-27)\n==================\n\n- This revision contains no code changes, but the build system was\n  changed (yet again).  This time to include the version.txt file\n  used by setup.py.\n\n1.1.7 (2010-10-26)\n==================\n\n- This revision contains no code changes, but the build system was\n  changed (again) to include the sample data used in tests.\n\n1.1.6 (2010-10-21)\n==================\n\n- This revision contains no code changes, but the build system was\n  changed to include the sample data used in tests.\n\n1.1.5 (2010-05-04)\n==================\n\n- Fixed a bug (Launchpad bug 274074) that prevented the lookup of\n  parameter values in resources associated directly with a\n  representation definition (rather than a resource type with a\n  representation definition). Bug fix provided by James Westby.\n\n1.1.4 (2009-09-15)\n==================\n\n- Fixed a bug that crashed wadllib unless all parameters of a\n  multipart representation were provided.\n\n1.1.3 (2009-08-26)\n==================\n\n- Remove unnecessary build dependencies.\n\n- Add missing dependencies to setup file.\n\n- Remove sys.path hack from setup.py.\n\n1.1.2 (2009-08-20)\n==================\n\n- Consistently handle different versions of simplejson.\n\n1.1.1 (2009-07-14)\n==================\n\n- Make wadllib aware of the <option> tags that go beneath <param> tags.\n\n1.1 (2009-07-09)\n================\n\n- Make wadllib capable of recognizing and generating\n  multipart/form-data representations, including representations that\n  incorporate binary parameters.\n\n\n1.0 (2009-03-23)\n================\n\n- Initial release on PyPI", "description_content_type": "", "docs_url": null, "download_url": "https://launchpad.net/wadllib/+download", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://launchpad.net/wadllib", "keywords": "", "license": "LGPL v3", "maintainer": "LAZR Developers", "maintainer_email": "lazr-developers@lists.launchpad.net", "name": "wadllib", "package_url": "https://pypi.org/project/wadllib/", "platform": "", "project_url": "https://pypi.org/project/wadllib/", "project_urls": {"Download": "https://launchpad.net/wadllib/+download", "Homepage": "https://launchpad.net/wadllib"}, "release_url": "https://pypi.org/project/wadllib/1.3.4/", "requires_dist": null, "requires_python": "", "summary": "Navigate HTTP resources using WADL files as guides.", "version": "1.3.4", "yanked": false, "html_description": "<div class=\"project-description\">\n            <div id=\"wadllib\">\n<h2>wadllib</h2>\n<p>An Application object represents a web service described by a WADL\nfile.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; import os\n&gt;&gt;&gt; import sys\n&gt;&gt;&gt; import pkg_resources\n&gt;&gt;&gt; from wadllib.application import Application\n</pre>\n</blockquote>\n<p>The first argument to the Application constructor is the URL at which\nthe WADL file was found. The second argument may be raw WADL markup.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; wadl_string = pkg_resources.resource_string(\n...     'wadllib.tests.data', 'launchpad-wadl.xml')\n&gt;&gt;&gt; wadl = Application(\"http://api.launchpad.dev/beta/\", wadl_string)\n</pre>\n</blockquote>\n<p>Or the second argument may be an open filehandle containing the markup.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; cleanups = []\n&gt;&gt;&gt; def application_for(filename, url=\"http://www.example.com/\"):\n...    wadl_stream = pkg_resources.resource_stream(\n...    'wadllib.tests.data', filename)\n...    cleanups.append(wadl_stream)\n...    return Application(url, wadl_stream)\n&gt;&gt;&gt; wadl = application_for(\"launchpad-wadl.xml\",\n...                        \"http://api.launchpad.dev/beta/\")\n</pre>\n</blockquote>\n<div id=\"link-navigation\">\n<h3>Link navigation</h3>\n<p>The preferred technique for finding a resource is to start at one of\nthe resources defined in the WADL file, and follow links. This code\nretrieves the definition of the root resource.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; service_root = wadl.get_resource_by_path('')\n&gt;&gt;&gt; service_root.url\n'http://api.launchpad.dev/beta/'\n&gt;&gt;&gt; service_root.type_url\n'#service-root'\n</pre>\n</blockquote>\n<p>The service root resource supports GET.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; get_method = service_root.get_method('get')\n&gt;&gt;&gt; get_method.id\n'service-root-get'\n</pre>\n<pre>&gt;&gt;&gt; get_method = service_root.get_method('GET')\n&gt;&gt;&gt; get_method.id\n'service-root-get'\n</pre>\n</blockquote>\n<p>If we want to invoke this method, we send a GET request to the service\nroot URL.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; get_method.name\n'get'\n&gt;&gt;&gt; get_method.build_request_url()\n'http://api.launchpad.dev/beta/'\n</pre>\n</blockquote>\n<p>The WADL description of a resource knows which representations are\navailable for that resource. In this case, the server root resource\nhas a a JSON representation, and it defines parameters like\n\u2018people_collection_link\u2019, a link to a list of people in Launchpad. We\nshould be able to use the get_parameter() method to get the WADL\ndefinition of the \u2018people_collection_link\u2019 parameter and find out more\nabout it\u2013for instance, is it a link to another resource?</p>\n<blockquote>\n<pre>&gt;&gt;&gt; def test_raises(exc_class, method, *args, **kwargs):\n...     try:\n...         method(*args, **kwargs)\n...     except Exception:\n...         # Contortion to support Python &lt; 2.6 and &gt;= 3 simultaneously.\n...         e = sys.exc_info()[1]\n...         if isinstance(e, exc_class):\n...             print(e)\n...             return\n...         raise\n...     raise Exception(\"Expected exception %s not raised\" % exc_class)\n</pre>\n<pre>&gt;&gt;&gt; from wadllib.application import NoBoundRepresentationError\n&gt;&gt;&gt; link_name = 'people_collection_link'\n&gt;&gt;&gt; test_raises(\n...     NoBoundRepresentationError, service_root.get_parameter, link_name)\nResource is not bound to any representation, and no media media type was specified.\n</pre>\n</blockquote>\n<p>Oops. The code has no way to know whether \u2018people_collection_link\u2019 is\na parameter of the JSON representation or some other kind of\nrepresentation. We can pass a media type to get_parameter and let it\nknow which representation the parameter lives in.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; link_parameter = service_root.get_parameter(\n...     link_name, 'application/json')\n&gt;&gt;&gt; test_raises(NoBoundRepresentationError, link_parameter.get_value)\nResource is not bound to any representation.\n</pre>\n</blockquote>\n<p>Oops again. The parameter is available, but it has no value, because\nthere\u2019s no actual data associated with the resource. The browser can\nlook up the description of the GET method to make an actual GET\nrequest to the service root, and bind the resulting representation to\nthe WADL description of the service root.</p>\n<p>You can\u2019t bind just any representation to a WADL resource description.\nIt has to be of a media type understood by the WADL description.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from wadllib.application import UnsupportedMediaTypeError\n&gt;&gt;&gt; test_raises(\n...     UnsupportedMediaTypeError, service_root.bind,\n...     '&lt;html&gt;Some HTML&lt;/html&gt;', 'text/html')\nThis resource doesn't define a representation for media type text/html\n</pre>\n</blockquote>\n<p>The WADL description of the service root resource has a JSON\nrepresentation. Here it is.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; json_representation = service_root.get_representation_definition(\n...     'application/json')\n&gt;&gt;&gt; json_representation.media_type\n'application/json'\n</pre>\n</blockquote>\n<p>We already have a WADL representation of the service root resource, so\nlet\u2019s try binding it to that JSON representation. We use test JSON\ndata from a file to simulate the result of a GET request to the\nservice root.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; def get_testdata(filename):\n...     return pkg_resources.resource_string(\n...         'wadllib.tests.data', filename + '.json')\n</pre>\n<pre>&gt;&gt;&gt; def bind_to_testdata(resource, filename):\n...     return resource.bind(get_testdata(filename), 'application/json')\n</pre>\n</blockquote>\n<p>The return value is a new Resource object that\u2019s \u201cbound\u201d to that JSON\ntest data.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; bound_service_root = bind_to_testdata(service_root, 'root')\n&gt;&gt;&gt; sorted([param.name for param in bound_service_root.parameters()])\n['bugs_collection_link', 'people_collection_link']\n&gt;&gt;&gt; sorted(bound_service_root.parameter_names())\n['bugs_collection_link', 'people_collection_link']\n&gt;&gt;&gt; [method.id for method in bound_service_root.method_iter]\n['service-root-get']\n</pre>\n</blockquote>\n<p>Now the bound resource object has a JSON representation, and now\n\u2018people_collection_link\u2019 makes sense. We can follow the\n\u2018people_collection_link\u2019 to a new Resource object.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; link_parameter = bound_service_root.get_parameter(link_name)\n&gt;&gt;&gt; link_parameter.style\n'plain'\n&gt;&gt;&gt; print(link_parameter.get_value())\nhttp://api.launchpad.dev/beta/people\n&gt;&gt;&gt; personset_resource = link_parameter.linked_resource\n&gt;&gt;&gt; personset_resource.__class__\n&lt;class 'wadllib.application.Resource'&gt;\n&gt;&gt;&gt; print(personset_resource.url)\nhttp://api.launchpad.dev/beta/people\n&gt;&gt;&gt; personset_resource.type_url\n'http://api.launchpad.dev/beta/#people'\n</pre>\n</blockquote>\n<p>This new resource is a collection of people.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; personset_resource.id\n'people'\n</pre>\n</blockquote>\n<p>The \u201ccollection of people\u201d resource supports a standard GET request as\nwell as a special GET and an overloaded POST. The get_method() method\nis used to retrieve WADL definitions of the possible HTTP requests you\nmight make. Here\u2019s how to get the WADL definition of the standard GET\nrequest.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; get_method = personset_resource.get_method('get')\n&gt;&gt;&gt; get_method.id\n'people-get'\n</pre>\n</blockquote>\n<p>The method name passed into get_method() is treated case-insensitively.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; personset_resource.get_method('GET').id\n'people-get'\n</pre>\n</blockquote>\n<p>To invoke the special GET request, the client sets the \u2018ws.op\u2019 query\nparameter to the fixed string \u2018findPerson\u2019.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; find_method = personset_resource.get_method(\n...     query_params={'ws.op' : 'findPerson'})\n&gt;&gt;&gt; find_method.id\n'people-findPerson'\n</pre>\n</blockquote>\n<p>Given an end-user\u2019s values for the non-fixed parameters, it\u2019s possible\nto get the URL that should be used to invoke the method.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; print(find_method.build_request_url(text='foo'))\nhttp://api.launchpad.dev/beta/people?text=foo&amp;ws.op=findPerson\n</pre>\n<pre>&gt;&gt;&gt; print(find_method.build_request_url(\n...     {'ws.op' : 'findPerson', 'text' : 'bar'}))\nhttp://api.launchpad.dev/beta/people?text=bar&amp;ws.op=findPerson\n</pre>\n</blockquote>\n<p>An error occurs if the end-user gives an incorrect value for a fixed\nparameter value, or omits a required parameter.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; find_method.build_request_url()\nTraceback (most recent call last):\n...\nValueError: No value for required parameter 'text'\n</pre>\n<pre>&gt;&gt;&gt; find_method.build_request_url(\n...     {'ws.op' : 'findAPerson', 'text' : 'foo'})\n... # doctest: +ELLIPSIS, +NORMALIZE_WHITESPACE\nTraceback (most recent call last):\n...\nValueError: Value 'findAPerson' for parameter 'ws.op' conflicts\nwith fixed value 'findPerson'\n</pre>\n</blockquote>\n<p>To invoke the overloaded POST request, the client sets the \u2018ws.op\u2019\nquery variable to the fixed string \u2018newTeam\u2019:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; create_team_method = personset_resource.get_method(\n...     'post', representation_params={'ws.op' : 'newTeam'})\n&gt;&gt;&gt; create_team_method.id\n'people-newTeam'\n</pre>\n</blockquote>\n<p>findMethod() returns None when there\u2019s no WADL method matching the\nname or the fixed parameters.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; print(personset_resource.get_method('nosuchmethod'))\nNone\n</pre>\n<pre>&gt;&gt;&gt; print(personset_resource.get_method(\n...     'post', query_params={'ws_op' : 'nosuchparam'}))\nNone\n</pre>\n</blockquote>\n<p>Let\u2019s say the browser makes a GET request to the person set resource\nand gets back a representation. We can bind that representation to our\ndescription of the person set resource.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; bound_personset = bind_to_testdata(personset_resource, 'personset')\n&gt;&gt;&gt; bound_personset.get_parameter(\"start\").get_value()\n0\n&gt;&gt;&gt; bound_personset.get_parameter(\"total_size\").get_value()\n63\n</pre>\n</blockquote>\n<p>We can keep following links indefinitely, so long as we bind to a\nrepresentation to each resource as we get it, and use the\nrepresentation to find the next link.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; next_page_link = bound_personset.get_parameter(\"next_collection_link\")\n&gt;&gt;&gt; print(next_page_link.get_value())\nhttp://api.launchpad.dev/beta/people?ws.start=5&amp;ws.size=5\n&gt;&gt;&gt; page_two = next_page_link.linked_resource\n&gt;&gt;&gt; bound_page_two = bind_to_testdata(page_two, 'personset-page2')\n&gt;&gt;&gt; print(bound_page_two.url)\nhttp://api.launchpad.dev/beta/people?ws.start=5&amp;ws.size=5\n&gt;&gt;&gt; bound_page_two.get_parameter(\"start\").get_value()\n5\n&gt;&gt;&gt; print(bound_page_two.get_parameter(\"next_collection_link\").get_value())\nhttp://api.launchpad.dev/beta/people?ws.start=10&amp;ws.size=5\n</pre>\n</blockquote>\n<p>Let\u2019s say the browser makes a POST request that invokes the \u2018newTeam\u2019\nnamed operation. The response will include a number of HTTP headers,\nincluding \u2018Location\u2019, which points the way to the newly created team.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; headers = { 'Location' : 'http://api.launchpad.dev/~newteam' }\n&gt;&gt;&gt; response = create_team_method.response.bind(headers)\n&gt;&gt;&gt; location_parameter = response.get_parameter('Location')\n&gt;&gt;&gt; location_parameter.get_value()\n'http://api.launchpad.dev/~newteam'\n&gt;&gt;&gt; new_team = location_parameter.linked_resource\n&gt;&gt;&gt; new_team.url\n'http://api.launchpad.dev/~newteam'\n&gt;&gt;&gt; new_team.type_url\n'http://api.launchpad.dev/beta/#team'\n</pre>\n</blockquote>\n<div id=\"examining-links\">\n<h4>Examining links</h4>\n<p>The \u2018linked_resource\u2019 property of a parameter lets you follow a link\nto another object. The \u2018link\u2019 property of a parameter lets you examine\nlinks before following them.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; import json\n&gt;&gt;&gt; links_wadl = application_for('links-wadl.xml')\n&gt;&gt;&gt; service_root = links_wadl.get_resource_by_path('')\n&gt;&gt;&gt; representation = json.dumps(\n...     {'scalar_value': 'foo',\n...      'known_link': 'http://known/',\n...      'unknown_link': 'http://unknown/'})\n&gt;&gt;&gt; bound_root = service_root.bind(representation)\n</pre>\n<pre>&gt;&gt;&gt; print(bound_root.get_parameter(\"scalar_value\").link)\nNone\n</pre>\n<pre>&gt;&gt;&gt; known_resource = bound_root.get_parameter(\"known_link\")\n&gt;&gt;&gt; unknown_resource = bound_root.get_parameter(\"unknown_link\")\n</pre>\n<pre>&gt;&gt;&gt; print(known_resource.link.can_follow)\nTrue\n&gt;&gt;&gt; print(unknown_resource.link.can_follow)\nFalse\n</pre>\n</blockquote>\n<p>A link whose type is unknown is a link to a resource not described by\nWADL. Following this link using .linked_resource or .link.follow will\ncause a wadllib error. You\u2019ll need to follow the link using a general\nHTTP library or some other tool.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; known_resource.link.follow\n&lt;wadllib.application.Resource object ...&gt;\n&gt;&gt;&gt; known_resource.linked_resource\n&lt;wadllib.application.Resource object ...&gt;\n</pre>\n<pre>&gt;&gt;&gt; from wadllib.application import WADLError\n&gt;&gt;&gt; test_raises(WADLError, getattr, unknown_resource.link, 'follow')\nCannot follow a link when the target has no WADL\ndescription. Try using a general HTTP client instead.\n</pre>\n<pre>&gt;&gt;&gt; test_raises(WADLError, getattr, unknown_resource, 'linked_resource')\nCannot follow a link when the target has no WADL\ndescription. Try using a general HTTP client instead.\n</pre>\n</blockquote>\n</div>\n</div>\n<div id=\"creating-a-resource-from-a-representation-definition\">\n<h3>Creating a Resource from a representation definition</h3>\n<p>Although every representation is a representation of some HTTP\nresource, an HTTP resource doesn\u2019t necessarily correspond directly to\na WADL &lt;resource&gt; or &lt;resource_type&gt; tag. Sometimes a representation\nis defined within a WADL &lt;method&gt; tag.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; find_method = personset_resource.get_method(\n...     query_params={'ws.op' : 'find'})\n&gt;&gt;&gt; find_method.id\n'people-find'\n</pre>\n<pre>&gt;&gt;&gt; representation_definition = (\n...     find_method.response.get_representation_definition(\n...     'application/json'))\n</pre>\n</blockquote>\n<p>There may be no WADL &lt;resource&gt; or &lt;resource_type&gt; tag for the\nrepresentation defined here. That\u2019s why wadllib makes it possible to\ninstantiate an anonymous Resource object using only the representation\ndefinition.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from wadllib.application import Resource\n&gt;&gt;&gt; anonymous_resource = Resource(\n...     wadl, \"http://foo/\", representation_definition.tag)\n</pre>\n</blockquote>\n<p>We can bind this resource to a representation, as long as we\nexplicitly pass in the representation definition.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; anonymous_resource = anonymous_resource.bind(\n...     get_testdata('personset'), 'application/json',\n...     representation_definition=representation_definition)\n</pre>\n</blockquote>\n<p>Once the resource is bound to a representation, we can get its\nparameter values.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; print(anonymous_resource.get_parameter(\n...     'total_size', 'application/json').get_value())\n63\n</pre>\n</blockquote>\n</div>\n<div id=\"resource-instantiation\">\n<h3>Resource instantiation</h3>\n<p>If you happen to have the URL to an object lying around, and you know\nits type, you can construct a Resource object directly instead of\nby following links.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from wadllib.application import Resource\n&gt;&gt;&gt; limi_person = Resource(wadl, \"http://api.launchpad.dev/beta/~limi\",\n...     \"http://api.launchpad.dev/beta/#person\")\n&gt;&gt;&gt; sorted([method.id for method in limi_person.method_iter])[:3]\n['person-acceptInvitationToBeMemberOf', 'person-addMember', 'person-declineInvitationToBeMemberOf']\n</pre>\n<pre>&gt;&gt;&gt; bound_limi = bind_to_testdata(limi_person, 'person-limi')\n&gt;&gt;&gt; sorted(bound_limi.parameter_names())[:3]\n['admins_collection_link', 'confirmed_email_addresses_collection_link',\n 'date_created']\n&gt;&gt;&gt; languages_link = bound_limi.get_parameter(\"languages_collection_link\")\n&gt;&gt;&gt; print(languages_link.get_value())\nhttp://api.launchpad.dev/beta/~limi/languages\n</pre>\n</blockquote>\n<p>You can bind a Resource to a representation when you create it.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; limi_data = get_testdata('person-limi')\n&gt;&gt;&gt; bound_limi = Resource(\n...     wadl, \"http://api.launchpad.dev/beta/~limi\",\n...     \"http://api.launchpad.dev/beta/#person\", limi_data,\n...     \"application/json\")\n&gt;&gt;&gt; print(bound_limi.get_parameter(\n...     \"languages_collection_link\").get_value())\nhttp://api.launchpad.dev/beta/~limi/languages\n</pre>\n</blockquote>\n<p>By default the representation is treated as a string and processed\naccording to the media type you pass into the Resource constructor. If\nyou\u2019ve already processed the representation, pass in False for the\n\u2018representation_needs_processing\u2019 argument.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from wadllib import _make_unicode\n&gt;&gt;&gt; processed_limi_data = json.loads(_make_unicode(limi_data))\n&gt;&gt;&gt; bound_limi = Resource(wadl, \"http://api.launchpad.dev/beta/~limi\",\n...     \"http://api.launchpad.dev/beta/#person\", processed_limi_data,\n...     \"application/json\", False)\n&gt;&gt;&gt; print(bound_limi.get_parameter(\n...     \"languages_collection_link\").get_value())\nhttp://api.launchpad.dev/beta/~limi/languages\n</pre>\n</blockquote>\n<p>Most of the time, the representation of a resource is of the type\nyou\u2019d get by sending a standard GET to that resource. If that\u2019s not\nthe case, you can specify a RepresentationDefinition as the\n\u2018representation_definition\u2019 argument to bind() or the Resource\nconstructor, to show what the representation really looks like. Here\u2019s\nan example.</p>\n<p>There\u2019s a method on a person resource such as bound_limi that\u2019s\nidentified by a distinctive query argument: ws.op=getMembersByStatus.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; method = bound_limi.get_method(\n...     query_params={'ws.op' : 'findPathToTeam'})\n</pre>\n</blockquote>\n<p>Invoke this method with a GET request and you\u2019ll get back a page from\na list of people.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; people_page_repr_definition = (\n...     method.response.get_representation_definition('application/json'))\n&gt;&gt;&gt; people_page_repr_definition.tag.attrib['href']\n'http://api.launchpad.dev/beta/#person-page'\n</pre>\n</blockquote>\n<p>As it happens, we have a page from a list of people to use as test data.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; people_page_repr = get_testdata('personset')\n</pre>\n</blockquote>\n<p>If we bind the resource to the result of the method invocation as\nhappened above, we don\u2019t be able to access any of the parameters we\u2019d\nexpect. wadllib will think the representation is of type\n\u2018person-full\u2019, the default GET type for bound_limi.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; bad_people_page = bound_limi.bind(people_page_repr)\n&gt;&gt;&gt; print(bad_people_page.get_parameter('total_size'))\nNone\n</pre>\n</blockquote>\n<p>Since we don\u2019t actually have a \u2018person-full\u2019 representation, we won\u2019t\nbe able to get values for the parameters of that kind of\nrepresentation.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; bad_people_page.get_parameter('name').get_value()\nTraceback (most recent call last):\n...\nKeyError: 'name'\n</pre>\n</blockquote>\n<p>So that\u2019s a dead end. <em>But</em>, if we pass the correct representation\ntype into bind(), we can access the parameters associated with a\n\u2018person-page\u2019 representation.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; people_page = bound_limi.bind(\n...     people_page_repr,\n...     representation_definition=people_page_repr_definition)\n&gt;&gt;&gt; people_page.get_parameter('total_size').get_value()\n63\n</pre>\n</blockquote>\n<p>If you invoke the method and ask for a media type other than JSON, you\nwon\u2019t get anything.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; print(method.response.get_representation_definition('text/html'))\nNone\n</pre>\n</blockquote>\n<div id=\"data-type-conversion\">\n<h4>Data type conversion</h4>\n<p>The values of date and dateTime parameters are automatically converted to\nPython datetime objects.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; data_type_wadl = application_for('data-types-wadl.xml')\n&gt;&gt;&gt; service_root = data_type_wadl.get_resource_by_path('')\n</pre>\n<pre>&gt;&gt;&gt; representation = json.dumps(\n...     {'a_date': '2007-10-20',\n...      'a_datetime': '2005-06-06T08:59:51.619713+00:00'})\n&gt;&gt;&gt; bound_root = service_root.bind(representation, 'application/json')\n</pre>\n<pre>&gt;&gt;&gt; bound_root.get_parameter('a_date').get_value()\ndatetime.datetime(2007, 10, 20, 0, 0)\n&gt;&gt;&gt; bound_root.get_parameter('a_datetime').get_value()\ndatetime.datetime(2005, 6, 6, 8, ...)\n</pre>\n</blockquote>\n<p>A \u2018date\u2019 field can include a timestamp, and a \u2018datetime\u2019 field can\nomit one. wadllib will turn both into datetime objects.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; representation = json.dumps(\n...     {'a_date': '2005-06-06T08:59:51.619713+00:00',\n...      'a_datetime': '2007-10-20'})\n&gt;&gt;&gt; bound_root = service_root.bind(representation, 'application/json')\n</pre>\n<pre>&gt;&gt;&gt; bound_root.get_parameter('a_datetime').get_value()\ndatetime.datetime(2007, 10, 20, 0, 0)\n&gt;&gt;&gt; bound_root.get_parameter('a_date').get_value()\ndatetime.datetime(2005, 6, 6, 8, ...)\n</pre>\n</blockquote>\n<p>If a date or dateTime parameter has a null value, you get None. If the\nvalue is a string that can\u2019t be parsed to a datetime object, you get a\nValueError.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; representation = json.dumps(\n...     {'a_date': 'foo', 'a_datetime': None})\n&gt;&gt;&gt; bound_root = service_root.bind(representation, 'application/json')\n&gt;&gt;&gt; bound_root.get_parameter('a_date').get_value()\nTraceback (most recent call last):\n...\nValueError: foo\n&gt;&gt;&gt; print(bound_root.get_parameter('a_datetime').get_value())\nNone\n</pre>\n</blockquote>\n</div>\n</div>\n<div id=\"representation-creation\">\n<h3>Representation creation</h3>\n<p>You must provide a representation when invoking certain methods. The\nrepresentation() method helps you build one without knowing the\ndetails of how a representation is put together.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; create_team_method.build_representation(\n...     display_name='Joe Bloggs', name='joebloggs')\n('application/x-www-form-urlencoded', 'display_name=Joe+Bloggs&amp;name=joebloggs&amp;ws.op=newTeam')\n</pre>\n</blockquote>\n<p>The return value of build_representation is a 2-tuple containing the\nmedia type of the built representation, and the string representation\nitself. Along with the resource\u2019s URL, this is all you need to send\nthe representation to a web server.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; bound_limi.get_method('patch').build_representation(name='limi2')\n('application/json', '{\"name\": \"limi2\"}')\n</pre>\n</blockquote>\n<p>Representations may require values for certain parameters.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; create_team_method.build_representation()\nTraceback (most recent call last):\n...\nValueError: No value for required parameter 'display_name'\n</pre>\n<pre>&gt;&gt;&gt; bound_limi.get_method('put').build_representation(name='limi2')\nTraceback (most recent call last):\n...\nValueError: No value for required parameter 'mugshot_link'\n</pre>\n</blockquote>\n<p>Some representations may safely include binary data.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; binary_stream = pkg_resources.resource_stream(\n...     'wadllib.tests.data', 'multipart-binary-wadl.xml')\n&gt;&gt;&gt; cleanups.append(binary_stream)\n&gt;&gt;&gt; binary_wadl = Application(\n...     \"http://www.example.com/\", binary_stream)\n&gt;&gt;&gt; service_root = binary_wadl.get_resource_by_path('')\n</pre>\n</blockquote>\n<p>Define a helper that processes the representation the same way\nzope.publisher would.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; import cgi\n&gt;&gt;&gt; import io\n&gt;&gt;&gt; def assert_message_parts(media_type, doc, expected):\n...     if sys.version_info[0] == 3 and sys.version_info[1] &lt; 3:\n...         # We can't do much due to https://bugs.python.org/issue18013.\n...         for value in expected:\n...             if not isinstance(value, bytes):\n...                 value = value.encode('UTF-8')\n...             assert value in doc\n...         return\n...     environ = {\n...         'REQUEST_METHOD': 'POST',\n...         'CONTENT_TYPE': media_type,\n...         'CONTENT_LENGTH': str(len(doc)),\n...         }\n...     kwargs = (\n...         {'encoding': 'UTF-8'} if sys.version_info[0] &gt;= 3 else {})\n...     fs = cgi.FieldStorage(\n...         fp=io.BytesIO(doc), environ=environ, keep_blank_values=1,\n...         **kwargs)\n...     values = []\n...     def append_values(fields):\n...         for field in fields:\n...             if field.list:\n...                 append_values(field.list)\n...             else:\n...                 values.append(field.value)\n...     append_values(fs.list)\n...     assert values == expected, (\n...         'Expected %s, got %s' % (expected, values))\n</pre>\n<pre>&gt;&gt;&gt; method = service_root.get_method('post', 'multipart/form-data')\n&gt;&gt;&gt; media_type, doc = method.build_representation(\n...     text_field=\"text\", binary_field=b\"\\x01\\x02\\r\\x81\\r\")\n&gt;&gt;&gt; print(media_type)\nmultipart/form-data; boundary=...\n&gt;&gt;&gt; assert_message_parts(media_type, doc, ['text', b'\\x01\\x02\\r\\x81\\r'])\n</pre>\n<pre>&gt;&gt;&gt; method = service_root.get_method('post', 'multipart/form-data')\n&gt;&gt;&gt; media_type, doc = method.build_representation(\n...     text_field=\"text\\n\", binary_field=b\"\\x01\\x02\\r\\x81\\n\\r\")\n&gt;&gt;&gt; print(media_type)\nmultipart/form-data; boundary=...\n&gt;&gt;&gt; assert_message_parts(\n...     media_type, doc, ['text\\r\\n', b'\\x01\\x02\\r\\x81\\n\\r'])\n</pre>\n<pre>&gt;&gt;&gt; method = service_root.get_method('post', 'multipart/form-data')\n&gt;&gt;&gt; media_type, doc = method.build_representation(\n...     text_field=\"text\\r\\nmore\\r\\n\",\n...     binary_field=b\"\\x01\\x02\\r\\n\\x81\\r\\x82\\n\")\n&gt;&gt;&gt; print(media_type)\nmultipart/form-data; boundary=...\n&gt;&gt;&gt; assert_message_parts(\n...     media_type, doc, ['text\\r\\nmore\\r\\n', b'\\x01\\x02\\r\\n\\x81\\r\\x82\\n'])\n</pre>\n<pre>&gt;&gt;&gt; method = service_root.get_method('post', 'text/unknown')\n&gt;&gt;&gt; method.build_representation(field=\"value\")\nTraceback (most recent call last):\n...\nValueError: Unsupported media type: 'text/unknown'\n</pre>\n</blockquote>\n</div>\n<div id=\"options\">\n<h3>Options</h3>\n<p>Some parameters take values from a predefined list of options.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; option_wadl = application_for('options-wadl.xml')\n&gt;&gt;&gt; definitions = option_wadl.representation_definitions\n&gt;&gt;&gt; service_root = option_wadl.get_resource_by_path('')\n&gt;&gt;&gt; definition = definitions['service-root-json']\n&gt;&gt;&gt; param = definition.params(service_root)[0]\n&gt;&gt;&gt; print(param.name)\nhas_options\n&gt;&gt;&gt; sorted([option.value for option in param.options])\n['Value 1', 'Value 2']\n</pre>\n</blockquote>\n<p>Such parameters cannot take values that are not in the list.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; definition.validate_param_values(\n...     [param], {'has_options': 'Value 1'})\n{'has_options': 'Value 1'}\n</pre>\n<pre>&gt;&gt;&gt; definition.validate_param_values(\n...     [param], {'has_options': 'Invalid value'})\nTraceback (most recent call last):\n...\nValueError: Invalid value 'Invalid value' for parameter\n'has_options': valid values are: \"Value 1\", \"Value 2\"\n</pre>\n</blockquote>\n</div>\n<div id=\"error-conditions\">\n<h3>Error conditions</h3>\n<p>You\u2019ll get None if you try to look up a nonexistent resource.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; print(wadl.get_resource_by_path('nosuchresource'))\nNone\n</pre>\n</blockquote>\n<p>You\u2019ll get an exception if you try to look up a nonexistent resource\ntype.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; print(wadl.get_resource_type('#nosuchtype'))\nTraceback (most recent call last):\nKeyError: 'No such XML ID: \"#nosuchtype\"'\n</pre>\n</blockquote>\n<p>You\u2019ll get None if you try to look up a method whose parameters don\u2019t\nmatch any defined method.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; print(bound_limi.get_method(\n...     'post', representation_params={ 'foo' : 'bar' }))\nNone\n</pre>\n</blockquote>\n</div>\n</div>\n<div id=\"news-for-wadllib\">\n<h2>NEWS for wadllib</h2>\n<div id=\"id1\">\n<h3>1.3.4 (2020-04-29)</h3>\n<ul>\n<li>Advertise support for Python 3.8.</li>\n<li>Add Python 3.9 compatibility by using xml.etree.ElementTree if\nxml.etree.cElementTree does not exist.  [bug=1870294]</li>\n</ul>\n</div>\n<div id=\"id2\">\n<h3>1.3.3 (2018-07-20)</h3>\n<ul>\n<li>Drop support for Python &lt; 2.6.</li>\n<li>Add tox testing support.</li>\n<li>Implement a subset of MIME multipart/form-data encoding locally rather\nthan using the standard library\u2019s email module, which doesn\u2019t have good\nhandling of binary parts and corrupts bytes in them that look like line\nendings in various ways depending on the Python version.  [bug=1729754]</li>\n</ul>\n</div>\n<div id=\"id3\">\n<h3>1.3.2 (2013-02-25)</h3>\n<ul>\n<li>Impose sort order to avoid test failures due to hash randomization.\nLP: #1132125</li>\n<li>Be sure to close streams opened by pkg_resources.resource_stream() to avoid\ntest suite complaints.</li>\n</ul>\n</div>\n<div id=\"id4\">\n<h3>1.3.1 (2012-03-22)</h3>\n<ul>\n<li>Correct the double pass through _from_string causing datetime issues</li>\n</ul>\n</div>\n<div id=\"id5\">\n<h3>1.3.0 (2012-01-27)</h3>\n<ul>\n<li>Add Python 3 compatibility</li>\n<li>Add the ability to inspect links before following them.</li>\n<li>Ensure that the sample data is packaged.</li>\n</ul>\n</div>\n<div id=\"id6\">\n<h3>1.2.0 (2011-02-03)</h3>\n<ul>\n<li>It\u2019s now possible to examine a link before following it, to see\nwhether it has a WADL description or whether it needs to be fetched\nwith a general HTTP client.</li>\n<li>It\u2019s now possible to iterate over a resource\u2019s Parameter objects\nwith the .parameters() method.</li>\n</ul>\n</div>\n<div id=\"id7\">\n<h3>1.1.8 (2010-10-27)</h3>\n<ul>\n<li>This revision contains no code changes, but the build system was\nchanged (yet again).  This time to include the version.txt file\nused by setup.py.</li>\n</ul>\n</div>\n<div id=\"id8\">\n<h3>1.1.7 (2010-10-26)</h3>\n<ul>\n<li>This revision contains no code changes, but the build system was\nchanged (again) to include the sample data used in tests.</li>\n</ul>\n</div>\n<div id=\"id9\">\n<h3>1.1.6 (2010-10-21)</h3>\n<ul>\n<li>This revision contains no code changes, but the build system was\nchanged to include the sample data used in tests.</li>\n</ul>\n</div>\n<div id=\"id10\">\n<h3>1.1.5 (2010-05-04)</h3>\n<ul>\n<li>Fixed a bug (Launchpad bug 274074) that prevented the lookup of\nparameter values in resources associated directly with a\nrepresentation definition (rather than a resource type with a\nrepresentation definition). Bug fix provided by James Westby.</li>\n</ul>\n</div>\n<div id=\"id11\">\n<h3>1.1.4 (2009-09-15)</h3>\n<ul>\n<li>Fixed a bug that crashed wadllib unless all parameters of a\nmultipart representation were provided.</li>\n</ul>\n</div>\n<div id=\"id12\">\n<h3>1.1.3 (2009-08-26)</h3>\n<ul>\n<li>Remove unnecessary build dependencies.</li>\n<li>Add missing dependencies to setup file.</li>\n<li>Remove sys.path hack from setup.py.</li>\n</ul>\n</div>\n<div id=\"id13\">\n<h3>1.1.2 (2009-08-20)</h3>\n<ul>\n<li>Consistently handle different versions of simplejson.</li>\n</ul>\n</div>\n<div id=\"id14\">\n<h3>1.1.1 (2009-07-14)</h3>\n<ul>\n<li>Make wadllib aware of the &lt;option&gt; tags that go beneath &lt;param&gt; tags.</li>\n</ul>\n</div>\n<div id=\"id15\">\n<h3>1.1 (2009-07-09)</h3>\n<ul>\n<li>Make wadllib capable of recognizing and generating\nmultipart/form-data representations, including representations that\nincorporate binary parameters.</li>\n</ul>\n</div>\n<div id=\"id16\">\n<h3>1.0 (2009-03-23)</h3>\n<ul>\n<li>Initial release on PyPI</li>\n</ul>\n</div>\n</div>\n\n          </div>"}, "last_serial": 7129931, "releases": {"0.1": [{"comment_text": "", "digests": {"md5": "59149f62dde5740fc5c7c453ad4ba98c", "sha256": "a34efdfa86a6999672f01f5bfe4456af126fabaff058c859c6ebd0a9eea8f58f"}, "downloads": -1, "filename": "wadllib-0.1.tar.gz", "has_sig": false, "md5_digest": "59149f62dde5740fc5c7c453ad4ba98c", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 49685, "upload_time": "2009-03-23T23:39:18", "upload_time_iso_8601": "2009-03-23T23:39:18.258798Z", "url": "https://files.pythonhosted.org/packages/8a/03/7b33fbdb63ba9e76d9ff46edf1f435844e186bc37763a210ebc9f851a54b/wadllib-0.1.tar.gz", "yanked": false}], "1.1": [], "1.1.1": [], "1.1.2": [], "1.1.3": [], "1.1.4": [], "1.1.5": [], "1.1.6": [], "1.1.7": [], "1.1.8": [], "1.2.0": [], "1.3.0": [], "1.3.1": [], "1.3.2": [{"comment_text": "", "digests": {"md5": "b78902ee7fda49ae50e5acc1bb0298f9", "sha256": "140e43fc16d4352a98a90a450c6326bee5e6de73ae373a569947f3b505405034"}, "downloads": -1, "filename": "wadllib-1.3.2.tar.gz", "has_sig": true, "md5_digest": "b78902ee7fda49ae50e5acc1bb0298f9", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 60085, "upload_time": "2013-02-25T21:54:33", "upload_time_iso_8601": "2013-02-25T21:54:33.937379Z", "url": "https://files.pythonhosted.org/packages/7e/94/9e5f9ad89001215f67619adc2ed3ac771dbbdb23bc7d91bf0bce4aff7bd6/wadllib-1.3.2.tar.gz", "yanked": false}], "1.3.3": [{"comment_text": "", "digests": {"md5": "09cb9d089f4f579b3051053aa0661047", "sha256": "1234cfe81e2cf223e56816f86df3aa18801d1770261865d93337b8b603be366e"}, "downloads": -1, "filename": "wadllib-1.3.3.tar.gz", "has_sig": true, "md5_digest": "09cb9d089f4f579b3051053aa0661047", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 62394, "upload_time": "2018-07-20T12:46:54", "upload_time_iso_8601": "2018-07-20T12:46:54.793306Z", "url": "https://files.pythonhosted.org/packages/e6/21/8194d85e898b2d8c3120a8c0dfb86125c194a725cc2189363fa6f96708c2/wadllib-1.3.3.tar.gz", "yanked": false}], "1.3.4": [{"comment_text": "", "digests": {"md5": "76b76d652a124782bd648ce6418785fe", "sha256": "e995691713d3c795d2b36278de8e212241870f46bec6ecba91794ea3cc5bd67d"}, "downloads": -1, "filename": "wadllib-1.3.4.tar.gz", "has_sig": true, "md5_digest": "76b76d652a124782bd648ce6418785fe", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 63151, "upload_time": "2020-04-29T15:52:21", "upload_time_iso_8601": "2020-04-29T15:52:21.846458Z", "url": "https://files.pythonhosted.org/packages/07/d5/2a77dcbb4185d4df41c61a3abccd6e570b652b11973437430cefd65d91ab/wadllib-1.3.4.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "76b76d652a124782bd648ce6418785fe", "sha256": "e995691713d3c795d2b36278de8e212241870f46bec6ecba91794ea3cc5bd67d"}, "downloads": -1, "filename": "wadllib-1.3.4.tar.gz", "has_sig": true, "md5_digest": "76b76d652a124782bd648ce6418785fe", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 63151, "upload_time": "2020-04-29T15:52:21", "upload_time_iso_8601": "2020-04-29T15:52:21.846458Z", "url": "https://files.pythonhosted.org/packages/07/d5/2a77dcbb4185d4df41c61a3abccd6e570b652b11973437430cefd65d91ab/wadllib-1.3.4.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:33:19 2020"}