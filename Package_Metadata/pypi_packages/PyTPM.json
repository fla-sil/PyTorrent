{"info": {"author": "Prasanth Nair", "author_email": "prasanthhn@gmail.com", "bugtrack_url": null, "classifiers": ["Development Status :: 6 - Mature", "Intended Audience :: Science/Research", "License :: OSI Approved :: BSD License", "Topic :: Scientific/Engineering :: Astronomy"], "description": "Python interface to the TPM C library\r\n=====================================\r\n\r\n.. _Telescope Pointing Machine: http://www.sal.wisc.edu/~jwp/astro/tpm/tpm.html\r\n.. _Jeffrey W Percival: http://www.sal.wisc.edu/~jwp/\r\n.. _Cython: http://www.cython.org/\r\n.. _SWIG: http://www.swig.org/\r\n.. _coords: https://trac6.assembla.com/astrolib\r\n.. _astrolib: https://trac6.assembla.com/astrolib\r\n.. _KPNO WIYN observatory: http://www.noao.edu/wiyn/wiyn.html\r\n.. _WHAM: http://www.astro.wisc.edu/wham/\r\n.. _KPNO: http://www.noao.edu/kpno\r\n.. _Virtualenv: http://pypi.python.org/pypi/virtualenv \r\n.. _Virtualenvwrapper: \r\n   http://www.doughellmann.com/projects/virtualenvwrapper/\r\n.. _ipython: http://ipython.scipy.org\r\n.. _Practical Astronomy With Your Calculator: \r\n  http://www.amazon.com/Practical-Astronomy-Calculator-Peter-Duffett-Smith/dp/0521356997\r\n.. _Distribute: http://packages.python.org/distribute/\r\n.. _numpydoc: http://pypi.python.org/pypi/numpydoc\r\n.. _Sphinx: http://sphinx.pocoo.org/\r\n.. _IERS: http://www.iers.org/\r\n.. _Nose: http://pypi.python.org/pypi/nose\r\n.. _pypi page for the project: http://pypi.python.org/pypi/PyTPM\r\n.. _pip: http://pypi.python.org/pypi/pip\r\n.. _pyslalib: https://github.com/scottransom/pyslalib\r\n\r\n** DEVELOPMENT CEASED **\r\n\r\nPyTPM is a Python interface to the `Telescope Pointing Machine`_ (TPM)\r\nlibrary. TPM is a C library written by `Jeffrey W Percival`_, for performing\r\ncoordinate conversions between several astronomical coordinate systems.\r\n\r\nTPM was designed with the aim of incorporating it into telescope\r\ncontrol systems. To meet this design goal, TPM offers control over\r\ncalculations carried out during coordinate conversions. Some of these\r\ncalculations must be performed frequently, for example time related\r\ncalculations. Others need to be performed only once per night, for\r\nexample nutation and precession matrices. TPM allows the user to select\r\nthe exact calculations to be performed. This enables the user to\r\ncontrol the computational load, which is important in telescope control\r\nsystems. TPM C library is used by the `KPNO WIYN observatory`_ and the\r\nWHAM_ projects.\r\n\r\nPyTPM is not a complete astrometry package. The aim is to provide\r\naccess to the TPM C code from Python. TPM machinery can be directly\r\naccessed using the `pytpm.tpm` sub-module. The sub-module\r\n`pytpm.convert` has several convenience functions that can be used for\r\nperforming coordinate conversions. The latter is sufficient for most,\r\nbut not all, calculations. You should read the `TPM manual`__ before\r\nattempting to use the `pytpm.tpm` module. The manual is present in the\r\nsource code repository and is also included with the PyTPM\r\ndocumentation\r\n\r\n__ `Telescope Pointing Machine`_\r\n\r\nPython interface to TPM C code is written using Cython_.\r\n\r\nInstalling PyTPM\r\n================\r\n\r\nPyTPM requires the following:\r\n\r\n+ Python 2.6, 2.7 or 3.2.\r\n+ GCC.\r\n+ The Distribute_ package.\r\n+ Nose_ for running tests.\r\n+ Cython_, only if the Cython output needs to be regenerated.\r\n\r\nTo build the documentation Sphinx_ and the numpydoc_ Sphinx extension\r\nis required.\r\n\r\nPyTPM was tested on Ubuntu 10.10 and 11.04.\r\n\r\nInstallation\r\n============\r\n\r\n.. important::\r\n\r\n    The file `src/tpm/delta_AT.c` must be updated when Delta-AT is\r\n    changed by the IERS_, and PyTPM Cython code must\r\n    re-compiled. Update the file and just run setup.py again. A new\r\n    version of PyTPM will be released when this change occurs.\r\n\r\nIf you don't have Distribute_, then install it. Then do one of the\r\nfollowing:\r\n\r\n+ pip_ or `easy_install`\r\n\r\n  Install pip_ and then run `pip install pytpm`. \r\n\r\n  If `easy_install` is available then `easy_install pytpm` will also\r\n  work. Distribute_ comes with easy_install. `pip`_ itself can be\r\n  installed using the command `easy_install pip`.\r\n\r\nor \r\n\r\n+ Manual installation.\r\n\r\n  Download the distribution from the `pypi page for the project`_. Then\r\n  run `python setup.py install`. Use the `--prefix <dest>` or `--user`\r\n  arguments to change the installation location.\r\n\r\n\r\nWith both these methods, virtualenv_ and virtualenvwrapper_ can be\r\nused. These tools enable easy installation and maintenance of Python\r\npackages.\r\n\r\nTo run tests, and to build documentation, the manual installation\r\nmethod has to be followed. Run `python setup.py test` and then run\r\n`python setup.py install`. To build documentation, run `make html` in\r\nthe `doc` directory.\r\n\r\nExamples\r\n========\r\n\r\nDetailed documentation is available at\r\nhttp://phn.github.com/pytpm. Documentation in HTML format can also be\r\ndownloaded from the `pypi page for the project`_. Documentation in ReST\r\nformat is available in the `doc` directory of the distribution.\r\n  \r\nPyTPM can be used to convert *positions and velocities* in a given\r\nastronomical coordinate system into another. Examples of doing this are\r\nin the `examples` folder of the source code repository and is also\r\nincluded with the HTML documentation.\r\n\r\nYou should read the `TPM manual`__ before attempting to use the\r\n`pytpm.tpm` module.  The manual is also available in the source code\r\nrepository and the HTML documentation.\r\n\r\n__ `Telescope Pointing Machine`_\r\n\r\n.. _coordinates of M100: http://simbad.u-strasbg.fr/simbad/sim-basic?Ident=M100&submit=SIMBAD+search\r\n\r\nIn the following examples `coordinates of M100`_ is converted between\r\ndifferent systems. \r\n\r\nThe following examples use the convenience function\r\n`pytpm.convert.convertv6`, instead of directly using the underlying TPM\r\nfunctions. The documentation has examples of using the latter.\r\n\r\nThe `convertv6` function takes the following arguments. Not all of\r\nthese need to be specified for a given conversion. \r\n\r\n+------------+----------------------------------------------------+\r\n| Parameter  | Description                                        |\r\n+============+====================================================+\r\n| v6         | one V6C vector or a list of V6C vectors.           |\r\n+------------+----------------------------------------------------+\r\n| s1         | start state                                        |\r\n+------------+----------------------------------------------------+\r\n| s2         | end state                                          |\r\n+------------+----------------------------------------------------+\r\n| epoch      | epoch of the coordinates as a Julian date          |\r\n+------------+----------------------------------------------------+\r\n| equinox    | equinox of the coordinates as Julian date          |\r\n+------------+----------------------------------------------------+\r\n| utc        | time of \"observation\" as a Julian date;            |\r\n|            | exact meaning depends on the type of conversion;   |\r\n|            | defaults to the epoch J2000.0                      |\r\n+------------+----------------------------------------------------+\r\n| delta_ut   | UT1 - UTC in seconds.                              |\r\n+------------+----------------------------------------------------+\r\n| delta_at   | TAI - UTC in seconds.                              |\r\n+------------+----------------------------------------------------+\r\n| lon        | geodetic longitude in degrees                      |\r\n+------------+----------------------------------------------------+\r\n| lat        | geodetic latitude in degrees                       |\r\n+------------+----------------------------------------------------+\r\n| alt        | altitude in meters                                 |\r\n+------------+----------------------------------------------------+\r\n| xpole      | ploar motion in radians                            |\r\n+------------+----------------------------------------------------+\r\n| ypole      | ploar motion in radians                            |\r\n+------------+----------------------------------------------------+\r\n| T          | temperature in kelvin                              |\r\n+------------+----------------------------------------------------+\r\n| P          | pressure in milli-bars                             |\r\n+------------+----------------------------------------------------+\r\n| H          | relative humidity (0-1)                            |\r\n+------------+----------------------------------------------------+\r\n| wavelength | wavelength of observation in microns               |\r\n+------------+----------------------------------------------------+\r\n\r\nA `V6C` object is a 6-D vector that stores positions and velocities in\r\nCartesian coordinates. The function `pytpm.convert.v62cat` can be used\r\nto create a `V6C` object from catalog data.  This function will accept\r\nscalar or list of coordinates. Function `pytpm.convert.v62cat` can\r\nconvert `V6C` objects to catalog coordinates. The coordinates are\r\nreturned as a dictionary. This function will also take a list of `V6C`\r\nobjects and will return a list of dictionaries.\r\n\r\nCoordinate systems are specified using integers or integer\r\nconstants. These are referred to as `states`.The following are some of\r\nthe important states.\r\n\r\n+---------+------------------------------------------------+\r\n| State   | Description                                    |\r\n+=========+================================================+\r\n|    3    | IAU 1980 Ecliptic system                       |\r\n+---------+------------------------------------------------+\r\n|    4    | IAU 1958 Galactic system                       |\r\n+---------+------------------------------------------------+\r\n|    5    | Heliocentric mean FK4 system, B1950 equinox    |\r\n+---------+------------------------------------------------+\r\n|    6    | Heliocentric mean FK5 system, J2000 equinox    |\r\n+---------+------------------------------------------------+\r\n|   11    | Geocentric apparent FK5, current equinox       |\r\n+---------+------------------------------------------------+\r\n|   16    | Topocentric apparent FK5, current equinox      |\r\n+---------+------------------------------------------------+\r\n|   17    | Topocentric apparent (Hour Angle, Declination) |\r\n+---------+------------------------------------------------+\r\n|   18    | Topocentric apparent (Azimuth, Elevation)      |\r\n+---------+------------------------------------------------+\r\n|   19    | Topocentric observed (Azimuth, Elevation)      |\r\n+---------+------------------------------------------------+\r\n|   20    | Topocentric observed (Hour Angle, Declination) |\r\n+---------+------------------------------------------------+\r\n\r\nFK5 equinox and epoch J2000.0, to FK4 equinox and epoch B1950.0\r\n---------------------------------------------------------------\r\n\r\nFirst obtain the FK5 equinox J2000.0 and epoch J2000.0 RA and Dec\r\ncoordinates in radians.\r\n\r\n::\r\n\r\n  >>> ra_j2000 = tpm.HMS(hh=12, mm=22, ss=54.899).to_radians()\r\n  >>> dec_j2000 = tpm.DMS(dd=15, mm=49, ss=20.57).to_radians()\r\n\r\nCreate a `V6C` vector for the object. Note that `pytpm.convert.cat2v6`\r\nwill accept a list of coordinates as well.\r\n\r\n::\r\n\r\n  >>> v6 = convert.cat2v6(ra_j2000, dec_j2000)\r\n\r\nNow convert to FK4 equinox B1950.0 but remaining at epoch J2000.0. In\r\nthe following `6` stands for FK5 equinox and epoch J2000.0 coordinates\r\nand `5` stands for FK4 equinox and epoch B1950.0. The epoch and equinox\r\nare specified using `epoch` and `equinox` keywords. But they can be\r\ninterpreted in different ways depending on the exact conversion\r\nrequested. In this case, they are applicable to the input coordinates.\r\n\r\n::\r\n\r\n  >>> v6_fk4 = convert.convertv6(v6, s1=6, s2=5, epoch=tpm.J2000, \r\n     ...: equinox=tpm.J2000)\r\n\r\nConvert V6C to catalog data and print results. Function\r\n`pytpm.convert.v62cat` will also accept a list of V6C objects.\r\n\r\n::\r\n\r\n  >>> d = convert.v62cat(v6_fk4, C=tpm.CB)\r\n  >>> print tpm.HMS(r=d['alpha'])\r\n   12H 20M 22.935S\r\n  >>> print tpm.DMS(r=d['delta'])\r\n  +16D 05' 58.024\"\r\n\r\nThe parameter `C` is the number of days in a century. The velocities in\r\nAU/day must be converted into \"/century. In the Besselian system, a\r\ncentury has approximately 36524.22 days, where as in the Julian system\r\na century has 36525.0 days. The former is used in FK4 and the latter is\r\nused in FK5. The default value is set to 36525.0.\r\n\r\nNote that the results above *do not agree* with the FK4 values given by\r\nSIMBAD. This is because the results are for the epoch J2000.0. Even\r\nthough the object doesn't have proper motion, the FK4 system is\r\nrotating with respect to FK5. This results in a fictitious proper\r\nmotion in the FK4 system. We must apply proper motion from epoch\r\nJ2000.0 to epoch B1950.0 to get the final result.\r\n\r\n::\r\n\r\n  >>> v6_fk4_ep1950 = convert.proper_motion(v6_fk4, tpm.B1950, tpm.J2000)\r\n\r\nFinally convert V6C to catalog data and print results. The final result\r\nis in FK4 equinox and epoch B1950.0. The final results agree with the\r\nvalues given by SIMBAD.\r\n\r\n::\r\n\r\n  >>> d = convert.v62cat(v6_fk4_ep1950, C=tpm.CB)\r\n  >>> print tpm.HMS(r=d['alpha'])\r\n   12H 20M 22.943S\r\n  >>> print tpm.DMS(r=d['delta'])\r\n  +16D 05' 58.241\"\r\n\r\n\r\nFK5 equinox and epoch J2000 to IAU 1958 Galactic System\r\n-------------------------------------------------------\r\n\r\nThe IAU 1958 galactic system is represented using state `4`. The result\r\nbelow is for the epoch J2000.0. The epoch of the Galactic coordinates\r\ngiven by SIMBAD is J2000.0. So the result obtained below is what we\r\nneed, i.e., we don't need to apply any proper motion corrections.\r\n\r\n::\r\n\r\n  >>> ra_j2000 = tpm.HMS(hh=12, mm=22, ss=54.899).to_radians()\r\n  >>> dec_j2000 = tpm.DMS(dd=15, mm=49, ss=20.57).to_radians()\r\n  >>> v6 = convert.cat2v6(ra_j2000, dec_j2000)\r\n\r\n  >>> v6_gal = convert.convertv6(v6, s1=6, s2=4, epoch=tpm.J2000, \r\n     ...: equinox=tpm.J2000)\r\n\r\n  >>> d = convert.v62cat(v6_gal)\r\n  >>> print tpm.r2d(d['alpha'])\r\n  271.136139562\r\n  >>> print tpm.r2d(d['delta'])\r\n  76.8988689751\r\n\r\n\r\nIAU 1958 Galactic to FK5 equinox and epoch J2000.0\r\n--------------------------------------------------\r\n\r\nHere we set the starting state to galactic i.e., `4` and the end state\r\nto FK5 equinox. Since the input coordinates are at epoch J2000.0, the\r\nfinal results will also be at epoch J2000.0, i.e., FK5 equinox and\r\nepoch J2000.0.\r\n\r\n::\r\n\r\n  >>> gal_lon = tpm.d2r(271.1361)\r\n  >>> gal_lat = tpm.d2r(76.8989)\r\n  >>> v6 = convert.cat2v6(gal_lon, gal_lat)\r\n\r\n  >>> v6_fk5 = convert.convertv6(v6, s1=4, s2=6, epoch=tpm.J2000)\r\n\r\n  >>> d = convert.v62cat(v6_fk5)\r\n  >>> print tpm.HMS(r=d['alpha'])\r\n   12H 22M 54.900S\r\n  >>> print tpm.DMS(r=d['delta'])\r\n  +15D 49' 20.683\"\r\n\r\nThe results are consistent with the accuracy of the input galactic\r\ncoordinates. \r\n\r\nFK5 equinox and epoch J2000 to IAU 1980 Ecliptic system\r\n-------------------------------------------------------\r\n\r\nThe ecliptic system is indicated using the state `3`. Here the epoch of\r\nthe output ecliptic coordinates will be J2000.0.\r\n\r\n::\r\n\r\n  >>> ra_j2000 = tpm.HMS(hh=12, mm=22, ss=54.899).to_radians()\r\n  >>> dec_j2000 = tpm.DMS(dd=15, mm=49, ss=20.57).to_radians()\r\n  >>> v6 = convert.cat2v6(ra_j2000, dec_j2000)\r\n\r\n  >>> v6_ecl = convert.convertv6(v6, s1=6, s2=3, epoch=tpm.J2000, \r\n     ...: equinox=tpm.J2000)\r\n\r\n  >>> d = convert.v62cat(v6_ecl)\r\n  >>> print tpm.r2d(d['alpha'])\r\n  178.78256462\r\n  >>> print tpm.r2d(d['delta'])\r\n  16.7597002513\r\n\r\nThe results agree with the results form the SLALIB (pyslalib_) routine\r\n`sla_eqecl`.\r\n\r\n\r\nIAU 1980 Ecliptic system to FK5 equinox and epoch J2000.0\r\n---------------------------------------------------------\r\n\r\nThe starting state is set to `3` for ecliptic and the end state is set\r\nto `6` for FK5 equinox and epoch J2000.0.\r\n\r\n::\r\n\r\n  >>> ecl_lon = tpm.d2r(178.78256462)\r\n  >>> ecl_lat = tpm.d2r(16.7597002513)\r\n  >>> v6 = convert.cat2v6(ecl_lon, ecl_lat)\r\n\r\n  >>> v6_fk5 = convert.convertv6(v6, s1=3, s2=6, epoch=tpm.J2000)\r\n\r\n  >>> d = convert.v62cat(v6_fk5)\r\n  >>> print tpm.HMS(r=d['alpha'])\r\n   12H 22M 54.898S\r\n  >>> print tpm.DMS(r=d['delta'])\r\n  +15D 49' 20.570\"\r\n\r\n\r\nFK5 equinox and epoch J2000 to Geocentric apparent\r\n--------------------------------------------------\r\n\r\nGeocentric apparent RA & Dec. for midnight of 2010/1/1 is calculated as\r\nshown below. The state identification number for geocentric apparent\r\nposition is `11`.\r\n\r\nObtain UTC and TDB time for the time of observation.\r\n\r\n::\r\n\r\n  >>> utc = tpm.gcal2j(2010, 1, 1) - 0.5  # midnight\r\n  >>> tdb = tpm.utc2tdb(utc)\r\n\r\nObtain coordinates and `V6C` vector.\r\n\r\n::\r\n\r\n  >>> ra_j2000 = tpm.HMS(hh=12, mm=22, ss=54.899).to_radians()\r\n  >>> dec_j2000 = tpm.DMS(dd=15, mm=49, ss=20.57).to_radians()\r\n  >>> v6 = convert.cat2v6(ra_j2000, dec_j2000)\r\n\r\nApply proper motion from epoch J2000.0 to epoch of observation. In this\r\nexample, this is not needed since proper motion is zero. But we do this\r\nfor completeness. The result is FK5 J2000 current epoch.\r\n\r\n::\r\n\r\n  >>> v6 = convert.proper_motion(v6, tt, tpm.J2000)\r\n\r\nConvert coordinates from FK5 equinox J2000, current epoch to FK5\r\nequinox and epoch of date.\r\n\r\n::\r\n\r\n  >>> v6_gc = convert.convertv6(v6, s1=6, s2=11, utc=utc)\r\n  >>> d = convert.v62cat(v6_gc)\r\n  >>> print tpm.r2d(d['alpha'])\r\n  185.860038856\r\n  >>> print tpm.r2d(d['delta'])\r\n  15.7631353482\r\n\r\nThe result from SLALIB (pyslalib_) for the equivalent conversion, using\r\nthe `sla_map` function is given below.\r\n\r\n::\r\n\r\n  >>> utc = slalib.sla_caldj(2010, 1, 1)[0]  # midnight\r\n  >>> tt = slalib.sla_dtt(utc) / 86400.0 + utc\r\n\r\n  >>> r, d = slalib.sla_map(ra_j2000, dec_j2000, 0, 0, 0, 0.0, 2000.0,\r\n     ...: tt)\r\n\r\n  >>> tpm.r2d(r)\r\n  185.86002229414245\r\n  >>> tpm.r2d(d)\r\n  15.763142468669891\r\n\r\nThe difference is about 0.06 arc-sec in RA and about 0.03 arc-sec\r\nin Dec.::\r\n\r\n  >>> (tpm.r2d(r) - 185.860038856) * 3600.0\r\n  -0.059622687126648088\r\n  >>> (tpm.r2d(d) - 15.7631353482) * 3600.0\r\n  0.025633691604554087\r\n\r\n\r\nFK5 equinox and epoch J2000 to topocentric observed\r\n---------------------------------------------------\r\n\r\nTopocentric observed azimuth and elevation (and zenith distance) for an\r\nobserver at the default location (KPNO) is calculated for 2010/1/1\r\nmid-day. The final state i.e., apparent topocentric Az & El, is `19`.\r\n\r\nFor midnight 2010/1/1 this object is below the horizon and hence the\r\nrefraction calculations are not reliable. So we use mid-day for the\r\nfollowing example.\r\n\r\n::\r\n\r\n  >>> utc = tpm.gcal2j(2010, 1, 1)  # mid-day\r\n  >>> tt = tpm.utc2tdb(utc)\r\n\r\n  >>> ra_j2000 = tpm.HMS(hh=12, mm=22, ss=54.899).to_radians()\r\n  >>> dec_j2000 = tpm.DMS(dd=15, mm=49, ss=20.57).to_radians()\r\n  >>> v6 = convert.cat2v6(ra_j2000, dec_j2000)\r\n\r\n  >>> v6 = convert.proper_motion(v6, tt, tpm.J2000)\r\n\r\n  >>> v6_app = convert.convertv6(v6, s1=6, s2=19, utc=utc)\r\n\r\n  >>> d = convert.v62cat(v6_app)\r\n  >>> print tpm.r2d(d['alpha']), 90 - tpm.r2d(d['delta'])\r\n  133.49820871 22.0162437585\r\n\r\nTo calculate the observed hour angle and declination the `v6_app`\r\nvector obtained above can be used as input. We don't need to go back to\r\nthe FK5 equinox and epoch J2000.0 values. The input state is now `19`\r\nand the output, i.e., topocentric observed HA & Dec, is `20`.\r\n\r\n::\r\n\r\n  >>> v6_hadec = convert.convertv6(v6_app, s1=19, s2=20, utc=utc)\r\n\r\n  >>> d = convert.v62cat(v6_hadec)\r\n  >>> print tpm.r2d(d['alpha'])\r\n  343.586827647\r\n  >>> print tpm.r2d(d['delta'])\r\n  15.7683070508\r\n\r\nTo calculate the observed RA we need to find the LAST, since TPM only\r\nprovides apparent RA. The observed RA can be found by subtracting hour\r\nangle from LAST. This is one situation where we need to access the\r\nunderlying TPM machinery provided in `pytpm.tpm`. Please consult the\r\nTPM manual and the PyTPM documentation for more information.\r\n\r\n::\r\n\r\n  >>> tstate = tpm.TSTATE()\r\n  >>> tpm.tpm_data(tstate, tpm.TPM_INIT)\r\n  >>> tstate.utc = utc\r\n  >>> tstate.delta_ut = tpm.delta_UT(utc)\r\n  >>> tstate.delta_at = tpm.delta_AT(utc)\r\n  >>> tstate.lon = tpm.d2r(-111.598333)\r\n  >>> tstate.lat = tpm.d2r(31.956389)\r\n  >>> tpm.tpm_data(tstate, tpm.TPM_ALL)\r\n  >>> last = tpm.r2d(tpm.r2r(tstate.last))\r\n  >>> last - tpm.r2d(d['alpha']) + 360.0\r\n  185.85569737491355  \r\n\r\nThe same calculation with SLALIB, using `sla_aop` produces results that\r\nagree with PyTPM.\r\n\r\n::\r\n\r\n  >>> dut = tpm.delta_UT(tpm.gcal2j(2010, 1, 1))  # DUT for mid-day.\r\n  >>> utc = slalib.sla_caldj(2010, 1, 1)[0] + 0.5  # mid-day.\r\n  >>> tt = slalib.sla_dtt(utc) / 86400.0 + utc\r\n\r\n  >>> r, d = slalib.sla_map(ra_j2000, dec_j2000, 0, 0, 0, 0.0, 2000.0,\r\n     ...: tt)\r\n\r\n  >>> lon = tpm.d2r(-111.598333)\r\n  >>> lat = tpm.d2r(31.956389)\r\n\r\n  >>> az, zd, ha, dec, ra = slalib.sla_aop(r, d, utc, dut, lon, lat,\r\n     ...: 2093.093, 0, 0, 273.15, 1013.25, 0, 0.550, 0.0065)\r\n\r\n  >>> tpm.r2d(tpm.r2r(az)), tpm.r2d(tpm.r2r(zd))\r\n  133.498195532 22.0162383595\r\n\r\nThe hour angle, declination and right ascension are::\r\n\r\n  >>> print tpm.r2d(tpm.r2r(ha))\r\n  343.586827289\r\n  >>> print tpm.r2d(tpm.r2r(dec))\r\n  15.7683143606\r\n  >>> print tpm.r2d(tpm.r2r(ra))\r\n  185.855680678\r\n\r\nConsult the appropriate section of the PyTPM documentation for a\r\ndetailed comparison between PyTPM and SLALIB.\r\n\r\nConverting positions and velocities\r\n-----------------------------------\r\n\r\nConverting positions and velocities follow exactly the same procedure\r\nas the examples shown above. The `convert.cat2v6` function will take\r\nproper motions, radial velocity and parallax in addition to\r\nposition. The returned dictionary will have appropriate fields for\r\nfinal proper motions, radial velocity and parallax.\r\n\r\nSee the file `doc/examples/conversions.py` for a full example. The file\r\nis also included with the HTML documentation and with the source\r\ndistribution. \r\n\r\nFor example if `tab` is a table that contains full 6-D coordinates with\r\nkeys `ra`, `dec`, `pma`, `pmd`, `px` and `rv`, then a full `V6C` vector\r\ncan be constructed as::\r\n\r\n  >>> v6 = convert.cat2v6(tab['ra'], tab['dec'], tab['pma'],\r\n     ...: tab['pmd'], tab['px'], rv, tpm.CJ)\r\n\r\nSee docstring of the `convert.convertv6` function for the required units\r\nfor each of these.\r\n\r\nTo convert this from, say FK5 to Ecliptic, at the same epoch, we can\r\nuse::\r\n\r\n  >>> v6o = convert.convertv6(v6, s1=6, s2=3)\r\n  >>> cat = convert.v62cat(v6o)\r\n\r\nThe variable `cat` will contain a dictionary, or a list of\r\ndictionaries, with the relevant catalog quantities. See the docstring\r\nof this `convert.v62cat` for units of output quantities.\r\n\r\n\r\nCredits and license\r\n===================\r\n\r\n`Jeffrey W Percival`_ wrote the TPM__ C library. See\r\n`src/tpm/TPM_LICENSE.txt` for TPM license.\r\n\r\nThe version used here was obtained from the coords_ package (version\r\n0.36) of the astrolib_ library. Some C source files missing from the\r\nabove source were provided by Jeff Percival.\r\n\r\nPython and Cython code for PyTPM is released under the BSD license; see\r\n`LICENSE.txt`.\r\n\r\nPlease send email to *prasanthhn*, at the *gmail.com* domain, for\r\nreporting errors, and for comments and suggestions.\r\n\r\n__ `Telescope Pointing Machine`_\r\n\r\n..  LocalWords:  pyslalib SLALIB sla caldj utc tstate TPM PyTPM pytpm tpm WIYN\r\n..  LocalWords:  numpydoc GCC virtualenvwrapper virtualenv LocalWords ReST\r\n..  LocalWords:  docstring", "description_content_type": null, "docs_url": "https://pythonhosted.org/PyTPM/", "download_url": "UNKNOWN", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/phn/pytpm", "keywords": "", "license": "BSD", "maintainer": "", "maintainer_email": "", "name": "PyTPM", "package_url": "https://pypi.org/project/PyTPM/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/PyTPM/", "project_urls": {"Download": "UNKNOWN", "Homepage": "https://github.com/phn/pytpm"}, "release_url": "https://pypi.org/project/PyTPM/0.7.1/", "requires_dist": null, "requires_python": null, "summary": "Python interface to Telescope Pointing Machine C library.", "version": "0.7.1", "yanked": false, "html_description": "<div class=\"project-description\">\n            <div id=\"python-interface-to-the-tpm-c-library\">\n<h2>Python interface to the TPM C library</h2>\n<p>** DEVELOPMENT CEASED **</p>\n<p>PyTPM is a Python interface to the <a href=\"http://www.sal.wisc.edu/~jwp/astro/tpm/tpm.html\" rel=\"nofollow\">Telescope Pointing Machine</a> (TPM)\nlibrary. TPM is a C library written by <a href=\"http://www.sal.wisc.edu/~jwp/\" rel=\"nofollow\">Jeffrey W Percival</a>, for performing\ncoordinate conversions between several astronomical coordinate systems.</p>\n<p>TPM was designed with the aim of incorporating it into telescope\ncontrol systems. To meet this design goal, TPM offers control over\ncalculations carried out during coordinate conversions. Some of these\ncalculations must be performed frequently, for example time related\ncalculations. Others need to be performed only once per night, for\nexample nutation and precession matrices. TPM allows the user to select\nthe exact calculations to be performed. This enables the user to\ncontrol the computational load, which is important in telescope control\nsystems. TPM C library is used by the <a href=\"http://www.noao.edu/wiyn/wiyn.html\" rel=\"nofollow\">KPNO WIYN observatory</a> and the\n<a href=\"http://www.astro.wisc.edu/wham/\" rel=\"nofollow\">WHAM</a> projects.</p>\n<p>PyTPM is not a complete astrometry package. The aim is to provide\naccess to the TPM C code from Python. TPM machinery can be directly\naccessed using the <cite>pytpm.tpm</cite> sub-module. The sub-module\n<cite>pytpm.convert</cite> has several convenience functions that can be used for\nperforming coordinate conversions. The latter is sufficient for most,\nbut not all, calculations. You should read the <a href=\"http://www.sal.wisc.edu/~jwp/astro/tpm/tpm.html\" rel=\"nofollow\">TPM manual</a> before\nattempting to use the <cite>pytpm.tpm</cite> module. The manual is present in the\nsource code repository and is also included with the PyTPM\ndocumentation</p>\n<p>Python interface to TPM C code is written using <a href=\"http://www.cython.org/\" rel=\"nofollow\">Cython</a>.</p>\n</div>\n<div id=\"installing-pytpm\">\n<h2>Installing PyTPM</h2>\n<p>PyTPM requires the following:</p>\n<ul>\n<li>Python 2.6, 2.7 or 3.2.</li>\n<li>GCC.</li>\n<li>The <a href=\"http://packages.python.org/distribute/\" rel=\"nofollow\">Distribute</a> package.</li>\n<li><a href=\"http://pypi.python.org/pypi/nose\" rel=\"nofollow\">Nose</a> for running tests.</li>\n<li><a href=\"http://www.cython.org/\" rel=\"nofollow\">Cython</a>, only if the Cython output needs to be regenerated.</li>\n</ul>\n<p>To build the documentation <a href=\"http://sphinx.pocoo.org/\" rel=\"nofollow\">Sphinx</a> and the <a href=\"http://pypi.python.org/pypi/numpydoc\" rel=\"nofollow\">numpydoc</a> Sphinx extension\nis required.</p>\n<p>PyTPM was tested on Ubuntu 10.10 and 11.04.</p>\n</div>\n<div id=\"installation\">\n<h2>Installation</h2>\n<div>\n<p>Important</p>\n<p>The file <cite>src/tpm/delta_AT.c</cite> must be updated when Delta-AT is\nchanged by the <a href=\"http://www.iers.org/\" rel=\"nofollow\">IERS</a>, and PyTPM Cython code must\nre-compiled. Update the file and just run setup.py again. A new\nversion of PyTPM will be released when this change occurs.</p>\n</div>\n<p>If you don\u2019t have <a href=\"http://packages.python.org/distribute/\" rel=\"nofollow\">Distribute</a>, then install it. Then do one of the\nfollowing:</p>\n<ul>\n<li><p><a href=\"http://pypi.python.org/pypi/pip\" rel=\"nofollow\">pip</a> or <cite>easy_install</cite></p>\n<p>Install <a href=\"http://pypi.python.org/pypi/pip\" rel=\"nofollow\">pip</a> and then run <cite>pip install pytpm</cite>.</p>\n<p>If <cite>easy_install</cite> is available then <cite>easy_install pytpm</cite> will also\nwork. <a href=\"http://packages.python.org/distribute/\" rel=\"nofollow\">Distribute</a> comes with easy_install. <a href=\"http://pypi.python.org/pypi/pip\" rel=\"nofollow\">pip</a> itself can be\ninstalled using the command <cite>easy_install pip</cite>.</p>\n</li>\n</ul>\n<p>or</p>\n<ul>\n<li><p>Manual installation.</p>\n<p>Download the distribution from the <a href=\"http://pypi.python.org/pypi/PyTPM\" rel=\"nofollow\">pypi page for the project</a>. Then\nrun <cite>python setup.py install</cite>. Use the <cite>\u2013prefix &lt;dest&gt;</cite> or <cite>\u2013user</cite>\narguments to change the installation location.</p>\n</li>\n</ul>\n<p>With both these methods, <a href=\"http://pypi.python.org/pypi/virtualenv\" rel=\"nofollow\">virtualenv</a> and <a href=\"http://www.doughellmann.com/projects/virtualenvwrapper/\" rel=\"nofollow\">virtualenvwrapper</a> can be\nused. These tools enable easy installation and maintenance of Python\npackages.</p>\n<p>To run tests, and to build documentation, the manual installation\nmethod has to be followed. Run <cite>python setup.py test</cite> and then run\n<cite>python setup.py install</cite>. To build documentation, run <cite>make html</cite> in\nthe <cite>doc</cite> directory.</p>\n</div>\n<div id=\"examples\">\n<h2>Examples</h2>\n<p>Detailed documentation is available at\n<a href=\"http://phn.github.com/pytpm\" rel=\"nofollow\">http://phn.github.com/pytpm</a>. Documentation in HTML format can also be\ndownloaded from the <a href=\"http://pypi.python.org/pypi/PyTPM\" rel=\"nofollow\">pypi page for the project</a>. Documentation in ReST\nformat is available in the <cite>doc</cite> directory of the distribution.</p>\n<p>PyTPM can be used to convert <em>positions and velocities</em> in a given\nastronomical coordinate system into another. Examples of doing this are\nin the <cite>examples</cite> folder of the source code repository and is also\nincluded with the HTML documentation.</p>\n<p>You should read the <a href=\"http://www.sal.wisc.edu/~jwp/astro/tpm/tpm.html\" rel=\"nofollow\">TPM manual</a> before attempting to use the\n<cite>pytpm.tpm</cite> module.  The manual is also available in the source code\nrepository and the HTML documentation.</p>\n<p>In the following examples <a href=\"http://simbad.u-strasbg.fr/simbad/sim-basic?Ident=M100&amp;submit=SIMBAD+search\" rel=\"nofollow\">coordinates of M100</a> is converted between\ndifferent systems.</p>\n<p>The following examples use the convenience function\n<cite>pytpm.convert.convertv6</cite>, instead of directly using the underlying TPM\nfunctions. The documentation has examples of using the latter.</p>\n<p>The <cite>convertv6</cite> function takes the following arguments. Not all of\nthese need to be specified for a given conversion.</p>\n<table>\n<colgroup>\n<col>\n<col>\n</colgroup>\n<thead>\n<tr><th>Parameter</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr><td>v6</td>\n<td>one V6C vector or a list of V6C vectors.</td>\n</tr>\n<tr><td>s1</td>\n<td>start state</td>\n</tr>\n<tr><td>s2</td>\n<td>end state</td>\n</tr>\n<tr><td>epoch</td>\n<td>epoch of the coordinates as a Julian date</td>\n</tr>\n<tr><td>equinox</td>\n<td>equinox of the coordinates as Julian date</td>\n</tr>\n<tr><td>utc</td>\n<td>time of \u201cobservation\u201d as a Julian date;\nexact meaning depends on the type of conversion;\ndefaults to the epoch J2000.0</td>\n</tr>\n<tr><td>delta_ut</td>\n<td>UT1 - UTC in seconds.</td>\n</tr>\n<tr><td>delta_at</td>\n<td>TAI - UTC in seconds.</td>\n</tr>\n<tr><td>lon</td>\n<td>geodetic longitude in degrees</td>\n</tr>\n<tr><td>lat</td>\n<td>geodetic latitude in degrees</td>\n</tr>\n<tr><td>alt</td>\n<td>altitude in meters</td>\n</tr>\n<tr><td>xpole</td>\n<td>ploar motion in radians</td>\n</tr>\n<tr><td>ypole</td>\n<td>ploar motion in radians</td>\n</tr>\n<tr><td>T</td>\n<td>temperature in kelvin</td>\n</tr>\n<tr><td>P</td>\n<td>pressure in milli-bars</td>\n</tr>\n<tr><td>H</td>\n<td>relative humidity (0-1)</td>\n</tr>\n<tr><td>wavelength</td>\n<td>wavelength of observation in microns</td>\n</tr>\n</tbody>\n</table>\n<p>A <cite>V6C</cite> object is a 6-D vector that stores positions and velocities in\nCartesian coordinates. The function <cite>pytpm.convert.v62cat</cite> can be used\nto create a <cite>V6C</cite> object from catalog data.  This function will accept\nscalar or list of coordinates. Function <cite>pytpm.convert.v62cat</cite> can\nconvert <cite>V6C</cite> objects to catalog coordinates. The coordinates are\nreturned as a dictionary. This function will also take a list of <cite>V6C</cite>\nobjects and will return a list of dictionaries.</p>\n<p>Coordinate systems are specified using integers or integer\nconstants. These are referred to as <cite>states</cite>.The following are some of\nthe important states.</p>\n<table>\n<colgroup>\n<col>\n<col>\n</colgroup>\n<thead>\n<tr><th>State</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr><td>3</td>\n<td>IAU 1980 Ecliptic system</td>\n</tr>\n<tr><td>4</td>\n<td>IAU 1958 Galactic system</td>\n</tr>\n<tr><td>5</td>\n<td>Heliocentric mean FK4 system, B1950 equinox</td>\n</tr>\n<tr><td>6</td>\n<td>Heliocentric mean FK5 system, J2000 equinox</td>\n</tr>\n<tr><td>11</td>\n<td>Geocentric apparent FK5, current equinox</td>\n</tr>\n<tr><td>16</td>\n<td>Topocentric apparent FK5, current equinox</td>\n</tr>\n<tr><td>17</td>\n<td>Topocentric apparent (Hour Angle, Declination)</td>\n</tr>\n<tr><td>18</td>\n<td>Topocentric apparent (Azimuth, Elevation)</td>\n</tr>\n<tr><td>19</td>\n<td>Topocentric observed (Azimuth, Elevation)</td>\n</tr>\n<tr><td>20</td>\n<td>Topocentric observed (Hour Angle, Declination)</td>\n</tr>\n</tbody>\n</table>\n<div id=\"fk5-equinox-and-epoch-j2000-0-to-fk4-equinox-and-epoch-b1950-0\">\n<h3>FK5 equinox and epoch J2000.0, to FK4 equinox and epoch B1950.0</h3>\n<p>First obtain the FK5 equinox J2000.0 and epoch J2000.0 RA and Dec\ncoordinates in radians.</p>\n<pre>&gt;&gt;&gt; ra_j2000 = tpm.HMS(hh=12, mm=22, ss=54.899).to_radians()\n&gt;&gt;&gt; dec_j2000 = tpm.DMS(dd=15, mm=49, ss=20.57).to_radians()\n</pre>\n<p>Create a <cite>V6C</cite> vector for the object. Note that <cite>pytpm.convert.cat2v6</cite>\nwill accept a list of coordinates as well.</p>\n<pre>&gt;&gt;&gt; v6 = convert.cat2v6(ra_j2000, dec_j2000)\n</pre>\n<p>Now convert to FK4 equinox B1950.0 but remaining at epoch J2000.0. In\nthe following <cite>6</cite> stands for FK5 equinox and epoch J2000.0 coordinates\nand <cite>5</cite> stands for FK4 equinox and epoch B1950.0. The epoch and equinox\nare specified using <cite>epoch</cite> and <cite>equinox</cite> keywords. But they can be\ninterpreted in different ways depending on the exact conversion\nrequested. In this case, they are applicable to the input coordinates.</p>\n<pre>&gt;&gt;&gt; v6_fk4 = convert.convertv6(v6, s1=6, s2=5, epoch=tpm.J2000,\n   ...: equinox=tpm.J2000)\n</pre>\n<p>Convert V6C to catalog data and print results. Function\n<cite>pytpm.convert.v62cat</cite> will also accept a list of V6C objects.</p>\n<pre>&gt;&gt;&gt; d = convert.v62cat(v6_fk4, C=tpm.CB)\n&gt;&gt;&gt; print tpm.HMS(r=d['alpha'])\n 12H 20M 22.935S\n&gt;&gt;&gt; print tpm.DMS(r=d['delta'])\n+16D 05' 58.024\"\n</pre>\n<p>The parameter <cite>C</cite> is the number of days in a century. The velocities in\nAU/day must be converted into \u201c/century. In the Besselian system, a\ncentury has approximately 36524.22 days, where as in the Julian system\na century has 36525.0 days. The former is used in FK4 and the latter is\nused in FK5. The default value is set to 36525.0.</p>\n<p>Note that the results above <em>do not agree</em> with the FK4 values given by\nSIMBAD. This is because the results are for the epoch J2000.0. Even\nthough the object doesn\u2019t have proper motion, the FK4 system is\nrotating with respect to FK5. This results in a fictitious proper\nmotion in the FK4 system. We must apply proper motion from epoch\nJ2000.0 to epoch B1950.0 to get the final result.</p>\n<pre>&gt;&gt;&gt; v6_fk4_ep1950 = convert.proper_motion(v6_fk4, tpm.B1950, tpm.J2000)\n</pre>\n<p>Finally convert V6C to catalog data and print results. The final result\nis in FK4 equinox and epoch B1950.0. The final results agree with the\nvalues given by SIMBAD.</p>\n<pre>&gt;&gt;&gt; d = convert.v62cat(v6_fk4_ep1950, C=tpm.CB)\n&gt;&gt;&gt; print tpm.HMS(r=d['alpha'])\n 12H 20M 22.943S\n&gt;&gt;&gt; print tpm.DMS(r=d['delta'])\n+16D 05' 58.241\"\n</pre>\n</div>\n<div id=\"fk5-equinox-and-epoch-j2000-to-iau-1958-galactic-system\">\n<h3>FK5 equinox and epoch J2000 to IAU 1958 Galactic System</h3>\n<p>The IAU 1958 galactic system is represented using state <cite>4</cite>. The result\nbelow is for the epoch J2000.0. The epoch of the Galactic coordinates\ngiven by SIMBAD is J2000.0. So the result obtained below is what we\nneed, i.e., we don\u2019t need to apply any proper motion corrections.</p>\n<pre>&gt;&gt;&gt; ra_j2000 = tpm.HMS(hh=12, mm=22, ss=54.899).to_radians()\n&gt;&gt;&gt; dec_j2000 = tpm.DMS(dd=15, mm=49, ss=20.57).to_radians()\n&gt;&gt;&gt; v6 = convert.cat2v6(ra_j2000, dec_j2000)\n\n&gt;&gt;&gt; v6_gal = convert.convertv6(v6, s1=6, s2=4, epoch=tpm.J2000,\n   ...: equinox=tpm.J2000)\n\n&gt;&gt;&gt; d = convert.v62cat(v6_gal)\n&gt;&gt;&gt; print tpm.r2d(d['alpha'])\n271.136139562\n&gt;&gt;&gt; print tpm.r2d(d['delta'])\n76.8988689751\n</pre>\n</div>\n<div id=\"iau-1958-galactic-to-fk5-equinox-and-epoch-j2000-0\">\n<h3>IAU 1958 Galactic to FK5 equinox and epoch J2000.0</h3>\n<p>Here we set the starting state to galactic i.e., <cite>4</cite> and the end state\nto FK5 equinox. Since the input coordinates are at epoch J2000.0, the\nfinal results will also be at epoch J2000.0, i.e., FK5 equinox and\nepoch J2000.0.</p>\n<pre>&gt;&gt;&gt; gal_lon = tpm.d2r(271.1361)\n&gt;&gt;&gt; gal_lat = tpm.d2r(76.8989)\n&gt;&gt;&gt; v6 = convert.cat2v6(gal_lon, gal_lat)\n\n&gt;&gt;&gt; v6_fk5 = convert.convertv6(v6, s1=4, s2=6, epoch=tpm.J2000)\n\n&gt;&gt;&gt; d = convert.v62cat(v6_fk5)\n&gt;&gt;&gt; print tpm.HMS(r=d['alpha'])\n 12H 22M 54.900S\n&gt;&gt;&gt; print tpm.DMS(r=d['delta'])\n+15D 49' 20.683\"\n</pre>\n<p>The results are consistent with the accuracy of the input galactic\ncoordinates.</p>\n</div>\n<div id=\"fk5-equinox-and-epoch-j2000-to-iau-1980-ecliptic-system\">\n<h3>FK5 equinox and epoch J2000 to IAU 1980 Ecliptic system</h3>\n<p>The ecliptic system is indicated using the state <cite>3</cite>. Here the epoch of\nthe output ecliptic coordinates will be J2000.0.</p>\n<pre>&gt;&gt;&gt; ra_j2000 = tpm.HMS(hh=12, mm=22, ss=54.899).to_radians()\n&gt;&gt;&gt; dec_j2000 = tpm.DMS(dd=15, mm=49, ss=20.57).to_radians()\n&gt;&gt;&gt; v6 = convert.cat2v6(ra_j2000, dec_j2000)\n\n&gt;&gt;&gt; v6_ecl = convert.convertv6(v6, s1=6, s2=3, epoch=tpm.J2000,\n   ...: equinox=tpm.J2000)\n\n&gt;&gt;&gt; d = convert.v62cat(v6_ecl)\n&gt;&gt;&gt; print tpm.r2d(d['alpha'])\n178.78256462\n&gt;&gt;&gt; print tpm.r2d(d['delta'])\n16.7597002513\n</pre>\n<p>The results agree with the results form the SLALIB (<a href=\"https://github.com/scottransom/pyslalib\" rel=\"nofollow\">pyslalib</a>) routine\n<cite>sla_eqecl</cite>.</p>\n</div>\n<div id=\"iau-1980-ecliptic-system-to-fk5-equinox-and-epoch-j2000-0\">\n<h3>IAU 1980 Ecliptic system to FK5 equinox and epoch J2000.0</h3>\n<p>The starting state is set to <cite>3</cite> for ecliptic and the end state is set\nto <cite>6</cite> for FK5 equinox and epoch J2000.0.</p>\n<pre>&gt;&gt;&gt; ecl_lon = tpm.d2r(178.78256462)\n&gt;&gt;&gt; ecl_lat = tpm.d2r(16.7597002513)\n&gt;&gt;&gt; v6 = convert.cat2v6(ecl_lon, ecl_lat)\n\n&gt;&gt;&gt; v6_fk5 = convert.convertv6(v6, s1=3, s2=6, epoch=tpm.J2000)\n\n&gt;&gt;&gt; d = convert.v62cat(v6_fk5)\n&gt;&gt;&gt; print tpm.HMS(r=d['alpha'])\n 12H 22M 54.898S\n&gt;&gt;&gt; print tpm.DMS(r=d['delta'])\n+15D 49' 20.570\"\n</pre>\n</div>\n<div id=\"fk5-equinox-and-epoch-j2000-to-geocentric-apparent\">\n<h3>FK5 equinox and epoch J2000 to Geocentric apparent</h3>\n<p>Geocentric apparent RA &amp; Dec. for midnight of 2010/1/1 is calculated as\nshown below. The state identification number for geocentric apparent\nposition is <cite>11</cite>.</p>\n<p>Obtain UTC and TDB time for the time of observation.</p>\n<pre>&gt;&gt;&gt; utc = tpm.gcal2j(2010, 1, 1) - 0.5  # midnight\n&gt;&gt;&gt; tdb = tpm.utc2tdb(utc)\n</pre>\n<p>Obtain coordinates and <cite>V6C</cite> vector.</p>\n<pre>&gt;&gt;&gt; ra_j2000 = tpm.HMS(hh=12, mm=22, ss=54.899).to_radians()\n&gt;&gt;&gt; dec_j2000 = tpm.DMS(dd=15, mm=49, ss=20.57).to_radians()\n&gt;&gt;&gt; v6 = convert.cat2v6(ra_j2000, dec_j2000)\n</pre>\n<p>Apply proper motion from epoch J2000.0 to epoch of observation. In this\nexample, this is not needed since proper motion is zero. But we do this\nfor completeness. The result is FK5 J2000 current epoch.</p>\n<pre>&gt;&gt;&gt; v6 = convert.proper_motion(v6, tt, tpm.J2000)\n</pre>\n<p>Convert coordinates from FK5 equinox J2000, current epoch to FK5\nequinox and epoch of date.</p>\n<pre>&gt;&gt;&gt; v6_gc = convert.convertv6(v6, s1=6, s2=11, utc=utc)\n&gt;&gt;&gt; d = convert.v62cat(v6_gc)\n&gt;&gt;&gt; print tpm.r2d(d['alpha'])\n185.860038856\n&gt;&gt;&gt; print tpm.r2d(d['delta'])\n15.7631353482\n</pre>\n<p>The result from SLALIB (<a href=\"https://github.com/scottransom/pyslalib\" rel=\"nofollow\">pyslalib</a>) for the equivalent conversion, using\nthe <cite>sla_map</cite> function is given below.</p>\n<pre>&gt;&gt;&gt; utc = slalib.sla_caldj(2010, 1, 1)[0]  # midnight\n&gt;&gt;&gt; tt = slalib.sla_dtt(utc) / 86400.0 + utc\n\n&gt;&gt;&gt; r, d = slalib.sla_map(ra_j2000, dec_j2000, 0, 0, 0, 0.0, 2000.0,\n   ...: tt)\n\n&gt;&gt;&gt; tpm.r2d(r)\n185.86002229414245\n&gt;&gt;&gt; tpm.r2d(d)\n15.763142468669891\n</pre>\n<p>The difference is about 0.06 arc-sec in RA and about 0.03 arc-sec\nin Dec.:</p>\n<pre>&gt;&gt;&gt; (tpm.r2d(r) - 185.860038856) * 3600.0\n-0.059622687126648088\n&gt;&gt;&gt; (tpm.r2d(d) - 15.7631353482) * 3600.0\n0.025633691604554087\n</pre>\n</div>\n<div id=\"fk5-equinox-and-epoch-j2000-to-topocentric-observed\">\n<h3>FK5 equinox and epoch J2000 to topocentric observed</h3>\n<p>Topocentric observed azimuth and elevation (and zenith distance) for an\nobserver at the default location (KPNO) is calculated for 2010/1/1\nmid-day. The final state i.e., apparent topocentric Az &amp; El, is <cite>19</cite>.</p>\n<p>For midnight 2010/1/1 this object is below the horizon and hence the\nrefraction calculations are not reliable. So we use mid-day for the\nfollowing example.</p>\n<pre>&gt;&gt;&gt; utc = tpm.gcal2j(2010, 1, 1)  # mid-day\n&gt;&gt;&gt; tt = tpm.utc2tdb(utc)\n\n&gt;&gt;&gt; ra_j2000 = tpm.HMS(hh=12, mm=22, ss=54.899).to_radians()\n&gt;&gt;&gt; dec_j2000 = tpm.DMS(dd=15, mm=49, ss=20.57).to_radians()\n&gt;&gt;&gt; v6 = convert.cat2v6(ra_j2000, dec_j2000)\n\n&gt;&gt;&gt; v6 = convert.proper_motion(v6, tt, tpm.J2000)\n\n&gt;&gt;&gt; v6_app = convert.convertv6(v6, s1=6, s2=19, utc=utc)\n\n&gt;&gt;&gt; d = convert.v62cat(v6_app)\n&gt;&gt;&gt; print tpm.r2d(d['alpha']), 90 - tpm.r2d(d['delta'])\n133.49820871 22.0162437585\n</pre>\n<p>To calculate the observed hour angle and declination the <cite>v6_app</cite>\nvector obtained above can be used as input. We don\u2019t need to go back to\nthe FK5 equinox and epoch J2000.0 values. The input state is now <cite>19</cite>\nand the output, i.e., topocentric observed HA &amp; Dec, is <cite>20</cite>.</p>\n<pre>&gt;&gt;&gt; v6_hadec = convert.convertv6(v6_app, s1=19, s2=20, utc=utc)\n\n&gt;&gt;&gt; d = convert.v62cat(v6_hadec)\n&gt;&gt;&gt; print tpm.r2d(d['alpha'])\n343.586827647\n&gt;&gt;&gt; print tpm.r2d(d['delta'])\n15.7683070508\n</pre>\n<p>To calculate the observed RA we need to find the LAST, since TPM only\nprovides apparent RA. The observed RA can be found by subtracting hour\nangle from LAST. This is one situation where we need to access the\nunderlying TPM machinery provided in <cite>pytpm.tpm</cite>. Please consult the\nTPM manual and the PyTPM documentation for more information.</p>\n<pre>&gt;&gt;&gt; tstate = tpm.TSTATE()\n&gt;&gt;&gt; tpm.tpm_data(tstate, tpm.TPM_INIT)\n&gt;&gt;&gt; tstate.utc = utc\n&gt;&gt;&gt; tstate.delta_ut = tpm.delta_UT(utc)\n&gt;&gt;&gt; tstate.delta_at = tpm.delta_AT(utc)\n&gt;&gt;&gt; tstate.lon = tpm.d2r(-111.598333)\n&gt;&gt;&gt; tstate.lat = tpm.d2r(31.956389)\n&gt;&gt;&gt; tpm.tpm_data(tstate, tpm.TPM_ALL)\n&gt;&gt;&gt; last = tpm.r2d(tpm.r2r(tstate.last))\n&gt;&gt;&gt; last - tpm.r2d(d['alpha']) + 360.0\n185.85569737491355\n</pre>\n<p>The same calculation with SLALIB, using <cite>sla_aop</cite> produces results that\nagree with PyTPM.</p>\n<pre>&gt;&gt;&gt; dut = tpm.delta_UT(tpm.gcal2j(2010, 1, 1))  # DUT for mid-day.\n&gt;&gt;&gt; utc = slalib.sla_caldj(2010, 1, 1)[0] + 0.5  # mid-day.\n&gt;&gt;&gt; tt = slalib.sla_dtt(utc) / 86400.0 + utc\n\n&gt;&gt;&gt; r, d = slalib.sla_map(ra_j2000, dec_j2000, 0, 0, 0, 0.0, 2000.0,\n   ...: tt)\n\n&gt;&gt;&gt; lon = tpm.d2r(-111.598333)\n&gt;&gt;&gt; lat = tpm.d2r(31.956389)\n\n&gt;&gt;&gt; az, zd, ha, dec, ra = slalib.sla_aop(r, d, utc, dut, lon, lat,\n   ...: 2093.093, 0, 0, 273.15, 1013.25, 0, 0.550, 0.0065)\n\n&gt;&gt;&gt; tpm.r2d(tpm.r2r(az)), tpm.r2d(tpm.r2r(zd))\n133.498195532 22.0162383595\n</pre>\n<p>The hour angle, declination and right ascension are:</p>\n<pre>&gt;&gt;&gt; print tpm.r2d(tpm.r2r(ha))\n343.586827289\n&gt;&gt;&gt; print tpm.r2d(tpm.r2r(dec))\n15.7683143606\n&gt;&gt;&gt; print tpm.r2d(tpm.r2r(ra))\n185.855680678\n</pre>\n<p>Consult the appropriate section of the PyTPM documentation for a\ndetailed comparison between PyTPM and SLALIB.</p>\n</div>\n<div id=\"converting-positions-and-velocities\">\n<h3>Converting positions and velocities</h3>\n<p>Converting positions and velocities follow exactly the same procedure\nas the examples shown above. The <cite>convert.cat2v6</cite> function will take\nproper motions, radial velocity and parallax in addition to\nposition. The returned dictionary will have appropriate fields for\nfinal proper motions, radial velocity and parallax.</p>\n<p>See the file <cite>doc/examples/conversions.py</cite> for a full example. The file\nis also included with the HTML documentation and with the source\ndistribution.</p>\n<p>For example if <cite>tab</cite> is a table that contains full 6-D coordinates with\nkeys <cite>ra</cite>, <cite>dec</cite>, <cite>pma</cite>, <cite>pmd</cite>, <cite>px</cite> and <cite>rv</cite>, then a full <cite>V6C</cite> vector\ncan be constructed as:</p>\n<pre>&gt;&gt;&gt; v6 = convert.cat2v6(tab['ra'], tab['dec'], tab['pma'],\n   ...: tab['pmd'], tab['px'], rv, tpm.CJ)\n</pre>\n<p>See docstring of the <cite>convert.convertv6</cite> function for the required units\nfor each of these.</p>\n<p>To convert this from, say FK5 to Ecliptic, at the same epoch, we can\nuse:</p>\n<pre>&gt;&gt;&gt; v6o = convert.convertv6(v6, s1=6, s2=3)\n&gt;&gt;&gt; cat = convert.v62cat(v6o)\n</pre>\n<p>The variable <cite>cat</cite> will contain a dictionary, or a list of\ndictionaries, with the relevant catalog quantities. See the docstring\nof this <cite>convert.v62cat</cite> for units of output quantities.</p>\n</div>\n</div>\n<div id=\"credits-and-license\">\n<h2>Credits and license</h2>\n<p><a href=\"http://www.sal.wisc.edu/~jwp/\" rel=\"nofollow\">Jeffrey W Percival</a> wrote the <a href=\"http://www.sal.wisc.edu/~jwp/astro/tpm/tpm.html\" rel=\"nofollow\">TPM</a> C library. See\n<cite>src/tpm/TPM_LICENSE.txt</cite> for TPM license.</p>\n<p>The version used here was obtained from the <a href=\"https://trac6.assembla.com/astrolib\" rel=\"nofollow\">coords</a> package (version\n0.36) of the <a href=\"https://trac6.assembla.com/astrolib\" rel=\"nofollow\">astrolib</a> library. Some C source files missing from the\nabove source were provided by Jeff Percival.</p>\n<p>Python and Cython code for PyTPM is released under the BSD license; see\n<cite>LICENSE.txt</cite>.</p>\n<p>Please send email to <em>prasanthhn</em>, at the <em>gmail.com</em> domain, for\nreporting errors, and for comments and suggestions.</p>\n</div>\n\n          </div>"}, "last_serial": 785380, "releases": {"0.7": [{"comment_text": "", "digests": {"md5": "d017ac2bd78719674e927c537c3f6c61", "sha256": "ca7246f85fd53a79f2d1166b76affde6db4ff36dfcbf40714e627527194bbbf1"}, "downloads": -1, "filename": "PyTPM-0.7.tar.gz", "has_sig": false, "md5_digest": "d017ac2bd78719674e927c537c3f6c61", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 1706074, "upload_time": "2011-08-28T11:44:59", "upload_time_iso_8601": "2011-08-28T11:44:59.730572Z", "url": "https://files.pythonhosted.org/packages/0b/f8/12e4a15ed8470510b324f254d0402b6c4b41600fedb199022b9353ccb0d1/PyTPM-0.7.tar.gz", "yanked": false}], "0.7.1": [{"comment_text": "", "digests": {"md5": "99a6fb3e56fcadcad3a1f60865c11071", "sha256": "37c1082482f0a338583d77932faf0b1ddee9aa19643a8c189890912759b82279"}, "downloads": -1, "filename": "PyTPM-0.7.1.tar.gz", "has_sig": false, "md5_digest": "99a6fb3e56fcadcad3a1f60865c11071", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 1696540, "upload_time": "2012-02-02T14:57:49", "upload_time_iso_8601": "2012-02-02T14:57:49.746666Z", "url": "https://files.pythonhosted.org/packages/9e/d4/8a0284d9042989e64cf85188fffc458309556d43cba1a10d09bf3ff3d4aa/PyTPM-0.7.1.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "99a6fb3e56fcadcad3a1f60865c11071", "sha256": "37c1082482f0a338583d77932faf0b1ddee9aa19643a8c189890912759b82279"}, "downloads": -1, "filename": "PyTPM-0.7.1.tar.gz", "has_sig": false, "md5_digest": "99a6fb3e56fcadcad3a1f60865c11071", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 1696540, "upload_time": "2012-02-02T14:57:49", "upload_time_iso_8601": "2012-02-02T14:57:49.746666Z", "url": "https://files.pythonhosted.org/packages/9e/d4/8a0284d9042989e64cf85188fffc458309556d43cba1a10d09bf3ff3d4aa/PyTPM-0.7.1.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:13:27 2020"}