{"info": {"author": "Tobias Reiher", "author_email": "reiher@componolit.com", "bugtrack_url": null, "classifiers": ["Development Status :: 5 - Production/Stable", "Environment :: Console", "License :: OSI Approved :: GNU Affero General Public License v3", "Operating System :: POSIX :: Linux", "Programming Language :: Ada", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.6", "Programming Language :: Python :: 3.7", "Programming Language :: Python :: 3.8", "Programming Language :: Python :: 3 :: Only", "Topic :: Communications", "Topic :: Security", "Topic :: Software Development :: Build Tools", "Topic :: Software Development :: Code Generators", "Topic :: System :: Networking"], "description": "# RecordFlux\n\n[![Build Status](https://github.com/Componolit/RecordFlux/workflows/CI/badge.svg)](https://github.com/Componolit/RecordFlux/actions)\n[![Code Coverage](https://codecov.io/github/Componolit/RecordFlux/coverage.svg?branch=master)](https://codecov.io/github/Componolit/RecordFlux)\n[![Python Versions](https://img.shields.io/badge/python-3.6%20%7C%203.7-blue.svg)](https://python.org/)\n[![Checked with mypy](http://www.mypy-lang.org/static/mypy_badge.svg)](http://mypy-lang.org/)\n\nRecordFlux is a toolset for the formal specification of messages and the generation of verifiable binary parsers and message generators.\n\n## Message Specification Language\n\nThe RecordFlux Message Specification Language is a domain-specific language to formally specify message formats of existing real-world binary protocols. Its syntax is inspired by [Ada](https://www.adacore.com/about-ada). A detailed description of the language elements can be found in the [Language Reference](/doc/Language-Reference.md).\n\n## Model Verification\n\nMessage specifications are automatically verified using the [Z3 theorem prover](https://github.com/Z3Prover/z3). The following invariants are proven at the specification level:\n\n* Field conditions are mutually exclusive\n* Field conditions do not contradict each other\n* Each field is reachable on at least one path from the initial node\n* Message fields are always located after the first message bit\n* Field length is never negative\n* Message fields cover all bits of a message on all paths\n* Overlaid fields are congruent with exactly one other field\n\n## Code Generation\n\nThe code generator generates message parsers and generators based on message specifications. The generated parser allows to validate and dissect messages and thereby respects all specified restrictions between message fields and related messages. The generated message generator enables the creation of messages according to the message specification. By using [SPARK](https://www.adacore.com/about-spark) we are able to prove the absence of runtime errors and prevent the incorrect usage of the generated code (e.g., enforce that a field of a message is validated before accessed).\n\nThe code generator creates a number of packages for a specification. All basic types like integers, enumerations and arrays are collectively declared in one package. For each message a child package is generated which contains validation, accessor and setter functions for every field of the message.\n\nA user of the generated code has to validate a message field or the whole message before accessing the data of a particular message field. The SPARK verification tools in combination with the generated contracts make it possible to ensure this property, and so prevent incorrect usage.\n\n## Usage\n\nThe `rflx` tool is used to verify a specification and generate code based on it. It offers the two sub-commands `check` and `generate` for this purpose.\n\n## Example\n\nIn the following, the complete process of specifying a message, generating code, and using the generated code is demonstrated using a small example.\n\n### Specification\n\nThe following sample specification describes a protocol `TLV` with one message type `Message` consisting of three fields:\n\n- A field `Tag` of 2 bit length,\n- a field `Value_Length` of 14 bit length, and\n- a field `Value`, whose length is specified by the value in `Value_Length`.\n\nThe `Tag` can have two valid values: `1` (`Msg_Data`) and `3` (`Msg_Error`). In case `Tag` has a value of `1` the fields `Value_Length` and `Value` follow. `Message` contains only the `Tag` field, if the value of `Tag` is `3`. All other values of `Tag` lead to an invalid message.\n\nThe structure of messages is often non-linear because of optional fields. For this reason the specification uses a graph-based representation. The order of fields is defined by then clauses. Then clauses are also used to state conditions and aspects of the following field. A more detailed description can be found in the [Language Reference](doc/Language-Reference.md#message-type).\n\n```\npackage TLV is\n\n   type Tag is (Msg_Data => 1, Msg_Error => 3) with Size => 2;\n   type Length is mod 2**14;\n\n   type Message is\n      message\n         Tag    : Tag\n            then Length\n               if Tag = Msg_Data,\n            then null\n               if Tag = Msg_Error;\n         Length : Length\n            then Value\n               with Length => Length * 8;\n         Value  : Payload;\n       end message;\n\nend TLV;\n```\n\n### Generating Code\n\nWith the sub-command `check` the correctness of the given specification file can be checked.\n\n```\n$ rflx check specs/tlv.rflx\nParsing specs/tlv.rflx... OK\n```\n\nThe sub-command `generate` is used to generate the code based on the specification. The target directory and the specification files have to be given.\n\n```\n$ rflx generate -d generated specs/tlv.rflx\nParsing specs/tlv.rflx... OK\nGenerating... OK\nCreated generated/rflx-tlv.ads\nCreated generated/rflx-tlv-generic_message.ads\nCreated generated/rflx-tlv-generic_message.adb\nCreated generated/rflx-tlv-message.ads\nCreated generated/rflx.ads\nCreated generated/rflx-lemmas.ads\nCreated generated/rflx-lemmas.adb\nCreated generated/rflx-types.ads\nCreated generated/rflx-types.adb\nCreated generated/rflx-message_sequence.ads\nCreated generated/rflx-message_sequence.adb\nCreated generated/rflx-scalar_sequence.ads\nCreated generated/rflx-scalar_sequence.adb\n```\n\n### Use of Generated Code\n\nAll scalar types defined in the specification are represented by a similar Ada type in the generated code. For `TLV` the following types are defined in the package `RFLX.TLV`:\n\n- `type Tag is (Msg_Data, Msg_Error) with Size => 2`\n- `for Tag use (Msg_Data => 1, Msg_Error => 3);`\n- `type Length is mod 2**14`\n\nAll types and subprograms related to `Message` can be found in the package `RFLX.TLV.Message`:\n\n- `type Context`\n    - Stores buffer and internal state\n- `function Create return Context`\n    - Return default initialized context\n- `procedure Initialize (Ctx : out Context; Buffer : in out RFLX.Types.Bytes_Ptr)`\n    - Initialize context with buffer\n- `procedure Initialize (Ctx : out Context; Buffer : in out RFLX.Types.Bytes_Ptr; First, Last : RFLX.Types.Bit_Index_Type)`\n    - Initialize context with buffer and explicit bounds\n- `procedure Take_Buffer (Ctx : in out Context; Buffer : out RFLX.Types.Bytes_Ptr)`\n    - Get buffer and remove it from context (note: buffer cannot put back into context, thus further verification of message is not possible after this action)\n- `function Has_Buffer (Ctx : Context) return Boolean`\n    - Check if context contains buffer (i.e. non-null pointer)\n- `procedure Verify (Ctx : in out Context; Fld : Field)`\n    - Verify validity of field\n- `procedure Verify_Message (Ctx : in out Context)`\n    - Verify all fields of message\n- `function Structural_Valid (Ctx : Context; Fld : Field) return Boolean`\n    - Check if composite field is structural valid (i.e. location and length of field is correct, but content is not necessarily valid)\n- `function Present (Ctx : Context; Fld : Field) return Boolean`\n    - Check if composite field is structural valid and has non-zero length\n- `function Valid (Ctx : Context; Fld : Field) return Boolean`\n    - Check if field is valid (i.e. it has valid structure and valid content)\n- `function Incomplete (Ctx : Context; Fld : Field) return Boolean`\n    - Check if buffer was too short to verify field\n- `function Structural_Valid_Message (Ctx : Context) return Boolean`\n    - Check if all fields of message are at least structural valid\n- `function Valid_Message (Ctx : Context) return Boolean`\n    - Check if all fields of message are valid\n- `function Incomplete_Message (Ctx : Context) return Boolean`\n    - Check if buffer was too short to verify message\n- `function Get_Tag (Ctx : Context) return Tag_Type`\n    - Get value of `Tag` field\n- `function Get_Length (Ctx : Context) return Length_Type`\n    - Get value of `Length` field\n- `generic with procedure Process_Value (Value : RFLX.Types.Bytes); procedure Get_Value (Ctx : Context)`\n    - Access content of `Value` field\n- `function Valid_Next (Ctx : Context; Fld : Field) return Boolean`\n    - Check if field is potential next field\n- `procedure Set_Tag (Ctx : in out Context; Value : Tag)`\n    - Set value of `Tag` field\n- `procedure Set_Length (Ctx : in out Context; Value : Length)`\n    - Set value of `Length` field\n- `generic with procedure Process_Payload (Payload : out RFLX.Types.Bytes); procedure Set_Value (Ctx : in out Context)`\n    - Set content of `Value` field\n- `procedure Initialize_Value (Ctx : in out Context)`\n    - Initialize `Value` field (precondition to switch context for generating contained message)\n\nA simple program to parse a `TLV.Message` could be as follows:\n\n```\nwith Ada.Text_IO;\nwith RFLX.Types;\nwith RFLX.TLV.Message;\n\nprocedure Main is\n   Buffer  : RFLX.Types.Bytes_Ptr := new RFLX.Types.Bytes'(64, 4, 0, 0, 0, 0);\n   Context : RFLX.TLV.Message.Context := RFLX.TLV.Message.Create;\nbegin\n   RFLX.TLV.Message.Initialize (Context, Buffer);\n   RFLX.TLV.Message.Verify_Message (Context);\n   if RFLX.TLV.Message.Structural_Valid_Message (Context) then\n      case RFLX.TLV.Message.Get_Tag (Context) is\n         when RFLX.TLV.Msg_Data =>\n            if RFLX.TLV.Message.Present (Context, RFLX.TLV.Message.F_Value) then\n               Ada.Text_IO.Put_Line (\"Data message with value of\"\n                                     & RFLX.TLV.Message.Get_Length (Context)'Img\n                                     & \" byte length\");\n            else\n               Ada.Text_IO.Put_Line (\"Data message without value\");\n            end if;\n         when RFLX.TLV.Msg_Error =>\n            Ada.Text_IO.Put_Line (\"Error message\");\n      end case;\n   else\n      Ada.Text_IO.Put_Line (\"Invalid message\");\n   end if;\nend Main;\n```\n\nIn case that a valid message is contained in `Buffer` the value of `Tag` is read. If the value of `Tag` is `Msg_Data` and the `Value` field is present, the content of `Value` can be accessed.\n\nA `TLV.Message` can be generated as follows:\n\n```\nwith Ada.Text_IO;\nwith RFLX.Types; use type RFLX.Types.Length, RFLX.Types.Bytes;\nwith RFLX.TLV.Message;\n\nprocedure Main is\n   Buffer  : RFLX.Types.Bytes_Ptr := new RFLX.Types.Bytes'(0, 0, 0, 0, 0, 0);\n   Context : RFLX.TLV.Message.Context := RFLX.TLV.Message.Create;\n   Data : RFLX.Types.Bytes (RFLX.Types.Index'First .. RFLX.Types.Index'First + 2**14);\n\n   procedure Write_Data (Buffer : out RFLX.Types.Bytes) is\n   begin\n      Buffer := Data (Data'First .. Data'First + Buffer'Length - 1);\n   end Write_Data;\n\n   procedure Set_Value is new RFLX.TLV.Message.Set_Value (Write_Data);\nbegin\n   --  Generating message\n   RFLX.TLV.Message.Initialize (Context, Buffer);\n   RFLX.TLV.Message.Set_Tag (Context, RFLX.TLV.Msg_Data);\n   RFLX.TLV.Message.Set_Length (Context, 4);\n   Data := (1, 2, 3, 4, others => 0);\n   Set_Value (Context);\n\n   --  Checking generated message\n   RFLX.TLV.Message.Take_Buffer (Context, Buffer);\n   if Buffer.all = (64, 4, 1, 2, 3, 4) then\n      Ada.Text_IO.Put_Line (\"Expected\");\n   else\n      Ada.Text_IO.Put_Line (\"Unexpected\");\n   end if;\nend Main;\n```\n\n## Dependencies\n\n- [Python >=3.6](https://www.python.org)\n- [PyParsing](https://github.com/pyparsing/pyparsing/)\n- [PyDotPlus](https://github.com/carlos-jenkins/pydotplus)\n- [Z3](https://github.com/Z3Prover/z3)\n- [GNAT Community 2019](https://www.adacore.com/download)\n- [SPARK Pro 20.0](https://www.adacore.com/sparkpro) (only required for fully automatic verification of generated code)\n\n## Known Issues\n\n### GNAT Community 2019\n\n- GNAT shows an incorrect warning for `Initialize (Context, Buffer)`. It can be suppressed by adding `pragma Assert (Buffer = null)` after calling `Initialize`.\n- GNATprove is unable to prove some parts of the generated code.\n\nThese issues should be fixed in the GNAT Community 2020 release.\n\n## Licence\n\nThis software is licensed under the `AGPL-3.0`. See the `LICENSE` file for the full license text.", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/Componolit/RecordFlux", "keywords": "", "license": "AGPL-3.0", "maintainer": "", "maintainer_email": "", "name": "RecordFlux", "package_url": "https://pypi.org/project/RecordFlux/", "platform": "", "project_url": "https://pypi.org/project/RecordFlux/", "project_urls": {"Homepage": "https://github.com/Componolit/RecordFlux"}, "release_url": "https://pypi.org/project/RecordFlux/0.3.0/", "requires_dist": null, "requires_python": ">=3.6", "summary": "A toolset for the formal specification of messages and the generation of verifiable binary parsers and message generators.", "version": "0.3.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>RecordFlux</h1>\n<p><a href=\"https://github.com/Componolit/RecordFlux/actions\" rel=\"nofollow\"><img alt=\"Build Status\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/40d12b3700d1ac9c8c5a9577a75a94da3b56694c/68747470733a2f2f6769746875622e636f6d2f436f6d706f6e6f6c69742f5265636f7264466c75782f776f726b666c6f77732f43492f62616467652e737667\"></a>\n<a href=\"https://codecov.io/github/Componolit/RecordFlux\" rel=\"nofollow\"><img alt=\"Code Coverage\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/f89ae91b34a09fedbf581c3c082cb68daf7218eb/68747470733a2f2f636f6465636f762e696f2f6769746875622f436f6d706f6e6f6c69742f5265636f7264466c75782f636f7665726167652e7376673f6272616e63683d6d6173746572\"></a>\n<a href=\"https://python.org/\" rel=\"nofollow\"><img alt=\"Python Versions\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/a2390055e2fdf2bcda0b376a926e961a950c060e/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f707974686f6e2d332e36253230253743253230332e372d626c75652e737667\"></a>\n<a href=\"http://mypy-lang.org/\" rel=\"nofollow\"><img alt=\"Checked with mypy\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/d0db8f5dcbf5f340f278004d5db3d16b4cdf33ba/687474703a2f2f7777772e6d7970792d6c616e672e6f72672f7374617469632f6d7970795f62616467652e737667\"></a></p>\n<p>RecordFlux is a toolset for the formal specification of messages and the generation of verifiable binary parsers and message generators.</p>\n<h2>Message Specification Language</h2>\n<p>The RecordFlux Message Specification Language is a domain-specific language to formally specify message formats of existing real-world binary protocols. Its syntax is inspired by <a href=\"https://www.adacore.com/about-ada\" rel=\"nofollow\">Ada</a>. A detailed description of the language elements can be found in the <a href=\"/doc/Language-Reference.md\" rel=\"nofollow\">Language Reference</a>.</p>\n<h2>Model Verification</h2>\n<p>Message specifications are automatically verified using the <a href=\"https://github.com/Z3Prover/z3\" rel=\"nofollow\">Z3 theorem prover</a>. The following invariants are proven at the specification level:</p>\n<ul>\n<li>Field conditions are mutually exclusive</li>\n<li>Field conditions do not contradict each other</li>\n<li>Each field is reachable on at least one path from the initial node</li>\n<li>Message fields are always located after the first message bit</li>\n<li>Field length is never negative</li>\n<li>Message fields cover all bits of a message on all paths</li>\n<li>Overlaid fields are congruent with exactly one other field</li>\n</ul>\n<h2>Code Generation</h2>\n<p>The code generator generates message parsers and generators based on message specifications. The generated parser allows to validate and dissect messages and thereby respects all specified restrictions between message fields and related messages. The generated message generator enables the creation of messages according to the message specification. By using <a href=\"https://www.adacore.com/about-spark\" rel=\"nofollow\">SPARK</a> we are able to prove the absence of runtime errors and prevent the incorrect usage of the generated code (e.g., enforce that a field of a message is validated before accessed).</p>\n<p>The code generator creates a number of packages for a specification. All basic types like integers, enumerations and arrays are collectively declared in one package. For each message a child package is generated which contains validation, accessor and setter functions for every field of the message.</p>\n<p>A user of the generated code has to validate a message field or the whole message before accessing the data of a particular message field. The SPARK verification tools in combination with the generated contracts make it possible to ensure this property, and so prevent incorrect usage.</p>\n<h2>Usage</h2>\n<p>The <code>rflx</code> tool is used to verify a specification and generate code based on it. It offers the two sub-commands <code>check</code> and <code>generate</code> for this purpose.</p>\n<h2>Example</h2>\n<p>In the following, the complete process of specifying a message, generating code, and using the generated code is demonstrated using a small example.</p>\n<h3>Specification</h3>\n<p>The following sample specification describes a protocol <code>TLV</code> with one message type <code>Message</code> consisting of three fields:</p>\n<ul>\n<li>A field <code>Tag</code> of 2 bit length,</li>\n<li>a field <code>Value_Length</code> of 14 bit length, and</li>\n<li>a field <code>Value</code>, whose length is specified by the value in <code>Value_Length</code>.</li>\n</ul>\n<p>The <code>Tag</code> can have two valid values: <code>1</code> (<code>Msg_Data</code>) and <code>3</code> (<code>Msg_Error</code>). In case <code>Tag</code> has a value of <code>1</code> the fields <code>Value_Length</code> and <code>Value</code> follow. <code>Message</code> contains only the <code>Tag</code> field, if the value of <code>Tag</code> is <code>3</code>. All other values of <code>Tag</code> lead to an invalid message.</p>\n<p>The structure of messages is often non-linear because of optional fields. For this reason the specification uses a graph-based representation. The order of fields is defined by then clauses. Then clauses are also used to state conditions and aspects of the following field. A more detailed description can be found in the <a href=\"doc/Language-Reference.md#message-type\" rel=\"nofollow\">Language Reference</a>.</p>\n<pre><code>package TLV is\n\n   type Tag is (Msg_Data =&gt; 1, Msg_Error =&gt; 3) with Size =&gt; 2;\n   type Length is mod 2**14;\n\n   type Message is\n      message\n         Tag    : Tag\n            then Length\n               if Tag = Msg_Data,\n            then null\n               if Tag = Msg_Error;\n         Length : Length\n            then Value\n               with Length =&gt; Length * 8;\n         Value  : Payload;\n       end message;\n\nend TLV;\n</code></pre>\n<h3>Generating Code</h3>\n<p>With the sub-command <code>check</code> the correctness of the given specification file can be checked.</p>\n<pre><code>$ rflx check specs/tlv.rflx\nParsing specs/tlv.rflx... OK\n</code></pre>\n<p>The sub-command <code>generate</code> is used to generate the code based on the specification. The target directory and the specification files have to be given.</p>\n<pre><code>$ rflx generate -d generated specs/tlv.rflx\nParsing specs/tlv.rflx... OK\nGenerating... OK\nCreated generated/rflx-tlv.ads\nCreated generated/rflx-tlv-generic_message.ads\nCreated generated/rflx-tlv-generic_message.adb\nCreated generated/rflx-tlv-message.ads\nCreated generated/rflx.ads\nCreated generated/rflx-lemmas.ads\nCreated generated/rflx-lemmas.adb\nCreated generated/rflx-types.ads\nCreated generated/rflx-types.adb\nCreated generated/rflx-message_sequence.ads\nCreated generated/rflx-message_sequence.adb\nCreated generated/rflx-scalar_sequence.ads\nCreated generated/rflx-scalar_sequence.adb\n</code></pre>\n<h3>Use of Generated Code</h3>\n<p>All scalar types defined in the specification are represented by a similar Ada type in the generated code. For <code>TLV</code> the following types are defined in the package <code>RFLX.TLV</code>:</p>\n<ul>\n<li><code>type Tag is (Msg_Data, Msg_Error) with Size =&gt; 2</code></li>\n<li><code>for Tag use (Msg_Data =&gt; 1, Msg_Error =&gt; 3);</code></li>\n<li><code>type Length is mod 2**14</code></li>\n</ul>\n<p>All types and subprograms related to <code>Message</code> can be found in the package <code>RFLX.TLV.Message</code>:</p>\n<ul>\n<li><code>type Context</code>\n<ul>\n<li>Stores buffer and internal state</li>\n</ul>\n</li>\n<li><code>function Create return Context</code>\n<ul>\n<li>Return default initialized context</li>\n</ul>\n</li>\n<li><code>procedure Initialize (Ctx : out Context; Buffer : in out RFLX.Types.Bytes_Ptr)</code>\n<ul>\n<li>Initialize context with buffer</li>\n</ul>\n</li>\n<li><code>procedure Initialize (Ctx : out Context; Buffer : in out RFLX.Types.Bytes_Ptr; First, Last : RFLX.Types.Bit_Index_Type)</code>\n<ul>\n<li>Initialize context with buffer and explicit bounds</li>\n</ul>\n</li>\n<li><code>procedure Take_Buffer (Ctx : in out Context; Buffer : out RFLX.Types.Bytes_Ptr)</code>\n<ul>\n<li>Get buffer and remove it from context (note: buffer cannot put back into context, thus further verification of message is not possible after this action)</li>\n</ul>\n</li>\n<li><code>function Has_Buffer (Ctx : Context) return Boolean</code>\n<ul>\n<li>Check if context contains buffer (i.e. non-null pointer)</li>\n</ul>\n</li>\n<li><code>procedure Verify (Ctx : in out Context; Fld : Field)</code>\n<ul>\n<li>Verify validity of field</li>\n</ul>\n</li>\n<li><code>procedure Verify_Message (Ctx : in out Context)</code>\n<ul>\n<li>Verify all fields of message</li>\n</ul>\n</li>\n<li><code>function Structural_Valid (Ctx : Context; Fld : Field) return Boolean</code>\n<ul>\n<li>Check if composite field is structural valid (i.e. location and length of field is correct, but content is not necessarily valid)</li>\n</ul>\n</li>\n<li><code>function Present (Ctx : Context; Fld : Field) return Boolean</code>\n<ul>\n<li>Check if composite field is structural valid and has non-zero length</li>\n</ul>\n</li>\n<li><code>function Valid (Ctx : Context; Fld : Field) return Boolean</code>\n<ul>\n<li>Check if field is valid (i.e. it has valid structure and valid content)</li>\n</ul>\n</li>\n<li><code>function Incomplete (Ctx : Context; Fld : Field) return Boolean</code>\n<ul>\n<li>Check if buffer was too short to verify field</li>\n</ul>\n</li>\n<li><code>function Structural_Valid_Message (Ctx : Context) return Boolean</code>\n<ul>\n<li>Check if all fields of message are at least structural valid</li>\n</ul>\n</li>\n<li><code>function Valid_Message (Ctx : Context) return Boolean</code>\n<ul>\n<li>Check if all fields of message are valid</li>\n</ul>\n</li>\n<li><code>function Incomplete_Message (Ctx : Context) return Boolean</code>\n<ul>\n<li>Check if buffer was too short to verify message</li>\n</ul>\n</li>\n<li><code>function Get_Tag (Ctx : Context) return Tag_Type</code>\n<ul>\n<li>Get value of <code>Tag</code> field</li>\n</ul>\n</li>\n<li><code>function Get_Length (Ctx : Context) return Length_Type</code>\n<ul>\n<li>Get value of <code>Length</code> field</li>\n</ul>\n</li>\n<li><code>generic with procedure Process_Value (Value : RFLX.Types.Bytes); procedure Get_Value (Ctx : Context)</code>\n<ul>\n<li>Access content of <code>Value</code> field</li>\n</ul>\n</li>\n<li><code>function Valid_Next (Ctx : Context; Fld : Field) return Boolean</code>\n<ul>\n<li>Check if field is potential next field</li>\n</ul>\n</li>\n<li><code>procedure Set_Tag (Ctx : in out Context; Value : Tag)</code>\n<ul>\n<li>Set value of <code>Tag</code> field</li>\n</ul>\n</li>\n<li><code>procedure Set_Length (Ctx : in out Context; Value : Length)</code>\n<ul>\n<li>Set value of <code>Length</code> field</li>\n</ul>\n</li>\n<li><code>generic with procedure Process_Payload (Payload : out RFLX.Types.Bytes); procedure Set_Value (Ctx : in out Context)</code>\n<ul>\n<li>Set content of <code>Value</code> field</li>\n</ul>\n</li>\n<li><code>procedure Initialize_Value (Ctx : in out Context)</code>\n<ul>\n<li>Initialize <code>Value</code> field (precondition to switch context for generating contained message)</li>\n</ul>\n</li>\n</ul>\n<p>A simple program to parse a <code>TLV.Message</code> could be as follows:</p>\n<pre><code>with Ada.Text_IO;\nwith RFLX.Types;\nwith RFLX.TLV.Message;\n\nprocedure Main is\n   Buffer  : RFLX.Types.Bytes_Ptr := new RFLX.Types.Bytes'(64, 4, 0, 0, 0, 0);\n   Context : RFLX.TLV.Message.Context := RFLX.TLV.Message.Create;\nbegin\n   RFLX.TLV.Message.Initialize (Context, Buffer);\n   RFLX.TLV.Message.Verify_Message (Context);\n   if RFLX.TLV.Message.Structural_Valid_Message (Context) then\n      case RFLX.TLV.Message.Get_Tag (Context) is\n         when RFLX.TLV.Msg_Data =&gt;\n            if RFLX.TLV.Message.Present (Context, RFLX.TLV.Message.F_Value) then\n               Ada.Text_IO.Put_Line (\"Data message with value of\"\n                                     &amp; RFLX.TLV.Message.Get_Length (Context)'Img\n                                     &amp; \" byte length\");\n            else\n               Ada.Text_IO.Put_Line (\"Data message without value\");\n            end if;\n         when RFLX.TLV.Msg_Error =&gt;\n            Ada.Text_IO.Put_Line (\"Error message\");\n      end case;\n   else\n      Ada.Text_IO.Put_Line (\"Invalid message\");\n   end if;\nend Main;\n</code></pre>\n<p>In case that a valid message is contained in <code>Buffer</code> the value of <code>Tag</code> is read. If the value of <code>Tag</code> is <code>Msg_Data</code> and the <code>Value</code> field is present, the content of <code>Value</code> can be accessed.</p>\n<p>A <code>TLV.Message</code> can be generated as follows:</p>\n<pre><code>with Ada.Text_IO;\nwith RFLX.Types; use type RFLX.Types.Length, RFLX.Types.Bytes;\nwith RFLX.TLV.Message;\n\nprocedure Main is\n   Buffer  : RFLX.Types.Bytes_Ptr := new RFLX.Types.Bytes'(0, 0, 0, 0, 0, 0);\n   Context : RFLX.TLV.Message.Context := RFLX.TLV.Message.Create;\n   Data : RFLX.Types.Bytes (RFLX.Types.Index'First .. RFLX.Types.Index'First + 2**14);\n\n   procedure Write_Data (Buffer : out RFLX.Types.Bytes) is\n   begin\n      Buffer := Data (Data'First .. Data'First + Buffer'Length - 1);\n   end Write_Data;\n\n   procedure Set_Value is new RFLX.TLV.Message.Set_Value (Write_Data);\nbegin\n   --  Generating message\n   RFLX.TLV.Message.Initialize (Context, Buffer);\n   RFLX.TLV.Message.Set_Tag (Context, RFLX.TLV.Msg_Data);\n   RFLX.TLV.Message.Set_Length (Context, 4);\n   Data := (1, 2, 3, 4, others =&gt; 0);\n   Set_Value (Context);\n\n   --  Checking generated message\n   RFLX.TLV.Message.Take_Buffer (Context, Buffer);\n   if Buffer.all = (64, 4, 1, 2, 3, 4) then\n      Ada.Text_IO.Put_Line (\"Expected\");\n   else\n      Ada.Text_IO.Put_Line (\"Unexpected\");\n   end if;\nend Main;\n</code></pre>\n<h2>Dependencies</h2>\n<ul>\n<li><a href=\"https://www.python.org\" rel=\"nofollow\">Python &gt;=3.6</a></li>\n<li><a href=\"https://github.com/pyparsing/pyparsing/\" rel=\"nofollow\">PyParsing</a></li>\n<li><a href=\"https://github.com/carlos-jenkins/pydotplus\" rel=\"nofollow\">PyDotPlus</a></li>\n<li><a href=\"https://github.com/Z3Prover/z3\" rel=\"nofollow\">Z3</a></li>\n<li><a href=\"https://www.adacore.com/download\" rel=\"nofollow\">GNAT Community 2019</a></li>\n<li><a href=\"https://www.adacore.com/sparkpro\" rel=\"nofollow\">SPARK Pro 20.0</a> (only required for fully automatic verification of generated code)</li>\n</ul>\n<h2>Known Issues</h2>\n<h3>GNAT Community 2019</h3>\n<ul>\n<li>GNAT shows an incorrect warning for <code>Initialize (Context, Buffer)</code>. It can be suppressed by adding <code>pragma Assert (Buffer = null)</code> after calling <code>Initialize</code>.</li>\n<li>GNATprove is unable to prove some parts of the generated code.</li>\n</ul>\n<p>These issues should be fixed in the GNAT Community 2020 release.</p>\n<h2>Licence</h2>\n<p>This software is licensed under the <code>AGPL-3.0</code>. See the <code>LICENSE</code> file for the full license text.</p>\n\n          </div>"}, "last_serial": 6513828, "releases": {"0.3.0": [{"comment_text": "", "digests": {"md5": "b97f12021828f3693f12081f3cd5267d", "sha256": "4598bac2b14b02a6af1a37e99827337bf3d3b8e85b4f168d27d0f3aa1b392959"}, "downloads": -1, "filename": "RecordFlux-0.3.0.tar.gz", "has_sig": false, "md5_digest": "b97f12021828f3693f12081f3cd5267d", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 69349, "upload_time": "2020-01-24T14:14:12", "upload_time_iso_8601": "2020-01-24T14:14:12.994882Z", "url": "https://files.pythonhosted.org/packages/a5/52/51617b47dbd4d01fe5b1fb29fc39cd3e675db699a6b3eda096e11f25bdcd/RecordFlux-0.3.0.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "b97f12021828f3693f12081f3cd5267d", "sha256": "4598bac2b14b02a6af1a37e99827337bf3d3b8e85b4f168d27d0f3aa1b392959"}, "downloads": -1, "filename": "RecordFlux-0.3.0.tar.gz", "has_sig": false, "md5_digest": "b97f12021828f3693f12081f3cd5267d", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 69349, "upload_time": "2020-01-24T14:14:12", "upload_time_iso_8601": "2020-01-24T14:14:12.994882Z", "url": "https://files.pythonhosted.org/packages/a5/52/51617b47dbd4d01fe5b1fb29fc39cd3e675db699a6b3eda096e11f25bdcd/RecordFlux-0.3.0.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:06:07 2020"}