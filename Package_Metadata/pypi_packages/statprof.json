{"info": {"author": "Bryan O'Sullivan", "author_email": "bos@serpentine.com", "bugtrack_url": null, "classifiers": ["Development Status :: 3 - Alpha", "License :: OSI Approved :: GNU Library or Lesser General Public License (LGPL)", "Topic :: Utilities"], "description": "statprof - statistical profiling for Python\n===========================================\n\nThis package provides a simple statistical profiler for Python.\n\nPython's default profiler has been `lsprof` for several years. This is\nan *instrumenting* profiler, which means that it saves data on every\naction of interest.  In the case of lsprof, it runs at function entry\nand exit.  This has problems: it can be expensive due to frequent\nsampling, and it is blind to hot spots *within* a function.\n\nIn contrast, `statprof` samples the call stack periodically (by\ndefault, 1000 times per second), and it correctly tracks line numbers\n*inside* a function.  This means that if you have a 50-line function\nthat contains two hot loops, `statprof` is likely to report them both\naccurately.\n\n<b>Note</b>: This package does not yet work on Windows! See the\nimplementation and portability notes below for details.\n\n\nBasic usage\n-----------\n\nIt's easy to get started with `statprof`:\n\n    import statprof\n\n    statprof.start()\n\ttry:\n\t    my_questionable_function()\n    finally:\n\t    statprof.stop()\n\t\tstatprof.display()\n\nFor more comprehensive help, run `pydoc statprof`.\n\n\nPortability\n-----------\n\nBecause `statprof` uses the Unix `itimer` signal facility, it does not\ncurrently work on Windows. (Patches to improve portability would be\nmost welcome.)\n\n\nImplementation notes\n--------------------\n\nThe `statprof` profiler works by setting the Unix profiling signal\n`ITIMER_PROF` to go off after the interval you define in the call to\n`reset()`. When the signal fires, a sampling routine is run which\nlooks at the current procedure that's executing, and then crawls up\nthe stack, and for each frame encountered, increments that frame's\ncode object's sample count.  Note that if a procedure is encountered\nmultiple times on a given stack, it is only counted once. After the\nsampling is complete, the profiler resets profiling timer to fire\nagain after the appropriate interval.\n\nMeanwhile, the profiler keeps track, via `os.times()`, how much CPU\ntime (system and user -- which is also what `ITIMER_PROF` tracks), has\nelapsed while code has been executing within a `start()`/`stop()`\nblock.\n\nThe profiler also tries (as much as possible) to avoid counting or\ntiming its own code.\n\n\nHistory\n-------\n\nThis package was originally\n[written and released by Andy Wingo](http://wingolog.org/archives/2005/10/28/profiling).\nIt was ported to modern Python by Alex Frazer, and posted to github by\nJeff Muizelaar.  The current maintainer is Bryan O'Sullivan\n<bos@serpentine.com>.\n\n\nReporting bugs, contributing patches\n------------------------------------\n\nThe current maintainer of this package is Bryan O'Sullivan\n<bos@serpentine.com>.\n\nPlease report bugs using the\n[github issue tracker](https://github.com/bos/statprof.py/issues).\n\nIf you'd like to contribute patches, please do - the source is on\ngithub, so please just issue a pull request.\n\n    $ git clone git://github.com/bos/statprof.py", "description_content_type": null, "docs_url": null, "download_url": "UNKNOWN", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "http://packages.python.org/statprof", "keywords": "profiling", "license": "LGPL", "maintainer": null, "maintainer_email": null, "name": "statprof", "package_url": "https://pypi.org/project/statprof/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/statprof/", "project_urls": {"Download": "UNKNOWN", "Homepage": "http://packages.python.org/statprof"}, "release_url": "https://pypi.org/project/statprof/0.1.2/", "requires_dist": null, "requires_python": null, "summary": "Statistical profiling for Python", "version": "0.1.2", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p>This package provides a simple statistical profiler for Python.</p>\n<p>Python\u2019s default profiler has been <cite>lsprof</cite> for several years. This is\nan <em>instrumenting</em> profiler, which means that it saves data on every\naction of interest.  In the case of lsprof, it runs at function entry\nand exit.  This has problems: it can be expensive due to frequent\nsampling, and it is blind to hot spots <em>within</em> a function.</p>\n<p>In contrast, <cite>statprof</cite> samples the call stack periodically (by\ndefault, 1000 times per second), and it correctly tracks line numbers\n<em>inside</em> a function.  This means that if you have a 50-line function\nthat contains two hot loops, <cite>statprof</cite> is likely to report them both\naccurately.</p>\n<p>&lt;b&gt;Note&lt;/b&gt;: This package does not yet work on Windows! See the\nimplementation and portability notes below for details.</p>\n<div id=\"basic-usage\">\n<h2>Basic usage</h2>\n<p>It\u2019s easy to get started with <cite>statprof</cite>:</p>\n<blockquote>\n<p>import statprof</p>\n<dl>\n<dt>statprof.start()</dt>\n<dd><dl>\n<dt>try:</dt>\n<dd>my_questionable_function()</dd>\n</dl>\n</dd>\n<dt>finally:</dt>\n<dd><dl>\n<dt>statprof.stop()</dt>\n<dd>statprof.display()</dd>\n</dl>\n</dd>\n</dl>\n</blockquote>\n<p>For more comprehensive help, run <cite>pydoc statprof</cite>.</p>\n</div>\n<div id=\"portability\">\n<h2>Portability</h2>\n<p>Because <cite>statprof</cite> uses the Unix <cite>itimer</cite> signal facility, it does not\ncurrently work on Windows. (Patches to improve portability would be\nmost welcome.)</p>\n</div>\n<div id=\"implementation-notes\">\n<h2>Implementation notes</h2>\n<p>The <cite>statprof</cite> profiler works by setting the Unix profiling signal\n<cite>ITIMER_PROF</cite> to go off after the interval you define in the call to\n<cite>reset()</cite>. When the signal fires, a sampling routine is run which\nlooks at the current procedure that\u2019s executing, and then crawls up\nthe stack, and for each frame encountered, increments that frame\u2019s\ncode object\u2019s sample count.  Note that if a procedure is encountered\nmultiple times on a given stack, it is only counted once. After the\nsampling is complete, the profiler resets profiling timer to fire\nagain after the appropriate interval.</p>\n<p>Meanwhile, the profiler keeps track, via <cite>os.times()</cite>, how much CPU\ntime (system and user \u2013 which is also what <cite>ITIMER_PROF</cite> tracks), has\nelapsed while code has been executing within a <cite>start()</cite>/<cite>stop()</cite>\nblock.</p>\n<p>The profiler also tries (as much as possible) to avoid counting or\ntiming its own code.</p>\n</div>\n<div id=\"history\">\n<h2>History</h2>\n<p>This package was originally\n[written and released by Andy Wingo](<a href=\"http://wingolog.org/archives/2005/10/28/profiling\" rel=\"nofollow\">http://wingolog.org/archives/2005/10/28/profiling</a>).\nIt was ported to modern Python by Alex Frazer, and posted to github by\nJeff Muizelaar.  The current maintainer is Bryan O\u2019Sullivan\n&lt;<a href=\"mailto:bos%40serpentine.com\">bos<span>@</span>serpentine<span>.</span>com</a>&gt;.</p>\n</div>\n<div id=\"reporting-bugs-contributing-patches\">\n<h2>Reporting bugs, contributing patches</h2>\n<p>The current maintainer of this package is Bryan O\u2019Sullivan\n&lt;<a href=\"mailto:bos%40serpentine.com\">bos<span>@</span>serpentine<span>.</span>com</a>&gt;.</p>\n<p>Please report bugs using the\n[github issue tracker](<a href=\"https://github.com/bos/statprof.py/issues\" rel=\"nofollow\">https://github.com/bos/statprof.py/issues</a>).</p>\n<p>If you\u2019d like to contribute patches, please do - the source is on\ngithub, so please just issue a pull request.</p>\n<blockquote>\n$ git clone git://github.com/bos/statprof.py</blockquote>\n</div>\n\n          </div>"}, "last_serial": 800098, "releases": {"0.1": [], "0.1.1": [{"comment_text": "", "digests": {"md5": "952811ec304a815ef44de9c8349f0bf2", "sha256": "274df5f3f643eef8b8d3ac6c319f8f534360ad14925df40cda1d83cd28f09e64"}, "downloads": -1, "filename": "statprof-0.1.1.tar.gz", "has_sig": false, "md5_digest": "952811ec304a815ef44de9c8349f0bf2", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 5929, "upload_time": "2012-04-10T00:20:37", "upload_time_iso_8601": "2012-04-10T00:20:37.270603Z", "url": "https://files.pythonhosted.org/packages/1e/22/eb77c6d2d30867fbeed07211acc0fbb18643ae9af7c4f2ce06d569ec6ec1/statprof-0.1.1.tar.gz", "yanked": false}], "0.1.2": [{"comment_text": "", "digests": {"md5": "00598a2cac2f37eb7f83c04ed24a3b41", "sha256": "adb8654edd5183e91e1538ee9112314f8129a52796bfa32cfa34b2f0e73295b4"}, "downloads": -1, "filename": "statprof-0.1.2.tar.gz", "has_sig": false, "md5_digest": "00598a2cac2f37eb7f83c04ed24a3b41", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 6206, "upload_time": "2012-04-10T19:32:10", "upload_time_iso_8601": "2012-04-10T19:32:10.998928Z", "url": "https://files.pythonhosted.org/packages/5b/00/8a05eb398e72f3aa5ec22a027bdffa51fd4f74296c7cb82f7b434d622296/statprof-0.1.2.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "00598a2cac2f37eb7f83c04ed24a3b41", "sha256": "adb8654edd5183e91e1538ee9112314f8129a52796bfa32cfa34b2f0e73295b4"}, "downloads": -1, "filename": "statprof-0.1.2.tar.gz", "has_sig": false, "md5_digest": "00598a2cac2f37eb7f83c04ed24a3b41", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 6206, "upload_time": "2012-04-10T19:32:10", "upload_time_iso_8601": "2012-04-10T19:32:10.998928Z", "url": "https://files.pythonhosted.org/packages/5b/00/8a05eb398e72f3aa5ec22a027bdffa51fd4f74296c7cb82f7b434d622296/statprof-0.1.2.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:02:23 2020"}