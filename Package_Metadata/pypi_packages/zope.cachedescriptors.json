{"info": {"author": "Zope Foundation and Contributors", "author_email": "zope-dev@zope.org", "bugtrack_url": null, "classifiers": ["Development Status :: 5 - Production/Stable", "Intended Audience :: Developers", "License :: OSI Approved :: Zope Public License", "Operating System :: OS Independent", "Programming Language :: Python", "Programming Language :: Python :: 2", "Programming Language :: Python :: 2.7", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.4", "Programming Language :: Python :: 3.5", "Programming Language :: Python :: 3.6", "Programming Language :: Python :: Implementation :: CPython", "Programming Language :: Python :: Implementation :: PyPy", "Topic :: Internet :: WWW/HTTP", "Topic :: Software Development"], "description": "===========================\n ``zope.cachedescriptors``\n===========================\n\n.. image:: https://img.shields.io/pypi/v/zope.cachedescriptors.svg\n        :target: https://pypi.org/project/zope.cachedescriptors/\n        :alt: Latest release\n\n.. image:: https://img.shields.io/pypi/pyversions/zope.cachedescriptors.svg\n        :target: https://pypi.org/project/zope.cachedescriptors/\n        :alt: Supported Python versions\n\n.. image:: https://travis-ci.org/zopefoundation/zope.cachedescriptors.svg?branch=master\n        :target: https://travis-ci.org/zopefoundation/zope.cachedescriptors\n\n.. image:: https://readthedocs.org/projects/zopehookable/badge/?version=latest\n        :target: http://zopehookable.readthedocs.io/en/latest/\n        :alt: Documentation Status\n\n.. image:: https://coveralls.io/repos/github/zopefoundation/zope.cachedescriptors/badge.svg?branch=master\n        :target: https://coveralls.io/github/zopefoundation/zope.cachedescriptors?branch=master\n\nCached descriptors cache their output.  They take into account\ninstance attributes that they depend on, so when the instance\nattributes change, the descriptors will change the values they\nreturn.\n\nCached descriptors cache their data in ``_v_`` attributes, so they are\nalso useful for managing the computation of volatile attributes for\npersistent objects.\n\nPersistent descriptors:\n\n- ``property``\n\n  A simple computed property.\n\n  See ``src/zope/cachedescriptors/property.rst``.\n\n- ``method``\n\n  Idempotent method.  The return values are cached based on method\n  arguments and on any instance attributes that the methods are\n  defined to depend on.\n\n  .. note::\n\n     Only a cache based on arguments has been implemented so far.\n\n  See ``src/zope/cachedescriptors/method.rst``.\n\n===================\n Cached Properties\n===================\n\nCached properties are computed properties that cache their computed\nvalues.  They take into account instance attributes that they depend\non, so when the instance attributes change, the properties will change\nthe values they return.\n\nCachedProperty\n==============\n\nCached properties cache their data in ``_v_`` attributes, so they are\nalso useful for managing the computation of volatile attributes for\npersistent objects. Let's look at an example:\n\n    >>> from zope.cachedescriptors import property\n    >>> import math\n\n    >>> class Point:\n    ...\n    ...     def __init__(self, x, y):\n    ...         self.x, self.y = x, y\n    ...\n    ...     @property.CachedProperty('x', 'y')\n    ...     def radius(self):\n    ...         print('computing radius')\n    ...         return math.sqrt(self.x**2 + self.y**2)\n\n    >>> point = Point(1.0, 2.0)\n\nIf we ask for the radius the first time:\n\n    >>> '%.2f' % point.radius\n    computing radius\n    '2.24'\n\nWe see that the radius function is called, but if we ask for it again:\n\n    >>> '%.2f' % point.radius\n    '2.24'\n\nThe function isn't called.  If we change one of the attribute the\nradius depends on, it will be recomputed:\n\n    >>> point.x = 2.0\n    >>> '%.2f' % point.radius\n    computing radius\n    '2.83'\n\nBut changing other attributes doesn't cause recomputation:\n\n    >>> point.q = 1\n    >>> '%.2f' % point.radius\n    '2.83'\n\nNote that we don't have any non-volitile attributes added:\n\n    >>> names = [name for name in point.__dict__ if not name.startswith('_v_')]\n    >>> names.sort()\n    >>> names\n    ['q', 'x', 'y']\n\nFor backwards compatibility, the same thing can alternately be written\nwithout using decorator syntax:\n\n    >>> class Point:\n    ...\n    ...     def __init__(self, x, y):\n    ...         self.x, self.y = x, y\n    ...\n    ...     def radius(self):\n    ...         print('computing radius')\n    ...         return math.sqrt(self.x**2 + self.y**2)\n    ...     radius = property.CachedProperty(radius, 'x', 'y')\n\n    >>> point = Point(1.0, 2.0)\n\nIf we ask for the radius the first time:\n\n    >>> '%.2f' % point.radius\n    computing radius\n    '2.24'\n\nWe see that the radius function is called, but if we ask for it again:\n\n    >>> '%.2f' % point.radius\n    '2.24'\n\nThe function isn't called.  If we change one of the attribute the\nradius depends on, it will be recomputed:\n\n    >>> point.x = 2.0\n    >>> '%.2f' % point.radius\n    computing radius\n    '2.83'\n\nDocumentation and the ``__name__`` are preserved if the attribute is accessed through\nthe class. This allows Sphinx to extract the documentation.\n\n    >>> class Point:\n    ...\n    ...     def __init__(self, x, y):\n    ...         self.x, self.y = x, y\n    ...\n    ...     @property.CachedProperty('x', 'y')\n    ...     def radius(self):\n    ...         '''The length of the line between self.x and self.y'''\n    ...         print('computing radius')\n    ...         return math.sqrt(self.x**2 + self.y**2)\n\n    >>> print(Point.radius.__doc__)\n    The length of the line between self.x and self.y\n    >>> print(Point.radius.__name__)\n    radius\n\nIt is possible to specify a CachedProperty that has no dependencies.\nFor backwards compatibility this can be written in a few different ways::\n\n    >>> class Point:\n    ...     def __init__(self, x, y):\n    ...         self.x, self.y = x, y\n    ...\n    ...     @property.CachedProperty\n    ...     def no_deps_no_parens(self):\n    ...         print(\"No deps, no parens\")\n    ...         return 1\n    ...\n    ...     @property.CachedProperty()\n    ...     def no_deps(self):\n    ...         print(\"No deps\")\n    ...         return 2\n    ...\n    ...     def no_deps_old_style(self):\n    ...         print(\"No deps, old style\")\n    ...         return 3\n    ...     no_deps_old_style = property.CachedProperty(no_deps_old_style)\n\n\n    >>> point = Point(1.0, 2.0)\n    >>> point.no_deps_no_parens\n    No deps, no parens\n    1\n    >>> point.no_deps_no_parens\n    1\n    >>> point.no_deps\n    No deps\n    2\n    >>> point.no_deps\n    2\n    >>> point.no_deps_old_style\n    No deps, old style\n    3\n    >>> point.no_deps_old_style\n    3\n\n\nLazy Computed Attributes\n========================\n\nThe `property` module provides another descriptor that supports a\nslightly different caching model: lazy attributes.  Like cached\nproprties, they are computed the first time they are used. however,\nthey aren't stored in volatile attributes and they aren't\nautomatically updated when other attributes change.  Furthermore, the\nstore their data using their attribute name, thus overriding\nthemselves. This provides much faster attribute access after the\nattribute has been computed. Let's look at the previous example using\nlazy attributes:\n\n    >>> class Point:\n    ...\n    ...     def __init__(self, x, y):\n    ...         self.x, self.y = x, y\n    ...\n    ...     @property.Lazy\n    ...     def radius(self):\n    ...         print('computing radius')\n    ...         return math.sqrt(self.x**2 + self.y**2)\n\n    >>> point = Point(1.0, 2.0)\n\nIf we ask for the radius the first time:\n\n    >>> '%.2f' % point.radius\n    computing radius\n    '2.24'\n\nWe see that the radius function is called, but if we ask for it again:\n\n    >>> '%.2f' % point.radius\n    '2.24'\n\nThe function isn't called.  If we change one of the attribute the\nradius depends on, it still isn't called:\n\n    >>> point.x = 2.0\n    >>> '%.2f' % point.radius\n    '2.24'\n\nIf we want the radius to be recomputed, we have to manually delete it:\n\n    >>> del point.radius\n\n    >>> point.x = 2.0\n    >>> '%.2f' % point.radius\n    computing radius\n    '2.83'\n\nNote that the radius is stored in the instance dictionary:\n\n    >>> '%.2f' % point.__dict__['radius']\n    '2.83'\n\nThe lazy attribute needs to know the attribute name.  It normally\ndeduces the attribute name from the name of the function passed. If we\nwant to use a different name, we need to pass it:\n\n    >>> def d(point):\n    ...     print('computing diameter')\n    ...     return 2*point.radius\n\n    >>> Point.diameter = property.Lazy(d, 'diameter')\n    >>> '%.2f' % point.diameter\n    computing diameter\n    '5.66'\n\nDocumentation and the ``__name__`` are preserved if the attribute is accessed through\nthe class. This allows Sphinx to extract the documentation.\n\n    >>> class Point:\n    ...\n    ...     def __init__(self, x, y):\n    ...         self.x, self.y = x, y\n    ...\n    ...     @property.Lazy\n    ...     def radius(self):\n    ...         '''The length of the line between self.x and self.y'''\n    ...         print('computing radius')\n    ...         return math.sqrt(self.x**2 + self.y**2)\n\n    >>> print(Point.radius.__doc__)\n    The length of the line between self.x and self.y\n    >>> print(Point.radius.__name__)\n    radius\n\nThe documentation of the attribute when accessed through the\ninstance will be the same as the return-value:\n\n   >>> p = Point(1.0, 2.0)\n   >>> p.radius.__doc__ == float.__doc__\n   computing radius\n   True\n\nThis is the same behaviour as the standard Python ``property``\ndecorator.\n\nreadproperty\n============\n\nreadproperties are like lazy computed attributes except that the\nattribute isn't set by the property:\n\n\n    >>> class Point:\n    ...\n    ...     def __init__(self, x, y):\n    ...         self.x, self.y = x, y\n    ...\n    ...     @property.readproperty\n    ...     def radius(self):\n    ...         print('computing radius')\n    ...         return math.sqrt(self.x**2 + self.y**2)\n\n    >>> point = Point(1.0, 2.0)\n\n    >>> '%.2f' % point.radius\n    computing radius\n    '2.24'\n\n    >>> '%.2f' % point.radius\n    computing radius\n    '2.24'\n\nBut you *can* replace the property by setting a value. This is the major\ndifference to the builtin `property`:\n\n    >>> point.radius = 5\n    >>> point.radius\n    5\n\nDocumentation and the ``__name__`` are preserved if the attribute is accessed through\nthe class. This allows Sphinx to extract the documentation.\n\n    >>> class Point:\n    ...\n    ...     def __init__(self, x, y):\n    ...         self.x, self.y = x, y\n    ...\n    ...     @property.readproperty\n    ...     def radius(self):\n    ...         '''The length of the line between self.x and self.y'''\n    ...         print('computing radius')\n    ...         return math.sqrt(self.x**2 + self.y**2)\n\n    >>> print(Point.radius.__doc__)\n    The length of the line between self.x and self.y\n    >>> print(Point.radius.__name__)\n    radius\n\ncachedIn\n========\n\nThe `cachedIn` property allows to specify the attribute where to store the\ncomputed value:\n\n    >>> class Point:\n    ...\n    ...     def __init__(self, x, y):\n    ...         self.x, self.y = x, y\n    ...\n    ...     @property.cachedIn('_radius_attribute')\n    ...     def radius(self):\n    ...         print('computing radius')\n    ...         return math.sqrt(self.x**2 + self.y**2)\n\n    >>> point = Point(1.0, 2.0)\n\n    >>> '%.2f' % point.radius\n    computing radius\n    '2.24'\n\n    >>> '%.2f' % point.radius\n    '2.24'\n\nThe radius is cached in the attribute with the given name, `_radius_attribute`\nin this case:\n\n    >>> '%.2f' % point._radius_attribute\n    '2.24'\n\nWhen the attribute is removed the radius is re-calculated once. This allows\ninvalidation:\n\n    >>> del point._radius_attribute\n\n    >>> '%.2f' % point.radius\n    computing radius\n    '2.24'\n\n    >>> '%.2f' % point.radius\n    '2.24'\n\nDocumentation is preserved if the attribute is accessed through\nthe class. This allows Sphinx to extract the documentation.\n\n    >>> class Point:\n    ...\n    ...     def __init__(self, x, y):\n    ...         self.x, self.y = x, y\n    ...\n    ...     @property.cachedIn('_radius_attribute')\n    ...     def radius(self):\n    ...         '''The length of the line between self.x and self.y'''\n    ...         print('computing radius')\n    ...         return math.sqrt(self.x**2 + self.y**2)\n\n    >>> print(Point.radius.__doc__)\n    The length of the line between self.x and self.y\n\n==============\n Method Cache\n==============\n\ncachedIn\n========\n\nThe `cachedIn` property allows to specify the attribute where to store the\ncomputed value:\n\n    >>> import math\n    >>> from zope.cachedescriptors import method\n\n    >>> class Point(object):\n    ...\n    ...     def __init__(self, x, y):\n    ...         self.x, self.y = x, y\n    ...\n    ...     @method.cachedIn('_cache')\n    ...     def distance(self, x, y):\n    ...         \"\"\"Compute the distance\"\"\"\n    ...         print('computing distance')\n    ...         return math.hypot(self.x - x, self.y - y)\n    ...\n    >>> point = Point(1.0, 2.0)\n\nThe value is computed once:\n\n    >>> point.distance(2, 2)\n    computing distance\n    1.0\n    >>> point.distance(2, 2)\n    1.0\n\n\nUsing different arguments calculates a new distance:\n\n    >>> point.distance(5, 2)\n    computing distance\n    4.0\n    >>> point.distance(5, 2)\n    4.0\n\n\nThe data is stored at the given `_cache` attribute:\n\n    >>> isinstance(point._cache, dict)\n    True\n\n    >>> sorted(point._cache.items())\n    [(((2, 2), ()), 1.0), (((5, 2), ()), 4.0)]\n\n\nIt is possible to exlicitly invalidate the data:\n\n    >>> point.distance.invalidate(point, 5, 2)\n    >>> point.distance(5, 2)\n    computing distance\n    4.0\n\nInvalidating keys which are not in the cache, does not result in an error:\n\n    >>> point.distance.invalidate(point, 47, 11)\n\nThe documentation of the function is preserved (whether through the\ninstance or the class), allowing Sphinx to extract it::\n\n    >>> print(point.distance.__doc__)\n    Compute the distance\n    >>> print(point.distance.__name__)\n    distance\n\n    >>> print(Point.distance.__doc__)\n    Compute the distance\n    >>> print(Point.distance.__name__)\n    distance\n\nIt is possible to pass in a factory for the cache attribute. Create another\nPoint class:\n\n\n    >>> class MyDict(dict):\n    ...     pass\n    >>> class Point(object):\n    ...\n    ...     def __init__(self, x, y):\n    ...         self.x, self.y = x, y\n    ...\n    ...     @method.cachedIn('_cache', MyDict)\n    ...     def distance(self, x, y):\n    ...         print('computing distance')\n    ...         return math.sqrt((self.x - x)**2 + (self.y - y)**2)\n    ...\n    >>> point = Point(1.0, 2.0)\n    >>> point.distance(2, 2)\n    computing distance\n    1.0\n\nNow the cache is a MyDict instance:\n\n    >>> isinstance(point._cache, MyDict)\n    True\n\n=========\n Changes\n=========\n\n4.3.1 (2017-12-09)\n==================\n\n- Fix test which will break in the upcomming Python 3.7 release.\n\n\n4.3.0 (2017-07-27)\n==================\n\n- Add support for Python 3.6.\n\n- Drop support for Python 3.3.\n\n\n4.2.0 (2016-09-05)\n==================\n\n- Add support for Python 3.5.\n\n- Drop support for Python 2.6 and 3.2.\n\n- The properties from the ``property`` module all preserve the\n  documentation string of the underlying function, and all except\n  ``cachedIn`` preserve everything that ``functools.update_wrapper``\n  preserves.\n\n- ``property.CachedProperty`` is usable as a decorator, with or\n  without dependent attribute names.\n\n- ``method.cachedIn`` preserves the documentation string of the\n  underlying function, and everything else that ``functools.wraps`` preserves.\n\n4.1.0 (2014-12-26)\n==================\n\n- Add support for PyPy and PyPy3.\n\n- Add support for Python 3.4.\n\n- Add support for testing on Travis.\n\n\n4.0.0 (2013-02-13)\n==================\n\n- Drop support for Python 2.4 and 2.5.\n\n- Add support for Python 3.2 and 3.3.\n\n\n3.5.1 (2010-04-30)\n==================\n\n- Remove undeclared testing dependency on zope.testing.\n\n3.5.0 (2009-02-10)\n==================\n\n- Remove dependency on ZODB by allowing to specify storage factory for\n  ``zope.cachedescriptors.method.cachedIn`` which is now ``dict`` by default.\n  If you need to use BTree instead, you must pass it as ``factory`` argument\n  to the ``zope.cachedescriptors.method.cachedIn`` decorator.\n\n- Remove zpkg-related file.\n\n- Clean up package description and documentation a bit.\n\n- Change package mailing list address to zope-dev at zope.org, as\n  zope3-dev at zope.org is now retired.\n\n3.4.0 (2007-08-30)\n==================\n\nInitial release as an independent package\n\n\n", "description_content_type": null, "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "http://github.com/zopefoundation/zope.cachedescriptors", "keywords": "persistent caching decorator method property", "license": "ZPL 2.1", "maintainer": "", "maintainer_email": "", "name": "zope.cachedescriptors", "package_url": "https://pypi.org/project/zope.cachedescriptors/", "platform": "", "project_url": "https://pypi.org/project/zope.cachedescriptors/", "project_urls": {"Homepage": "http://github.com/zopefoundation/zope.cachedescriptors"}, "release_url": "https://pypi.org/project/zope.cachedescriptors/4.3.1/", "requires_dist": ["setuptools"], "requires_python": "", "summary": "Method and property caching decorators", "version": "4.3.1", "yanked": false, "html_description": "<div class=\"project-description\">\n            <div id=\"zope-cachedescriptors\">\n<h2><tt>zope.cachedescriptors</tt></h2>\n<a href=\"https://pypi.org/project/zope.cachedescriptors/\" rel=\"nofollow\"><img alt=\"Latest release\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/93348fc4097e22fae2eb6cb95e5a10ee4929f6d7/68747470733a2f2f696d672e736869656c64732e696f2f707970692f762f7a6f70652e636163686564657363726970746f72732e737667\"></a>\n<a href=\"https://pypi.org/project/zope.cachedescriptors/\" rel=\"nofollow\"><img alt=\"Supported Python versions\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/6bb25972e4da071639ff17e64ab4fea6e937f45d/68747470733a2f2f696d672e736869656c64732e696f2f707970692f707976657273696f6e732f7a6f70652e636163686564657363726970746f72732e737667\"></a>\n<a href=\"https://travis-ci.org/zopefoundation/zope.cachedescriptors\" rel=\"nofollow\"><img alt=\"https://travis-ci.org/zopefoundation/zope.cachedescriptors.svg?branch=master\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/5a92a6e4bd045dc6d1adfda52c2ede0ff208f81b/68747470733a2f2f7472617669732d63692e6f72672f7a6f7065666f756e646174696f6e2f7a6f70652e636163686564657363726970746f72732e7376673f6272616e63683d6d6173746572\"></a>\n<a href=\"http://zopehookable.readthedocs.io/en/latest/\" rel=\"nofollow\"><img alt=\"Documentation Status\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/91197e543162d7c201b47d222535f4a16ba0275b/68747470733a2f2f72656164746865646f63732e6f72672f70726f6a656374732f7a6f7065686f6f6b61626c652f62616467652f3f76657273696f6e3d6c6174657374\"></a>\n<a href=\"https://coveralls.io/github/zopefoundation/zope.cachedescriptors?branch=master\" rel=\"nofollow\"><img alt=\"https://coveralls.io/repos/github/zopefoundation/zope.cachedescriptors/badge.svg?branch=master\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/c981680f400bf54c49bab262efed1af26196954e/68747470733a2f2f636f766572616c6c732e696f2f7265706f732f6769746875622f7a6f7065666f756e646174696f6e2f7a6f70652e636163686564657363726970746f72732f62616467652e7376673f6272616e63683d6d6173746572\"></a>\n<p>Cached descriptors cache their output.  They take into account\ninstance attributes that they depend on, so when the instance\nattributes change, the descriptors will change the values they\nreturn.</p>\n<p>Cached descriptors cache their data in <tt>_v_</tt> attributes, so they are\nalso useful for managing the computation of volatile attributes for\npersistent objects.</p>\n<p>Persistent descriptors:</p>\n<ul>\n<li><p><tt>property</tt></p>\n<p>A simple computed property.</p>\n<p>See <tt>src/zope/cachedescriptors/property.rst</tt>.</p>\n</li>\n<li><p><tt>method</tt></p>\n<p>Idempotent method.  The return values are cached based on method\narguments and on any instance attributes that the methods are\ndefined to depend on.</p>\n<div>\n<p>Note</p>\n<p>Only a cache based on arguments has been implemented so far.</p>\n</div>\n<p>See <tt>src/zope/cachedescriptors/method.rst</tt>.</p>\n</li>\n</ul>\n</div>\n<div id=\"cached-properties\">\n<h2>Cached Properties</h2>\n<p>Cached properties are computed properties that cache their computed\nvalues.  They take into account instance attributes that they depend\non, so when the instance attributes change, the properties will change\nthe values they return.</p>\n<div id=\"cachedproperty\">\n<h3>CachedProperty</h3>\n<p>Cached properties cache their data in <tt>_v_</tt> attributes, so they are\nalso useful for managing the computation of volatile attributes for\npersistent objects. Let\u2019s look at an example:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from zope.cachedescriptors import property\n&gt;&gt;&gt; import math\n</pre>\n<pre>&gt;&gt;&gt; class Point:\n...\n...     def __init__(self, x, y):\n...         self.x, self.y = x, y\n...\n...     @property.CachedProperty('x', 'y')\n...     def radius(self):\n...         print('computing radius')\n...         return math.sqrt(self.x**2 + self.y**2)\n</pre>\n<pre>&gt;&gt;&gt; point = Point(1.0, 2.0)\n</pre>\n</blockquote>\n<p>If we ask for the radius the first time:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; '%.2f' % point.radius\ncomputing radius\n'2.24'\n</pre>\n</blockquote>\n<p>We see that the radius function is called, but if we ask for it again:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; '%.2f' % point.radius\n'2.24'\n</pre>\n</blockquote>\n<p>The function isn\u2019t called.  If we change one of the attribute the\nradius depends on, it will be recomputed:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; point.x = 2.0\n&gt;&gt;&gt; '%.2f' % point.radius\ncomputing radius\n'2.83'\n</pre>\n</blockquote>\n<p>But changing other attributes doesn\u2019t cause recomputation:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; point.q = 1\n&gt;&gt;&gt; '%.2f' % point.radius\n'2.83'\n</pre>\n</blockquote>\n<p>Note that we don\u2019t have any non-volitile attributes added:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; names = [name for name in point.__dict__ if not name.startswith('_v_')]\n&gt;&gt;&gt; names.sort()\n&gt;&gt;&gt; names\n['q', 'x', 'y']\n</pre>\n</blockquote>\n<p>For backwards compatibility, the same thing can alternately be written\nwithout using decorator syntax:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; class Point:\n...\n...     def __init__(self, x, y):\n...         self.x, self.y = x, y\n...\n...     def radius(self):\n...         print('computing radius')\n...         return math.sqrt(self.x**2 + self.y**2)\n...     radius = property.CachedProperty(radius, 'x', 'y')\n</pre>\n<pre>&gt;&gt;&gt; point = Point(1.0, 2.0)\n</pre>\n</blockquote>\n<p>If we ask for the radius the first time:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; '%.2f' % point.radius\ncomputing radius\n'2.24'\n</pre>\n</blockquote>\n<p>We see that the radius function is called, but if we ask for it again:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; '%.2f' % point.radius\n'2.24'\n</pre>\n</blockquote>\n<p>The function isn\u2019t called.  If we change one of the attribute the\nradius depends on, it will be recomputed:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; point.x = 2.0\n&gt;&gt;&gt; '%.2f' % point.radius\ncomputing radius\n'2.83'\n</pre>\n</blockquote>\n<p>Documentation and the <tt>__name__</tt> are preserved if the attribute is accessed through\nthe class. This allows Sphinx to extract the documentation.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; class Point:\n...\n...     def __init__(self, x, y):\n...         self.x, self.y = x, y\n...\n...     @property.CachedProperty('x', 'y')\n...     def radius(self):\n...         '''The length of the line between self.x and self.y'''\n...         print('computing radius')\n...         return math.sqrt(self.x**2 + self.y**2)\n</pre>\n<pre>&gt;&gt;&gt; print(Point.radius.__doc__)\nThe length of the line between self.x and self.y\n&gt;&gt;&gt; print(Point.radius.__name__)\nradius\n</pre>\n</blockquote>\n<p>It is possible to specify a CachedProperty that has no dependencies.\nFor backwards compatibility this can be written in a few different ways:</p>\n<pre>&gt;&gt;&gt; class Point:\n...     def __init__(self, x, y):\n...         self.x, self.y = x, y\n...\n...     @property.CachedProperty\n...     def no_deps_no_parens(self):\n...         print(\"No deps, no parens\")\n...         return 1\n...\n...     @property.CachedProperty()\n...     def no_deps(self):\n...         print(\"No deps\")\n...         return 2\n...\n...     def no_deps_old_style(self):\n...         print(\"No deps, old style\")\n...         return 3\n...     no_deps_old_style = property.CachedProperty(no_deps_old_style)\n\n\n&gt;&gt;&gt; point = Point(1.0, 2.0)\n&gt;&gt;&gt; point.no_deps_no_parens\nNo deps, no parens\n1\n&gt;&gt;&gt; point.no_deps_no_parens\n1\n&gt;&gt;&gt; point.no_deps\nNo deps\n2\n&gt;&gt;&gt; point.no_deps\n2\n&gt;&gt;&gt; point.no_deps_old_style\nNo deps, old style\n3\n&gt;&gt;&gt; point.no_deps_old_style\n3\n</pre>\n</div>\n<div id=\"lazy-computed-attributes\">\n<h3>Lazy Computed Attributes</h3>\n<p>The <cite>property</cite> module provides another descriptor that supports a\nslightly different caching model: lazy attributes.  Like cached\nproprties, they are computed the first time they are used. however,\nthey aren\u2019t stored in volatile attributes and they aren\u2019t\nautomatically updated when other attributes change.  Furthermore, the\nstore their data using their attribute name, thus overriding\nthemselves. This provides much faster attribute access after the\nattribute has been computed. Let\u2019s look at the previous example using\nlazy attributes:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; class Point:\n...\n...     def __init__(self, x, y):\n...         self.x, self.y = x, y\n...\n...     @property.Lazy\n...     def radius(self):\n...         print('computing radius')\n...         return math.sqrt(self.x**2 + self.y**2)\n</pre>\n<pre>&gt;&gt;&gt; point = Point(1.0, 2.0)\n</pre>\n</blockquote>\n<p>If we ask for the radius the first time:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; '%.2f' % point.radius\ncomputing radius\n'2.24'\n</pre>\n</blockquote>\n<p>We see that the radius function is called, but if we ask for it again:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; '%.2f' % point.radius\n'2.24'\n</pre>\n</blockquote>\n<p>The function isn\u2019t called.  If we change one of the attribute the\nradius depends on, it still isn\u2019t called:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; point.x = 2.0\n&gt;&gt;&gt; '%.2f' % point.radius\n'2.24'\n</pre>\n</blockquote>\n<p>If we want the radius to be recomputed, we have to manually delete it:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; del point.radius\n</pre>\n<pre>&gt;&gt;&gt; point.x = 2.0\n&gt;&gt;&gt; '%.2f' % point.radius\ncomputing radius\n'2.83'\n</pre>\n</blockquote>\n<p>Note that the radius is stored in the instance dictionary:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; '%.2f' % point.__dict__['radius']\n'2.83'\n</pre>\n</blockquote>\n<p>The lazy attribute needs to know the attribute name.  It normally\ndeduces the attribute name from the name of the function passed. If we\nwant to use a different name, we need to pass it:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; def d(point):\n...     print('computing diameter')\n...     return 2*point.radius\n</pre>\n<pre>&gt;&gt;&gt; Point.diameter = property.Lazy(d, 'diameter')\n&gt;&gt;&gt; '%.2f' % point.diameter\ncomputing diameter\n'5.66'\n</pre>\n</blockquote>\n<p>Documentation and the <tt>__name__</tt> are preserved if the attribute is accessed through\nthe class. This allows Sphinx to extract the documentation.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; class Point:\n...\n...     def __init__(self, x, y):\n...         self.x, self.y = x, y\n...\n...     @property.Lazy\n...     def radius(self):\n...         '''The length of the line between self.x and self.y'''\n...         print('computing radius')\n...         return math.sqrt(self.x**2 + self.y**2)\n</pre>\n<pre>&gt;&gt;&gt; print(Point.radius.__doc__)\nThe length of the line between self.x and self.y\n&gt;&gt;&gt; print(Point.radius.__name__)\nradius\n</pre>\n</blockquote>\n<p>The documentation of the attribute when accessed through the\ninstance will be the same as the return-value:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; p = Point(1.0, 2.0)\n&gt;&gt;&gt; p.radius.__doc__ == float.__doc__\ncomputing radius\nTrue\n</pre>\n</blockquote>\n<p>This is the same behaviour as the standard Python <tt>property</tt>\ndecorator.</p>\n</div>\n<div id=\"readproperty\">\n<h3>readproperty</h3>\n<p>readproperties are like lazy computed attributes except that the\nattribute isn\u2019t set by the property:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; class Point:\n...\n...     def __init__(self, x, y):\n...         self.x, self.y = x, y\n...\n...     @property.readproperty\n...     def radius(self):\n...         print('computing radius')\n...         return math.sqrt(self.x**2 + self.y**2)\n</pre>\n<pre>&gt;&gt;&gt; point = Point(1.0, 2.0)\n</pre>\n<pre>&gt;&gt;&gt; '%.2f' % point.radius\ncomputing radius\n'2.24'\n</pre>\n<pre>&gt;&gt;&gt; '%.2f' % point.radius\ncomputing radius\n'2.24'\n</pre>\n</blockquote>\n<p>But you <em>can</em> replace the property by setting a value. This is the major\ndifference to the builtin <cite>property</cite>:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; point.radius = 5\n&gt;&gt;&gt; point.radius\n5\n</pre>\n</blockquote>\n<p>Documentation and the <tt>__name__</tt> are preserved if the attribute is accessed through\nthe class. This allows Sphinx to extract the documentation.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; class Point:\n...\n...     def __init__(self, x, y):\n...         self.x, self.y = x, y\n...\n...     @property.readproperty\n...     def radius(self):\n...         '''The length of the line between self.x and self.y'''\n...         print('computing radius')\n...         return math.sqrt(self.x**2 + self.y**2)\n</pre>\n<pre>&gt;&gt;&gt; print(Point.radius.__doc__)\nThe length of the line between self.x and self.y\n&gt;&gt;&gt; print(Point.radius.__name__)\nradius\n</pre>\n</blockquote>\n</div>\n<div id=\"cachedin\">\n<h3>cachedIn</h3>\n<p>The <cite>cachedIn</cite> property allows to specify the attribute where to store the\ncomputed value:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; class Point:\n...\n...     def __init__(self, x, y):\n...         self.x, self.y = x, y\n...\n...     @property.cachedIn('_radius_attribute')\n...     def radius(self):\n...         print('computing radius')\n...         return math.sqrt(self.x**2 + self.y**2)\n</pre>\n<pre>&gt;&gt;&gt; point = Point(1.0, 2.0)\n</pre>\n<pre>&gt;&gt;&gt; '%.2f' % point.radius\ncomputing radius\n'2.24'\n</pre>\n<pre>&gt;&gt;&gt; '%.2f' % point.radius\n'2.24'\n</pre>\n</blockquote>\n<p>The radius is cached in the attribute with the given name, <cite>_radius_attribute</cite>\nin this case:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; '%.2f' % point._radius_attribute\n'2.24'\n</pre>\n</blockquote>\n<p>When the attribute is removed the radius is re-calculated once. This allows\ninvalidation:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; del point._radius_attribute\n</pre>\n<pre>&gt;&gt;&gt; '%.2f' % point.radius\ncomputing radius\n'2.24'\n</pre>\n<pre>&gt;&gt;&gt; '%.2f' % point.radius\n'2.24'\n</pre>\n</blockquote>\n<p>Documentation is preserved if the attribute is accessed through\nthe class. This allows Sphinx to extract the documentation.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; class Point:\n...\n...     def __init__(self, x, y):\n...         self.x, self.y = x, y\n...\n...     @property.cachedIn('_radius_attribute')\n...     def radius(self):\n...         '''The length of the line between self.x and self.y'''\n...         print('computing radius')\n...         return math.sqrt(self.x**2 + self.y**2)\n</pre>\n<pre>&gt;&gt;&gt; print(Point.radius.__doc__)\nThe length of the line between self.x and self.y\n</pre>\n</blockquote>\n</div>\n</div>\n<div id=\"method-cache\">\n<h2>Method Cache</h2>\n<h2 id=\"id1\"><span class=\"section-subtitle\">cachedIn</span></h2>\n<p>The <cite>cachedIn</cite> property allows to specify the attribute where to store the\ncomputed value:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; import math\n&gt;&gt;&gt; from zope.cachedescriptors import method\n</pre>\n<pre>&gt;&gt;&gt; class Point(object):\n...\n...     def __init__(self, x, y):\n...         self.x, self.y = x, y\n...\n...     @method.cachedIn('_cache')\n...     def distance(self, x, y):\n...         \"\"\"Compute the distance\"\"\"\n...         print('computing distance')\n...         return math.hypot(self.x - x, self.y - y)\n...\n&gt;&gt;&gt; point = Point(1.0, 2.0)\n</pre>\n</blockquote>\n<p>The value is computed once:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; point.distance(2, 2)\ncomputing distance\n1.0\n&gt;&gt;&gt; point.distance(2, 2)\n1.0\n</pre>\n</blockquote>\n<p>Using different arguments calculates a new distance:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; point.distance(5, 2)\ncomputing distance\n4.0\n&gt;&gt;&gt; point.distance(5, 2)\n4.0\n</pre>\n</blockquote>\n<p>The data is stored at the given <cite>_cache</cite> attribute:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; isinstance(point._cache, dict)\nTrue\n</pre>\n<pre>&gt;&gt;&gt; sorted(point._cache.items())\n[(((2, 2), ()), 1.0), (((5, 2), ()), 4.0)]\n</pre>\n</blockquote>\n<p>It is possible to exlicitly invalidate the data:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; point.distance.invalidate(point, 5, 2)\n&gt;&gt;&gt; point.distance(5, 2)\ncomputing distance\n4.0\n</pre>\n</blockquote>\n<p>Invalidating keys which are not in the cache, does not result in an error:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; point.distance.invalidate(point, 47, 11)\n</pre>\n</blockquote>\n<p>The documentation of the function is preserved (whether through the\ninstance or the class), allowing Sphinx to extract it:</p>\n<pre>&gt;&gt;&gt; print(point.distance.__doc__)\nCompute the distance\n&gt;&gt;&gt; print(point.distance.__name__)\ndistance\n\n&gt;&gt;&gt; print(Point.distance.__doc__)\nCompute the distance\n&gt;&gt;&gt; print(Point.distance.__name__)\ndistance\n</pre>\n<p>It is possible to pass in a factory for the cache attribute. Create another\nPoint class:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; class MyDict(dict):\n...     pass\n&gt;&gt;&gt; class Point(object):\n...\n...     def __init__(self, x, y):\n...         self.x, self.y = x, y\n...\n...     @method.cachedIn('_cache', MyDict)\n...     def distance(self, x, y):\n...         print('computing distance')\n...         return math.sqrt((self.x - x)**2 + (self.y - y)**2)\n...\n&gt;&gt;&gt; point = Point(1.0, 2.0)\n&gt;&gt;&gt; point.distance(2, 2)\ncomputing distance\n1.0\n</pre>\n</blockquote>\n<p>Now the cache is a MyDict instance:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; isinstance(point._cache, MyDict)\nTrue\n</pre>\n</blockquote>\n</div>\n<div id=\"changes\">\n<h2>Changes</h2>\n<div id=\"id2\">\n<h3>4.3.1 (2017-12-09)</h3>\n<ul>\n<li>Fix test which will break in the upcomming Python 3.7 release.</li>\n</ul>\n</div>\n<div id=\"id3\">\n<h3>4.3.0 (2017-07-27)</h3>\n<ul>\n<li>Add support for Python 3.6.</li>\n<li>Drop support for Python 3.3.</li>\n</ul>\n</div>\n<div id=\"id4\">\n<h3>4.2.0 (2016-09-05)</h3>\n<ul>\n<li>Add support for Python 3.5.</li>\n<li>Drop support for Python 2.6 and 3.2.</li>\n<li>The properties from the <tt>property</tt> module all preserve the\ndocumentation string of the underlying function, and all except\n<tt>cachedIn</tt> preserve everything that <tt>functools.update_wrapper</tt>\npreserves.</li>\n<li><tt>property.CachedProperty</tt> is usable as a decorator, with or\nwithout dependent attribute names.</li>\n<li><tt>method.cachedIn</tt> preserves the documentation string of the\nunderlying function, and everything else that <tt>functools.wraps</tt> preserves.</li>\n</ul>\n</div>\n<div id=\"id5\">\n<h3>4.1.0 (2014-12-26)</h3>\n<ul>\n<li>Add support for PyPy and PyPy3.</li>\n<li>Add support for Python 3.4.</li>\n<li>Add support for testing on Travis.</li>\n</ul>\n</div>\n<div id=\"id6\">\n<h3>4.0.0 (2013-02-13)</h3>\n<ul>\n<li>Drop support for Python 2.4 and 2.5.</li>\n<li>Add support for Python 3.2 and 3.3.</li>\n</ul>\n</div>\n<div id=\"id7\">\n<h3>3.5.1 (2010-04-30)</h3>\n<ul>\n<li>Remove undeclared testing dependency on zope.testing.</li>\n</ul>\n</div>\n<div id=\"id8\">\n<h3>3.5.0 (2009-02-10)</h3>\n<ul>\n<li>Remove dependency on ZODB by allowing to specify storage factory for\n<tt>zope.cachedescriptors.method.cachedIn</tt> which is now <tt>dict</tt> by default.\nIf you need to use BTree instead, you must pass it as <tt>factory</tt> argument\nto the <tt>zope.cachedescriptors.method.cachedIn</tt> decorator.</li>\n<li>Remove zpkg-related file.</li>\n<li>Clean up package description and documentation a bit.</li>\n<li>Change package mailing list address to zope-dev at zope.org, as\nzope3-dev at zope.org is now retired.</li>\n</ul>\n</div>\n<div id=\"id9\">\n<h3>3.4.0 (2007-08-30)</h3>\n<p>Initial release as an independent package</p>\n</div>\n</div>\n\n          </div>"}, "last_serial": 3403010, "releases": {"3.4.0": [{"comment_text": "", "digests": {"md5": "0b49993716328c22d17efb698aa69797", "sha256": "233ef73866754f64832ce6fc790fa2284af1b69a69967de6ba732c5fd4190cfb"}, "downloads": -1, "filename": "zope.cachedescriptors-3.4.0.tar.gz", "has_sig": false, "md5_digest": "0b49993716328c22d17efb698aa69797", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 6647, "upload_time": "2007-08-30T13:13:59", "upload_time_iso_8601": "2007-08-30T13:13:59Z", "url": "https://files.pythonhosted.org/packages/8d/fa/710f90dadd0f758588efe1c71a520c6f542b9ffb144a213214c34e01fc22/zope.cachedescriptors-3.4.0.tar.gz", "yanked": false}], "3.4.0b1dev-r75668": [{"comment_text": "", "digests": {"md5": "50235cf71ab689ea3c7bf622154743c4", "sha256": "7c06b6a01aa0a36ac29e220652bf97018a4655a2bb5996305c1761e8b149fba2"}, "downloads": -1, "filename": "zope.cachedescriptors-3.4.0b1dev-r75668.tar.gz", "has_sig": false, "md5_digest": "50235cf71ab689ea3c7bf622154743c4", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 5264, "upload_time": "2007-05-10T11:02:05", "upload_time_iso_8601": "2007-05-10T11:02:05Z", "url": "https://files.pythonhosted.org/packages/74/c4/b9831d47c3c17b537c9f51af1f4fe3c2432bb177a1b315b1d0d03b852c39/zope.cachedescriptors-3.4.0b1dev-r75668.tar.gz", "yanked": false}], "3.4.1": [{"comment_text": "", "digests": {"md5": "e29c3cb2f3a3ebea3d562c817dffcb3e", "sha256": "83b2de4ae5bf7a4db833a5db9bff4682c7fbbf6d4969c0df00c743d4f61de5ae"}, "downloads": -1, "filename": "zope.cachedescriptors-3.4.1.tar.gz", "has_sig": false, "md5_digest": "e29c3cb2f3a3ebea3d562c817dffcb3e", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 7865, "upload_time": "2008-04-23T07:17:38", "upload_time_iso_8601": "2008-04-23T07:17:38Z", "url": "https://files.pythonhosted.org/packages/46/55/170e88ae72533e866c89345dc7ceb2188f5f37e6dd9c08f3988d876a4232/zope.cachedescriptors-3.4.1.tar.gz", "yanked": false}], "3.4dev-r72926": [{"comment_text": "", "digests": {"md5": "7d126e44e170ea6c5b40a1ea5958ea8c", "sha256": "ebe92c424981aea06db2294bfafde49c7b124a632e4df6dc9001ec720ae0c14c"}, "downloads": -1, "filename": "zope.cachedescriptors-3.4dev_r72926-py2.4.egg", "has_sig": false, "md5_digest": "7d126e44e170ea6c5b40a1ea5958ea8c", "packagetype": "bdist_egg", "python_version": "2.4", "requires_python": null, "size": 7674, "upload_time": "2007-03-21T07:21:21", "upload_time_iso_8601": "2007-03-21T07:21:21Z", "url": "https://files.pythonhosted.org/packages/81/a1/ff7d29995298a7342c9f24a07783127e1ad6796b921bd303b03241008c51/zope.cachedescriptors-3.4dev_r72926-py2.4.egg", "yanked": false}], "3.5.0": [{"comment_text": "", "digests": {"md5": "90cb40ca97c65c2054e30db7a327dea9", "sha256": "01041cb4463241fcf01e483af8a8da3eac1b6b62c0480f425c7232b0156c3830"}, "downloads": -1, "filename": "zope.cachedescriptors-3.5.0.tar.gz", "has_sig": false, "md5_digest": "90cb40ca97c65c2054e30db7a327dea9", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 7248, "upload_time": "2009-03-09T23:59:20", "upload_time_iso_8601": "2009-03-09T23:59:20.386788Z", "url": "https://files.pythonhosted.org/packages/98/5e/9c2da34228d023eda7e6a56fff6b9fe578d799d94c5c24dd063f5832a797/zope.cachedescriptors-3.5.0.tar.gz", "yanked": false}], "3.5.1": [{"comment_text": "", "digests": {"md5": "263459a95238fd61d17e815d97ca49ce", "sha256": "6a37062ce6b17029521155d3301a3df2bf05ebd6a8ee0477a031435a4a2af3d0"}, "downloads": -1, "filename": "zope.cachedescriptors-3.5.1.zip", "has_sig": false, "md5_digest": "263459a95238fd61d17e815d97ca49ce", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 17822, "upload_time": "2010-04-30T20:03:00", "upload_time_iso_8601": "2010-04-30T20:03:00.877556Z", "url": "https://files.pythonhosted.org/packages/b8/8a/b54eb8dea20aa3b7e55b186f43d50953a514c3e362c06e71d3005be11a5c/zope.cachedescriptors-3.5.1.zip", "yanked": false}], "4.0.0": [{"comment_text": "", "digests": {"md5": "8d308de8c936792c8e758058fcb7d0f0", "sha256": "8c2e03159e4181b616b8ab1e26e76b5002c7085792d82816887142959a483da4"}, "downloads": -1, "filename": "zope.cachedescriptors-4.0.0.tar.gz", "has_sig": false, "md5_digest": "8d308de8c936792c8e758058fcb7d0f0", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 9436, "upload_time": "2013-02-13T21:26:40", "upload_time_iso_8601": "2013-02-13T21:26:40.465921Z", "url": "https://files.pythonhosted.org/packages/40/33/694b6644c37f28553f4b9f20b3c3a20fb709a22574dff20b5bdffb09ecd5/zope.cachedescriptors-4.0.0.tar.gz", "yanked": false}], "4.1.0": [{"comment_text": "", "digests": {"md5": "146eb3f86cce5675aca8059810cac7a2", "sha256": "a7dbc94528444acd8c15b04750f64ebfda07b321f1ececaf5a6b5353439c195d"}, "downloads": -1, "filename": "zope.cachedescriptors-4.1.0.tar.gz", "has_sig": false, "md5_digest": "146eb3f86cce5675aca8059810cac7a2", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 10187, "upload_time": "2014-12-26T20:29:03", "upload_time_iso_8601": "2014-12-26T20:29:03.980882Z", "url": "https://files.pythonhosted.org/packages/58/f3/a8f4657fd45dd0c6ca6cb1d55ca452cdacf33bebc34561df284bfe2001f4/zope.cachedescriptors-4.1.0.tar.gz", "yanked": false}], "4.2.0": [{"comment_text": "", "digests": {"md5": "ba1c7163f92b33bf46cb712f9979801c", "sha256": "cd4cde000c981184017b4d1eeaa9ec221b8289b14b906a51163140f55afd1e1e"}, "downloads": -1, "filename": "zope.cachedescriptors-4.2.0-py2.py3-none-any.whl", "has_sig": true, "md5_digest": "ba1c7163f92b33bf46cb712f9979801c", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 16383, "upload_time": "2017-06-13T20:41:10", "upload_time_iso_8601": "2017-06-13T20:41:10.893598Z", "url": "https://files.pythonhosted.org/packages/41/58/03fadc1d58c28e57c2013d4200b82b52a75e6d0cdfbb7ed858de5e2ee571/zope.cachedescriptors-4.2.0-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "e1b00b7422ca515e2035784276c2b1d3", "sha256": "a6bdb3e18888ef1da1837ea29e3432edbe0a46033c001a0f7db476c7d05669f6"}, "downloads": -1, "filename": "zope.cachedescriptors-4.2.0.tar.gz", "has_sig": false, "md5_digest": "e1b00b7422ca515e2035784276c2b1d3", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 14474, "upload_time": "2016-09-05T06:12:12", "upload_time_iso_8601": "2016-09-05T06:12:12.112490Z", "url": "https://files.pythonhosted.org/packages/06/14/a188b03efc12813178585840e71a2c8751d0fe12dd644764c7025f202181/zope.cachedescriptors-4.2.0.tar.gz", "yanked": false}], "4.3.0": [{"comment_text": "", "digests": {"md5": "9ab646d2996336347ecf919b311b2368", "sha256": "dc7e5d6623276a59c7067ac47160c53e356323d5446f3650da6c8d3d82a8e028"}, "downloads": -1, "filename": "zope.cachedescriptors-4.3.0-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "9ab646d2996336347ecf919b311b2368", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 16282, "upload_time": "2017-07-27T13:10:53", "upload_time_iso_8601": "2017-07-27T13:10:53.404732Z", "url": "https://files.pythonhosted.org/packages/6a/ac/8b1fbdf234e576259eb5c09666caf36d2c64b27164d2cb3d6b058f9e5292/zope.cachedescriptors-4.3.0-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "2db7d1ccb4130ff3150667b24e690581", "sha256": "d7c734fc925f93ad3974b6783e59ecd04a0105cdb804dca43d0754b2f94ded3b"}, "downloads": -1, "filename": "zope.cachedescriptors-4.3.0.tar.gz", "has_sig": false, "md5_digest": "2db7d1ccb4130ff3150667b24e690581", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 15548, "upload_time": "2017-07-27T13:10:54", "upload_time_iso_8601": "2017-07-27T13:10:54.351309Z", "url": "https://files.pythonhosted.org/packages/d1/9d/8c147b80ec66dff0a70063fdb2dfb7db311120326098305ac951b2056026/zope.cachedescriptors-4.3.0.tar.gz", "yanked": false}], "4.3.1": [{"comment_text": "", "digests": {"md5": "f5e88e94ac1c47d851c9b7ea217d3194", "sha256": "ebf5d6768a7ef0a9e59bdc8a5416ce0e0ae2df86817bdb3b352defc410c9bf6d"}, "downloads": -1, "filename": "zope.cachedescriptors-4.3.1-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "f5e88e94ac1c47d851c9b7ea217d3194", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 16339, "upload_time": "2017-12-09T06:42:00", "upload_time_iso_8601": "2017-12-09T06:42:00.408636Z", "url": "https://files.pythonhosted.org/packages/81/6f/d668102e1bd4fba6cfb160e178477b4e5ade20ccac0b2b390d4f64d0bb9d/zope.cachedescriptors-4.3.1-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "42f3693f43bc93f3b1eb86940f58acf3", "sha256": "1f4d1a702f2ea3d177a1ffb404235551bb85560100ec88e6c98691734b1d194a"}, "downloads": -1, "filename": "zope.cachedescriptors-4.3.1.tar.gz", "has_sig": false, "md5_digest": "42f3693f43bc93f3b1eb86940f58acf3", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 16442, "upload_time": "2017-12-09T06:42:02", "upload_time_iso_8601": "2017-12-09T06:42:02.077054Z", "url": "https://files.pythonhosted.org/packages/2f/89/ebe1890cc6d3291ebc935558fa764d5fffe571018dbbee200e9db78762cb/zope.cachedescriptors-4.3.1.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "f5e88e94ac1c47d851c9b7ea217d3194", "sha256": "ebf5d6768a7ef0a9e59bdc8a5416ce0e0ae2df86817bdb3b352defc410c9bf6d"}, "downloads": -1, "filename": "zope.cachedescriptors-4.3.1-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "f5e88e94ac1c47d851c9b7ea217d3194", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 16339, "upload_time": "2017-12-09T06:42:00", "upload_time_iso_8601": "2017-12-09T06:42:00.408636Z", "url": "https://files.pythonhosted.org/packages/81/6f/d668102e1bd4fba6cfb160e178477b4e5ade20ccac0b2b390d4f64d0bb9d/zope.cachedescriptors-4.3.1-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "42f3693f43bc93f3b1eb86940f58acf3", "sha256": "1f4d1a702f2ea3d177a1ffb404235551bb85560100ec88e6c98691734b1d194a"}, "downloads": -1, "filename": "zope.cachedescriptors-4.3.1.tar.gz", "has_sig": false, "md5_digest": "42f3693f43bc93f3b1eb86940f58acf3", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 16442, "upload_time": "2017-12-09T06:42:02", "upload_time_iso_8601": "2017-12-09T06:42:02.077054Z", "url": "https://files.pythonhosted.org/packages/2f/89/ebe1890cc6d3291ebc935558fa764d5fffe571018dbbee200e9db78762cb/zope.cachedescriptors-4.3.1.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:14:09 2020"}