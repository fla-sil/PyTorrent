{"info": {"author": "Santi Villalba", "author_email": "sdvillal@gmail.com", "bugtrack_url": null, "classifiers": ["Intended Audience :: Developers", "Intended Audience :: Science/Research", "License :: OSI Approved", "Operating System :: Unix", "Programming Language :: Python :: 2", "Programming Language :: Python :: 2.7", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.4", "Topic :: Scientific/Engineering", "Topic :: Software Development"], "description": "jagged\n======\n\nEfficient storage of same-type, uneven-size arrays\n--------------------------------------------------\n\n|Pypi Version| \n\n*Jagged* is an ongoing amateur project exploring the storage panorama\nfor datasets containing (large amounts of) arrays with the same type\nand number of columns, but varying number of rows. Examples of such\ndatasets for which *jagged* has been used are collections of multivariate\ntimeseries (short animal behaviour snippets) and collections of molecules\n(represented as varying length strings).\n\nJagged aims to help analyzing data in the laptop and the cluster, in batch\nor interactively, providing a very lightweight store. Jagged provides fast\nretrieval of array subsets for many-GB datasets containing millions of rows.\n\nBy-design constraints\n---------------------\n\nFocus is on fast retrieval of arbitrary batch queries.\n\nJagged stores are append only.\n\nThere is no transaction, replication or distribution.\nIt is all files in your local or network disks.\n\nNot important efforts have been given yet to optimize\n(although some backends work quite smoothly).\n\nAt the moment, everything is simple algorithms implemented in pure python.\n\nInstallation\n------------\n\nIt should suffice to use pip::\n\n    pip install jagged\n\nJagged stores builds on top of several high quality python libraries: numpy, blosc,\nbloscpack, bcolz and joblib. It also needs whatami and python-future.\nTesting relies on pytest (you need to install all dependencies to test at the moment,\nthis will change soon).\n\n\nShowcase\n--------\n\nUsing jagged is simple. There are different implementations that provide\ntwo basic methods: *append* adds a new array to the store, *get* retrieves\ncollections of arrays identified by their insertion order in the store.\n\n.. code:: python\n\n    import os.path as op\n    import numpy as np\n    from jagged.mmap_backend import JaggedByMemmap\n\n    # A Jagged instance is all you need\n    jagged = JaggedByMemmap(op.expanduser(path='~/jagged-example/mmap'))\n    # You can drop here any you want to\n\n    # Generate a random dataset\n    rng = np.random.RandomState(0)\n    max_length = 2000\n    num_arrays = 100\n    originals = [rng.randn(rng.randint(0, max_length), 50)\n                 for _ in range(num_arrays))\n\n    # Add these to the store (context is usually optional but recommended)\n    with jagged:\n        indices = map(jagged.append, originals)\n\n    # What do we have in store?\n    print('Number of arrays: %d, number of rows: %d' % (jbmm.narrays, jbmm.nrows))\n    print('Jagged shape=%r, dtype=%r, order=%r' %\n          (jagged.shape, jagged.dtype, jagged.order))\n\n    # Check roundtrip\n    roundtripped = jagged.get(indices)\n    print('The store has %d arrays')\n\n    # Jagged stores self-identified themselves (using whatami)\n    print(jagged.what().id())\n\n    # Jagged stores can be iterated in chunks\n    # See iter\n\n    # Jagged stores can be populated from other jagged stores\n\n    # Some jagged stores allow to retrieve arbitrary rows as fast\n    # as arbitrary arrays.\n\n\nBackends\n--------\n\nAlthough rapidly changing, *jagged* already provides the following storage backends\nthat can be considered as working and stable. Other backends are planned.\n\n+-------------------+------+-------+--------+------+-----+------+------+\n| Backend           | comp | chunk | column | mmap | lin | lazy | cont |\n+===================+======+=======+========+======+=====+======+======+\n| JaggedByBlosc     | X    |       |        | X    |     |      |      |\n+-------------------+------+-------+--------+------+-----+------+------+\n| JaggedByCarray    | X    | X     |        |      | X   |      | X    |\n+-------------------+------+-------+--------+------+-----+------+------+\n| JaggedByH5Py      | X    | X     |        |      | X   | X    | X    |\n+-------------------+------+-------+--------+------+-----+------+------+\n| JaggedByJoblib    | X    | X     |        |      |     |      |      |\n+-------------------+------+-------+--------+------+-----+------+------+\n| JaggedByMemMap    |      |       |        | X    | X   | X    | X    |\n+-------------------+------+-------+--------+------+-----+------+------+\n| JaggedByNPY       |      |       |        |      |     |      |      |\n+-------------------+------+-------+--------+------+-----+------+------+\n| JaggedByBloscpack | X    |       |        |      |     |      |      |\n+-------------------+------+-------+--------+------+-----+------+------+\n| JaggedByPickle    | X    | X     |        |      |     |      |      |\n+-------------------+------+-------+--------+------+-----+------+------+\n\n\n- comp: can be compressed\n- chunk: can be chunked\n- column: stores columns of the array contiguously (can be easily implemented by using a store per column)\n- mmap: can open a memmap to the data\n- lin: can retrieve any row without the need to retrieve the whole\n       array it contains it\n- lazy: the arrays are not fetched immediatly; this can mean also that they can be managed\n        as virtual-memory by the OS (JaggedByMemMap only)\n- cont: retrieved arrays can be forced to lie in contiguous memory segments\n\nBenchmarks\n----------\n\nWhat backend and parameters work best depends on whether your data is compressible or not and the\nsizes of the arrays. We have a good idea of what works best for our data and are working at\nproviding a benchmarking framework. Find here a preview_.\n\n\n.. |Pypi Version| image:: https://badge.fury.io/py/jagged.svg\n   :target: http://badge.fury.io/py/jagged\n.. |Build Status| image:: https://travis-ci.org/sdvillal/jagged.svg?branch=master\n   :target: https://travis-ci.org/sdvillal/jagged\n.. |Coverage Status| image:: http://codecov.io/github/sdvillal/jagged/coverage.svg?branch=master\n   :target: http://codecov.io/github/sdvillal/jagged?branch=master\n.. |Scrutinizer Status| image:: https://scrutinizer-ci.com/g/sdvillal/jagged/badges/quality-score.png?b=master\n   :target: https://scrutinizer-ci.com/g/sdvillal/jagged/?branch=master\n.. _preview: https://github.com/sdvillal/strawlab-examples/tree/master/strawlab_examples/benchmarks", "description_content_type": null, "docs_url": null, "download_url": "UNKNOWN", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/sdvillal/jagged", "keywords": null, "license": "BSD 3 clause", "maintainer": null, "maintainer_email": null, "name": "jagged", "package_url": "https://pypi.org/project/jagged/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/jagged/", "project_urls": {"Download": "UNKNOWN", "Homepage": "https://github.com/sdvillal/jagged"}, "release_url": "https://pypi.org/project/jagged/0.1.0/", "requires_dist": null, "requires_python": null, "summary": "Simple tricks for efficient loading or merging collections of unevenly sized elements", "version": "0.1.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            <div id=\"efficient-storage-of-same-type-uneven-size-arrays\">\n<h2>Efficient storage of same-type, uneven-size arrays</h2>\n<p><a href=\"http://badge.fury.io/py/jagged\" rel=\"nofollow\"><img alt=\"Pypi Version\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/902aad9094f6d4cf6e4b4e17cf055345803dce55/68747470733a2f2f62616467652e667572792e696f2f70792f6a61676765642e737667\"></a></p>\n<p><em>Jagged</em> is an ongoing amateur project exploring the storage panorama\nfor datasets containing (large amounts of) arrays with the same type\nand number of columns, but varying number of rows. Examples of such\ndatasets for which <em>jagged</em> has been used are collections of multivariate\ntimeseries (short animal behaviour snippets) and collections of molecules\n(represented as varying length strings).</p>\n<p>Jagged aims to help analyzing data in the laptop and the cluster, in batch\nor interactively, providing a very lightweight store. Jagged provides fast\nretrieval of array subsets for many-GB datasets containing millions of rows.</p>\n</div>\n<div id=\"by-design-constraints\">\n<h2>By-design constraints</h2>\n<p>Focus is on fast retrieval of arbitrary batch queries.</p>\n<p>Jagged stores are append only.</p>\n<p>There is no transaction, replication or distribution.\nIt is all files in your local or network disks.</p>\n<p>Not important efforts have been given yet to optimize\n(although some backends work quite smoothly).</p>\n<p>At the moment, everything is simple algorithms implemented in pure python.</p>\n</div>\n<div id=\"installation\">\n<h2>Installation</h2>\n<p>It should suffice to use pip:</p>\n<pre>pip install jagged\n</pre>\n<p>Jagged stores builds on top of several high quality python libraries: numpy, blosc,\nbloscpack, bcolz and joblib. It also needs whatami and python-future.\nTesting relies on pytest (you need to install all dependencies to test at the moment,\nthis will change soon).</p>\n</div>\n<div id=\"showcase\">\n<h2>Showcase</h2>\n<p>Using jagged is simple. There are different implementations that provide\ntwo basic methods: <em>append</em> adds a new array to the store, <em>get</em> retrieves\ncollections of arrays identified by their insertion order in the store.</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">os.path</span> <span class=\"k\">as</span> <span class=\"nn\">op</span>\n<span class=\"kn\">import</span> <span class=\"nn\">numpy</span> <span class=\"k\">as</span> <span class=\"nn\">np</span>\n<span class=\"kn\">from</span> <span class=\"nn\">jagged.mmap_backend</span> <span class=\"kn\">import</span> <span class=\"n\">JaggedByMemmap</span>\n\n<span class=\"c1\"># A Jagged instance is all you need</span>\n<span class=\"n\">jagged</span> <span class=\"o\">=</span> <span class=\"n\">JaggedByMemmap</span><span class=\"p\">(</span><span class=\"n\">op</span><span class=\"o\">.</span><span class=\"n\">expanduser</span><span class=\"p\">(</span><span class=\"n\">path</span><span class=\"o\">=</span><span class=\"s1\">'~/jagged-example/mmap'</span><span class=\"p\">))</span>\n<span class=\"c1\"># You can drop here any you want to</span>\n\n<span class=\"c1\"># Generate a random dataset</span>\n<span class=\"n\">rng</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">random</span><span class=\"o\">.</span><span class=\"n\">RandomState</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">)</span>\n<span class=\"n\">max_length</span> <span class=\"o\">=</span> <span class=\"mi\">2000</span>\n<span class=\"n\">num_arrays</span> <span class=\"o\">=</span> <span class=\"mi\">100</span>\n<span class=\"n\">originals</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">rng</span><span class=\"o\">.</span><span class=\"n\">randn</span><span class=\"p\">(</span><span class=\"n\">rng</span><span class=\"o\">.</span><span class=\"n\">randint</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">max_length</span><span class=\"p\">),</span> <span class=\"mi\">50</span><span class=\"p\">)</span>\n             <span class=\"k\">for</span> <span class=\"n\">_</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"n\">num_arrays</span><span class=\"p\">))</span>\n\n<span class=\"c1\"># Add these to the store (context is usually optional but recommended)</span>\n<span class=\"k\">with</span> <span class=\"n\">jagged</span><span class=\"p\">:</span>\n    <span class=\"n\">indices</span> <span class=\"o\">=</span> <span class=\"nb\">map</span><span class=\"p\">(</span><span class=\"n\">jagged</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">,</span> <span class=\"n\">originals</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># What do we have in store?</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">'Number of arrays: </span><span class=\"si\">%d</span><span class=\"s1\">, number of rows: </span><span class=\"si\">%d</span><span class=\"s1\">'</span> <span class=\"o\">%</span> <span class=\"p\">(</span><span class=\"n\">jbmm</span><span class=\"o\">.</span><span class=\"n\">narrays</span><span class=\"p\">,</span> <span class=\"n\">jbmm</span><span class=\"o\">.</span><span class=\"n\">nrows</span><span class=\"p\">))</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">'Jagged shape=</span><span class=\"si\">%r</span><span class=\"s1\">, dtype=</span><span class=\"si\">%r</span><span class=\"s1\">, order=</span><span class=\"si\">%r</span><span class=\"s1\">'</span> <span class=\"o\">%</span>\n      <span class=\"p\">(</span><span class=\"n\">jagged</span><span class=\"o\">.</span><span class=\"n\">shape</span><span class=\"p\">,</span> <span class=\"n\">jagged</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">,</span> <span class=\"n\">jagged</span><span class=\"o\">.</span><span class=\"n\">order</span><span class=\"p\">))</span>\n\n<span class=\"c1\"># Check roundtrip</span>\n<span class=\"n\">roundtripped</span> <span class=\"o\">=</span> <span class=\"n\">jagged</span><span class=\"o\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"n\">indices</span><span class=\"p\">)</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">'The store has </span><span class=\"si\">%d</span><span class=\"s1\"> arrays'</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Jagged stores self-identified themselves (using whatami)</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">jagged</span><span class=\"o\">.</span><span class=\"n\">what</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">id</span><span class=\"p\">())</span>\n\n<span class=\"c1\"># Jagged stores can be iterated in chunks</span>\n<span class=\"c1\"># See iter</span>\n\n<span class=\"c1\"># Jagged stores can be populated from other jagged stores</span>\n\n<span class=\"c1\"># Some jagged stores allow to retrieve arbitrary rows as fast</span>\n<span class=\"c1\"># as arbitrary arrays.</span>\n</pre>\n</div>\n<div id=\"backends\">\n<h2>Backends</h2>\n<p>Although rapidly changing, <em>jagged</em> already provides the following storage backends\nthat can be considered as working and stable. Other backends are planned.</p>\n<table>\n<colgroup>\n<col>\n<col>\n<col>\n<col>\n<col>\n<col>\n<col>\n<col>\n</colgroup>\n<thead>\n<tr><th>Backend</th>\n<th>comp</th>\n<th>chunk</th>\n<th>column</th>\n<th>mmap</th>\n<th>lin</th>\n<th>lazy</th>\n<th>cont</th>\n</tr>\n</thead>\n<tbody>\n<tr><td>JaggedByBlosc</td>\n<td>X</td>\n<td>\u00a0</td>\n<td>\u00a0</td>\n<td>X</td>\n<td>\u00a0</td>\n<td>\u00a0</td>\n<td>\u00a0</td>\n</tr>\n<tr><td>JaggedByCarray</td>\n<td>X</td>\n<td>X</td>\n<td>\u00a0</td>\n<td>\u00a0</td>\n<td>X</td>\n<td>\u00a0</td>\n<td>X</td>\n</tr>\n<tr><td>JaggedByH5Py</td>\n<td>X</td>\n<td>X</td>\n<td>\u00a0</td>\n<td>\u00a0</td>\n<td>X</td>\n<td>X</td>\n<td>X</td>\n</tr>\n<tr><td>JaggedByJoblib</td>\n<td>X</td>\n<td>X</td>\n<td>\u00a0</td>\n<td>\u00a0</td>\n<td>\u00a0</td>\n<td>\u00a0</td>\n<td>\u00a0</td>\n</tr>\n<tr><td>JaggedByMemMap</td>\n<td>\u00a0</td>\n<td>\u00a0</td>\n<td>\u00a0</td>\n<td>X</td>\n<td>X</td>\n<td>X</td>\n<td>X</td>\n</tr>\n<tr><td>JaggedByNPY</td>\n<td>\u00a0</td>\n<td>\u00a0</td>\n<td>\u00a0</td>\n<td>\u00a0</td>\n<td>\u00a0</td>\n<td>\u00a0</td>\n<td>\u00a0</td>\n</tr>\n<tr><td>JaggedByBloscpack</td>\n<td>X</td>\n<td>\u00a0</td>\n<td>\u00a0</td>\n<td>\u00a0</td>\n<td>\u00a0</td>\n<td>\u00a0</td>\n<td>\u00a0</td>\n</tr>\n<tr><td>JaggedByPickle</td>\n<td>X</td>\n<td>X</td>\n<td>\u00a0</td>\n<td>\u00a0</td>\n<td>\u00a0</td>\n<td>\u00a0</td>\n<td>\u00a0</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>comp: can be compressed</li>\n<li>chunk: can be chunked</li>\n<li>column: stores columns of the array contiguously (can be easily implemented by using a store per column)</li>\n<li>mmap: can open a memmap to the data</li>\n<li><dl>\n<dt>lin: can retrieve any row without the need to retrieve the whole</dt>\n<dd>array it contains it</dd>\n</dl>\n</li>\n<li><dl>\n<dt>lazy: the arrays are not fetched immediatly; this can mean also that they can be managed</dt>\n<dd>as virtual-memory by the OS (JaggedByMemMap only)</dd>\n</dl>\n</li>\n<li>cont: retrieved arrays can be forced to lie in contiguous memory segments</li>\n</ul>\n</div>\n<div id=\"benchmarks\">\n<h2>Benchmarks</h2>\n<p>What backend and parameters work best depends on whether your data is compressible or not and the\nsizes of the arrays. We have a good idea of what works best for our data and are working at\nproviding a benchmarking framework. Find here a <a href=\"https://github.com/sdvillal/strawlab-examples/tree/master/strawlab_examples/benchmarks\" rel=\"nofollow\">preview</a>.</p>\n</div>\n\n          </div>"}, "last_serial": 1699158, "releases": {"0.1.0": [{"comment_text": "", "digests": {"md5": "09aea20f86a7689bad446117edb19778", "sha256": "cbaae035d3f221953064131042b4ab3bbc7a9bbda752f9150dc37ee749986ba7"}, "downloads": -1, "filename": "jagged-0.1.0.tar.gz", "has_sig": false, "md5_digest": "09aea20f86a7689bad446117edb19778", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 23718, "upload_time": "2015-08-29T06:20:23", "upload_time_iso_8601": "2015-08-29T06:20:23.033829Z", "url": "https://files.pythonhosted.org/packages/4a/df/9eb13cee1df8a2694f5a6a5997c447242c64edf7f95017c7466d69162104/jagged-0.1.0.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "09aea20f86a7689bad446117edb19778", "sha256": "cbaae035d3f221953064131042b4ab3bbc7a9bbda752f9150dc37ee749986ba7"}, "downloads": -1, "filename": "jagged-0.1.0.tar.gz", "has_sig": false, "md5_digest": "09aea20f86a7689bad446117edb19778", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 23718, "upload_time": "2015-08-29T06:20:23", "upload_time_iso_8601": "2015-08-29T06:20:23.033829Z", "url": "https://files.pythonhosted.org/packages/4a/df/9eb13cee1df8a2694f5a6a5997c447242c64edf7f95017c7466d69162104/jagged-0.1.0.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:53:21 2020"}