{"info": {"author": "isidentical", "author_email": "isidentical@gmail.com", "bugtrack_url": null, "classifiers": [], "description": "# Bicycle Repair Man\nBRM is a python source rewriting library with the freedom you are looking for. It gives you a chance to intervene lexing before any tree-like structre constructed. You are free to do anything; change already constructed tokens with matching them according to your patterns, put **new** tokens and modify the lexer rules, refactor tons of python files without losing any information (full roundtripability).\n\n\nThis long paragraph can be boring, let me show you some examples of what you can actually.\n\n\nI hate plus operator\n```py\nclass DestoryAllOfThem(TokenTransformer):\n    def visit_plus(self, token):\n        return token._replace(string=\"-\")\n\ntransformer = DestoryAllOfThem()\nassert transformer.transform(\"(2p) + 2 # with my precious comment\") == \"(2p) - 2 # with my precious comment\"\n```\n\nWhy I have to use `x ** 0.5` in order to get square root of `x`, can't I just use a `\u221a` operator?\n```py\nclass SquareRoot(TokenTransformer):\n\n    def register_squareroot(self):\n        return \"\u221a\"\n\n    @pattern(\"squareroot\", \"number\")\n    def remove_varprefix(self, operator, token):\n        return self.quick_tokenize(f\"int({token.string} ** 0.5)\")\n\nsqr = SquareRoot()\nassert eval(sqr.transform(\"\u221a9 # some more comments\")) == 3\nassert \"some more comments\" in sqr.transform(\"\u221a9 # some more comments\")\n```\n\n## Making transformers permanent\nIf you like your transformer and use it on the real python files, you can use `~/.brm` folder. Actually you shouldn't depend that folder, you can just write your transformer and do this `cp transformer.py $(python -m brm)`. It should print out the right location for transformers. After that operation you can just add `# coding: brm` comment to every python file you want to use your transformers. If you already using an encoding you can keep using it with `# coding: brm-<encoding>` like `# coding: brm-utf8` etc. Let's do an example\n\n```py\nfrom brm import TokenTransformer, pattern\n\nclass AlwaysTrue(TokenTransformer):\n\n    STRICT = False\n\n    @pattern(\"name\", \"*any\", \"colon\")\n    def always_true_if(self, *tokens):\n        statement, *_, colon = tokens\n        if statement.string not in {\"if\", \"elif\", \"while\"}:\n            return\n        true, = self.quick_tokenize(\"True\")\n        return (statement, true, colon)\n\n```\nFirst of all, the `STRICT` state means do we care about how the result would look like. In this case, no. Because imagine this as a pre-processor, no one is going to see the result of processed text it except the interpreter it self. So we are free to swallow every location information (that won't break any code integrity).\n\n\nThis example's pattern starts with a  that catches a name, which could be a keyword but during the lexing you can't know if it is or not. Then it catches as many things as possible until it gets a colon. The transformer function assignes first token to `statement` and last token to `colon` and swallows all of the tokens between them. The swallowed tokens constructs the actual condition but they wont be needed because we'll just replace condition with True. After setting statement, we just acess `string` attribute (which contains the value of token) and check if it is a valid keyword. If it is not, we return `None` which means this transformer didn't change anything and continue. If it is a valid statement we'll use `quick_tokenize` method to get tokens from a string. It is returning a sequence so we'll do some unpacking with trailing comma. At the end we'll return a sequence of tokens; the statement it self (e.g `if` keyword), `True` token and the colon (`:`).\n\n\nAfter we finish our work with transformer, we'll put this to the pre-processor folder of BRM. Transformers on that folder will be executed on every python interpreter run, and transform python sources if they use special brm coding (`# coding: brm`).\n\n```\n(.venv) [  9:12\u00d6S ]  [ isidentical@x200:~ ]\n $ cat -n r.py\n     1  # coding: brm\n     2\n     3  a = 2\n     4  if a > 2:\n     5      print(\"LOL\")\n(.venv) [  9:12\u00d6S ]  [ isidentical@x200:~ ]\n $ cp test.py $(python -m brm)\n(.venv) [  9:12\u00d6S ]  [ isidentical@x200:~ ]\n $ python r.py\nLOL\n```\n\nTA-DA!\n\n# BRM Pattern Syntax\nBRM sees python source code as a stream of token types when it is searching a pattern. Imagine this code;\n```py\nif a == x:\n    2 + 2 # lol\n```\nthe text representation of this tokens is like this;\n```\nNAME NAME EQEQUAL NAME COLON NEWLINE INDENT NUMBER PLUS NUMBER COMMENT NEWLINE DEDENT ENDMARKER\n```\nAnd BRM process it like this\n\n\n![brm pattern show gif](docs/pattern.gif)\n\n\nIf you want to match binary plus operation here (`2 + 2`), you can create pattern with `number, plus, name`.\nIf you want to match if statement's body, you can use some implicit tokens (which we can't show in the gif :D) called `INDENT` and `DEDENT`. So If there are only simple expressions or statements inside to if's body, you can create a pattern that starts with an indent token and takes anything between that indent and the dedent token, `indent, *any, dedent`. Any is a pattern that expands to any token, like regex's `(.?*)` capturing group. \n\n![brm pattern matching complex gif](docs/custom_patterns.gif)\n\nWanna try this? Just run `python visualize.py --help`\n# Some minor functions\n- `quick_tokenize(source: str)` => `List[TokenInfo]`, give some source and get some tokens that can construct the same source that was inputted.\n- `quick_untokenize(tokens: Sequence[TokenInfo])` => `str`, give some sequence of tokens and get a string form of it without any usage of positions. It helps the cases when you dont want to deal with preceding issues about token locations. If you want to get a pretty input with using token locations, call `tokenize.untokenize` directly.\n- `directional_length(tokens: Sequence[TokenInfo])` => `int`, calculate the X distance between start of the sequence and end of the sequence.\n- `shift_all(tokens: Sequence[TokenInfo], x_offset: int, y_offset: int)` => `int`, shift positions of all tokens in the given sequence\n- `get_type(token: TokenInfo)`", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/isidentical/brm", "keywords": "", "license": "", "maintainer": "", "maintainer_email": "", "name": "brm", "package_url": "https://pypi.org/project/brm/", "platform": "", "project_url": "https://pypi.org/project/brm/", "project_urls": {"Homepage": "https://github.com/isidentical/brm"}, "release_url": "https://pypi.org/project/brm/0.2.7/", "requires_dist": null, "requires_python": ">=3.6", "summary": "Bicycle Repair Man - Rewrite Python Sources", "version": "0.2.7", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>Bicycle Repair Man</h1>\n<p>BRM is a python source rewriting library with the freedom you are looking for. It gives you a chance to intervene lexing before any tree-like structre constructed. You are free to do anything; change already constructed tokens with matching them according to your patterns, put <strong>new</strong> tokens and modify the lexer rules, refactor tons of python files without losing any information (full roundtripability).</p>\n<p>This long paragraph can be boring, let me show you some examples of what you can actually.</p>\n<p>I hate plus operator</p>\n<pre><span class=\"k\">class</span> <span class=\"nc\">DestoryAllOfThem</span><span class=\"p\">(</span><span class=\"n\">TokenTransformer</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"nf\">visit_plus</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">token</span><span class=\"p\">):</span>\n        <span class=\"k\">return</span> <span class=\"n\">token</span><span class=\"o\">.</span><span class=\"n\">_replace</span><span class=\"p\">(</span><span class=\"n\">string</span><span class=\"o\">=</span><span class=\"s2\">\"-\"</span><span class=\"p\">)</span>\n\n<span class=\"n\">transformer</span> <span class=\"o\">=</span> <span class=\"n\">DestoryAllOfThem</span><span class=\"p\">()</span>\n<span class=\"k\">assert</span> <span class=\"n\">transformer</span><span class=\"o\">.</span><span class=\"n\">transform</span><span class=\"p\">(</span><span class=\"s2\">\"(2p) + 2 # with my precious comment\"</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"s2\">\"(2p) - 2 # with my precious comment\"</span>\n</pre>\n<p>Why I have to use <code>x ** 0.5</code> in order to get square root of <code>x</code>, can't I just use a <code>\u221a</code> operator?</p>\n<pre><span class=\"k\">class</span> <span class=\"nc\">SquareRoot</span><span class=\"p\">(</span><span class=\"n\">TokenTransformer</span><span class=\"p\">):</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">register_squareroot</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"k\">return</span> <span class=\"s2\">\"\u221a\"</span>\n\n    <span class=\"nd\">@pattern</span><span class=\"p\">(</span><span class=\"s2\">\"squareroot\"</span><span class=\"p\">,</span> <span class=\"s2\">\"number\"</span><span class=\"p\">)</span>\n    <span class=\"k\">def</span> <span class=\"nf\">remove_varprefix</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">operator</span><span class=\"p\">,</span> <span class=\"n\">token</span><span class=\"p\">):</span>\n        <span class=\"k\">return</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">quick_tokenize</span><span class=\"p\">(</span><span class=\"sa\">f</span><span class=\"s2\">\"int(</span><span class=\"si\">{</span><span class=\"n\">token</span><span class=\"o\">.</span><span class=\"n\">string</span><span class=\"si\">}</span><span class=\"s2\"> ** 0.5)\"</span><span class=\"p\">)</span>\n\n<span class=\"n\">sqr</span> <span class=\"o\">=</span> <span class=\"n\">SquareRoot</span><span class=\"p\">()</span>\n<span class=\"k\">assert</span> <span class=\"nb\">eval</span><span class=\"p\">(</span><span class=\"n\">sqr</span><span class=\"o\">.</span><span class=\"n\">transform</span><span class=\"p\">(</span><span class=\"s2\">\"\u221a9 # some more comments\"</span><span class=\"p\">))</span> <span class=\"o\">==</span> <span class=\"mi\">3</span>\n<span class=\"k\">assert</span> <span class=\"s2\">\"some more comments\"</span> <span class=\"ow\">in</span> <span class=\"n\">sqr</span><span class=\"o\">.</span><span class=\"n\">transform</span><span class=\"p\">(</span><span class=\"s2\">\"\u221a9 # some more comments\"</span><span class=\"p\">)</span>\n</pre>\n<h2>Making transformers permanent</h2>\n<p>If you like your transformer and use it on the real python files, you can use <code>~/.brm</code> folder. Actually you shouldn't depend that folder, you can just write your transformer and do this <code>cp transformer.py $(python -m brm)</code>. It should print out the right location for transformers. After that operation you can just add <code># coding: brm</code> comment to every python file you want to use your transformers. If you already using an encoding you can keep using it with <code># coding: brm-&lt;encoding&gt;</code> like <code># coding: brm-utf8</code> etc. Let's do an example</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">brm</span> <span class=\"kn\">import</span> <span class=\"n\">TokenTransformer</span><span class=\"p\">,</span> <span class=\"n\">pattern</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">AlwaysTrue</span><span class=\"p\">(</span><span class=\"n\">TokenTransformer</span><span class=\"p\">):</span>\n\n    <span class=\"n\">STRICT</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>\n\n    <span class=\"nd\">@pattern</span><span class=\"p\">(</span><span class=\"s2\">\"name\"</span><span class=\"p\">,</span> <span class=\"s2\">\"*any\"</span><span class=\"p\">,</span> <span class=\"s2\">\"colon\"</span><span class=\"p\">)</span>\n    <span class=\"k\">def</span> <span class=\"nf\">always_true_if</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"o\">*</span><span class=\"n\">tokens</span><span class=\"p\">):</span>\n        <span class=\"n\">statement</span><span class=\"p\">,</span> <span class=\"o\">*</span><span class=\"n\">_</span><span class=\"p\">,</span> <span class=\"n\">colon</span> <span class=\"o\">=</span> <span class=\"n\">tokens</span>\n        <span class=\"k\">if</span> <span class=\"n\">statement</span><span class=\"o\">.</span><span class=\"n\">string</span> <span class=\"ow\">not</span> <span class=\"ow\">in</span> <span class=\"p\">{</span><span class=\"s2\">\"if\"</span><span class=\"p\">,</span> <span class=\"s2\">\"elif\"</span><span class=\"p\">,</span> <span class=\"s2\">\"while\"</span><span class=\"p\">}:</span>\n            <span class=\"k\">return</span>\n        <span class=\"n\">true</span><span class=\"p\">,</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">quick_tokenize</span><span class=\"p\">(</span><span class=\"s2\">\"True\"</span><span class=\"p\">)</span>\n        <span class=\"k\">return</span> <span class=\"p\">(</span><span class=\"n\">statement</span><span class=\"p\">,</span> <span class=\"n\">true</span><span class=\"p\">,</span> <span class=\"n\">colon</span><span class=\"p\">)</span>\n</pre>\n<p>First of all, the <code>STRICT</code> state means do we care about how the result would look like. In this case, no. Because imagine this as a pre-processor, no one is going to see the result of processed text it except the interpreter it self. So we are free to swallow every location information (that won't break any code integrity).</p>\n<p>This example's pattern starts with a  that catches a name, which could be a keyword but during the lexing you can't know if it is or not. Then it catches as many things as possible until it gets a colon. The transformer function assignes first token to <code>statement</code> and last token to <code>colon</code> and swallows all of the tokens between them. The swallowed tokens constructs the actual condition but they wont be needed because we'll just replace condition with True. After setting statement, we just acess <code>string</code> attribute (which contains the value of token) and check if it is a valid keyword. If it is not, we return <code>None</code> which means this transformer didn't change anything and continue. If it is a valid statement we'll use <code>quick_tokenize</code> method to get tokens from a string. It is returning a sequence so we'll do some unpacking with trailing comma. At the end we'll return a sequence of tokens; the statement it self (e.g <code>if</code> keyword), <code>True</code> token and the colon (<code>:</code>).</p>\n<p>After we finish our work with transformer, we'll put this to the pre-processor folder of BRM. Transformers on that folder will be executed on every python interpreter run, and transform python sources if they use special brm coding (<code># coding: brm</code>).</p>\n<pre><code>(.venv) [  9:12\u00d6S ]  [ isidentical@x200:~ ]\n $ cat -n r.py\n     1  # coding: brm\n     2\n     3  a = 2\n     4  if a &gt; 2:\n     5      print(\"LOL\")\n(.venv) [  9:12\u00d6S ]  [ isidentical@x200:~ ]\n $ cp test.py $(python -m brm)\n(.venv) [  9:12\u00d6S ]  [ isidentical@x200:~ ]\n $ python r.py\nLOL\n</code></pre>\n<p>TA-DA!</p>\n<h1>BRM Pattern Syntax</h1>\n<p>BRM sees python source code as a stream of token types when it is searching a pattern. Imagine this code;</p>\n<pre><span class=\"k\">if</span> <span class=\"n\">a</span> <span class=\"o\">==</span> <span class=\"n\">x</span><span class=\"p\">:</span>\n    <span class=\"mi\">2</span> <span class=\"o\">+</span> <span class=\"mi\">2</span> <span class=\"c1\"># lol</span>\n</pre>\n<p>the text representation of this tokens is like this;</p>\n<pre><code>NAME NAME EQEQUAL NAME COLON NEWLINE INDENT NUMBER PLUS NUMBER COMMENT NEWLINE DEDENT ENDMARKER\n</code></pre>\n<p>And BRM process it like this</p>\n<p><img alt=\"brm pattern show gif\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/01f8cff827080c7187d9cd57220a7f44c4714041/646f63732f7061747465726e2e676966\"></p>\n<p>If you want to match binary plus operation here (<code>2 + 2</code>), you can create pattern with <code>number, plus, name</code>.\nIf you want to match if statement's body, you can use some implicit tokens (which we can't show in the gif :D) called <code>INDENT</code> and <code>DEDENT</code>. So If there are only simple expressions or statements inside to if's body, you can create a pattern that starts with an indent token and takes anything between that indent and the dedent token, <code>indent, *any, dedent</code>. Any is a pattern that expands to any token, like regex's <code>(.?*)</code> capturing group.</p>\n<p><img alt=\"brm pattern matching complex gif\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/9520d917b699ac9ea49b8def5fdd709ba3a55021/646f63732f637573746f6d5f7061747465726e732e676966\"></p>\n<p>Wanna try this? Just run <code>python visualize.py --help</code></p>\n<h1>Some minor functions</h1>\n<ul>\n<li><code>quick_tokenize(source: str)</code> =&gt; <code>List[TokenInfo]</code>, give some source and get some tokens that can construct the same source that was inputted.</li>\n<li><code>quick_untokenize(tokens: Sequence[TokenInfo])</code> =&gt; <code>str</code>, give some sequence of tokens and get a string form of it without any usage of positions. It helps the cases when you dont want to deal with preceding issues about token locations. If you want to get a pretty input with using token locations, call <code>tokenize.untokenize</code> directly.</li>\n<li><code>directional_length(tokens: Sequence[TokenInfo])</code> =&gt; <code>int</code>, calculate the X distance between start of the sequence and end of the sequence.</li>\n<li><code>shift_all(tokens: Sequence[TokenInfo], x_offset: int, y_offset: int)</code> =&gt; <code>int</code>, shift positions of all tokens in the given sequence</li>\n<li><code>get_type(token: TokenInfo)</code></li>\n</ul>\n\n          </div>"}, "last_serial": 6482891, "releases": {"0.1.0": [{"comment_text": "", "digests": {"md5": "e3de6ffc5ff5c5222b139c0855b44012", "sha256": "057a5391e3447a171473cce4cbc30296df5b01e4112666ccaa72968c14b8b0cb"}, "downloads": -1, "filename": "brm-0.1.0-py3.9.egg", "has_sig": false, "md5_digest": "e3de6ffc5ff5c5222b139c0855b44012", "packagetype": "bdist_egg", "python_version": "3.9", "requires_python": ">=3.6", "size": 12391, "upload_time": "2020-01-19T14:37:27", "upload_time_iso_8601": "2020-01-19T14:37:27.023482Z", "url": "https://files.pythonhosted.org/packages/be/a6/374d6deb07adf85c51d42414b505fc14bfb41b25be1a7e26af7d9d8585f4/brm-0.1.0-py3.9.egg", "yanked": false}, {"comment_text": "", "digests": {"md5": "9bc99494c24847cfd1ea0b8347993147", "sha256": "31a37a45c1cfa31a24fc5c61c23a97b834adba99c683f1934ca6fcd170f50fa5"}, "downloads": -1, "filename": "brm-0.1.0.tar.gz", "has_sig": false, "md5_digest": "9bc99494c24847cfd1ea0b8347993147", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 5586, "upload_time": "2020-01-11T13:53:56", "upload_time_iso_8601": "2020-01-11T13:53:56.603338Z", "url": "https://files.pythonhosted.org/packages/62/6b/6c01139cfc0b0ba432ebe8ddca49acaaeda43b22dcd61a69c82104a12e82/brm-0.1.0.tar.gz", "yanked": false}], "0.1.0a0": [{"comment_text": "", "digests": {"md5": "66f51a88d72da1c5b1a794a8f7dbb512", "sha256": "181654a28ce53bdd4b7f071c3ad01b17abd4b3547647d73cb6516b317ddbac89"}, "downloads": -1, "filename": "brm-0.1.0a0.tar.gz", "has_sig": false, "md5_digest": "66f51a88d72da1c5b1a794a8f7dbb512", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.7", "size": 3894, "upload_time": "2019-12-05T17:28:50", "upload_time_iso_8601": "2019-12-05T17:28:50.725060Z", "url": "https://files.pythonhosted.org/packages/9e/1b/a134c55827a44fb862a91f7b0c591441341887432fe31f3ea9a5531a9e2e/brm-0.1.0a0.tar.gz", "yanked": false}], "0.2.1": [{"comment_text": "", "digests": {"md5": "2c60a272cf6db8cef8ebd19820d25e89", "sha256": "65091922799b55fcb73c88336059834d564efdf39328f4d59f2d9e0d07930823"}, "downloads": -1, "filename": "brm-0.2.1.tar.gz", "has_sig": false, "md5_digest": "2c60a272cf6db8cef8ebd19820d25e89", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 2891, "upload_time": "2020-01-15T14:28:44", "upload_time_iso_8601": "2020-01-15T14:28:44.895386Z", "url": "https://files.pythonhosted.org/packages/a7/1b/67c207e265e69f753bf6179062c6fc4b878f804f2d7d8d99aed40abe96cb/brm-0.2.1.tar.gz", "yanked": false}], "0.2.2": [{"comment_text": "", "digests": {"md5": "c19f431c9a6fd9c452000c3d9872618d", "sha256": "95720f21f0a8e9faf72cad113254d8cbc5efcdb891329e92a53a73b7e15cdff8"}, "downloads": -1, "filename": "brm-0.2.2.tar.gz", "has_sig": false, "md5_digest": "c19f431c9a6fd9c452000c3d9872618d", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 6904, "upload_time": "2020-01-15T14:34:39", "upload_time_iso_8601": "2020-01-15T14:34:39.453130Z", "url": "https://files.pythonhosted.org/packages/26/13/86841291579dbb3b29a3be3524180c3ca0af956f256282ed21e6488e424d/brm-0.2.2.tar.gz", "yanked": false}], "0.2.3": [{"comment_text": "", "digests": {"md5": "eef10b69bf1779707ecf50dd65e50f1a", "sha256": "53aee2820134fac8ef6792cdfd754c173a2b877e1eb54ed22f8c97c100955263"}, "downloads": -1, "filename": "brm-0.2.3.tar.gz", "has_sig": false, "md5_digest": "eef10b69bf1779707ecf50dd65e50f1a", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 6956, "upload_time": "2020-01-15T14:35:51", "upload_time_iso_8601": "2020-01-15T14:35:51.515950Z", "url": "https://files.pythonhosted.org/packages/be/ab/29fae425ba4e7f6297664b3dee0923869fd84371416a469c04b7102564de/brm-0.2.3.tar.gz", "yanked": false}], "0.2.4": [{"comment_text": "", "digests": {"md5": "feb6b656f5e394b86bb551fa8cdfba9c", "sha256": "a18624d3bafd6a99c89083a55adc1155b896dc8d6ba9b6c0b450cad34f3054e2"}, "downloads": -1, "filename": "brm-0.2.4.tar.gz", "has_sig": false, "md5_digest": "feb6b656f5e394b86bb551fa8cdfba9c", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 7003, "upload_time": "2020-01-15T14:55:22", "upload_time_iso_8601": "2020-01-15T14:55:22.088750Z", "url": "https://files.pythonhosted.org/packages/b0/df/c27aac375945556bb26cdfc053469ea9a937415122ebc068a0878314b42d/brm-0.2.4.tar.gz", "yanked": false}], "0.2.5": [{"comment_text": "", "digests": {"md5": "7b5bd7fea0b0ed7c765f2b948ad4a67a", "sha256": "aae5d3c5fa27f10ff8e4f8c52bfb2c6987f5c019b9321c50b26bc13d62b7f92f"}, "downloads": -1, "filename": "brm-0.2.5.tar.gz", "has_sig": false, "md5_digest": "7b5bd7fea0b0ed7c765f2b948ad4a67a", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 7008, "upload_time": "2020-01-15T17:34:51", "upload_time_iso_8601": "2020-01-15T17:34:51.789446Z", "url": "https://files.pythonhosted.org/packages/7d/77/354f003eb615524b04b4a0bc7ffafebb21c8e5bcdcc1cd55638efade42f6/brm-0.2.5.tar.gz", "yanked": false}], "0.2.6": [{"comment_text": "", "digests": {"md5": "3f1c6fc4283c6ceb4444652e4d77fad5", "sha256": "23b2629cc5d07c3b5754f059cab7dd63664dcf3ac0e3984cac8c01ca319e8e99"}, "downloads": -1, "filename": "brm-0.2.6.tar.gz", "has_sig": false, "md5_digest": "3f1c6fc4283c6ceb4444652e4d77fad5", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 9682, "upload_time": "2020-01-19T14:37:38", "upload_time_iso_8601": "2020-01-19T14:37:38.159982Z", "url": "https://files.pythonhosted.org/packages/79/ad/b3d5ceb1d6bd236bc22d8c0c71223912bc946e13874cfd7daad0202f716b/brm-0.2.6.tar.gz", "yanked": false}], "0.2.7": [{"comment_text": "", "digests": {"md5": "e68f9c07ad61d5597d45986ccf7a280d", "sha256": "63c3ed307fd94042f0e5d95dee62a62a2d0cbd24dcceeef348126030c1a62fd6"}, "downloads": -1, "filename": "brm-0.2.7.tar.gz", "has_sig": false, "md5_digest": "e68f9c07ad61d5597d45986ccf7a280d", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 9410, "upload_time": "2020-01-19T17:15:58", "upload_time_iso_8601": "2020-01-19T17:15:58.667208Z", "url": "https://files.pythonhosted.org/packages/0d/6a/f5e0766c249e1bd09cf69f073b40d11846ca6614a3c9ff47ff7d0f345393/brm-0.2.7.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "e68f9c07ad61d5597d45986ccf7a280d", "sha256": "63c3ed307fd94042f0e5d95dee62a62a2d0cbd24dcceeef348126030c1a62fd6"}, "downloads": -1, "filename": "brm-0.2.7.tar.gz", "has_sig": false, "md5_digest": "e68f9c07ad61d5597d45986ccf7a280d", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 9410, "upload_time": "2020-01-19T17:15:58", "upload_time_iso_8601": "2020-01-19T17:15:58.667208Z", "url": "https://files.pythonhosted.org/packages/0d/6a/f5e0766c249e1bd09cf69f073b40d11846ca6614a3c9ff47ff7d0f345393/brm-0.2.7.tar.gz", "yanked": false}], "timestamp": "Thu May  7 22:36:17 2020"}