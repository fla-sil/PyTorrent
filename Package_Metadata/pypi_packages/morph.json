{"info": {"author": "metagriffin", "author_email": "mg.pypi@uberdev.org", "bugtrack_url": null, "classifiers": ["Development Status :: 4 - Beta", "Intended Audience :: Developers", "License :: OSI Approved :: GNU General Public License v3 or later (GPLv3+)", "Operating System :: OS Independent", "Programming Language :: Python", "Topic :: Software Development", "Topic :: Software Development :: Libraries :: Python Modules", "Topic :: Utilities"], "description": "======\nMorph!\n======\n\n\nMorph provides the following functions to help identify object types:\n\n============================  =================================================\nName                          Functionality\n============================  =================================================\n``morph.isstr(obj)``          Is `obj` a string?\n``morph.isseq(obj)``          Is `obj` a sequence-like (i.e. iterable) type\n                              (but not a string or dict)?\n``morph.isdict(obj)``         Is `obj` a dict-like type? This means that it\n                              must have at least the following methods:\n                              `keys()`, `values()`, and `items()`.\n============================  =================================================\n\nMorph provides the following functions to help morph objects:\n\n============================  =================================================\nName                          Functionality\n============================  =================================================\n``morph.tobool(obj)``         Converts `obj` to a bool; if string-like, it\n                              is matched against a list of \"truthy\" or \"falsy\"\n                              strings; if bool-like, returns itself; then, if\n                              the `default` parameter is not ``ValueError``\n                              (which defaults to ``False``), returns that;\n                              otherwise throws a ValueError exception.\n``morph.tolist(obj)``         Converts `obj` to a list; if string-like, it\n                              splits it according to Unix shell semantics (if\n                              keyword `split` is truthy, the default); if\n                              sequence-like, returns itself converted to a list\n                              (optionally flattened if keyword `flat` is\n                              truthy, the default), and otherwise returns a\n                              list with itself as single object.\n``morph.pick(...)``           Extracts a subset of key/value pairs from a\n                              dict-like object where the key is a specific\n                              value or has a specific prefix.\n``morph.omit(...)``           Converse of `morph.pick()`.\n``morph.flatten(obj)``        Converts a multi-dimensional list or dict type\n                              to a one-dimensional list or dict.\n``morph.unflatten(obj)``      Reverses the effects of `flatten` (note that\n                              lists cannot be unflattened).\n``morph.xform(obj, func)``    Recursively transforms sequences & dicts in\n                              `object`.\n============================  =================================================\n\n\nFlattening\n==========\n\nWhen flattening a sequence-like object (i.e. list or tuple),\n`morph.flatten` recursively reduces multi-dimensional arrays to a\nsingle dimension, but only for elements of each descended list that\nare list-like. For example:\n\n.. code:: python\n\n  [1, [2, [3, 'abc', 'def', {'foo': ['zig', ['zag', 'zog']]}], 4]]\n\n  # is morphed to\n\n  [1, 2, 3, 'abc', 'def', {'foo': ['zig', ['zag', 'zog']]}, 4]\n\nWhen flattening a dict-like object, it collapses list- and dict-\nsubkeys into indexed and dotted top-level keys. For example:\n\n.. code:: python\n\n  {\n    'a': {\n      'b': 1,\n      'c': [\n        2,\n        {\n          'd': 3,\n          'e': 4,\n        }\n      ]\n    }\n  }\n\n  # is morphed to\n\n  {\n    'a.b':      1,\n    'a.c[0]':   2,\n    'a.c[1].d': 3,\n    'a.c[1].e': 4,\n  }\n\n(This is primarily useful when dealing with INI files, which can only\nbe flat: the `flatten` and `unflatten` functions allow converting\nbetween complex structures and flat INI files).\n\nNote that lists can never be unflattened, and unflattening dicts is\nnot garanteed to be round-trip consistent. The latter can happen if\nthe dict-to-be-flattened had keys with special characters in them,\nsuch as a period (``'.'``) or square brackets (``'[]'``).\n\n\nPicking and Omitting\n====================\n\nMorph's `pick` and `omit` functions allow you to extract a set of keys\n(or properties) from a dict-like object (or plain object). These\nfunctions will aggressively return a valid dict, regardless of the\nsupplied value -- i.e. if ``None`` is given as a source, an empty dict\nis returned. Furthermore, the following optional keyword parameters\nare accepted:\n\n* **dict**:\n\n  Specifies the class type that should be returned, which defaults\n  to the standard python ``dict`` type.\n\n* **prefix**:\n\n  For `pick`, specifies that only keys that start with the specified\n  string will be returned (and also filtered for the specified keys),\n  with the prefix stripped from the keys. If no keys are specified,\n  this will simply return only the keys with the specified prefix.\n\n  For `omit`, specifies that keys that start with the specified value\n  should be stripped from the returned dict.\n\n* **tree**:\n\n  If specified and truthy, then the keys specified to either `pick` or\n  `omit` are evaluated as a multi-dimensional item addresses like\n  those produced by `morph.flatten`.\n\nExamples:\n\n.. code:: python\n\n  d = {'foo': 'bar', 'zig.a': 'b', 'zig.c': 'd'}\n\n  morph.pick(d, 'foo', 'zig.a')\n  # ==> {'foo', 'bar', 'zig.a': 'b'}\n\n  morph.pick(d, prefix='zig.')\n  # ==> {'a': 'b', 'c': 'd'}\n\n  morph.pick(d, 'c', prefix='zig.')\n  # ==> {'c': 'd'}\n\n  morph.omit(d, 'foo')\n  # ==> {'zig.a': 'b', 'zig.c': 'd'}\n\n  morph.omit(d, prefix='zig.')\n  # ==> {'foo': 'bar'}\n\n  class mydict(dict): pass\n  morph.pick(dict(foo='bar', zig='zag'), 'foo', dict=mydict)\n  # ==> mydict({'foo': 'bar'})\n\n\nWith some limitations, this also works on object properties. For\nexample:\n\n.. code:: python\n\n  class X():\n    def __init__(self):\n      self.foo = 'bar'\n      self.zig1 = 'zog'\n      self.zig2 = 'zug'\n    def zigMethod(self):\n      pass\n  x = X()\n\n  morph.pick(x, 'foo', 'zig1')\n  # ==> {'foo': 'bar', 'zig1': 'zog'}\n\n  morph.pick(x, prefix='zig')\n  # ==> {'1': 'zog', '2': 'zug'}\n\n  morph.pick(x)\n  # ==> {}\n\n  morph.omit(x, 'foo')\n  # ==> {'zig1': 'zog', 'zig2': 'zug'}\n\n  morph.omit(x, prefix='zig')\n  # ==> {'foo': 'bar'}\n\n  morph.omit(x)\n  # ==> {'foo': 'bar', 'zig1': 'zog', 'zig2': 'zug'}\n\n\nTransformation\n==============\n\nThe `morph.xform` helper function can be used to recursively transform\nall the items in a list & dictionary tree -- this effectively allows\nthe ease of list comprehensions to be applied to nested list/dict\nstructures.\n\nExample:\n\n.. code:: python\n\n  morph.xform([2, [4, {6: 8}]], lambda val, **kws: val ** 2)\n  # ==> [4, [16, {36: 64}]]\n\n\nNote that the callback function `xformer`, passed as the second\nargument to `morph.xform`, should always support an arbitrary number\nof keyword parameters (i.e. should always end the parameter list with\nsomething like ``**kws``).\n", "description_content_type": "", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "http://github.com/metagriffin/morph", "keywords": "morph transform string list tuple dict flatten unflatten tolist tobool pick omit", "license": "GPLv3+", "maintainer": "", "maintainer_email": "", "name": "morph", "package_url": "https://pypi.org/project/morph/", "platform": "any", "project_url": "https://pypi.org/project/morph/", "project_urls": {"Homepage": "http://github.com/metagriffin/morph"}, "release_url": "https://pypi.org/project/morph/0.1.4/", "requires_dist": null, "requires_python": "", "summary": "A collection of routines to help identify and morph objects.", "version": "0.1.4", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p>Morph provides the following functions to help identify object types:</p>\n<table>\n<colgroup>\n<col>\n<col>\n</colgroup>\n<thead>\n<tr><th>Name</th>\n<th>Functionality</th>\n</tr>\n</thead>\n<tbody>\n<tr><td><tt>morph.isstr(obj)</tt></td>\n<td>Is <cite>obj</cite> a string?</td>\n</tr>\n<tr><td><tt>morph.isseq(obj)</tt></td>\n<td>Is <cite>obj</cite> a sequence-like (i.e. iterable) type\n(but not a string or dict)?</td>\n</tr>\n<tr><td><tt>morph.isdict(obj)</tt></td>\n<td>Is <cite>obj</cite> a dict-like type? This means that it\nmust have at least the following methods:\n<cite>keys()</cite>, <cite>values()</cite>, and <cite>items()</cite>.</td>\n</tr>\n</tbody>\n</table>\n<p>Morph provides the following functions to help morph objects:</p>\n<table>\n<colgroup>\n<col>\n<col>\n</colgroup>\n<thead>\n<tr><th>Name</th>\n<th>Functionality</th>\n</tr>\n</thead>\n<tbody>\n<tr><td><tt>morph.tobool(obj)</tt></td>\n<td>Converts <cite>obj</cite> to a bool; if string-like, it\nis matched against a list of \u201ctruthy\u201d or \u201cfalsy\u201d\nstrings; if bool-like, returns itself; then, if\nthe <cite>default</cite> parameter is not <tt>ValueError</tt>\n(which defaults to <tt>False</tt>), returns that;\notherwise throws a ValueError exception.</td>\n</tr>\n<tr><td><tt>morph.tolist(obj)</tt></td>\n<td>Converts <cite>obj</cite> to a list; if string-like, it\nsplits it according to Unix shell semantics (if\nkeyword <cite>split</cite> is truthy, the default); if\nsequence-like, returns itself converted to a list\n(optionally flattened if keyword <cite>flat</cite> is\ntruthy, the default), and otherwise returns a\nlist with itself as single object.</td>\n</tr>\n<tr><td><tt><span class=\"pre\">morph.pick(...)</span></tt></td>\n<td>Extracts a subset of key/value pairs from a\ndict-like object where the key is a specific\nvalue or has a specific prefix.</td>\n</tr>\n<tr><td><tt><span class=\"pre\">morph.omit(...)</span></tt></td>\n<td>Converse of <cite>morph.pick()</cite>.</td>\n</tr>\n<tr><td><tt>morph.flatten(obj)</tt></td>\n<td>Converts a multi-dimensional list or dict type\nto a one-dimensional list or dict.</td>\n</tr>\n<tr><td><tt>morph.unflatten(obj)</tt></td>\n<td>Reverses the effects of <cite>flatten</cite> (note that\nlists cannot be unflattened).</td>\n</tr>\n<tr><td><tt>morph.xform(obj, func)</tt></td>\n<td>Recursively transforms sequences &amp; dicts in\n<cite>object</cite>.</td>\n</tr>\n</tbody>\n</table>\n<div id=\"flattening\">\n<h2>Flattening</h2>\n<p>When flattening a sequence-like object (i.e. list or tuple),\n<cite>morph.flatten</cite> recursively reduces multi-dimensional arrays to a\nsingle dimension, but only for elements of each descended list that\nare list-like. For example:</p>\n<pre><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"p\">[</span><span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"s1\">'abc'</span><span class=\"p\">,</span> <span class=\"s1\">'def'</span><span class=\"p\">,</span> <span class=\"p\">{</span><span class=\"s1\">'foo'</span><span class=\"p\">:</span> <span class=\"p\">[</span><span class=\"s1\">'zig'</span><span class=\"p\">,</span> <span class=\"p\">[</span><span class=\"s1\">'zag'</span><span class=\"p\">,</span> <span class=\"s1\">'zog'</span><span class=\"p\">]]}],</span> <span class=\"mi\">4</span><span class=\"p\">]]</span>\n\n<span class=\"c1\"># is morphed to</span>\n\n<span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"s1\">'abc'</span><span class=\"p\">,</span> <span class=\"s1\">'def'</span><span class=\"p\">,</span> <span class=\"p\">{</span><span class=\"s1\">'foo'</span><span class=\"p\">:</span> <span class=\"p\">[</span><span class=\"s1\">'zig'</span><span class=\"p\">,</span> <span class=\"p\">[</span><span class=\"s1\">'zag'</span><span class=\"p\">,</span> <span class=\"s1\">'zog'</span><span class=\"p\">]]},</span> <span class=\"mi\">4</span><span class=\"p\">]</span>\n</pre>\n<p>When flattening a dict-like object, it collapses list- and dict-\nsubkeys into indexed and dotted top-level keys. For example:</p>\n<pre><span class=\"p\">{</span>\n  <span class=\"s1\">'a'</span><span class=\"p\">:</span> <span class=\"p\">{</span>\n    <span class=\"s1\">'b'</span><span class=\"p\">:</span> <span class=\"mi\">1</span><span class=\"p\">,</span>\n    <span class=\"s1\">'c'</span><span class=\"p\">:</span> <span class=\"p\">[</span>\n      <span class=\"mi\">2</span><span class=\"p\">,</span>\n      <span class=\"p\">{</span>\n        <span class=\"s1\">'d'</span><span class=\"p\">:</span> <span class=\"mi\">3</span><span class=\"p\">,</span>\n        <span class=\"s1\">'e'</span><span class=\"p\">:</span> <span class=\"mi\">4</span><span class=\"p\">,</span>\n      <span class=\"p\">}</span>\n    <span class=\"p\">]</span>\n  <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n\n<span class=\"c1\"># is morphed to</span>\n\n<span class=\"p\">{</span>\n  <span class=\"s1\">'a.b'</span><span class=\"p\">:</span>      <span class=\"mi\">1</span><span class=\"p\">,</span>\n  <span class=\"s1\">'a.c[0]'</span><span class=\"p\">:</span>   <span class=\"mi\">2</span><span class=\"p\">,</span>\n  <span class=\"s1\">'a.c[1].d'</span><span class=\"p\">:</span> <span class=\"mi\">3</span><span class=\"p\">,</span>\n  <span class=\"s1\">'a.c[1].e'</span><span class=\"p\">:</span> <span class=\"mi\">4</span><span class=\"p\">,</span>\n<span class=\"p\">}</span>\n</pre>\n<p>(This is primarily useful when dealing with INI files, which can only\nbe flat: the <cite>flatten</cite> and <cite>unflatten</cite> functions allow converting\nbetween complex structures and flat INI files).</p>\n<p>Note that lists can never be unflattened, and unflattening dicts is\nnot garanteed to be round-trip consistent. The latter can happen if\nthe dict-to-be-flattened had keys with special characters in them,\nsuch as a period (<tt>'.'</tt>) or square brackets (<tt><span class=\"pre\">'[]'</span></tt>).</p>\n</div>\n<div id=\"picking-and-omitting\">\n<h2>Picking and Omitting</h2>\n<p>Morph\u2019s <cite>pick</cite> and <cite>omit</cite> functions allow you to extract a set of keys\n(or properties) from a dict-like object (or plain object). These\nfunctions will aggressively return a valid dict, regardless of the\nsupplied value \u2013 i.e. if <tt>None</tt> is given as a source, an empty dict\nis returned. Furthermore, the following optional keyword parameters\nare accepted:</p>\n<ul>\n<li><p><strong>dict</strong>:</p>\n<p>Specifies the class type that should be returned, which defaults\nto the standard python <tt>dict</tt> type.</p>\n</li>\n<li><p><strong>prefix</strong>:</p>\n<p>For <cite>pick</cite>, specifies that only keys that start with the specified\nstring will be returned (and also filtered for the specified keys),\nwith the prefix stripped from the keys. If no keys are specified,\nthis will simply return only the keys with the specified prefix.</p>\n<p>For <cite>omit</cite>, specifies that keys that start with the specified value\nshould be stripped from the returned dict.</p>\n</li>\n<li><p><strong>tree</strong>:</p>\n<p>If specified and truthy, then the keys specified to either <cite>pick</cite> or\n<cite>omit</cite> are evaluated as a multi-dimensional item addresses like\nthose produced by <cite>morph.flatten</cite>.</p>\n</li>\n</ul>\n<p>Examples:</p>\n<pre><span class=\"n\">d</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"s1\">'foo'</span><span class=\"p\">:</span> <span class=\"s1\">'bar'</span><span class=\"p\">,</span> <span class=\"s1\">'zig.a'</span><span class=\"p\">:</span> <span class=\"s1\">'b'</span><span class=\"p\">,</span> <span class=\"s1\">'zig.c'</span><span class=\"p\">:</span> <span class=\"s1\">'d'</span><span class=\"p\">}</span>\n\n<span class=\"n\">morph</span><span class=\"o\">.</span><span class=\"n\">pick</span><span class=\"p\">(</span><span class=\"n\">d</span><span class=\"p\">,</span> <span class=\"s1\">'foo'</span><span class=\"p\">,</span> <span class=\"s1\">'zig.a'</span><span class=\"p\">)</span>\n<span class=\"c1\"># ==&gt; {'foo', 'bar', 'zig.a': 'b'}</span>\n\n<span class=\"n\">morph</span><span class=\"o\">.</span><span class=\"n\">pick</span><span class=\"p\">(</span><span class=\"n\">d</span><span class=\"p\">,</span> <span class=\"n\">prefix</span><span class=\"o\">=</span><span class=\"s1\">'zig.'</span><span class=\"p\">)</span>\n<span class=\"c1\"># ==&gt; {'a': 'b', 'c': 'd'}</span>\n\n<span class=\"n\">morph</span><span class=\"o\">.</span><span class=\"n\">pick</span><span class=\"p\">(</span><span class=\"n\">d</span><span class=\"p\">,</span> <span class=\"s1\">'c'</span><span class=\"p\">,</span> <span class=\"n\">prefix</span><span class=\"o\">=</span><span class=\"s1\">'zig.'</span><span class=\"p\">)</span>\n<span class=\"c1\"># ==&gt; {'c': 'd'}</span>\n\n<span class=\"n\">morph</span><span class=\"o\">.</span><span class=\"n\">omit</span><span class=\"p\">(</span><span class=\"n\">d</span><span class=\"p\">,</span> <span class=\"s1\">'foo'</span><span class=\"p\">)</span>\n<span class=\"c1\"># ==&gt; {'zig.a': 'b', 'zig.c': 'd'}</span>\n\n<span class=\"n\">morph</span><span class=\"o\">.</span><span class=\"n\">omit</span><span class=\"p\">(</span><span class=\"n\">d</span><span class=\"p\">,</span> <span class=\"n\">prefix</span><span class=\"o\">=</span><span class=\"s1\">'zig.'</span><span class=\"p\">)</span>\n<span class=\"c1\"># ==&gt; {'foo': 'bar'}</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">mydict</span><span class=\"p\">(</span><span class=\"nb\">dict</span><span class=\"p\">):</span> <span class=\"k\">pass</span>\n<span class=\"n\">morph</span><span class=\"o\">.</span><span class=\"n\">pick</span><span class=\"p\">(</span><span class=\"nb\">dict</span><span class=\"p\">(</span><span class=\"n\">foo</span><span class=\"o\">=</span><span class=\"s1\">'bar'</span><span class=\"p\">,</span> <span class=\"n\">zig</span><span class=\"o\">=</span><span class=\"s1\">'zag'</span><span class=\"p\">),</span> <span class=\"s1\">'foo'</span><span class=\"p\">,</span> <span class=\"nb\">dict</span><span class=\"o\">=</span><span class=\"n\">mydict</span><span class=\"p\">)</span>\n<span class=\"c1\"># ==&gt; mydict({'foo': 'bar'})</span>\n</pre>\n<p>With some limitations, this also works on object properties. For\nexample:</p>\n<pre><span class=\"k\">class</span> <span class=\"nc\">X</span><span class=\"p\">():</span>\n  <span class=\"k\">def</span> <span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n    <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">foo</span> <span class=\"o\">=</span> <span class=\"s1\">'bar'</span>\n    <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">zig1</span> <span class=\"o\">=</span> <span class=\"s1\">'zog'</span>\n    <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">zig2</span> <span class=\"o\">=</span> <span class=\"s1\">'zug'</span>\n  <span class=\"k\">def</span> <span class=\"nf\">zigMethod</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n    <span class=\"k\">pass</span>\n<span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"n\">X</span><span class=\"p\">()</span>\n\n<span class=\"n\">morph</span><span class=\"o\">.</span><span class=\"n\">pick</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"s1\">'foo'</span><span class=\"p\">,</span> <span class=\"s1\">'zig1'</span><span class=\"p\">)</span>\n<span class=\"c1\"># ==&gt; {'foo': 'bar', 'zig1': 'zog'}</span>\n\n<span class=\"n\">morph</span><span class=\"o\">.</span><span class=\"n\">pick</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">prefix</span><span class=\"o\">=</span><span class=\"s1\">'zig'</span><span class=\"p\">)</span>\n<span class=\"c1\"># ==&gt; {'1': 'zog', '2': 'zug'}</span>\n\n<span class=\"n\">morph</span><span class=\"o\">.</span><span class=\"n\">pick</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span>\n<span class=\"c1\"># ==&gt; {}</span>\n\n<span class=\"n\">morph</span><span class=\"o\">.</span><span class=\"n\">omit</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"s1\">'foo'</span><span class=\"p\">)</span>\n<span class=\"c1\"># ==&gt; {'zig1': 'zog', 'zig2': 'zug'}</span>\n\n<span class=\"n\">morph</span><span class=\"o\">.</span><span class=\"n\">omit</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">prefix</span><span class=\"o\">=</span><span class=\"s1\">'zig'</span><span class=\"p\">)</span>\n<span class=\"c1\"># ==&gt; {'foo': 'bar'}</span>\n\n<span class=\"n\">morph</span><span class=\"o\">.</span><span class=\"n\">omit</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span>\n<span class=\"c1\"># ==&gt; {'foo': 'bar', 'zig1': 'zog', 'zig2': 'zug'}</span>\n</pre>\n</div>\n<div id=\"transformation\">\n<h2>Transformation</h2>\n<p>The <cite>morph.xform</cite> helper function can be used to recursively transform\nall the items in a list &amp; dictionary tree \u2013 this effectively allows\nthe ease of list comprehensions to be applied to nested list/dict\nstructures.</p>\n<p>Example:</p>\n<pre><span class=\"n\">morph</span><span class=\"o\">.</span><span class=\"n\">xform</span><span class=\"p\">([</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"p\">[</span><span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"p\">{</span><span class=\"mi\">6</span><span class=\"p\">:</span> <span class=\"mi\">8</span><span class=\"p\">}]],</span> <span class=\"k\">lambda</span> <span class=\"n\">val</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kws</span><span class=\"p\">:</span> <span class=\"n\">val</span> <span class=\"o\">**</span> <span class=\"mi\">2</span><span class=\"p\">)</span>\n<span class=\"c1\"># ==&gt; [4, [16, {36: 64}]]</span>\n</pre>\n<p>Note that the callback function <cite>xformer</cite>, passed as the second\nargument to <cite>morph.xform</cite>, should always support an arbitrary number\nof keyword parameters (i.e. should always end the parameter list with\nsomething like <tt>**kws</tt>).</p>\n</div>\n\n          </div>"}, "last_serial": 4275679, "releases": {"0.0.1": [], "0.1.0": [{"comment_text": "", "digests": {"md5": "b519d376b0287c1467cedbc5c72e7323", "sha256": "e9012417077ee3b42e47ca7be36aac55409310cdf7ee355b4a3b3bb1010b00a4"}, "downloads": -1, "filename": "morph-0.1.0.tar.gz", "has_sig": false, "md5_digest": "b519d376b0287c1467cedbc5c72e7323", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 7842, "upload_time": "2013-11-10T00:20:32", "upload_time_iso_8601": "2013-11-10T00:20:32.095717Z", "url": "https://files.pythonhosted.org/packages/0c/31/31e2576208292a9137a5ca720af1ea16c52f0da8267ae3195c0b0b66f194/morph-0.1.0.tar.gz", "yanked": false}], "0.1.1": [{"comment_text": "", "digests": {"md5": "8163d187e261ff3fdb92498fd8f3e179", "sha256": "5158447351dbef99a3ddd16bdf51c09a4af9f5adeb9485a3e50020935a5295ba"}, "downloads": -1, "filename": "morph-0.1.1.tar.gz", "has_sig": false, "md5_digest": "8163d187e261ff3fdb92498fd8f3e179", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 20439, "upload_time": "2013-11-20T18:15:12", "upload_time_iso_8601": "2013-11-20T18:15:12.667911Z", "url": "https://files.pythonhosted.org/packages/06/e4/5c0902b547270a910b75bd7988613f8a33dcebe2245b78ea846d73754a3a/morph-0.1.1.tar.gz", "yanked": false}], "0.1.2": [{"comment_text": "", "digests": {"md5": "0ec4f816b53edf995b3c19aa18cdf98a", "sha256": "59af57fd64517baed6fdfb48e918706d834bf3853eaed3ef1ec8b865cfd2d438"}, "downloads": -1, "filename": "morph-0.1.2.tar.gz", "has_sig": false, "md5_digest": "0ec4f816b53edf995b3c19aa18cdf98a", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 21287, "upload_time": "2015-08-18T16:38:13", "upload_time_iso_8601": "2015-08-18T16:38:13.045251Z", "url": "https://files.pythonhosted.org/packages/0c/7f/82bac37b331c125f4a20f98b96ba1661926a75543afb1ce96d76b5f5b53e/morph-0.1.2.tar.gz", "yanked": false}], "0.1.3": [{"comment_text": "", "digests": {"md5": "c1334c73b8888eca65620f823322efec", "sha256": "1ab0bff23ee464cc6eb8db6d7dfb67022f41dca8c3f837f875e3ad6424ef11ca"}, "downloads": -1, "filename": "morph-0.1.3.tar.gz", "has_sig": false, "md5_digest": "c1334c73b8888eca65620f823322efec", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 21387, "upload_time": "2018-05-27T16:47:52", "upload_time_iso_8601": "2018-05-27T16:47:52.012838Z", "url": "https://files.pythonhosted.org/packages/28/b7/f08bb52c2b54fcd9d55a56942430cf55626b588d9c82f0530a45cfe146e6/morph-0.1.3.tar.gz", "yanked": false}], "0.1.4": [{"comment_text": "", "digests": {"md5": "8307d9dde07f8e0626643591ae81eadb", "sha256": "c4c65c36c15ccdcdb4a305bb1d96375625c2b4800115d57c56e5ad4e66cc1447"}, "downloads": -1, "filename": "morph-0.1.4.tar.gz", "has_sig": false, "md5_digest": "8307d9dde07f8e0626643591ae81eadb", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 21468, "upload_time": "2018-09-16T00:13:11", "upload_time_iso_8601": "2018-09-16T00:13:11.672833Z", "url": "https://files.pythonhosted.org/packages/e9/c1/bb9fdc3f9ac5a65f9c4d7eb30644aba587b7d960472a7dc8e35949cb35a3/morph-0.1.4.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "8307d9dde07f8e0626643591ae81eadb", "sha256": "c4c65c36c15ccdcdb4a305bb1d96375625c2b4800115d57c56e5ad4e66cc1447"}, "downloads": -1, "filename": "morph-0.1.4.tar.gz", "has_sig": false, "md5_digest": "8307d9dde07f8e0626643591ae81eadb", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 21468, "upload_time": "2018-09-16T00:13:11", "upload_time_iso_8601": "2018-09-16T00:13:11.672833Z", "url": "https://files.pythonhosted.org/packages/e9/c1/bb9fdc3f9ac5a65f9c4d7eb30644aba587b7d960472a7dc8e35949cb35a3/morph-0.1.4.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:51:46 2020"}