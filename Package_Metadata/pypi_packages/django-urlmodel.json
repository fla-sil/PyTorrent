{"info": {"author": "Johnny Lee", "author_email": "jleeothon@outlook.com", "bugtrack_url": null, "classifiers": ["Environment :: Web Environment", "Framework :: Django", "Intended Audience :: Developers", "License :: OSI Approved :: MIT License", "Operating System :: OS Independent", "Programming Language :: Python", "Programming Language :: Python :: 3.4", "Topic :: Internet :: WWW/HTTP :: Dynamic Content"], "description": "========\nurlmodel\n========\n\nCreating rich and dry URLs for a Django model.\n\n------------\nIntroduction\n------------\n\n    **Disclaimer.** Until release of version 1.0, API could significantly change.\n\nAs I started using class-based views for Django, I understood what the `get_absolute_url` method was about. Then I encountered the problem of using URLs that required more than once piece of information from a model instance, let's say, not a single primary key or slug. That's a bit abstract, take:\n\n- ``/regions/cat-cat-province/towns/mieaou/``\n\nThis identifies Mieaou town within Cat-Cat Province (there's another Mieaou town within Copy-Cat Province). Now let's say the usual list of things you'll do with a model is listing, reading detail, creating, updating, deleting (roughly, CRUD_). Roughly, you'll have this URLs:\n\n.. _CRUD: http://en.wikipedia.org/wiki/Create,_read,_update_and_delete\n\n- ``/regions/cat-cat-province/towns/list``\n- ``/regions/cat-cat-province/towns/create``\n- ``/regions/cat-cat-province/towns/mieaou/edit``\n- ``/regions/cat-cat-province/towns/mieaou/delete``\n\nAn important part to notice is that we're using *more than one piece of information per instance*, which makes things a bit more messy than just a pk. Why not just use a pk? First, I *think* there are security implications. Second, nobody wants to remember a pk. Third, programmers respect well-formed URLs and look down to senseless sequences of numbers with unfathomable disdain.\n\nWhat if you provide a link to the edit and delete sections? You'll probably go for::\n\n    # urls.py\n\n    urlpatterns = patterns('',\n        # ...\n        url(\n            '^regions/(?P<region_slug>[\\w-]+)/towns/(?P<town_slug>[\\w-]+)/edit/?$',\n            name='town-update'\n        ),\n        # ...\n    )\n\nWith something in your template like::\n\n    # html\n    \n    <a href=\"{% url 'town-update' region_slug=town.region.name_slug town_slug=town.name_slug %}\">\n      Update this town\n    </a>\n\n..\n\n    Note: I mostly use \"update\" for internal stuff for convention and readability (\"update\" has the length as \"create\" and \"delete\" and \"detail\" and \"search\"), but I use \"edit\" for usability when it'll be read by the end-user.\n\nThe latter one is not very DRY_. So I thought I could start writing a ``get_update_url`` method, and so on. Then every model class definition would have a set of ``get_detail_url``, ``get_update_url``, ``get_delete_url`` methods, plus ``get_create_url`` and ``get_list_url`` methods (in the original project, it was \"search\" instead of \"list\"). Now, given that my URLs have roughly the same naming format for every model (``town-list``, ``town-create``, ``town-detail``, ``town-update``, ``town-delete``), that is not very DRY either!\n\n.. _DRY: https://docs.djangoproject.com/en/dev/misc/design-philosophies/#don-t-repeat-yourself-dry\n\nI decided to write a smart and flexible URL system so that the next time I would need a list-create-detail-update-delete set of URLs, things would be as easy as adding a mixin to the inheritance tree of the model.\n\n------------\nInstallation\n------------\n\nI know, my requirements suck:\n\n- Python 3\n- Django 1.6\n\nI'm not sure if this app will not work on previous versions of Django, but I think I will not with Python 2.\n\nTo install version 0.1::\n\n    pip install django-urlmodel\n\nTo install the latest version, run the command::\n\n    pip install git+git://github.com/jleeothon/urlmodel.git\n\n----------\nHow to use\n----------\n\nUsing the default CRUD urls is as easy as extending funcionality as a mixin::\n\n    # models.py\n\n    from django.db import models\n\n    class Town(CrudUrlModelMixin, models.Model):\n        pass\n        \n    # or, if you're only going to extend the urlmodel functionality...\n\n    class Town(CrudUrlModel):\n        pass\n\nThe former example will create a set of five methods (class-level: list, create; instance-level: detail, update, delete) that expect an URL based on the model name and the name of the \"action\". Also, these expect an URL keyword argument called \"pk\".\n\nIn order to use a slug field, you should override ``slug_kwarg_name`` to match the URL kwarg::\n\n    # urls.py\n\n    urlpatterns = patterns('',\n        # ...\n        url(\n            '^digimons/(?P<name>[\\w-]+)/?$',\n            name='digimon-detail'\n        ),\n        # ...\n    )\n\nand ``slug_field_name``, to match the model slug::\n\n    # models.py\n\n    class Digimon(UrlModelMixin, models.Model):\n        name = CharField(max_length=100)\n        sluggified_name = SlugField(max_length=100)\n        \n        slug_kwarg_name = 'name'\n        slug_field_name = 'sluggified_name'\n\n..\n\n    Try out their lazy equivalents, ``LazyCrudUrlModelMixin`` and ``LazyCrudUrlModel``!\n\n..\n\n    **Note.** CrudUrlModel provides implementation for ``get_absolute_url`` too, and defaults to ``get_detail_url``.\n\n--------------\nAdvanced stuff\n--------------\n\nIf the default \"CRUD\" system (here: list, create, detail, update, delete) do not work for you, you can try out ``UrlModel`` and ``UrlModelMixin`` (plus their lazy counterparts).\n\n~~~~~~~~~~~\nAction URLs\n~~~~~~~~~~~\n\nThese are URLs based on \"action names\", such as \"detail\", \"create\", etc. For convention, ease and readability, you should try to stick to these methods, e.g.::\n\n    class TownPerson(UrlModelMixin, Model):\n\n        def get_defenestrate_url(self):\n            # expects townperson-defenestrate to exist.\n            return self.get_instance_action_url(\"defenestrate\")\n\n        @classmethod\n        def get_last_defenestrated(cls):\n            # expects townperson-last-defenestrated to exist.\n            return cls.get_class_action_url(\"last-defenestrated\")\n\n~~~~~~~~~~~~~~~~~~~~~~~~~\nExtra information for URL\n~~~~~~~~~~~~~~~~~~~~~~~~~\n\nIf you need to rely on more information than a single pk or slug, use ``*args`` and ``**kwargs`` to pass on this information to the ``urlresolvers.reverse`` method::\n\n    class Town(CrudUrlModelMixin, Model):\n        \n        def get_detail_url(self):\n            return super().get_detail_url(region_slug=self.region.sluggified_name)\n\nThe above example does also work similarly for the simpler ``UrlModelMixin`` class.\n\nBe careful!,\n\n    instance url methods (``get_instance_url`` and ``get_instance_action_url``) always pass the pk or slug argument to ``urlresolvers.reverse``.\n\n~~~~~~~~~~~~~~~~\nCustom URL names\n~~~~~~~~~~~~~~~~\n\nIf you want to provide a custom URL instead of an automatic ``modelname-action``, use ``@classmethod get_class_url(cls, url_name, *args, **kwargs)`` and ``get_instance_url(self, url_name, *args, **kwargs)``.\n\n~~~~~~~~~~~~~~~~~~~~~~\nFormat for action URLs\n~~~~~~~~~~~~~~~~~~~~~~\n\n**Note:** this section is subject to change in upcoming versions.\n\nAction URLs are formatted ``modelname-action`` by default. To change this format, override the ``action_url_formatter`` object or provide a ``format_action`` class method. If you provide the latter (method), the former (object) will be ignored::\n\n    action_url_formatter = lambda model, action: '%s-%s' % (model, action)\n    # this signature will override action_url_formatter\n    # @classmethod\n    # def format_action(cls, modelname, action):\n    #     pass\n\n---------\nProposals\n---------\n\n- Provide support for Python 2, probably through six_.\n- Submit this project to PyPI.\n\n.. _six: https://pypi.python.org/pypi/six/1.7.3\n\n---------\nResources\n---------\n\n- `url template tag`_\n- `Reversing URLs`_\n- `Slug fields`_\n- `Class-based views`_\n\n.. _`url template tag`: https://docs.djangoproject.com/en/dev/ref/templates/builtins/#url\n.. _`Reversing URLs`: https://docs.djangoproject.com/en/dev/ref/urlresolvers/#reverse\n.. _`Slug fields`: https://docs.djangoproject.com/en/dev/ref/models/fields/#slugfield\n.. _`Class-based views`: https://docs.djangoproject.com/en/dev/topics/class-based-views/", "description_content_type": null, "docs_url": null, "download_url": "UNKNOWN", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/jleeothon/urlmodel", "keywords": null, "license": "MIT", "maintainer": null, "maintainer_email": null, "name": "django-urlmodel", "package_url": "https://pypi.org/project/django-urlmodel/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/django-urlmodel/", "project_urls": {"Download": "UNKNOWN", "Homepage": "https://github.com/jleeothon/urlmodel"}, "release_url": "https://pypi.org/project/django-urlmodel/0.12/", "requires_dist": null, "requires_python": null, "summary": "Rich URLs for Django models.", "version": "0.12", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p>Creating rich and dry URLs for a Django model.</p>\n<div id=\"introduction\">\n<h2>Introduction</h2>\n<blockquote>\n<strong>Disclaimer.</strong> Until release of version 1.0, API could significantly change.</blockquote>\n<p>As I started using class-based views for Django, I understood what the <cite>get_absolute_url</cite> method was about. Then I encountered the problem of using URLs that required more than once piece of information from a model instance, let\u2019s say, not a single primary key or slug. That\u2019s a bit abstract, take:</p>\n<ul>\n<li><tt><span class=\"pre\">/regions/cat-cat-province/towns/mieaou/</span></tt></li>\n</ul>\n<p>This identifies Mieaou town within Cat-Cat Province (there\u2019s another Mieaou town within Copy-Cat Province). Now let\u2019s say the usual list of things you\u2019ll do with a model is listing, reading detail, creating, updating, deleting (roughly, <a href=\"http://en.wikipedia.org/wiki/Create,_read,_update_and_delete\" rel=\"nofollow\">CRUD</a>). Roughly, you\u2019ll have this URLs:</p>\n<ul>\n<li><tt><span class=\"pre\">/regions/cat-cat-province/towns/list</span></tt></li>\n<li><tt><span class=\"pre\">/regions/cat-cat-province/towns/create</span></tt></li>\n<li><tt><span class=\"pre\">/regions/cat-cat-province/towns/mieaou/edit</span></tt></li>\n<li><tt><span class=\"pre\">/regions/cat-cat-province/towns/mieaou/delete</span></tt></li>\n</ul>\n<p>An important part to notice is that we\u2019re using <em>more than one piece of information per instance</em>, which makes things a bit more messy than just a pk. Why not just use a pk? First, I <em>think</em> there are security implications. Second, nobody wants to remember a pk. Third, programmers respect well-formed URLs and look down to senseless sequences of numbers with unfathomable disdain.</p>\n<p>What if you provide a link to the edit and delete sections? You\u2019ll probably go for:</p>\n<pre># urls.py\n\nurlpatterns = patterns('',\n    # ...\n    url(\n        '^regions/(?P&lt;region_slug&gt;[\\w-]+)/towns/(?P&lt;town_slug&gt;[\\w-]+)/edit/?$',\n        name='town-update'\n    ),\n    # ...\n)\n</pre>\n<p>With something in your template like:</p>\n<pre># html\n\n&lt;a href=\"{% url 'town-update' region_slug=town.region.name_slug town_slug=town.name_slug %}\"&gt;\n  Update this town\n&lt;/a&gt;\n</pre>\n<blockquote>\nNote: I mostly use \u201cupdate\u201d for internal stuff for convention and readability (\u201cupdate\u201d has the length as \u201ccreate\u201d and \u201cdelete\u201d and \u201cdetail\u201d and \u201csearch\u201d), but I use \u201cedit\u201d for usability when it\u2019ll be read by the end-user.</blockquote>\n<p>The latter one is not very <a href=\"https://docs.djangoproject.com/en/dev/misc/design-philosophies/#don-t-repeat-yourself-dry\" rel=\"nofollow\">DRY</a>. So I thought I could start writing a <tt>get_update_url</tt> method, and so on. Then every model class definition would have a set of <tt>get_detail_url</tt>, <tt>get_update_url</tt>, <tt>get_delete_url</tt> methods, plus <tt>get_create_url</tt> and <tt>get_list_url</tt> methods (in the original project, it was \u201csearch\u201d instead of \u201clist\u201d). Now, given that my URLs have roughly the same naming format for every model (<tt><span class=\"pre\">town-list</span></tt>, <tt><span class=\"pre\">town-create</span></tt>, <tt><span class=\"pre\">town-detail</span></tt>, <tt><span class=\"pre\">town-update</span></tt>, <tt><span class=\"pre\">town-delete</span></tt>), that is not very DRY either!</p>\n<p>I decided to write a smart and flexible URL system so that the next time I would need a list-create-detail-update-delete set of URLs, things would be as easy as adding a mixin to the inheritance tree of the model.</p>\n</div>\n<div id=\"installation\">\n<h2>Installation</h2>\n<p>I know, my requirements suck:</p>\n<ul>\n<li>Python 3</li>\n<li>Django 1.6</li>\n</ul>\n<p>I\u2019m not sure if this app will not work on previous versions of Django, but I think I will not with Python 2.</p>\n<p>To install version 0.1:</p>\n<pre>pip install django-urlmodel\n</pre>\n<p>To install the latest version, run the command:</p>\n<pre>pip install git+git://github.com/jleeothon/urlmodel.git\n</pre>\n</div>\n<div id=\"how-to-use\">\n<h2>How to use</h2>\n<p>Using the default CRUD urls is as easy as extending funcionality as a mixin:</p>\n<pre># models.py\n\nfrom django.db import models\n\nclass Town(CrudUrlModelMixin, models.Model):\n    pass\n\n# or, if you're only going to extend the urlmodel functionality...\n\nclass Town(CrudUrlModel):\n    pass\n</pre>\n<p>The former example will create a set of five methods (class-level: list, create; instance-level: detail, update, delete) that expect an URL based on the model name and the name of the \u201caction\u201d. Also, these expect an URL keyword argument called \u201cpk\u201d.</p>\n<p>In order to use a slug field, you should override <tt>slug_kwarg_name</tt> to match the URL kwarg:</p>\n<pre># urls.py\n\nurlpatterns = patterns('',\n    # ...\n    url(\n        '^digimons/(?P&lt;name&gt;[\\w-]+)/?$',\n        name='digimon-detail'\n    ),\n    # ...\n)\n</pre>\n<p>and <tt>slug_field_name</tt>, to match the model slug:</p>\n<pre># models.py\n\nclass Digimon(UrlModelMixin, models.Model):\n    name = CharField(max_length=100)\n    sluggified_name = SlugField(max_length=100)\n\n    slug_kwarg_name = 'name'\n    slug_field_name = 'sluggified_name'\n</pre>\n<blockquote>\nTry out their lazy equivalents, <tt>LazyCrudUrlModelMixin</tt> and <tt>LazyCrudUrlModel</tt>!</blockquote>\n<blockquote>\n<strong>Note.</strong> CrudUrlModel provides implementation for <tt>get_absolute_url</tt> too, and defaults to <tt>get_detail_url</tt>.</blockquote>\n</div>\n<div id=\"advanced-stuff\">\n<h2>Advanced stuff</h2>\n<p>If the default \u201cCRUD\u201d system (here: list, create, detail, update, delete) do not work for you, you can try out <tt>UrlModel</tt> and <tt>UrlModelMixin</tt> (plus their lazy counterparts).</p>\n<div id=\"action-urls\">\n<h3>Action URLs</h3>\n<p>These are URLs based on \u201caction names\u201d, such as \u201cdetail\u201d, \u201ccreate\u201d, etc. For convention, ease and readability, you should try to stick to these methods, e.g.:</p>\n<pre>class TownPerson(UrlModelMixin, Model):\n\n    def get_defenestrate_url(self):\n        # expects townperson-defenestrate to exist.\n        return self.get_instance_action_url(\"defenestrate\")\n\n    @classmethod\n    def get_last_defenestrated(cls):\n        # expects townperson-last-defenestrated to exist.\n        return cls.get_class_action_url(\"last-defenestrated\")\n</pre>\n</div>\n<div id=\"extra-information-for-url\">\n<h3>Extra information for URL</h3>\n<p>If you need to rely on more information than a single pk or slug, use <tt>*args</tt> and <tt>**kwargs</tt> to pass on this information to the <tt>urlresolvers.reverse</tt> method:</p>\n<pre>class Town(CrudUrlModelMixin, Model):\n\n    def get_detail_url(self):\n        return super().get_detail_url(region_slug=self.region.sluggified_name)\n</pre>\n<p>The above example does also work similarly for the simpler <tt>UrlModelMixin</tt> class.</p>\n<p>Be careful!,</p>\n<blockquote>\ninstance url methods (<tt>get_instance_url</tt> and <tt>get_instance_action_url</tt>) always pass the pk or slug argument to <tt>urlresolvers.reverse</tt>.</blockquote>\n</div>\n<div id=\"custom-url-names\">\n<h3>Custom URL names</h3>\n<p>If you want to provide a custom URL instead of an automatic <tt><span class=\"pre\">modelname-action</span></tt>, use <tt>@classmethod get_class_url(cls, url_name, *args, **kwargs)</tt> and <tt>get_instance_url(self, url_name, *args, **kwargs)</tt>.</p>\n</div>\n<div id=\"format-for-action-urls\">\n<h3>Format for action URLs</h3>\n<p><strong>Note:</strong> this section is subject to change in upcoming versions.</p>\n<p>Action URLs are formatted <tt><span class=\"pre\">modelname-action</span></tt> by default. To change this format, override the <tt>action_url_formatter</tt> object or provide a <tt>format_action</tt> class method. If you provide the latter (method), the former (object) will be ignored:</p>\n<pre>action_url_formatter = lambda model, action: '%s-%s' % (model, action)\n# this signature will override action_url_formatter\n# @classmethod\n# def format_action(cls, modelname, action):\n#     pass\n</pre>\n</div>\n</div>\n<div id=\"proposals\">\n<h2>Proposals</h2>\n<ul>\n<li>Provide support for Python 2, probably through <a href=\"https://pypi.python.org/pypi/six/1.7.3\" rel=\"nofollow\">six</a>.</li>\n<li>Submit this project to PyPI.</li>\n</ul>\n</div>\n<div id=\"resources\">\n<h2>Resources</h2>\n<ul>\n<li><a href=\"https://docs.djangoproject.com/en/dev/ref/templates/builtins/#url\" rel=\"nofollow\">url template tag</a></li>\n<li><a href=\"https://docs.djangoproject.com/en/dev/ref/urlresolvers/#reverse\" rel=\"nofollow\">Reversing URLs</a></li>\n<li><a href=\"https://docs.djangoproject.com/en/dev/ref/models/fields/#slugfield\" rel=\"nofollow\">Slug fields</a></li>\n<li><a href=\"https://docs.djangoproject.com/en/dev/topics/class-based-views/\" rel=\"nofollow\">Class-based views</a></li>\n</ul>\n</div>\n\n          </div>"}, "last_serial": 1197256, "releases": {"0.1": [{"comment_text": "", "digests": {"md5": "cb0fb1af7beee5f69baa4a083e653444", "sha256": "c82838cd131a60a7cd8c068ae221ce1aa41acbf5a956593a7c7f47bd8681068c"}, "downloads": -1, "filename": "django-urlmodel-0.1.tar.gz", "has_sig": false, "md5_digest": "cb0fb1af7beee5f69baa4a083e653444", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 7290, "upload_time": "2014-08-20T22:43:53", "upload_time_iso_8601": "2014-08-20T22:43:53.350759Z", "url": "https://files.pythonhosted.org/packages/0b/b6/411d43b2646e6a73bd46350746fb7a02ca1dc42ecc1d7ed64571ae710d30/django-urlmodel-0.1.tar.gz", "yanked": false}], "0.12": [{"comment_text": "", "digests": {"md5": "9556d9b1d1b24059a38d240a28a20cc0", "sha256": "08991e796d0763ab9c552b597d3f82474e7a9bee4a0ba90063e579e5e0e8b6a1"}, "downloads": -1, "filename": "django-urlmodel-0.12.tar.gz", "has_sig": false, "md5_digest": "9556d9b1d1b24059a38d240a28a20cc0", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 6692, "upload_time": "2014-08-21T03:11:38", "upload_time_iso_8601": "2014-08-21T03:11:38.403897Z", "url": "https://files.pythonhosted.org/packages/40/c1/f2f808440658312af5e3317659065c7fe8ceceb7a5e05b9c25bbfcf2d33c/django-urlmodel-0.12.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "9556d9b1d1b24059a38d240a28a20cc0", "sha256": "08991e796d0763ab9c552b597d3f82474e7a9bee4a0ba90063e579e5e0e8b6a1"}, "downloads": -1, "filename": "django-urlmodel-0.12.tar.gz", "has_sig": false, "md5_digest": "9556d9b1d1b24059a38d240a28a20cc0", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 6692, "upload_time": "2014-08-21T03:11:38", "upload_time_iso_8601": "2014-08-21T03:11:38.403897Z", "url": "https://files.pythonhosted.org/packages/40/c1/f2f808440658312af5e3317659065c7fe8ceceb7a5e05b9c25bbfcf2d33c/django-urlmodel-0.12.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:52:11 2020"}