{"info": {"author": "Ilan Moscovitz", "author_email": "ilan.moscovitz@gmail.com", "bugtrack_url": null, "classifiers": ["Programming Language :: Python", "Programming Language :: Python :: 3.6", "Programming Language :: Python :: 3.7"], "description": "# wittgenstein\n\n_And is there not also the case where we play and--make up the rules as we go along?\n  -Ludwig Wittgenstein_\n\n![the duck-rabbit](https://github.com/imoscovitz/wittgenstein/blob/master/duck-rabbit.jpg)\n\n## Summary\n\nThis package implements two iterative coverage-based ruleset algorithms: IREP and RIPPERk.\n\nPerformance is similar to sklearn's DecisionTree CART implementation (see [Performance Tests](https://github.com/imoscovitz/ruleset/blob/master/Performance%20Tests.ipynb)).\n\nFor explanation of the algorithms, see my article in _Towards Data Science_, or the papers below, under [Useful References](https://github.com/imoscovitz/wittgenstein#useful-references).\n\n## Installation\n\nTo install, use\n```bash\n$ pip install wittgenstein\n```\n\nTo uninstall, use\n```bash\n$ pip uninstall wittgenstein\n```\n\n## Requirements\n- pandas\n- numpy\n- python version>=3.6\n\n## Usage\n\n#### Training\nUsage syntax is similar to sklearn's.\nOnce you have loaded and split your data...\n```python\n>>> import pandas as pd\n>>> df = pd.read_csv(dataset_filename)\n>>> from sklearn.model_selection import train_test_split # Or any other mechanism you want to use for data partitioning\n>>> train, test = train_test_split(df, test_size=.33)\n```\nWe can fit a ruleset classifier using RIPPER or IREP.\n\n```python\n>>> import wittgenstein as lw\n>>> ripper_clf = lw.RIPPER() # Or irep_clf = lw.IREP() to build a model using IREP\n>>> ripper_clf.fit(train, class_feat='Party') # Or pass X and y data to .fit\n>>> ripper_clf\n<RIPPER with fit ruleset (k=2, prune_size=0.33, dl_allowance=64)> # Hyperparameter details available in the docstrings and TDS article below\n```\n\nAccess the underlying trained model with the `.ruleset_` attribute, or output it with `.out_model()`. A ruleset is a disjunction of conjunctions -- 'V' represents 'or'; '^' represents 'and'.\n\nIn other words, the model predicts positive class if any of the inner-nested condition-combinations are all true:\n```python\n>>> ripper_clf.ruleset_\n<Ruleset [physician-fee-freeze=n] V [synfuels-corporation-cutback=y^adoption-of-the-budget-resolution=y^anti-satellite-test-ban=n]>\n```\n### Scoring\nTo score our fit model:\n```python\n>>> X_test = test.drop(class_feat, axis=1)\n>>> y_test = test[class_feat]\n>>> ripper_clf.score(test_X, test_y)\n0.9985686906328078\n```\nDefault scoring metric is accuracy. You can pass in alternate scoring functions, including those available through sklearn:\n```python\nfrom sklearn.metrics import precision_score, recall_score\n>>> precision = clf.score(X_test, y_test, precision_score)\n>>> recall = clf.score(X_test, y_test, recall_score)\n>>> print(f'precision: {precision} recall: {recall})\nprecision: 0.9914..., recall: 0.9953...\n```\n### Model selection\nwittgenstein classifiers are also compatible with sklearn model_selection tools such as `cross_val_score` and `GridSearchCV`, as well as ensemblers like `StackingClassifier`.\n\nCross validation:\n```python\n>>> # First dummify your categorical features to make sklearn happy\n>>> X_train = pd.get_dummies(X_train, columns=X_train.select_dtypes('object').columns)\n>>> y_train = y_train.map(lambda x: 1 if x=='democrat' else 0)\n>>> cross_val_score(ripper, X_train, y_train)\n```\nGrid search:\n```python\n>>> param_grid = {\"prune_size\": [0.33, 0.5], \"k\": [1, 2]}\n>>> grid = GridSearchCV(estimator=ripper, param_grid=param_grid)\n>>> grid.fit(X_train, y_train)\n```\nEnsemble:\n```python\n>>> tree = DecisionTreeClassifier(random_state=42)\n>>> estimators = [(\"rip\", ripper_clf), (\"tree\", tree)]\n  ensemble_clf = StackingClassifier(\n      estimators=estimators, final_estimator=LogisticRegression()\n  )\n  ensemble_clf.fit(X_train, y_train)\n```\n### Prediction\nTo perform predictions:\n```python\n>>> ripper_clf.predict(new_data)[:5]\n[True, True, False, True, False]\n```\nPredict class probabilities:\n```python\n>>> ripper_clf.predict_proba(test)\n# Pairs of negative and positive class probabilities\narray([[0.01212121, 0.98787879],\n       [0.01212121, 0.98787879],\n       [0.77777778, 0.22222222],\n       [0.2       , 0.8       ],\n       ...\n```\nWe can also ask our model to tell us why it made each positive prediction that it did:\n```python\n>>> ripper_clf.predict(new_data[:5], give_reasons=True)\n([True, True, False, True, True]\n[<Rule object: [physician-fee-freeze=n]>],\n[<Rule object: [physician-fee-freeze=n]>,\n  <Rule object: [synfuels-corporation-cutback=y^adoption-of-the-budget-resolution=y^anti-satellite-test-ban=n]>], # This example met multiple sufficient conditions for a positive prediction\n[],\n[<Rule object: [physician-fee-freeze=n]>],\n[])\n```\n\n## Issues\nIf you encounter any issues, or if you have feedback or improvement requests for how wittgenstein could be more helpful for you, please post them to [issues](https://github.com/imoscovitz/wittgenstein/issues), and I'll respond.\n\n## Changelog\n\n#### v0.7.0: 5/4/2020\n- Algorithmic optimizations to improve training speed (~10x - ~100x)\n- Support for training on iterable datatypes besides DataFrames, such as numpy arrays and python lists\n- Compatibility with sklearn ensembling metalearners and sklearn model_selection\n- `.predict_proba` returns probas in neg, pos order\n- Certain parameters (hyperparameters, random_state, etc.) should now be passed into IREP/RIPPER constructors rather than the .fit method.\n- Sundry bugfixes\n\n## Contributing\nContributions are welcome! If you are interested in contributing, let me know at ilan.moscovitz@gmail.com or on [linkedin](https://www.linkedin.com/in/ilan-moscovitz/).\n\n## Useful references\n- [My article in _Towards Data Science_ explaining IREP, RIPPER, and wittgenstein](https://towardsdatascience.com/how-to-perform-explainable-machine-learning-classification-without-any-trees-873db4192c68)\n- [Furnkrantz-Widmer IREP paper](https://pdfs.semanticscholar.org/f67e/bb7b392f51076899f58c53bf57d5e71e36e9.pdf)\n- [Cohen's RIPPER paper](http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.107.2612&rep=rep1&type=pdf)\n- [Partial decision trees](https://researchcommons.waikato.ac.nz/bitstream/handle/10289/1047/uow-cs-wp-1998-02.pdf?sequence=1&isAllowed=y)\n- [Bayesian Rulesets](https://pdfs.semanticscholar.org/bb51/b3046f6ff607deb218792347cb0e9b0b621a.pdf)\n- [C4.5 paper including all the gory details on MDL](https://pdfs.semanticscholar.org/cb94/e3d981a5e1901793c6bfedd93ce9cc07885d.pdf)\n- [_Philosophical Investigations_](https://static1.squarespace.com/static/54889e73e4b0a2c1f9891289/t/564b61a4e4b04eca59c4d232/1447780772744/Ludwig.Wittgenstein.-.Philosophical.Investigations.pdf)\n\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/imoscovitz/wittgenstein", "keywords": "Classification,Decision Rule,Machine Learning,Explainable Machine Learning,Data Science", "license": "MIT", "maintainer": "", "maintainer_email": "", "name": "wittgenstein", "package_url": "https://pypi.org/project/wittgenstein/", "platform": "", "project_url": "https://pypi.org/project/wittgenstein/", "project_urls": {"Homepage": "https://github.com/imoscovitz/wittgenstein"}, "release_url": "https://pypi.org/project/wittgenstein/0.2.0/", "requires_dist": ["pandas", "numpy"], "requires_python": "", "summary": "Ruleset covering algorithms for explainable machine learning", "version": "0.2.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>wittgenstein</h1>\n<p><em>And is there not also the case where we play and--make up the rules as we go along?\n-Ludwig Wittgenstein</em></p>\n<p><img alt=\"the duck-rabbit\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/2630de7ac47923e71c3b3595548f097fcc16f902/68747470733a2f2f6769746875622e636f6d2f696d6f73636f7669747a2f7769747467656e737465696e2f626c6f622f6d61737465722f6475636b2d7261626269742e6a7067\"></p>\n<h2>Summary</h2>\n<p>This package implements two iterative coverage-based ruleset algorithms: IREP and RIPPERk.</p>\n<p>Performance is similar to sklearn's DecisionTree CART implementation (see <a href=\"https://github.com/imoscovitz/ruleset/blob/master/Performance%20Tests.ipynb\" rel=\"nofollow\">Performance Tests</a>).</p>\n<p>For explanation of the algorithms, see my article in <em>Towards Data Science</em>, or the papers below, under <a href=\"https://github.com/imoscovitz/wittgenstein#useful-references\" rel=\"nofollow\">Useful References</a>.</p>\n<h2>Installation</h2>\n<p>To install, use</p>\n<pre>$ pip install wittgenstein\n</pre>\n<p>To uninstall, use</p>\n<pre>$ pip uninstall wittgenstein\n</pre>\n<h2>Requirements</h2>\n<ul>\n<li>pandas</li>\n<li>numpy</li>\n<li>python version&gt;=3.6</li>\n</ul>\n<h2>Usage</h2>\n<h4>Training</h4>\n<p>Usage syntax is similar to sklearn's.\nOnce you have loaded and split your data...</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">import</span> <span class=\"nn\">pandas</span> <span class=\"k\">as</span> <span class=\"nn\">pd</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">df</span> <span class=\"o\">=</span> <span class=\"n\">pd</span><span class=\"o\">.</span><span class=\"n\">read_csv</span><span class=\"p\">(</span><span class=\"n\">dataset_filename</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">from</span> <span class=\"nn\">sklearn.model_selection</span> <span class=\"kn\">import</span> <span class=\"n\">train_test_split</span> <span class=\"c1\"># Or any other mechanism you want to use for data partitioning</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">train</span><span class=\"p\">,</span> <span class=\"n\">test</span> <span class=\"o\">=</span> <span class=\"n\">train_test_split</span><span class=\"p\">(</span><span class=\"n\">df</span><span class=\"p\">,</span> <span class=\"n\">test_size</span><span class=\"o\">=.</span><span class=\"mi\">33</span><span class=\"p\">)</span>\n</pre>\n<p>We can fit a ruleset classifier using RIPPER or IREP.</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">import</span> <span class=\"nn\">wittgenstein</span> <span class=\"k\">as</span> <span class=\"nn\">lw</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">ripper_clf</span> <span class=\"o\">=</span> <span class=\"n\">lw</span><span class=\"o\">.</span><span class=\"n\">RIPPER</span><span class=\"p\">()</span> <span class=\"c1\"># Or irep_clf = lw.IREP() to build a model using IREP</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">ripper_clf</span><span class=\"o\">.</span><span class=\"n\">fit</span><span class=\"p\">(</span><span class=\"n\">train</span><span class=\"p\">,</span> <span class=\"n\">class_feat</span><span class=\"o\">=</span><span class=\"s1\">'Party'</span><span class=\"p\">)</span> <span class=\"c1\"># Or pass X and y data to .fit</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">ripper_clf</span>\n<span class=\"o\">&lt;</span><span class=\"n\">RIPPER</span> <span class=\"k\">with</span> <span class=\"n\">fit</span> <span class=\"n\">ruleset</span> <span class=\"p\">(</span><span class=\"n\">k</span><span class=\"o\">=</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"n\">prune_size</span><span class=\"o\">=</span><span class=\"mf\">0.33</span><span class=\"p\">,</span> <span class=\"n\">dl_allowance</span><span class=\"o\">=</span><span class=\"mi\">64</span><span class=\"p\">)</span><span class=\"o\">&gt;</span> <span class=\"c1\"># Hyperparameter details available in the docstrings and TDS article below</span>\n</pre>\n<p>Access the underlying trained model with the <code>.ruleset_</code> attribute, or output it with <code>.out_model()</code>. A ruleset is a disjunction of conjunctions -- 'V' represents 'or'; '^' represents 'and'.</p>\n<p>In other words, the model predicts positive class if any of the inner-nested condition-combinations are all true:</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">ripper_clf</span><span class=\"o\">.</span><span class=\"n\">ruleset_</span>\n<span class=\"o\">&lt;</span><span class=\"n\">Ruleset</span> <span class=\"p\">[</span><span class=\"n\">physician</span><span class=\"o\">-</span><span class=\"n\">fee</span><span class=\"o\">-</span><span class=\"n\">freeze</span><span class=\"o\">=</span><span class=\"n\">n</span><span class=\"p\">]</span> <span class=\"n\">V</span> <span class=\"p\">[</span><span class=\"n\">synfuels</span><span class=\"o\">-</span><span class=\"n\">corporation</span><span class=\"o\">-</span><span class=\"n\">cutback</span><span class=\"o\">=</span><span class=\"n\">y</span><span class=\"o\">^</span><span class=\"n\">adoption</span><span class=\"o\">-</span><span class=\"n\">of</span><span class=\"o\">-</span><span class=\"n\">the</span><span class=\"o\">-</span><span class=\"n\">budget</span><span class=\"o\">-</span><span class=\"n\">resolution</span><span class=\"o\">=</span><span class=\"n\">y</span><span class=\"o\">^</span><span class=\"n\">anti</span><span class=\"o\">-</span><span class=\"n\">satellite</span><span class=\"o\">-</span><span class=\"n\">test</span><span class=\"o\">-</span><span class=\"n\">ban</span><span class=\"o\">=</span><span class=\"n\">n</span><span class=\"p\">]</span><span class=\"o\">&gt;</span>\n</pre>\n<h3>Scoring</h3>\n<p>To score our fit model:</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">X_test</span> <span class=\"o\">=</span> <span class=\"n\">test</span><span class=\"o\">.</span><span class=\"n\">drop</span><span class=\"p\">(</span><span class=\"n\">class_feat</span><span class=\"p\">,</span> <span class=\"n\">axis</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">y_test</span> <span class=\"o\">=</span> <span class=\"n\">test</span><span class=\"p\">[</span><span class=\"n\">class_feat</span><span class=\"p\">]</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">ripper_clf</span><span class=\"o\">.</span><span class=\"n\">score</span><span class=\"p\">(</span><span class=\"n\">test_X</span><span class=\"p\">,</span> <span class=\"n\">test_y</span><span class=\"p\">)</span>\n<span class=\"mf\">0.9985686906328078</span>\n</pre>\n<p>Default scoring metric is accuracy. You can pass in alternate scoring functions, including those available through sklearn:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">sklearn.metrics</span> <span class=\"kn\">import</span> <span class=\"n\">precision_score</span><span class=\"p\">,</span> <span class=\"n\">recall_score</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">precision</span> <span class=\"o\">=</span> <span class=\"n\">clf</span><span class=\"o\">.</span><span class=\"n\">score</span><span class=\"p\">(</span><span class=\"n\">X_test</span><span class=\"p\">,</span> <span class=\"n\">y_test</span><span class=\"p\">,</span> <span class=\"n\">precision_score</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">recall</span> <span class=\"o\">=</span> <span class=\"n\">clf</span><span class=\"o\">.</span><span class=\"n\">score</span><span class=\"p\">(</span><span class=\"n\">X_test</span><span class=\"p\">,</span> <span class=\"n\">y_test</span><span class=\"p\">,</span> <span class=\"n\">recall_score</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"sa\">f</span><span class=\"s1\">'precision: </span><span class=\"si\">{</span><span class=\"n\">precision</span><span class=\"si\">}</span><span class=\"s1\"> recall: </span><span class=\"si\">{</span><span class=\"n\">recall</span><span class=\"si\">}</span><span class=\"s1\">)</span>\n<span class=\"n\">precision</span><span class=\"p\">:</span> <span class=\"mf\">0.9914</span><span class=\"o\">...</span><span class=\"p\">,</span> <span class=\"n\">recall</span><span class=\"p\">:</span> <span class=\"mf\">0.9953</span><span class=\"o\">...</span>\n</pre>\n<h3>Model selection</h3>\n<p>wittgenstein classifiers are also compatible with sklearn model_selection tools such as <code>cross_val_score</code> and <code>GridSearchCV</code>, as well as ensemblers like <code>StackingClassifier</code>.</p>\n<p>Cross validation:</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"c1\"># First dummify your categorical features to make sklearn happy</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">X_train</span> <span class=\"o\">=</span> <span class=\"n\">pd</span><span class=\"o\">.</span><span class=\"n\">get_dummies</span><span class=\"p\">(</span><span class=\"n\">X_train</span><span class=\"p\">,</span> <span class=\"n\">columns</span><span class=\"o\">=</span><span class=\"n\">X_train</span><span class=\"o\">.</span><span class=\"n\">select_dtypes</span><span class=\"p\">(</span><span class=\"s1\">'object'</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">columns</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">y_train</span> <span class=\"o\">=</span> <span class=\"n\">y_train</span><span class=\"o\">.</span><span class=\"n\">map</span><span class=\"p\">(</span><span class=\"k\">lambda</span> <span class=\"n\">x</span><span class=\"p\">:</span> <span class=\"mi\">1</span> <span class=\"k\">if</span> <span class=\"n\">x</span><span class=\"o\">==</span><span class=\"s1\">'democrat'</span> <span class=\"k\">else</span> <span class=\"mi\">0</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">cross_val_score</span><span class=\"p\">(</span><span class=\"n\">ripper</span><span class=\"p\">,</span> <span class=\"n\">X_train</span><span class=\"p\">,</span> <span class=\"n\">y_train</span><span class=\"p\">)</span>\n</pre>\n<p>Grid search:</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">param_grid</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"s2\">\"prune_size\"</span><span class=\"p\">:</span> <span class=\"p\">[</span><span class=\"mf\">0.33</span><span class=\"p\">,</span> <span class=\"mf\">0.5</span><span class=\"p\">],</span> <span class=\"s2\">\"k\"</span><span class=\"p\">:</span> <span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">]}</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">grid</span> <span class=\"o\">=</span> <span class=\"n\">GridSearchCV</span><span class=\"p\">(</span><span class=\"n\">estimator</span><span class=\"o\">=</span><span class=\"n\">ripper</span><span class=\"p\">,</span> <span class=\"n\">param_grid</span><span class=\"o\">=</span><span class=\"n\">param_grid</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">grid</span><span class=\"o\">.</span><span class=\"n\">fit</span><span class=\"p\">(</span><span class=\"n\">X_train</span><span class=\"p\">,</span> <span class=\"n\">y_train</span><span class=\"p\">)</span>\n</pre>\n<p>Ensemble:</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">tree</span> <span class=\"o\">=</span> <span class=\"n\">DecisionTreeClassifier</span><span class=\"p\">(</span><span class=\"n\">random_state</span><span class=\"o\">=</span><span class=\"mi\">42</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">estimators</span> <span class=\"o\">=</span> <span class=\"p\">[(</span><span class=\"s2\">\"rip\"</span><span class=\"p\">,</span> <span class=\"n\">ripper_clf</span><span class=\"p\">),</span> <span class=\"p\">(</span><span class=\"s2\">\"tree\"</span><span class=\"p\">,</span> <span class=\"n\">tree</span><span class=\"p\">)]</span>\n  <span class=\"n\">ensemble_clf</span> <span class=\"o\">=</span> <span class=\"n\">StackingClassifier</span><span class=\"p\">(</span>\n      <span class=\"n\">estimators</span><span class=\"o\">=</span><span class=\"n\">estimators</span><span class=\"p\">,</span> <span class=\"n\">final_estimator</span><span class=\"o\">=</span><span class=\"n\">LogisticRegression</span><span class=\"p\">()</span>\n  <span class=\"p\">)</span>\n  <span class=\"n\">ensemble_clf</span><span class=\"o\">.</span><span class=\"n\">fit</span><span class=\"p\">(</span><span class=\"n\">X_train</span><span class=\"p\">,</span> <span class=\"n\">y_train</span><span class=\"p\">)</span>\n</pre>\n<h3>Prediction</h3>\n<p>To perform predictions:</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">ripper_clf</span><span class=\"o\">.</span><span class=\"n\">predict</span><span class=\"p\">(</span><span class=\"n\">new_data</span><span class=\"p\">)[:</span><span class=\"mi\">5</span><span class=\"p\">]</span>\n<span class=\"p\">[</span><span class=\"kc\">True</span><span class=\"p\">,</span> <span class=\"kc\">True</span><span class=\"p\">,</span> <span class=\"kc\">False</span><span class=\"p\">,</span> <span class=\"kc\">True</span><span class=\"p\">,</span> <span class=\"kc\">False</span><span class=\"p\">]</span>\n</pre>\n<p>Predict class probabilities:</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">ripper_clf</span><span class=\"o\">.</span><span class=\"n\">predict_proba</span><span class=\"p\">(</span><span class=\"n\">test</span><span class=\"p\">)</span>\n<span class=\"c1\"># Pairs of negative and positive class probabilities</span>\n<span class=\"n\">array</span><span class=\"p\">([[</span><span class=\"mf\">0.01212121</span><span class=\"p\">,</span> <span class=\"mf\">0.98787879</span><span class=\"p\">],</span>\n       <span class=\"p\">[</span><span class=\"mf\">0.01212121</span><span class=\"p\">,</span> <span class=\"mf\">0.98787879</span><span class=\"p\">],</span>\n       <span class=\"p\">[</span><span class=\"mf\">0.77777778</span><span class=\"p\">,</span> <span class=\"mf\">0.22222222</span><span class=\"p\">],</span>\n       <span class=\"p\">[</span><span class=\"mf\">0.2</span>       <span class=\"p\">,</span> <span class=\"mf\">0.8</span>       <span class=\"p\">],</span>\n       <span class=\"o\">...</span>\n</pre>\n<p>We can also ask our model to tell us why it made each positive prediction that it did:</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">ripper_clf</span><span class=\"o\">.</span><span class=\"n\">predict</span><span class=\"p\">(</span><span class=\"n\">new_data</span><span class=\"p\">[:</span><span class=\"mi\">5</span><span class=\"p\">],</span> <span class=\"n\">give_reasons</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n<span class=\"p\">([</span><span class=\"kc\">True</span><span class=\"p\">,</span> <span class=\"kc\">True</span><span class=\"p\">,</span> <span class=\"kc\">False</span><span class=\"p\">,</span> <span class=\"kc\">True</span><span class=\"p\">,</span> <span class=\"kc\">True</span><span class=\"p\">]</span>\n<span class=\"p\">[</span><span class=\"o\">&lt;</span><span class=\"n\">Rule</span> <span class=\"nb\">object</span><span class=\"p\">:</span> <span class=\"p\">[</span><span class=\"n\">physician</span><span class=\"o\">-</span><span class=\"n\">fee</span><span class=\"o\">-</span><span class=\"n\">freeze</span><span class=\"o\">=</span><span class=\"n\">n</span><span class=\"p\">]</span><span class=\"o\">&gt;</span><span class=\"p\">],</span>\n<span class=\"p\">[</span><span class=\"o\">&lt;</span><span class=\"n\">Rule</span> <span class=\"nb\">object</span><span class=\"p\">:</span> <span class=\"p\">[</span><span class=\"n\">physician</span><span class=\"o\">-</span><span class=\"n\">fee</span><span class=\"o\">-</span><span class=\"n\">freeze</span><span class=\"o\">=</span><span class=\"n\">n</span><span class=\"p\">]</span><span class=\"o\">&gt;</span><span class=\"p\">,</span>\n  <span class=\"o\">&lt;</span><span class=\"n\">Rule</span> <span class=\"nb\">object</span><span class=\"p\">:</span> <span class=\"p\">[</span><span class=\"n\">synfuels</span><span class=\"o\">-</span><span class=\"n\">corporation</span><span class=\"o\">-</span><span class=\"n\">cutback</span><span class=\"o\">=</span><span class=\"n\">y</span><span class=\"o\">^</span><span class=\"n\">adoption</span><span class=\"o\">-</span><span class=\"n\">of</span><span class=\"o\">-</span><span class=\"n\">the</span><span class=\"o\">-</span><span class=\"n\">budget</span><span class=\"o\">-</span><span class=\"n\">resolution</span><span class=\"o\">=</span><span class=\"n\">y</span><span class=\"o\">^</span><span class=\"n\">anti</span><span class=\"o\">-</span><span class=\"n\">satellite</span><span class=\"o\">-</span><span class=\"n\">test</span><span class=\"o\">-</span><span class=\"n\">ban</span><span class=\"o\">=</span><span class=\"n\">n</span><span class=\"p\">]</span><span class=\"o\">&gt;</span><span class=\"p\">],</span> <span class=\"c1\"># This example met multiple sufficient conditions for a positive prediction</span>\n<span class=\"p\">[],</span>\n<span class=\"p\">[</span><span class=\"o\">&lt;</span><span class=\"n\">Rule</span> <span class=\"nb\">object</span><span class=\"p\">:</span> <span class=\"p\">[</span><span class=\"n\">physician</span><span class=\"o\">-</span><span class=\"n\">fee</span><span class=\"o\">-</span><span class=\"n\">freeze</span><span class=\"o\">=</span><span class=\"n\">n</span><span class=\"p\">]</span><span class=\"o\">&gt;</span><span class=\"p\">],</span>\n<span class=\"p\">[])</span>\n</pre>\n<h2>Issues</h2>\n<p>If you encounter any issues, or if you have feedback or improvement requests for how wittgenstein could be more helpful for you, please post them to <a href=\"https://github.com/imoscovitz/wittgenstein/issues\" rel=\"nofollow\">issues</a>, and I'll respond.</p>\n<h2>Changelog</h2>\n<h4>v0.7.0: 5/4/2020</h4>\n<ul>\n<li>Algorithmic optimizations to improve training speed (~10x - ~100x)</li>\n<li>Support for training on iterable datatypes besides DataFrames, such as numpy arrays and python lists</li>\n<li>Compatibility with sklearn ensembling metalearners and sklearn model_selection</li>\n<li><code>.predict_proba</code> returns probas in neg, pos order</li>\n<li>Certain parameters (hyperparameters, random_state, etc.) should now be passed into IREP/RIPPER constructors rather than the .fit method.</li>\n<li>Sundry bugfixes</li>\n</ul>\n<h2>Contributing</h2>\n<p>Contributions are welcome! If you are interested in contributing, let me know at <a href=\"mailto:ilan.moscovitz@gmail.com\">ilan.moscovitz@gmail.com</a> or on <a href=\"https://www.linkedin.com/in/ilan-moscovitz/\" rel=\"nofollow\">linkedin</a>.</p>\n<h2>Useful references</h2>\n<ul>\n<li><a href=\"https://towardsdatascience.com/how-to-perform-explainable-machine-learning-classification-without-any-trees-873db4192c68\" rel=\"nofollow\">My article in <em>Towards Data Science</em> explaining IREP, RIPPER, and wittgenstein</a></li>\n<li><a href=\"https://pdfs.semanticscholar.org/f67e/bb7b392f51076899f58c53bf57d5e71e36e9.pdf\" rel=\"nofollow\">Furnkrantz-Widmer IREP paper</a></li>\n<li><a href=\"http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.107.2612&amp;rep=rep1&amp;type=pdf\" rel=\"nofollow\">Cohen's RIPPER paper</a></li>\n<li><a href=\"https://researchcommons.waikato.ac.nz/bitstream/handle/10289/1047/uow-cs-wp-1998-02.pdf?sequence=1&amp;isAllowed=y\" rel=\"nofollow\">Partial decision trees</a></li>\n<li><a href=\"https://pdfs.semanticscholar.org/bb51/b3046f6ff607deb218792347cb0e9b0b621a.pdf\" rel=\"nofollow\">Bayesian Rulesets</a></li>\n<li><a href=\"https://pdfs.semanticscholar.org/cb94/e3d981a5e1901793c6bfedd93ce9cc07885d.pdf\" rel=\"nofollow\">C4.5 paper including all the gory details on MDL</a></li>\n<li><a href=\"https://static1.squarespace.com/static/54889e73e4b0a2c1f9891289/t/564b61a4e4b04eca59c4d232/1447780772744/Ludwig.Wittgenstein.-.Philosophical.Investigations.pdf\" rel=\"nofollow\"><em>Philosophical Investigations</em></a></li>\n</ul>\n\n          </div>"}, "last_serial": 7176216, "releases": {"0.1.0": [{"comment_text": "", "digests": {"md5": "54f91a9bc3c2a9440ecf7a7995cef408", "sha256": "1ea346cc61507acadce770c997ae3a1d904810021dcf8a6156f89147dafdc0c9"}, "downloads": -1, "filename": "wittgenstein-0.1.0-py3.6.egg", "has_sig": false, "md5_digest": "54f91a9bc3c2a9440ecf7a7995cef408", "packagetype": "bdist_egg", "python_version": "3.6", "requires_python": null, "size": 89550, "upload_time": "2019-02-22T00:30:27", "upload_time_iso_8601": "2019-02-22T00:30:27.636029Z", "url": "https://files.pythonhosted.org/packages/37/12/f7c9687075918710b9bb6b42f904273c14719bb5dfa54537fe3e83575cf8/wittgenstein-0.1.0-py3.6.egg", "yanked": false}], "0.1.1": [{"comment_text": "", "digests": {"md5": "af4b72a876ace503e9440a7c102cbd17", "sha256": "a26106974c3dc27a5876d5af43e0c8d1d0b5fcf22405371008863bc35aedd0b5"}, "downloads": -1, "filename": "wittgenstein-0.1.1-py3.6.egg", "has_sig": false, "md5_digest": "af4b72a876ace503e9440a7c102cbd17", "packagetype": "bdist_egg", "python_version": "3.6", "requires_python": null, "size": 89619, "upload_time": "2019-02-22T00:30:36", "upload_time_iso_8601": "2019-02-22T00:30:36.097406Z", "url": "https://files.pythonhosted.org/packages/70/3d/54998f3a5e2c70d1dc56e55bd1bca08a3874ef00e74b3aec2028620f2318/wittgenstein-0.1.1-py3.6.egg", "yanked": false}, {"comment_text": "", "digests": {"md5": "c244bb169d2cc4707780daa7f7c199db", "sha256": "7d38d20829ecdc24cd7de429c4bf6d5a71c4a784532e3d4e3bf32b8231493781"}, "downloads": -1, "filename": "wittgenstein-0.1.1-py3-none-any.whl", "has_sig": false, "md5_digest": "c244bb169d2cc4707780daa7f7c199db", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 41659, "upload_time": "2019-02-22T00:30:24", "upload_time_iso_8601": "2019-02-22T00:30:24.136078Z", "url": "https://files.pythonhosted.org/packages/99/4d/605574f34dc898df686708a54d6671737e9058822bcb7204bffea7a148c2/wittgenstein-0.1.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "00cfd6de665a6806885e28611c7b9f6d", "sha256": "08571897fea9958e6f695d330177a28db3b056025b104fa450c2c4a02752d3ff"}, "downloads": -1, "filename": "wittgenstein-0.1.1.tar.gz", "has_sig": false, "md5_digest": "00cfd6de665a6806885e28611c7b9f6d", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 19775, "upload_time": "2019-02-22T00:30:40", "upload_time_iso_8601": "2019-02-22T00:30:40.666507Z", "url": "https://files.pythonhosted.org/packages/67/b8/151a6e3da17cd81e050e25748a1823ae369ecc6af300cc269f6f950c1abf/wittgenstein-0.1.1.tar.gz", "yanked": false}], "0.1.3": [{"comment_text": "", "digests": {"md5": "e9664abb95b17e6e3a6402783db9a3f5", "sha256": "246ee4189c8a2dc238f42142816a16db476d48bcf0fd7f6f10a2824511ab7876"}, "downloads": -1, "filename": "wittgenstein-0.1.3.tar.gz", "has_sig": false, "md5_digest": "e9664abb95b17e6e3a6402783db9a3f5", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 20522, "upload_time": "2019-03-05T01:20:50", "upload_time_iso_8601": "2019-03-05T01:20:50.164513Z", "url": "https://files.pythonhosted.org/packages/0c/c4/f0675a3fce7c6156c7781b4e256e6726889052f95a0b52da65a046733ae8/wittgenstein-0.1.3.tar.gz", "yanked": false}], "0.1.4": [{"comment_text": "", "digests": {"md5": "8055da240d54a91b51aa5ac009f76edf", "sha256": "4979233ad7e1e8488e37b5292e15548b080083aae620b94deaf94b7a375942ad"}, "downloads": -1, "filename": "wittgenstein-0.1.4.tar.gz", "has_sig": false, "md5_digest": "8055da240d54a91b51aa5ac009f76edf", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 20526, "upload_time": "2019-03-05T01:32:37", "upload_time_iso_8601": "2019-03-05T01:32:37.046086Z", "url": "https://files.pythonhosted.org/packages/04/eb/f03311eb9c03e9338bf0247511feab2ff82d4914ee064d0742de2c4e8b4f/wittgenstein-0.1.4.tar.gz", "yanked": false}], "0.1.5": [{"comment_text": "", "digests": {"md5": "8f3ee2817f8ee47bcbebc2f8a4daba15", "sha256": "27fea9027bc323273d0764914dcb2fde343283696b1572a66df708815acdd748"}, "downloads": -1, "filename": "wittgenstein-0.1.5.tar.gz", "has_sig": false, "md5_digest": "8f3ee2817f8ee47bcbebc2f8a4daba15", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 20742, "upload_time": "2019-03-07T00:42:14", "upload_time_iso_8601": "2019-03-07T00:42:14.317607Z", "url": "https://files.pythonhosted.org/packages/dc/50/541bfb656bebc21a2b0112affdd47b6954abf093e9b3d2d378baee3599ac/wittgenstein-0.1.5.tar.gz", "yanked": false}], "0.1.6": [{"comment_text": "", "digests": {"md5": "a415f9bcebbb2d7d3c8be90fca9305ba", "sha256": "7f6865af4135b5039ca4461a1b9c5b210ec604c6c60a23fd6c7fe76e1f9643b7"}, "downloads": -1, "filename": "wittgenstein-0.1.6.tar.gz", "has_sig": false, "md5_digest": "a415f9bcebbb2d7d3c8be90fca9305ba", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 25316, "upload_time": "2019-04-18T23:14:27", "upload_time_iso_8601": "2019-04-18T23:14:27.184573Z", "url": "https://files.pythonhosted.org/packages/09/fb/35564fb8efa80ab7b690c0312bb73af10892993e8f6d4930b8e6fd87dec4/wittgenstein-0.1.6.tar.gz", "yanked": false}], "0.2.0": [{"comment_text": "", "digests": {"md5": "9d58c49c07914e6b82c58eb5b582c32d", "sha256": "65cf02600b77156fb557f854038a0583b41f52701b475f8b6ebbe9e534fc8f8e"}, "downloads": -1, "filename": "wittgenstein-0.2.0-py3-none-any.whl", "has_sig": false, "md5_digest": "9d58c49c07914e6b82c58eb5b582c32d", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 74453, "upload_time": "2020-05-05T22:11:53", "upload_time_iso_8601": "2020-05-05T22:11:53.013883Z", "url": "https://files.pythonhosted.org/packages/ed/16/c1bd26a8b45cdca67d3fe370e53cea4f02548aac2dd517555bcb1725cd40/wittgenstein-0.2.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "e84125b14ec4f9f90c14311d67ed3720", "sha256": "f87159134d4f90214a6335a1740955d9459305d4f9a4199ad6b91237266eeca1"}, "downloads": -1, "filename": "wittgenstein-0.2.0.tar.gz", "has_sig": false, "md5_digest": "e84125b14ec4f9f90c14311d67ed3720", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 422555, "upload_time": "2020-05-05T22:11:55", "upload_time_iso_8601": "2020-05-05T22:11:55.165044Z", "url": "https://files.pythonhosted.org/packages/3e/3d/f58b2f52884fea0925b541011a33192db41b673594dd8f83ca387f4b9e37/wittgenstein-0.2.0.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "9d58c49c07914e6b82c58eb5b582c32d", "sha256": "65cf02600b77156fb557f854038a0583b41f52701b475f8b6ebbe9e534fc8f8e"}, "downloads": -1, "filename": "wittgenstein-0.2.0-py3-none-any.whl", "has_sig": false, "md5_digest": "9d58c49c07914e6b82c58eb5b582c32d", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 74453, "upload_time": "2020-05-05T22:11:53", "upload_time_iso_8601": "2020-05-05T22:11:53.013883Z", "url": "https://files.pythonhosted.org/packages/ed/16/c1bd26a8b45cdca67d3fe370e53cea4f02548aac2dd517555bcb1725cd40/wittgenstein-0.2.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "e84125b14ec4f9f90c14311d67ed3720", "sha256": "f87159134d4f90214a6335a1740955d9459305d4f9a4199ad6b91237266eeca1"}, "downloads": -1, "filename": "wittgenstein-0.2.0.tar.gz", "has_sig": false, "md5_digest": "e84125b14ec4f9f90c14311d67ed3720", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 422555, "upload_time": "2020-05-05T22:11:55", "upload_time_iso_8601": "2020-05-05T22:11:55.165044Z", "url": "https://files.pythonhosted.org/packages/3e/3d/f58b2f52884fea0925b541011a33192db41b673594dd8f83ca387f4b9e37/wittgenstein-0.2.0.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:28:31 2020"}