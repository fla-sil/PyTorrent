{"info": {"author": "Jeff Forcier", "author_email": "jeff@bitprophet.org", "bugtrack_url": null, "classifiers": ["Development Status :: 5 - Production/Stable", "Environment :: Console", "Intended Audience :: Developers", "License :: OSI Approved :: BSD License", "Operating System :: MacOS :: MacOS X", "Operating System :: POSIX", "Operating System :: Unix", "Programming Language :: Python", "Programming Language :: Python :: 2", "Programming Language :: Python :: 2.6", "Programming Language :: Python :: 2.7", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.3", "Programming Language :: Python :: 3.4", "Programming Language :: Python :: 3.5", "Topic :: Software Development", "Topic :: Software Development :: Libraries", "Topic :: Software Development :: Libraries :: Python Modules"], "description": "## WHAT\n\nLexicon is a simple Python 2.6+ and 3.3+ compatible collection of `dict`\nsubclasses providing extra power:\n\n* `AliasDict`, a dictionary supporting both simple and complex key aliasing:\n    * Alias a single key to another key, so that e.g. `mydict['bar']` points to\n    `mydict['foo']`, for both reads and writes.\n    * Alias a single key to a list of other keys, for writing only, e.g. with\n    `active_groups = AliasDict({'ops': True, 'biz': True, 'dev': True,\n    'product': True})` one can make an alias `'tech'` mapping to `('ops',\n    'dev')` and then e.g. `active_groups['tech'] = False`.\n    * Aliasing is recursive: an alias pointing to another alias will behave as\n    if it points to the other alias' target.\n* `AttributeDict`, supporting attribute read & write access, e.g.\n  `mydict = AttributeDict({'foo': 'bar'})` exhibits `mydict.foo` and\n  `mydict.foo = 'new value'`.\n* `Lexicon`, a subclass of both of the above which exhibits both sets of\n  behavior.\n\n## HOW\n\n* `pip install lexicon`\n* `from lexicon import Lexicon` (or one of the superclasses)\n* Use as needed.\n\nYou can install the [development\nversion](https://github.com/bitprophet/lexicon/tarball/master#egg=lexicon-dev)\nvia `pip install lexicon==dev`.\n\nIf you have a clone of the source repository, you can run the tests like so:\n\n* `pip install -r dev-requirements.txt`\n* `spec`\n\n## API\n\n### `AliasDict`\n\nIn all examples, `'myalias'` is the alias and `'realkey'` is the \"real\",\nunaliased key.\n\n* `alias(from_'myalias', to='realkey')`: Alias `myalias` to `realkey` so\n  `d['myalias']` behaves exactly like `d['realkey']` for both reads and writes.\n    * `from_` is the first keyword argument, but typically it can be omitted\n    and still reads fine. See below examples for this usage.\n  See below for details on how an alias affects other dict operations.\n* `alias('myalias', to=('realkey', 'otherrealkey'))`: Alias `myalias` to\n  both `realkey` and `otherrealkey`. As you might expect, this only works well\n  for writes, as there is never any guarantee that all targets of the alias\n  will contain the same value.\n* `unalias('myalias')`: Removes the `myalias` alias; any subsequent\n  reads/writes to `myalias` will behave as normal for a regular `dict`.\n* `'myalias' in d` (aka `__contains__`): Returns True when given an alias, so\n  if `myalias` is an alias to some other key, dictionary membership tests will\n  behave as if `myalias` is set.\n* `del d['myalias']` (aka `__delitem__`): This effectively becomes `del\n  d['realkey']` -- to remove the alias itself, use `unalias()`.\n* `del d['realkey']`: Deletes the real key/value pair (i.e. it calls\n  `dict.__del__`) but doesn't touch any aliases pointing to `realkey`.\n    * As a result, \"dangling\" aliases pointing to nonexistent keys will raise\n    `KeyError` on access, but will continue working if the target key is\n    repopulated later.\n\nCaveats:\n\n* Because of the single-key/multi-key duality, `AliasDict` is incapable of\n  honoring non-string-type keys when aliasing (it must test `isinstance(key,\n  basestring)` to tell strings apart from non-string iterables).\n    * `AliasDict` instances may still *use* non-string keys, of course -- it\n    just can't use them as alias targets.\n\n### `AttributeDict`\n\n* `d.key = 'value'` (aka `__setattr__`): Maps directly to `d['key'] = 'value'`.\n* `d.key` (aka `__getattr__`): Maps directly to `d['key']`.\n* `del d.key` (aka `__delattr__`): Maps directly to `del d['key']`.\n* Collisions between \"real\" or pre-existing attributes, and\n  attributes-as-dict-keys, always results in the real attribute winning. Thus\n  it isn't possible to use attribute access to access e.g. `d['get']`.\n\n### `Lexicon`\n\nLexicon subclasses from `AttributeDict` first, then `AliasDict`, with the end\nresult that attribute access will honor aliases. E.g.:\n\n    d = Lexicon()\n    d.alias('myalias', to='realkey')\n    d.myalias = 'foo'\n    print d.realkey # prints 'foo'", "description_content_type": null, "docs_url": null, "download_url": null, "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/bitprophet/lexicon", "keywords": null, "license": "BSD", "maintainer": null, "maintainer_email": null, "name": "lexicon", "package_url": "https://pypi.org/project/lexicon/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/lexicon/", "project_urls": {"Homepage": "https://github.com/bitprophet/lexicon"}, "release_url": "https://pypi.org/project/lexicon/1.0.0/", "requires_dist": ["six"], "requires_python": null, "summary": "Powerful dict subclass(es) with aliasing & attribute access", "version": "1.0.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            ## WHAT<br><br>Lexicon is a simple Python 2.6+ and 3.3+ compatible collection of `dict`<br>subclasses providing extra power:<br><br>* `AliasDict`, a dictionary supporting both simple and complex key aliasing:<br>    * Alias a single key to another key, so that e.g. `mydict['bar']` points to<br>    `mydict['foo']`, for both reads and writes.<br>    * Alias a single key to a list of other keys, for writing only, e.g. with<br>    `active_groups = AliasDict({'ops': True, 'biz': True, 'dev': True,<br>    'product': True})` one can make an alias `'tech'` mapping to `('ops',<br>    'dev')` and then e.g. `active_groups['tech'] = False`.<br>    * Aliasing is recursive: an alias pointing to another alias will behave as<br>    if it points to the other alias' target.<br>* `AttributeDict`, supporting attribute read &amp; write access, e.g.<br>  `mydict = AttributeDict({'foo': 'bar'})` exhibits `mydict.foo` and<br>  `mydict.foo = 'new value'`.<br>* `Lexicon`, a subclass of both of the above which exhibits both sets of<br>  behavior.<br><br>## HOW<br><br>* `pip install lexicon`<br>* `from lexicon import Lexicon` (or one of the superclasses)<br>* Use as needed.<br><br>You can install the [development<br>version](https://github.com/bitprophet/lexicon/tarball/master#egg=lexicon-dev)<br>via `pip install lexicon==dev`.<br><br>If you have a clone of the source repository, you can run the tests like so:<br><br>* `pip install -r dev-requirements.txt`<br>* `spec`<br><br>## API<br><br>### `AliasDict`<br><br>In all examples, `'myalias'` is the alias and `'realkey'` is the \"real\",<br>unaliased key.<br><br>* `alias(from_'myalias', to='realkey')`: Alias `myalias` to `realkey` so<br>  `d['myalias']` behaves exactly like `d['realkey']` for both reads and writes.<br>    * `from_` is the first keyword argument, but typically it can be omitted<br>    and still reads fine. See below examples for this usage.<br>  See below for details on how an alias affects other dict operations.<br>* `alias('myalias', to=('realkey', 'otherrealkey'))`: Alias `myalias` to<br>  both `realkey` and `otherrealkey`. As you might expect, this only works well<br>  for writes, as there is never any guarantee that all targets of the alias<br>  will contain the same value.<br>* `unalias('myalias')`: Removes the `myalias` alias; any subsequent<br>  reads/writes to `myalias` will behave as normal for a regular `dict`.<br>* `'myalias' in d` (aka `__contains__`): Returns True when given an alias, so<br>  if `myalias` is an alias to some other key, dictionary membership tests will<br>  behave as if `myalias` is set.<br>* `del d['myalias']` (aka `__delitem__`): This effectively becomes `del<br>  d['realkey']` -- to remove the alias itself, use `unalias()`.<br>* `del d['realkey']`: Deletes the real key/value pair (i.e. it calls<br>  `dict.__del__`) but doesn't touch any aliases pointing to `realkey`.<br>    * As a result, \"dangling\" aliases pointing to nonexistent keys will raise<br>    `KeyError` on access, but will continue working if the target key is<br>    repopulated later.<br><br>Caveats:<br><br>* Because of the single-key/multi-key duality, `AliasDict` is incapable of<br>  honoring non-string-type keys when aliasing (it must test `isinstance(key,<br>  basestring)` to tell strings apart from non-string iterables).<br>    * `AliasDict` instances may still *use* non-string keys, of course -- it<br>    just can't use them as alias targets.<br><br>### `AttributeDict`<br><br>* `d.key = 'value'` (aka `__setattr__`): Maps directly to `d['key'] = 'value'`.<br>* `d.key` (aka `__getattr__`): Maps directly to `d['key']`.<br>* `del d.key` (aka `__delattr__`): Maps directly to `del d['key']`.<br>* Collisions between \"real\" or pre-existing attributes, and<br>  attributes-as-dict-keys, always results in the real attribute winning. Thus<br>  it isn't possible to use attribute access to access e.g. `d['get']`.<br><br>### `Lexicon`<br><br>Lexicon subclasses from `AttributeDict` first, then `AliasDict`, with the end<br>result that attribute access will honor aliases. E.g.:<br><br>    d = Lexicon()<br>    d.alias('myalias', to='realkey')<br>    d.myalias = 'foo'<br>    print d.realkey # prints 'foo'\n          </div>"}, "last_serial": 1962201, "releases": {"0.1.0": [{"comment_text": "", "digests": {"md5": "5492d0fe5b5d96bdae675b58e6beafff", "sha256": "5447c37536814fddf733cd4a111f5e5dbe197348f44a0b82fcc3fd11daf51e21"}, "downloads": -1, "filename": "lexicon-0.1.0.tar.gz", "has_sig": false, "md5_digest": "5492d0fe5b5d96bdae675b58e6beafff", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 3945, "upload_time": "2012-05-31T19:00:08", "upload_time_iso_8601": "2012-05-31T19:00:08.138687Z", "url": "https://files.pythonhosted.org/packages/bb/e2/7b4075cd1cee5b1f01319ba82ce62cde7701ed17ae1071259b59c639e4c9/lexicon-0.1.0.tar.gz", "yanked": false}], "0.1.1": [{"comment_text": "", "digests": {"md5": "3a02443bbd4135de0c2c38d043809acc", "sha256": "72b789f6aa02ada8e6be6bd73e7eea7f2ac0554c3a81deff2286718a53ce9504"}, "downloads": -1, "filename": "lexicon-0.1.1.tar.gz", "has_sig": false, "md5_digest": "3a02443bbd4135de0c2c38d043809acc", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 6386, "upload_time": "2012-06-01T04:57:54", "upload_time_iso_8601": "2012-06-01T04:57:54.051046Z", "url": "https://files.pythonhosted.org/packages/7d/9c/c25851008726231c314c5a6c2c541b2187bc1a9523a4c305e6718974b5ba/lexicon-0.1.1.tar.gz", "yanked": false}], "0.1.2": [{"comment_text": "", "digests": {"md5": "3bc877e5ec9bd55ef90d031c21932b76", "sha256": "72e980cfaf4b9a7a5f6632d86841e04d76a16e600b5f20783e48dea3a2cc26dd"}, "downloads": -1, "filename": "lexicon-0.1.2.tar.gz", "has_sig": false, "md5_digest": "3bc877e5ec9bd55ef90d031c21932b76", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 8273, "upload_time": "2012-07-10T19:07:22", "upload_time_iso_8601": "2012-07-10T19:07:22.672358Z", "url": "https://files.pythonhosted.org/packages/a7/6a/6df0badda586cd5c6ff750aa6d542d868e75a551bdba6cb46f04e151e653/lexicon-0.1.2.tar.gz", "yanked": false}], "0.2.0": [{"comment_text": "", "digests": {"md5": "32c08a4e69f7b642431b73a732c6c893", "sha256": "d8b33ec95400e5500ef70d4a83e2cbf9fdab74a4f0224113ede8cd280fa66106"}, "downloads": -1, "filename": "lexicon-0.2.0.tar.gz", "has_sig": false, "md5_digest": "32c08a4e69f7b642431b73a732c6c893", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 7180, "upload_time": "2013-03-16T01:29:37", "upload_time_iso_8601": "2013-03-16T01:29:37.084931Z", "url": "https://files.pythonhosted.org/packages/78/4d/8722328adeded539b642b8cc00afe57f118bc3b9236180a57ee2d96bc35f/lexicon-0.2.0.tar.gz", "yanked": false}], "1.0.0": [{"comment_text": "", "digests": {"md5": "06b2c0be9e62b2dd45713e2a1580101d", "sha256": "a0c74b52ebd53a6bdf34185b36ebfee46423d1138ef4a80ef406649a565938e6"}, "downloads": -1, "filename": "lexicon-1.0.0-py2.py3-none-any.whl", "has_sig": true, "md5_digest": "06b2c0be9e62b2dd45713e2a1580101d", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 7916, "upload_time": "2016-02-17T22:10:35", "upload_time_iso_8601": "2016-02-17T22:10:35.396287Z", "url": "https://files.pythonhosted.org/packages/90/bc/a82e3fa550aacb472b64bc75e1473b57371ab5590342ee86646c82d7bed9/lexicon-1.0.0-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "3458e3a6fa04cb53f860a835b295f7a0", "sha256": "1a2ed9d86142e2d2dfdb431ed434b2c8ae19a2ed6ca2cea07c75d123353dca3e"}, "downloads": -1, "filename": "lexicon-1.0.0.tar.gz", "has_sig": true, "md5_digest": "3458e3a6fa04cb53f860a835b295f7a0", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 7539, "upload_time": "2016-02-17T22:10:50", "upload_time_iso_8601": "2016-02-17T22:10:50.212081Z", "url": "https://files.pythonhosted.org/packages/05/00/70adc50cf69312cdd7dbff010062e6587b7951dd0dcd5c535b34e36c2d24/lexicon-1.0.0.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "06b2c0be9e62b2dd45713e2a1580101d", "sha256": "a0c74b52ebd53a6bdf34185b36ebfee46423d1138ef4a80ef406649a565938e6"}, "downloads": -1, "filename": "lexicon-1.0.0-py2.py3-none-any.whl", "has_sig": true, "md5_digest": "06b2c0be9e62b2dd45713e2a1580101d", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 7916, "upload_time": "2016-02-17T22:10:35", "upload_time_iso_8601": "2016-02-17T22:10:35.396287Z", "url": "https://files.pythonhosted.org/packages/90/bc/a82e3fa550aacb472b64bc75e1473b57371ab5590342ee86646c82d7bed9/lexicon-1.0.0-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "3458e3a6fa04cb53f860a835b295f7a0", "sha256": "1a2ed9d86142e2d2dfdb431ed434b2c8ae19a2ed6ca2cea07c75d123353dca3e"}, "downloads": -1, "filename": "lexicon-1.0.0.tar.gz", "has_sig": true, "md5_digest": "3458e3a6fa04cb53f860a835b295f7a0", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 7539, "upload_time": "2016-02-17T22:10:50", "upload_time_iso_8601": "2016-02-17T22:10:50.212081Z", "url": "https://files.pythonhosted.org/packages/05/00/70adc50cf69312cdd7dbff010062e6587b7951dd0dcd5c535b34e36c2d24/lexicon-1.0.0.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:46:50 2020"}