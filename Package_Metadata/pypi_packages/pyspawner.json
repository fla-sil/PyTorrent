{"info": {"author": "Adam Hooper", "author_email": "adam@adamhooper.com", "bugtrack_url": null, "classifiers": ["Development Status :: 4 - Beta", "Intended Audience :: Developers", "License :: OSI Approved :: MIT License", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.7", "Topic :: Software Development :: Libraries :: Python Modules"], "description": "Clone sandboxed Python processes quickly and securely.\n\nUsage\n=====\n\nCreate a ``pyspawner.Client`` that imports the \"common\" Python imports\nyour sandboxed code will run. (These ``import`` statements aren't sandboxed,\nso be sure you trust the Python modules.)\n\nThen call ``pyspawner.Client.spawn_child()`` each time you want to create\na new child. It will invoke the pyspawner's ``child_main`` function with the\ngiven arguments.\n\nHere's pseudo-code for invoking the pyspawner part::\n\n    import pyspawner\n\n    # pyspawner.Client() is slow; ideally, you'll just call it during startup.\n    with pyspawner.Client(\n        child_main=\"mymodule.main\",\n        environment={\"LC_ALL\": \"C.UTF-8\"},\n        preload_imports=[\"pandas\"],  # put all your slow imports here\n    ) as cloner:\n        # cloner.spawn_child() is fast; call it as many times as you like.\n        child_process: pyspawner.ChildProcess = cloner.spawn_child(\n            args=[\"arg1\", \"arg2\"],  # List of picklable Python objects\n            process_name=\"child-1\",\n            sandbox_config=pyspawner.SandboxConfig(\n                chroot_dir=Path(\"/path/to/chroot/dir\"),\n                network=pyspawner.NetworkConfig()\n            )\n        )\n\n        # child_process has .pid, .stdin, .stdout, .stderr.\n        # Read from its stdout and stderr, and then wait for it.\n\nFor each child, read from stdout and stderr until end-of-file; then wait() for\nthe process to exit. Reading from two pipes at once is a standard exercise in\nUNIX, so the minutae are left as an exercise. A safe approach:\n\n1. Register both stdout and stderr in a ``selectors.DefaultSelector``\n2. loop, calling ``selectors.BaseSelector.select()`` and reading from\n   whichever file descriptors have data. Unregister whichever file descriptors\n   reach EOF; and read but _ignore_ data past a predetermined buffer size. Kill\n   the child process if this is taking too long. (Keep reading after killing\n   the child to avoid deadlock.)\n3. Wait for the child process (using ``os.waitpid()``) to clean up its\n   system resources.\n\nSetting up your environment\n===========================\n\n[TODO link to big docs]\n\nYour system must have ``libcap.so.2`` installed.\n\nPyspawner relies on Linux's ``clone()`` system call to create child-process\ncontainers. If you're using pyspawner from a Docker container, subcontainer\nare disabled by default. Run Docker with\n``--seccomp-opt=/path/to/pyspawner/docker/pyspawner-seccomp-profile.json`` to\nallow creating subcontainers.\n\nBy default, sandboxed children cannot access the Internet. If you want to\nenable networking for child processes, ensure your process has the\n``CAP_NET_ADMIN`` capability. (``docker run --cap-add NET_ADMIN ...``).\nAlso, you'll need to configure NAT in the parent-process environment ...\nwhich is beyond the scope of this README. Finally, you may want to supply a\n``chroot_dir`` to give child processes a custom ``/etc/resolv.conf``.\n\nIdeally, sandboxed children would not be able to write anywhere on the main\nfilesystem. Unfortunately, the ``umount()`` and ``pivot_root()`` system calls\nare restricted in many environments. As a placeholder, you're encouraged to\nsupply a ``chroot_dir`` to provide an environment for your sandboxed child\ncode. ``chroot_dir`` must be in a separate filesystem from the root filesystem.\n(In the future, when the Linux container ecosystem evolves enough,\n``chroot_dir`` will make children unmount the root filesystem.) Again, chroot\nis beyond the scope of this README.\n\n\nDeveloping\n==========\n\nThe test suite depends on Docker. (Security tests involve temporary files\noutside of temporary directories, iptables rules and setuid-0 files.)\n\nRun ``./test.sh`` to test.\n\nTo add or fix features:\n\n1. Write a test in ``tests/`` that breaks.\n2. Write code in ``pyspawner/`` that makes the test pass.\n3. Submit a pull request.\n\n\nReleasing\n=========\n\n1. Run ``./test.sh`` and ``sphinx-build docs docs/build`` to check for errors.\n2. Write a new version in ``pyspawner/__init__.py``. Use semver -- e.g., ``1.2.3``.\n3. Write a ``CHANGELOG.rst`` entry.\n4. ``git commit``\n5. ``git tag VERSION`` (use semver with a ``v`` -- e.g., ``v1.2.3``)\n6. ``git push --tags && git push``\n7. ``python3 ./setup.py sdist``\n8. ``twine upload dist/*``\n\n\nLicense\n=======\n\nMIT. See ``LICENSE.txt``.", "description_content_type": "text/x-rst", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/CJWorkbench/pyspawner", "keywords": "", "license": "BSD", "maintainer": "", "maintainer_email": "", "name": "pyspawner", "package_url": "https://pypi.org/project/pyspawner/", "platform": "", "project_url": "https://pypi.org/project/pyspawner/", "project_urls": {"Homepage": "https://github.com/CJWorkbench/pyspawner"}, "release_url": "https://pypi.org/project/pyspawner/0.9.0/", "requires_dist": null, "requires_python": "", "summary": "Launch Python environments quickly, using Linux's clone() syscall.", "version": "0.9.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p>Clone sandboxed Python processes quickly and securely.</p>\n<div id=\"usage\">\n<h2>Usage</h2>\n<p>Create a <tt>pyspawner.Client</tt> that imports the \u201ccommon\u201d Python imports\nyour sandboxed code will run. (These <tt>import</tt> statements aren\u2019t sandboxed,\nso be sure you trust the Python modules.)</p>\n<p>Then call <tt>pyspawner.Client.spawn_child()</tt> each time you want to create\na new child. It will invoke the pyspawner\u2019s <tt>child_main</tt> function with the\ngiven arguments.</p>\n<p>Here\u2019s pseudo-code for invoking the pyspawner part:</p>\n<pre>import pyspawner\n\n# pyspawner.Client() is slow; ideally, you'll just call it during startup.\nwith pyspawner.Client(\n    child_main=\"mymodule.main\",\n    environment={\"LC_ALL\": \"C.UTF-8\"},\n    preload_imports=[\"pandas\"],  # put all your slow imports here\n) as cloner:\n    # cloner.spawn_child() is fast; call it as many times as you like.\n    child_process: pyspawner.ChildProcess = cloner.spawn_child(\n        args=[\"arg1\", \"arg2\"],  # List of picklable Python objects\n        process_name=\"child-1\",\n        sandbox_config=pyspawner.SandboxConfig(\n            chroot_dir=Path(\"/path/to/chroot/dir\"),\n            network=pyspawner.NetworkConfig()\n        )\n    )\n\n    # child_process has .pid, .stdin, .stdout, .stderr.\n    # Read from its stdout and stderr, and then wait for it.\n</pre>\n<p>For each child, read from stdout and stderr until end-of-file; then wait() for\nthe process to exit. Reading from two pipes at once is a standard exercise in\nUNIX, so the minutae are left as an exercise. A safe approach:</p>\n<ol>\n<li>Register both stdout and stderr in a <tt>selectors.DefaultSelector</tt></li>\n<li>loop, calling <tt>selectors.BaseSelector.select()</tt> and reading from\nwhichever file descriptors have data. Unregister whichever file descriptors\nreach EOF; and read but _ignore_ data past a predetermined buffer size. Kill\nthe child process if this is taking too long. (Keep reading after killing\nthe child to avoid deadlock.)</li>\n<li>Wait for the child process (using <tt>os.waitpid()</tt>) to clean up its\nsystem resources.</li>\n</ol>\n</div>\n<div id=\"setting-up-your-environment\">\n<h2>Setting up your environment</h2>\n<p>[TODO link to big docs]</p>\n<p>Your system must have <tt>libcap.so.2</tt> installed.</p>\n<p>Pyspawner relies on Linux\u2019s <tt>clone()</tt> system call to create child-process\ncontainers. If you\u2019re using pyspawner from a Docker container, subcontainer\nare disabled by default. Run Docker with\n<tt><span class=\"pre\">--seccomp-opt=/path/to/pyspawner/docker/pyspawner-seccomp-profile.json</span></tt> to\nallow creating subcontainers.</p>\n<p>By default, sandboxed children cannot access the Internet. If you want to\nenable networking for child processes, ensure your process has the\n<tt>CAP_NET_ADMIN</tt> capability. (<tt>docker run <span class=\"pre\">--cap-add</span> NET_ADMIN ...</tt>).\nAlso, you\u2019ll need to configure NAT in the parent-process environment \u2026\nwhich is beyond the scope of this README. Finally, you may want to supply a\n<tt>chroot_dir</tt> to give child processes a custom <tt>/etc/resolv.conf</tt>.</p>\n<p>Ideally, sandboxed children would not be able to write anywhere on the main\nfilesystem. Unfortunately, the <tt>umount()</tt> and <tt>pivot_root()</tt> system calls\nare restricted in many environments. As a placeholder, you\u2019re encouraged to\nsupply a <tt>chroot_dir</tt> to provide an environment for your sandboxed child\ncode. <tt>chroot_dir</tt> must be in a separate filesystem from the root filesystem.\n(In the future, when the Linux container ecosystem evolves enough,\n<tt>chroot_dir</tt> will make children unmount the root filesystem.) Again, chroot\nis beyond the scope of this README.</p>\n</div>\n<div id=\"developing\">\n<h2>Developing</h2>\n<p>The test suite depends on Docker. (Security tests involve temporary files\noutside of temporary directories, iptables rules and setuid-0 files.)</p>\n<p>Run <tt>./test.sh</tt> to test.</p>\n<p>To add or fix features:</p>\n<ol>\n<li>Write a test in <tt>tests/</tt> that breaks.</li>\n<li>Write code in <tt>pyspawner/</tt> that makes the test pass.</li>\n<li>Submit a pull request.</li>\n</ol>\n</div>\n<div id=\"releasing\">\n<h2>Releasing</h2>\n<ol>\n<li>Run <tt>./test.sh</tt> and <tt><span class=\"pre\">sphinx-build</span> docs docs/build</tt> to check for errors.</li>\n<li>Write a new version in <tt>pyspawner/__init__.py</tt>. Use semver \u2013 e.g., <tt>1.2.3</tt>.</li>\n<li>Write a <tt>CHANGELOG.rst</tt> entry.</li>\n<li><tt>git commit</tt></li>\n<li><tt>git tag VERSION</tt> (use semver with a <tt>v</tt> \u2013 e.g., <tt>v1.2.3</tt>)</li>\n<li><tt>git push <span class=\"pre\">--tags</span> &amp;&amp; git push</tt></li>\n<li><tt>python3 ./setup.py sdist</tt></li>\n<li><tt>twine upload dist/*</tt></li>\n</ol>\n</div>\n<div id=\"license\">\n<h2>License</h2>\n<p>MIT. See <tt>LICENSE.txt</tt>.</p>\n</div>\n\n          </div>"}, "last_serial": 6158983, "releases": {"0.9.0": [{"comment_text": "", "digests": {"md5": "0f9aef22715a71f8fa83850671d0bdf1", "sha256": "a0f4466325b2a5d0839470b30fba6401a995335a3d9e75ba077ec34d6200cad7"}, "downloads": -1, "filename": "pyspawner-0.9.0.tar.gz", "has_sig": false, "md5_digest": "0f9aef22715a71f8fa83850671d0bdf1", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 23048, "upload_time": "2019-11-18T23:38:42", "upload_time_iso_8601": "2019-11-18T23:38:42.350186Z", "url": "https://files.pythonhosted.org/packages/4a/1e/3f6c6f6a22dbe7d2210f54a743fb979e1b90a48b9d15111deeffaa4c669d/pyspawner-0.9.0.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "0f9aef22715a71f8fa83850671d0bdf1", "sha256": "a0f4466325b2a5d0839470b30fba6401a995335a3d9e75ba077ec34d6200cad7"}, "downloads": -1, "filename": "pyspawner-0.9.0.tar.gz", "has_sig": false, "md5_digest": "0f9aef22715a71f8fa83850671d0bdf1", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 23048, "upload_time": "2019-11-18T23:38:42", "upload_time_iso_8601": "2019-11-18T23:38:42.350186Z", "url": "https://files.pythonhosted.org/packages/4a/1e/3f6c6f6a22dbe7d2210f54a743fb979e1b90a48b9d15111deeffaa4c669d/pyspawner-0.9.0.tar.gz", "yanked": false}], "timestamp": "Fri May  8 02:56:17 2020"}