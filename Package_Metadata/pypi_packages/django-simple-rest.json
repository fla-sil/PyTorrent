{"info": {"author": "Christopher Roach", "author_email": "croach@freshplum.com", "bugtrack_url": null, "classifiers": ["Development Status :: 3 - Alpha", "Environment :: Web Environment", "Framework :: Django", "Intended Audience :: Developers", "License :: OSI Approved :: MIT License", "Operating System :: OS Independent", "Programming Language :: Python :: 2.6", "Programming Language :: Python :: 2.7", "Topic :: Internet :: WWW/HTTP", "Topic :: Internet :: WWW/HTTP :: Dynamic Content", "Topic :: Software Development :: Libraries :: Python Modules"], "description": "##################\nDjango Simple REST\n##################\n\nDjango Simple REST is a very light framework that provides only the bare bones basics of what is needed to create RESTful APIs on top of Django.\n\n############\nInstallation\n############\n\n1. Install using pip or easy_install:\n\n   - ``pip install django-simple-rest`` or ``easy_install install django-simple-rest``\n\n2. Add the package to the list of installed apps (optional):\n\n   - ``INSTALLED_APPS += ['simple-rest']``\n   - This step is optional and is only needed if you plan on using the custom django command(s).\n\n###########################\nWhy Another REST Framework?\n###########################\n\nThat's a great question, and the simplest answer to it is that this really isn't a framework at all, but let me explain a bit further.\n\nWith the introduction of class-based views in version 1.3 of Django, the web framework has nearly everything it needs built in to create RESTful APIs, but just a few things are missing. This \"framework\" supplies those last few things.\n\nThink of Simple REST as the code that you would have written to get class-based views working properly as a platform for RESTful API development. Looked at from that view, you start to understand what Simple REST1 is; it's a collection of code that makes it possible to create RESTful APIs with Django's class-based views, nothing more and nothing less.\n\nIf you like creating your API by hand, laboring over every last URL, then this is the framework for you. If you want something a little more full featured that handles creating large swaths of your API from Django models and things like that, let me suggest a few excellent frameworks: `Tastypie`_, `Piston`_, and `Django REST`_.\n\n################\nHow do I use it?\n################\n\nThere's nothing to it, it works just like you'd expect it to---assuming you're familiar with Django's `class based views`_. Before we get started though, let's create a base project and application for us to play around with.\n\n####################\nSample Project Setup\n####################\n\nThe code in the rest of this document will assume that you're using Django 1.4 or greater (you can follow along using Django 1.3, but your directory structure will be slightly different form the one below) and that you've created a project called ``simple_rest_example`` and an application within it called ``phonebook``.\n\nOnce you've created your sample project and application, you'll need to add a new URLconf to the phonebook application where we will add all of our routes for the duration of this tutorial. Then, update the URLconf in the ``simple_rest_example`` folder to include the URLconf you've just created. This will allow us to do all of our work in the phonebook app from here on out. The ``urls.py`` file in your ``simple_rest_example`` folder should now look like the following::\n\n    # =============================\n    # simple_rest_example/views.py\n    # =============================\n\n    from django.conf.urls import patterns, include, url\n\n    urlpatterns = patterns('',\n        url(r'^phonebook/', include('phonebook.urls')),\n    )\n\nIf you've set everything up correctly, you should have a directory structure that matches the one shown below::\n\n    simple_rest_example\n            |\n            |___ simple_rest_sample\n            |           |___ __init__.py\n            |           |___ settings.py\n            |           |___ urls.py\n            |           |___ wsgi.py\n            |\n            |___ phonebook\n            |       |\n            |       |___ __init__.py\n            |       |___ models.py\n            |       |___ tests.py\n            |       |___ urls.py\n            |       |___ views.py\n            |\n            |___ manage.py\n\nFinally, we're going to create a new model class called ``Contact`` and create our database to hold all of the contacts in our phonebook. Open up ``phonebook/models.py`` and update it to match the following::\n\n    # =====================\n    # phonebook/models.py\n    # =====================\n\n    from django.db import models\n\n    class Contact(models.Model):\n        fname = models.CharField(max_length=30)\n        lname = models.CharField(max_length=30)\n        phone_number = models.CharField(max_length=12)\n\nOnce you've added a new model, update the ``settings.py`` file in the ``simple_rest_example`` directory to use a sqlite database named phonebook.db and run the ``manage.py syncdb`` command to create the database. Make sure to add an administrator account so that we'll have something to use later on when discussing the authentication options provided by the Simple REST framework.\n\n###################\nCreating a Resource\n###################\n\nNow that you've got your development environment set up properly, let's take a look at an example of how to use the Simple REST framework to create a dead simple phonebook application.\n\nThe sample code below shows one example of how we could create a simple resource for managing lists of contacts::\n\n    # ====================\n    # phonebook/views.py\n    # ====================\n\n    from django.http import HttpResponse\n    from django.core import serializers\n\n    from simple_rest import Resource\n\n    from .models import Contact\n\n\n    class Contacts(Resource):\n\n        def get(self, request, contact_id=None, **kwargs):\n            json_serializer = serializers.get_serializer('json')()\n            if contact_id:\n                contacts = json_serializer.serialize(Contact.objects.filter(pk=contact_id))\n            else:\n                contacts = json_serializer.serialize(Contact.objects.all())\n            return HttpResponse(contacts, content_type='application/json', status=200)\n\n        def post(self, request, *args, **kwargs):\n            Contact.objects.create(\n                fname=request.POST.get('fname'),\n                lname=request.POST.get('lname'),\n                phone_number=request.POST.get('phone_number'))\n            return HttpResponse(status=201)\n\n        def delete(self, request, contact_id):\n            contact = Contact.objects.get(pk=contact_id)\n            contact.delete()\n            return HttpResponse(status=200)\n\nIn the example code above, we imported the ``Resource`` class, which simply inherits from Django's ``View`` class and provides the extra sauce to get all of the HTTP methods working properly. Then, we create a new class that inherits from the ``Resource`` class, and we add a function for each HTTP method that we want to handle.The only requirement is that the function name must match the HTTP method name and be in all lower case letters, so ``get`` for a GET call and so forth.\n\nNotice that in the ``post`` method, the data for the message body of the request can be accessed through the ``request.POST`` ``QueryDict`` object. Since all exsiting browsers can only handle GET and POST requests, having ``QueryDict``s for GET and POST were all that were needed in the past and so those were all that Django has historically provided. However, with a RESTful API, the server can receive requests using any HTTP method. As a result, the message body for a request can be found in the corresponding ``QueryDict`` on the ``request`` object. For example, if a PUT request is made, the message body data can be accessed through the ``request.PUT`` ``QueryDict``.\n\nConsidering that browsers only support the GET and POST methods, the Simple REST framework also provides an HTTP method override that can be used to make it possible for a typical website to use a RESTful backend. To override the HTTP method, send the attribute ``_method``, either in the querystring or in the message body, set to the HTTP method you want the request to be treated as.\n\nOne issue that can arise when allowing the user to use the ``_method`` option is that the data may not always be in the place you expect it to be. For example, let's assume that you've received a POST request to create a new contact. In this scenario, all of the data can be found in the ``request.POST`` ``QueryDict`` object as you would expect. However, if you were to send a GET request with all of the data in the querystring and set the ``_method`` to POST, our ``post`` method in the example above would throw an exception. The reason is that request would be treated as a POST request, but the``request.POST`` ``QueryDict`` object would be empty since the original request was a GET and all of its data would then be found within the ``request.GET`` ``QueryDict``. To make your code more flexible when allowing this option, you should consider using the ``request.REQUEST`` ``QueryDict`` instead to get all of the data in the request since Django basically compiles all of the data sent into this single object.\n\nNow, let's see how to hook up our resource::\n\n    # ===================\n    # phonebook/urls.py\n    # ===================\n\n    from django.conf.urls import patterns, include, url\n\n    from .views import Contacts\n\n    urlpatterns = patterns('',\n        # Allow access to the contacts resource collection\n        url(r'^contacts/?$', Contacts.as_view()),\n\n        # Allow access to a single contact resource\n        url(r'^contacts/(?P<contact_id>[0-9]+)/?$', Contacts.as_view()),\n    )\n\nThe sample ``urls.py`` above shows exactly how we would go about creating the URL patterns for our example resource. Again, if you're familiar with Django class based views, there should be no surprises here.\n\n##############\nAuthentication\n##############\n\nSo what about authentication? Well, you could simply use the ``method_decorator`` function as the `Django docs suggest`_ to decorate each method in your resource with the appropriate authentication decorator. Assuming you want the entire resource protected, you could also decorate the result of the call to ``as_view`` in the URLconf. Both of these options are completely valid and you can feel free to use them, this framework does provide another option, however.\n\nIn the ``simple_rest.auth.decorators`` module you'll find decorators there that you can use to add authentication to your resources. Let's take a look at a few examples using our sample code from above::\n\n    # ====================\n    # phonebook/views.py\n    # ====================\n\n    from django.http import HttpResponse\n    from django.core import serializers\n\n    from simple_rest import Resource\n    from simple_rest.auth.decorators import login_required, admin_required\n\n    from .models import Contact\n\n\n    class Contacts(Resource):\n\n        def get(self, request, contact_id=None, **kwargs):\n            json_serializer = serializers.get_serializer('json')()\n            if contact_id:\n                contacts = json_serializer.serialize(Contact.objects.filter(pk=contact_id))\n            else:\n                contacts = json_serializer.serialize(Contact.objects.all())\n            return HttpResponse(contacts, content_type='application/json', status=200)\n\n        @login_required\n        def post(self, request, *args, **kwargs):\n            Contact.objects.create(\n                fname=request.POST.get('fname'),\n                lname=request.POST.get('lname'),\n                phone_number=request.POST.get('phone_number'))\n            return HttpResponse(status=201)\n\n        @admin_required\n        def delete(self, request, contact_id):\n            contact = Contact.objects.get(pk=contact_id)\n            contact.delete()\n            return HttpResponse(status=200)\n\nAssuming that we don't mind if anyone sees our collection of contacts, we can leave ``get`` method as is, but let's assume that we have strict requirements for who can add and delete contacts. Assuming that only registered users can add contacts, we add the ``login_required`` decorator to the ``post`` method. We don't mind if any our members add new contacts, but we don't want a contact to be accidentally deleted from our database, so let's decorate that one differently with the ``admin_required`` decorator. ``admin_required`` simply makes sure that the user is logged in and is also a super user before they will be granted access to the decorated view method.\n\nNow, this can get a bit tedious if we have lots of resources and they all tend to have the same authentication requirements. To make a little less tedious, the authentication decorators work on both classes and methods. In the example below we're adding a superuser requirement to every method offered by the resource simply by decorating the resource class::\n\n    # ====================\n    # phonebook/views.py\n    # ====================\n\n    from django.http import HttpResponse\n    from django.core import serializers\n\n    from simple_rest import Resource\n    from simple_rest.auth.decorators import admin_required\n\n    from .models import Contact\n\n\n    @admin_required\n    class Contacts(Resource):\n\n        def get(self, request, contact_id=None, **kwargs):\n            json_serializer = serializers.get_serializer('json')()\n            if contact_id:\n                contacts = json_serializer.serialize(Contact.objects.filter(pk=contact_id))\n            else:\n                contacts = json_serializer.serialize(Contact.objects.all())\n            return HttpResponse(contacts, content_type='application/json', status=200)\n\n        def post(self, request, *args, **kwargs):\n            Contact.objects.create(\n                fname=request.POST.get('fname'),\n                lname=request.POST.get('lname'),\n                phone_number=request.POST.get('phone_number'))\n            return HttpResponse(status=201)\n\n        def delete(self, request, contact_id):\n            contact = Contact.objects.get(pk=contact_id)\n            contact.delete()\n            return HttpResponse(status=200)\n\nBefore we leave the topic of authentication decorators there are two more items to take a look at.\n\nFirst, when using the framework's authentication decorators, the correct RESTful response is returned whenever authentication fails. The typical Django authentication decorators will try to redirect the user to the login page. While this is great when you're on a webpage, when accessing the resource from any other type of client, receiving a 401 (Unauthorized) is the preferred response and the one that is returned when using Simple REST authentication decorators. For that reason alone, you should prefer the Simple REST authentication decorators over Django's built in ones when creating a RESTful API.\n\nThe other item to discuss is the ``signature_required`` authentication decorator. Many APIs use a secure signature to identify and the Simple REST framework provides an authentication decorator that you can use to add that functionality to your resources. The ``signature_required`` decorator will expect that an `HMAC`_, as defined by `RFC 2104`_, is sent with the HTTP request in order to authenticate the user. An HMAC is built around a user's secret key and so there needs to be a way for the ``signature_required`` decorator to get that secret key and that is done by providing the decorator with a function that takes a Django `HttpRequest`_ object and any number of positional and keyword arguments as defined by the URLconf. Let's take a look at an example of using the ``signature_required`` decorator with our sample resource code::\n\n    # ====================\n    # phonebook/views.py\n    # ====================\n\n    from django.http import HttpResponse\n    from django.core import serializers\n\n    from simple_rest import Resource\n    from simple_rest.auth.decorators import signature_required\n\n    from .models import Contact\n\n\n    def secret_key(request, *args, **kwargs):\n        return 'test'\n\n    @signature_required(secret_key)\n    class Contacts(Resource):\n\n        def get(self, request, contact_id=None, **kwargs):\n            json_serializer = serializers.get_serializer('json')()\n            if contact_id:\n                contacts = json_serializer.serialize(Contact.objects.filter(pk=contact_id))\n            else:\n                contacts = json_serializer.serialize(Contact.objects.all())\n            return HttpResponse(contacts, content_type='application/json', status=200)\n\n        def post(self, request, *args, **kwargs):\n            Contact.objects.create(\n                fname=request.POST.get('fname'),\n                lname=request.POST.get('lname'),\n                phone_number=request.POST.get('phone_number'))\n            return HttpResponse(status=201)\n\n        def delete(self, request, contact_id):\n            contact = Contact.objects.get(pk=contact_id)\n            contact.delete()\n            return HttpResponse(status=200)\n\nThe ``signature_required`` decorator takes one argument, a function that, when called with an HttpRequest object and any number of positional and keyword arguments as defined by the URLconf entry for the resource, will return a string representing the secret key for the user making the request. In the example above, we created a function that returns the string 'test' no matter what arguments are passed into the function. Obviously, you don't want to use a secret key function like this in production, but for our purposes it will suffice.\n\nTo test out the ``signature_required`` decorator, you can hit any of the URLs for the Contacts resource with a ``t`` value representing a UTC POSIX timestamp for the current time and a ``sig`` value representing the HMAC signature generated from the data being sent, the timestamp, and the secret key (in this case, 'test'). If you've added 'simple_rest' to your list of ``INSTALLED_APPS``, you can use the handy ``urlencode`` command to calculate the signature and timestamp for testing your resources. The command line below shows how to generate the timestamp and signature values for a simple GET request. To test the GET call, just enter the line below into your command line and copy and paste the response to the querystring part of the URL::\n\n    % manage.py urlencode --secret-key=test\n\nTo URL encode the request body as well, just include each piece of data as a key=value pair in the call to the ``urlencode`` command. As an example of how to do so, let's test the ``POST`` call. Run the following command in your terminal and copy the results into either the request body or the querystring portion of the URL::\n\n    % manage.py urlencode --secret-key fname=Winston lname=Smith phone_number=555-555-5555\n\nSimple REST provides one more decorator that's sort of a mashup of two other decorators. The decorator ``auth_required`` works in the same manner as the ``signature_required`` (meaning that it takes a function that returns a secret key) but it requires that the user is either logged in or has a valid signature before granting them access to the resource.\n\nFinally, you can create your own authentication decorators with relative ease. The Simple REST framework provides two functions to help out with this task. First, the ``request_passes_test`` function can be used to create a new decorator function. Then the ``wrap_object`` function can be used to properly decorate either an entire class or a specific method within. The code below shows a sample of how you would create a decorator that makes sure a user has the proper permission to access a resource::\n\n    from simple_rest.auth.decorators import request_passes_test\n    from simple_rest.utils.decorators import wrap_object\n\n\n    def has_permission(request, *args, **kwargs):\n        return False # Make sure the user has the proper permission here\n\n    def permission_required(obj):\n        decorator = request_passes_test(has_permission,\n            message=\"You don't have permission to access this resource\",\n            status=403\n        )\n        return wrap_object(obj, decorator)\n\n\n###############\nForm Validation\n###############\n\nIf you want to use a form to validate the data in a REST request (e.g., a POST to create a new resource) you can run into some problems using Django's ModelForm class. Specifically, let's assume that you have a model that has several optional attributes with default values specified. If you send a request to create a new instance of this class but only include data for a handful of the optional attributes, you'd expect that the form object you create would not fail validation since saving the object would mean that the new record would simply end up with the default values for the missing attributes. This is, however, not the case with Django's ModelForm class. It is expecting to see all of the data in every request and will fail if any is missing.\n\nTo solve this issue, the Simple REST framework provides a ``ModelForm`` class in ``simple_rest.forms`` that inherits from Django's ``ModelForm`` and initializes the incoming request with the default values from the underlying model object for any missing attributes. This allows the form validation to work correctly and for the new object to be saved with only a portion of the full set of attributes sent within the request. To use the class, simply import it instead of the normal Django ``ModelForm`` and have your form class inherit from it instead of Django's.\n\nTo give it a try, let's add another field to the ``Contact`` model class in ``phonebook/models.py`` to hold an honorific for a contact. We'll make this field optional and make the default title be '(no title)'. With these new changes, the ``models.py`` file should match the one listed below::\n\n    # ====================\n    # phonebook/models.py\n    # ====================\n\n    from django.db import models\n\n    class Contact(models.Model):\n        title = models.CharField(max_length=10, default='(no title)')\n        fname = models.CharField(max_length=30)\n        lname = models.CharField(max_length=30)\n        phone_number = models.CharField(max_length=12)\n\nOnce, you've updated the ``models.py`` file, either delete and rerun ``syncdb`` or add the new column to the phonebook_contact table by hand. Then, create a new form class called ``ContactForm`` in the ``phonebook/views.py`` file and set its model to ``Contact``. Then you can remove the code to create a new contact in the ``post`` method and replace it with code that uses the new ``Contactform`` class. The result should be similar to the following::\n\n    # ====================\n    # phonebook/views.py\n    # ====================\n\n    from django.http import HttpResponse\n    from django.core import serializers\n\n    from simple_rest import Resource\n    from simple_rest.auth.decorators import signature_required\n    from simple_rest.forms import ModelForm\n\n    from .models import Contact\n\n\n    def secret_key(request, *args, **kwargs):\n        return 'test'\n\n\n    class ContactForm(ModelForm):\n        class Meta:\n            model = Contact\n\n\n    @signature_required(secret_key)\n    class Contacts(Resource):\n\n        def get(self, request, contact_id=None, **kwargs):\n            json_serializer = serializers.get_serializer('json')()\n            if contact_id:\n                contacts = json_serializer.serialize(Contact.objects.filter(pk=contact_id))\n            else:\n                contacts = json_serializer.serialize(Contact.objects.all())\n            return HttpResponse(contacts, content_type='application/json', status=200)\n\n        def post(self, request, *args, **kwargs):\n            form = ContactForm(request.POST)\n            if not form.is_valid():\n                return HttpResponse(status=409)\n            form.save()\n            return HttpResponse(status=201)\n\n        def delete(self, request, contact_id):\n            contact = Contact.objects.get(pk=contact_id)\n            contact.delete()\n            return HttpResponse(status=200)\n\n\n###################\nContent Negotiation\n###################\n\nA key factor to having a truly RESTful API is the decoupling of your resources from their representation. In other words, whether or not a resource is delivered as XML or JSON shouldn't be part of the resource itself. This is where `content negotiation`_ comes into play. It provides a standardized way for a single URI to serve a resource while still allowing the user to request several different representations of that resource. Content negotiation is part of the HTTP specification and the mechanism it provides the client for requesting a representation is through the Accept header. In the Accept header the client gives a list of acceptable representations and the server works out the best possible representation of the resource to deliver according to what is available on the server and desired representations requested.\n\nThe Simple Rest framework provides a mechanism by which you can add content negotiation to your resources. This functionality is provided in the `RESTfulResponse`_ class. The ``RESTfulResponse`` class is an implementation of the method described by James Bennett in his article \"`Another take on content negotiation`_\". The way it works is simple, create an instance of the class and use it as a decorator on your resource. The rest of this section will take a look at a few examples to show the different options available to you when using the ``RESTfulResonse`` class to provide multiple representations of your resource.\n\nThe first example below shows the absolute simplest way to use the ``RESTfulResponse`` class. By default, the RESTfulResponse provides JSON, HTML, and plain text formats. JSON is one of the most popular resource representations (arguably the most popular, at least for APIs being created today) and so the ``RESTfulResponse`` class provides support for it right out of the box. The HTML format is mainly provided to make it easy to view the data in a browser and also to allow the `Django Debug Toolbar`_ to function properly when testing RESTful APIs. The HTML representation will format the data as JSON and, if you have `pygments`_ installed, the data will syntax highlighted as well.\n\nTo provide a JSON representation of your resource using the RESTfulResponse class, you simply create an instance of it and decorate your resource just like the example shows below::\n\n    # ====================\n    # phonebook/views.py\n    # ====================\n\n    from django.http import HttpResponse\n\n    from simple_rest import Resource\n    from simple_rest.auth.decorators import signature_required\n    from simple_rest.forms import ModelForm\n    from simple_rest.response import RESTfulResponse\n\n    from .models import Contact\n\n\n    def secret_key(request, *args, **kwargs):\n        return 'test'\n\n\n    class ContactForm(ModelForm):\n        class Meta:\n            model = Contact\n\n\n    @signature_required(secret_key)\n    class Contacts(Resource):\n\n        @RESTfulResponse()\n        def get(self, request, contact_id=None, **kwargs):\n            if contact_id:\n                contacts = Contact.objects.filter(pk=contact_id)\n            else:\n                contacts = Contact.objects.all()\n            return contacts\n\n        def post(self, request, *args, **kwargs):\n            form = ContactForm(request.POST)\n            if not form.is_valid():\n                return HttpResponse(status=409)\n            form.save()\n            return HttpResponse(status=201)\n\n        def delete(self, request, contact_id):\n            contact = Contact.objects.get(pk=contact_id)\n            contact.delete()\n            return HttpResponse(status=200)\n\nNotice that in the ``get`` method above we are no longer returning an HttpResponse object, instead we return the ``QuerySet`` of the contacts that matched the GET request. When using content negotiation on your resources, simple serializable python objects are the typical response. If you return an HttpResponse object it will simply bypass the content negotiation and just return the response object as is.\n\nIn the example above we only decorated the ``get`` method, but an instance of RESTfulResponse works just as the authentication decorators we saw earlier in that they can be used to decorate methods or full classes. In the next example we decorate the entire resource and, though we can continue to return an HttpResponse object, if we want all of our methods to enjoy the benefits provided by the RESTfulResponse decorator, we need to change what they return from an HttpResponse object to a serializable python object. The code below shows how you can do that for the simple example we saw above::\n\n    # ====================\n    # phonebook/views.py\n    # ====================\n\n    from django.http import HttpResponse\n\n    from simple_rest import Resource\n    from simple_rest.auth.decorators import signature_required\n    from simple_rest.forms import ModelForm\n    from simple_rest.response import RESTfulResponse\n\n    from .models import Contact\n\n\n    def secret_key(request, *args, **kwargs):\n        return 'test'\n\n\n    class ContactForm(ModelForm):\n        class Meta:\n            model = Contact\n\n\n    @RESTfulResponse()\n    @signature_required(secret_key)\n    class Contacts(Resource):\n\n        def get(self, request, contact_id=None, **kwargs):\n            if contact_id:\n                contacts = Contact.objects.filter(pk=contact_id)\n            else:\n                contacts = Contact.objects.all()\n            return contacts\n\n        def post(self, request, *args, **kwargs):\n            form = ContactForm(request.POST)\n            if not form.is_valid():\n                return HttpResponse(status=409)\n            form.save()\n            return None, 201\n\n        def delete(self, request, contact_id):\n            contact = Contact.objects.get(pk=contact_id)\n            contact.delete()\n            return None, 200\n\nOne thing to notice in the code above is that the ``post`` method returns a tuple. That's because when we use the ``RESTfulResponse`` decorator it's expected that we are returning a tuple the first element of which is the object to be serialized and returned to the client. The second (optional) element of the response tuple is the status code of the response. If only a serializable object is returned (as we've done in the ``get`` method), the default status code of 200 (OK) is used. If, on the other hand, you'd like to return an empty response with just the HTTP Response Code set to signify the success or failure of the operation, you can simply return ``None`` for the data object and the desired status code as the second element in the tuple. In the ``post`` method in the code sample above we see an example of this. Since performing a POST on our resource creates a new instance of that resource we want to return a 201 (Created) signifying that a new resource was succesfully created and the response body can be empty.\n\nFinally, content negotiation doesn't really do much if you only provide a single representation of your resource. The question then becomes: how do we provide more than just the default JSON representation? The answer is that we pass into the ``RESTfulResponse`` constructor a dict that maps mime types to either a python callable that can be called on the data object to transform it into the designated representation or a string that points to a template that will be used to produce the desired representation. In this example we'll be using a template to transform the resource into an XML representation.\n\nThe first step is to create our XML template. Create a new folder in the phonebook application's directory called ``templates`` and add a file called ``phonebook.xml`` to it. Make sure that the ``django.template.loaders.app_directories.Loader`` line is included, and uncommented, in the ``TEMPLATE_LOADERS`` tuple in ``simple_rest_example/settings.py``. This will ensure that Django will pick up templates within the apps that you've registered in the ``INSTALLED_APPS`` tuple.\n\nNow we just need to add some XML/code to turn our response data into proper XML. The ``RESTfulResponse`` decorator will automatically provide any data returned from the resource to the template under the name ``context``. In the exmaple code below we sort the contacts in the ``context`` variable according to last name and return a contact element that has fname, lname, phone_number, and title subelements::\n\n    <?xml version=\"1.0\"?>\n    {% with contacts=context.values|dictsort:\"lname\" %}\n    <phonebook>\n      {% for contact in contacts %}\n          <contact>\n            <fname>{{ contact.fname }}</fname>\n            <lname>{{ contact.lname }}</lname>\n            <phone_number>{{ contact.phone_number }}</phone_number>\n            <title>{{ contact.title }}</title>\n          </contact>\n      {% endfor %}\n    </phonebook>\n    {% endwith %}\n\nOnce we've got the template created, we just need to create a new RESTfulResponse decorator with the correct mime type mapped to the template. The code below shows how to do that by passing a dictionary that maps supported mimetypes to either a function or a template filename. The RESTFulResponse class also inherits from the `collections.MutableMapping <http://bit.ly/TXcyXV>`_ Abstract Base Class, so you could have just as easily added the mimetype to function/template mapping like you would with any ordinary python dict. Also keep in mind that JSON, HTML, and plain text are provided by default, so our mime type mapping dict doesn't need to contain an entry for any of those---unless you want to override the default behavior::\n\n    # ====================\n    # phonebook/views.py\n    # ====================\n\n    from django.http import HttpResponse\n\n    from simple_rest import Resource\n    from simple_rest.auth.decorators import signature_required\n    from simple_rest.forms import ModelForm\n    from simple_rest.response import RESTfulResponse\n\n    from .models import Contact\n\n\n    def secret_key(request, *args, **kwargs):\n        return 'test'\n\n    json_or_xml = RESTfulResponse({'application/xml': 'phonebook.xml'})\n    # Since RESTfulResponse inherits from collections.MutableMapping, we could\n    # have also done the following instead of passing a dict to the constructor\n    # json_or_xml = RESTfulResponse()\n    # json_or_xml['application/xml'] = 'phonebook.xml'\n\n\n    class ContactForm(ModelForm):\n        class Meta:\n            model = Contact\n\n\n    @json_or_xml\n    @signature_required(secret_key)\n    class Contacts(Resource):\n\n        def get(self, request, contact_id=None, **kwargs):\n            if contact_id:\n                contacts = Contact.objects.filter(pk=contact_id)\n            else:\n                contacts = Contact.objects.all()\n            return contacts\n\n        def post(self, request, *args, **kwargs):\n            form = ContactForm(request.POST)\n            if not form.is_valid():\n                return HttpResponse(status=409)\n            form.save()\n            return None, 201\n\n        def delete(self, request, contact_id):\n            contact = Contact.objects.get(pk=contact_id)\n            contact.delete()\n            return None, 200\n\nWith the new changes in place, you can get either XML or JSON just by changing the Accept header in your request. The only problem with this scenario though is that you can't always simply change the Accept header. For example, a simple HTML form (no JavaScript) will always send a request with Accept headers set to HTML (or XHTML) and probably some form of XML. If you want to specify the format of the response, and you don't have access to the Accept header, you can either append a file extension to the URL or pass a `_format` attribute in the request's querystring or message body. If either a file extension or an override attribute is used, the response format will be determined using it, otherwise, if neither is present, it will fallback on the Accept header to determine the requested format.\n\nUsing the `_format` override attribute is easy, simply add the attribute to the HTTP call in either the querystring or the message body and it just works. there's absolutely nothing that needs to be done on the backend to get the override attribute working. If, on the other hand, you want to use the file extension override, you will need to alter your URL patterns to accept an optional named pattern. The name you should use for the optional file extenstion is the same as the name for the override attribute. The example below shows the newly altered ``phonebook/urls.py`` file with the optional file extension::\n\n    # ===================\n    # phonebook/urls.py\n    # ===================\n\n    from django.conf.urls import patterns, include, url\n\n    from .views import Contacts\n\n    urlpatterns = patterns('',\n        # Allow access to the contacts resource collection\n        url(r'^contacts(\\.(?P<_format>[a-zA-Z]+))?/?$', Contacts.as_view()),\n\n        # # Allow access to a single contact resource\n        url(r'^contacts/(?P<contact_id>[0-9]+)(\\.(?P<_format>[a-zA-Z]+))?/?$',\n            Contacts.as_view()),\n    )\n\nKeep in mind that the example above will be passing a new keyword argument into your view methods, so you'll need to make sure that the last parameter on your view methods is the catch all parameter for keyword arguments (`**kwargs`).\n\nWith the addition above made to the URLconf, you can now request differnt response formats using either a file extension on the URL, a `_format` attribute in querystring or message body, or by specifying the desired format in the Accept header. The order of precedence is override attribute, then file extension, and finally the HTTP Accept header.\n\n\n.. _Tastypie: http://tastypieapi.org/\n.. _Piston: https://bitbucket.org/jespern/django-piston/wiki/Home\n.. _Django REST: http://django-rest-framework.org/\n.. _class based views: https://docs.djangoproject.com/en/dev/topics/class-based-views/\n.. _Django docs suggest: https://docs.djangoproject.com/en/dev/topics/class-based-views/#decorating-class-based-views\n.. _HMAC: http://en.wikipedia.org/wiki/Hash-based_message_authentication_code\n.. _RFC 2104: http://tools.ietf.org/html/rfc2104\n.. _HttpRequest: https://docs.djangoproject.com/en/dev/ref/request-response/#httprequest-objects\n.. _REST Console: http://restconsole.com\n.. _content negotation: http://en.wikipedia.org/wiki/Content_negotiation\n.. _Another take on content negotiation: http://www.b-list.org/weblog/2008/nov/29/multiresponse/\n.. _RESTFulResponse: https://raw.github.com/freshplum/django-simple-rest/master/simple_rest/response.py\n.. _Django Debug Toolbar: https://github.com/django-debug-toolbar/django-debug-toolbar\n.. _pygments: http://pygments.org", "description_content_type": null, "docs_url": null, "download_url": "UNKNOWN", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/freshplum/django-simple-rest", "keywords": "rest,django,api", "license": "UNKNOWN", "maintainer": null, "maintainer_email": null, "name": "django-simple-rest", "package_url": "https://pypi.org/project/django-simple-rest/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/django-simple-rest/", "project_urls": {"Download": "UNKNOWN", "Homepage": "https://github.com/freshplum/django-simple-rest"}, "release_url": "https://pypi.org/project/django-simple-rest/1.4.1/", "requires_dist": null, "requires_python": null, "summary": "A drop dead simple package for creating RESTful APIs on top of Django", "version": "1.4.1", "yanked": false, "html_description": "<div class=\"project-description\">\n            <div id=\"django-simple-rest\">\n<h2>Django Simple REST</h2>\n<p>Django Simple REST is a very light framework that provides only the bare bones basics of what is needed to create RESTful APIs on top of Django.</p>\n</div>\n<div id=\"installation\">\n<h2>Installation</h2>\n<ol>\n<li>Install using pip or easy_install:<ul>\n<li><tt>pip install <span class=\"pre\">django-simple-rest</span></tt> or <tt>easy_install install <span class=\"pre\">django-simple-rest</span></tt></li>\n</ul>\n</li>\n<li>Add the package to the list of installed apps (optional):<ul>\n<li><tt>INSTALLED_APPS += <span class=\"pre\">['simple-rest']</span></tt></li>\n<li>This step is optional and is only needed if you plan on using the custom django command(s).</li>\n</ul>\n</li>\n</ol>\n</div>\n<div id=\"why-another-rest-framework\">\n<h2>Why Another REST Framework?</h2>\n<p>That\u2019s a great question, and the simplest answer to it is that this really isn\u2019t a framework at all, but let me explain a bit further.</p>\n<p>With the introduction of class-based views in version 1.3 of Django, the web framework has nearly everything it needs built in to create RESTful APIs, but just a few things are missing. This \u201cframework\u201d supplies those last few things.</p>\n<p>Think of Simple REST as the code that you would have written to get class-based views working properly as a platform for RESTful API development. Looked at from that view, you start to understand what Simple REST1 is; it\u2019s a collection of code that makes it possible to create RESTful APIs with Django\u2019s class-based views, nothing more and nothing less.</p>\n<p>If you like creating your API by hand, laboring over every last URL, then this is the framework for you. If you want something a little more full featured that handles creating large swaths of your API from Django models and things like that, let me suggest a few excellent frameworks: <a href=\"http://tastypieapi.org/\" rel=\"nofollow\">Tastypie</a>, <a href=\"https://bitbucket.org/jespern/django-piston/wiki/Home\" rel=\"nofollow\">Piston</a>, and <a href=\"http://django-rest-framework.org/\" rel=\"nofollow\">Django REST</a>.</p>\n</div>\n<div id=\"how-do-i-use-it\">\n<h2>How do I use it?</h2>\n<p>There\u2019s nothing to it, it works just like you\u2019d expect it to\u2014assuming you\u2019re familiar with Django\u2019s <a href=\"https://docs.djangoproject.com/en/dev/topics/class-based-views/\" rel=\"nofollow\">class based views</a>. Before we get started though, let\u2019s create a base project and application for us to play around with.</p>\n</div>\n<div id=\"sample-project-setup\">\n<h2>Sample Project Setup</h2>\n<p>The code in the rest of this document will assume that you\u2019re using Django 1.4 or greater (you can follow along using Django 1.3, but your directory structure will be slightly different form the one below) and that you\u2019ve created a project called <tt>simple_rest_example</tt> and an application within it called <tt>phonebook</tt>.</p>\n<p>Once you\u2019ve created your sample project and application, you\u2019ll need to add a new URLconf to the phonebook application where we will add all of our routes for the duration of this tutorial. Then, update the URLconf in the <tt>simple_rest_example</tt> folder to include the URLconf you\u2019ve just created. This will allow us to do all of our work in the phonebook app from here on out. The <tt>urls.py</tt> file in your <tt>simple_rest_example</tt> folder should now look like the following:</p>\n<pre># =============================\n# simple_rest_example/views.py\n# =============================\n\nfrom django.conf.urls import patterns, include, url\n\nurlpatterns = patterns('',\n    url(r'^phonebook/', include('phonebook.urls')),\n)\n</pre>\n<p>If you\u2019ve set everything up correctly, you should have a directory structure that matches the one shown below:</p>\n<pre>simple_rest_example\n        |\n        |___ simple_rest_sample\n        |           |___ __init__.py\n        |           |___ settings.py\n        |           |___ urls.py\n        |           |___ wsgi.py\n        |\n        |___ phonebook\n        |       |\n        |       |___ __init__.py\n        |       |___ models.py\n        |       |___ tests.py\n        |       |___ urls.py\n        |       |___ views.py\n        |\n        |___ manage.py\n</pre>\n<p>Finally, we\u2019re going to create a new model class called <tt>Contact</tt> and create our database to hold all of the contacts in our phonebook. Open up <tt>phonebook/models.py</tt> and update it to match the following:</p>\n<pre># =====================\n# phonebook/models.py\n# =====================\n\nfrom django.db import models\n\nclass Contact(models.Model):\n    fname = models.CharField(max_length=30)\n    lname = models.CharField(max_length=30)\n    phone_number = models.CharField(max_length=12)\n</pre>\n<p>Once you\u2019ve added a new model, update the <tt>settings.py</tt> file in the <tt>simple_rest_example</tt> directory to use a sqlite database named phonebook.db and run the <tt>manage.py syncdb</tt> command to create the database. Make sure to add an administrator account so that we\u2019ll have something to use later on when discussing the authentication options provided by the Simple REST framework.</p>\n</div>\n<div id=\"creating-a-resource\">\n<h2>Creating a Resource</h2>\n<p>Now that you\u2019ve got your development environment set up properly, let\u2019s take a look at an example of how to use the Simple REST framework to create a dead simple phonebook application.</p>\n<p>The sample code below shows one example of how we could create a simple resource for managing lists of contacts:</p>\n<pre># ====================\n# phonebook/views.py\n# ====================\n\nfrom django.http import HttpResponse\nfrom django.core import serializers\n\nfrom simple_rest import Resource\n\nfrom .models import Contact\n\n\nclass Contacts(Resource):\n\n    def get(self, request, contact_id=None, **kwargs):\n        json_serializer = serializers.get_serializer('json')()\n        if contact_id:\n            contacts = json_serializer.serialize(Contact.objects.filter(pk=contact_id))\n        else:\n            contacts = json_serializer.serialize(Contact.objects.all())\n        return HttpResponse(contacts, content_type='application/json', status=200)\n\n    def post(self, request, *args, **kwargs):\n        Contact.objects.create(\n            fname=request.POST.get('fname'),\n            lname=request.POST.get('lname'),\n            phone_number=request.POST.get('phone_number'))\n        return HttpResponse(status=201)\n\n    def delete(self, request, contact_id):\n        contact = Contact.objects.get(pk=contact_id)\n        contact.delete()\n        return HttpResponse(status=200)\n</pre>\n<p>In the example code above, we imported the <tt>Resource</tt> class, which simply inherits from Django\u2019s <tt>View</tt> class and provides the extra sauce to get all of the HTTP methods working properly. Then, we create a new class that inherits from the <tt>Resource</tt> class, and we add a function for each HTTP method that we want to handle.The only requirement is that the function name must match the HTTP method name and be in all lower case letters, so <tt>get</tt> for a GET call and so forth.</p>\n<p>Notice that in the <tt>post</tt> method, the data for the message body of the request can be accessed through the <tt>request.POST</tt> <tt>QueryDict</tt> object. Since all exsiting browsers can only handle GET and POST requests, having <tt><span class=\"pre\">QueryDict``s</span> for GET and POST were all that were needed in the past and so those were all that Django has historically provided. However, with a RESTful API, the server can receive requests using any HTTP method. As a result, the message body for a request can be found in the corresponding ``QueryDict</tt> on the <tt>request</tt> object. For example, if a PUT request is made, the message body data can be accessed through the <tt>request.PUT</tt> <tt>QueryDict</tt>.</p>\n<p>Considering that browsers only support the GET and POST methods, the Simple REST framework also provides an HTTP method override that can be used to make it possible for a typical website to use a RESTful backend. To override the HTTP method, send the attribute <tt>_method</tt>, either in the querystring or in the message body, set to the HTTP method you want the request to be treated as.</p>\n<p>One issue that can arise when allowing the user to use the <tt>_method</tt> option is that the data may not always be in the place you expect it to be. For example, let\u2019s assume that you\u2019ve received a POST request to create a new contact. In this scenario, all of the data can be found in the <tt>request.POST</tt> <tt>QueryDict</tt> object as you would expect. However, if you were to send a GET request with all of the data in the querystring and set the <tt>_method</tt> to POST, our <tt>post</tt> method in the example above would throw an exception. The reason is that request would be treated as a POST request, but the``request.POST`` <tt>QueryDict</tt> object would be empty since the original request was a GET and all of its data would then be found within the <tt>request.GET</tt> <tt>QueryDict</tt>. To make your code more flexible when allowing this option, you should consider using the <tt>request.REQUEST</tt> <tt>QueryDict</tt> instead to get all of the data in the request since Django basically compiles all of the data sent into this single object.</p>\n<p>Now, let\u2019s see how to hook up our resource:</p>\n<pre># ===================\n# phonebook/urls.py\n# ===================\n\nfrom django.conf.urls import patterns, include, url\n\nfrom .views import Contacts\n\nurlpatterns = patterns('',\n    # Allow access to the contacts resource collection\n    url(r'^contacts/?$', Contacts.as_view()),\n\n    # Allow access to a single contact resource\n    url(r'^contacts/(?P&lt;contact_id&gt;[0-9]+)/?$', Contacts.as_view()),\n)\n</pre>\n<p>The sample <tt>urls.py</tt> above shows exactly how we would go about creating the URL patterns for our example resource. Again, if you\u2019re familiar with Django class based views, there should be no surprises here.</p>\n</div>\n<div id=\"authentication\">\n<h2>Authentication</h2>\n<p>So what about authentication? Well, you could simply use the <tt>method_decorator</tt> function as the <a href=\"https://docs.djangoproject.com/en/dev/topics/class-based-views/#decorating-class-based-views\" rel=\"nofollow\">Django docs suggest</a> to decorate each method in your resource with the appropriate authentication decorator. Assuming you want the entire resource protected, you could also decorate the result of the call to <tt>as_view</tt> in the URLconf. Both of these options are completely valid and you can feel free to use them, this framework does provide another option, however.</p>\n<p>In the <tt>simple_rest.auth.decorators</tt> module you\u2019ll find decorators there that you can use to add authentication to your resources. Let\u2019s take a look at a few examples using our sample code from above:</p>\n<pre># ====================\n# phonebook/views.py\n# ====================\n\nfrom django.http import HttpResponse\nfrom django.core import serializers\n\nfrom simple_rest import Resource\nfrom simple_rest.auth.decorators import login_required, admin_required\n\nfrom .models import Contact\n\n\nclass Contacts(Resource):\n\n    def get(self, request, contact_id=None, **kwargs):\n        json_serializer = serializers.get_serializer('json')()\n        if contact_id:\n            contacts = json_serializer.serialize(Contact.objects.filter(pk=contact_id))\n        else:\n            contacts = json_serializer.serialize(Contact.objects.all())\n        return HttpResponse(contacts, content_type='application/json', status=200)\n\n    @login_required\n    def post(self, request, *args, **kwargs):\n        Contact.objects.create(\n            fname=request.POST.get('fname'),\n            lname=request.POST.get('lname'),\n            phone_number=request.POST.get('phone_number'))\n        return HttpResponse(status=201)\n\n    @admin_required\n    def delete(self, request, contact_id):\n        contact = Contact.objects.get(pk=contact_id)\n        contact.delete()\n        return HttpResponse(status=200)\n</pre>\n<p>Assuming that we don\u2019t mind if anyone sees our collection of contacts, we can leave <tt>get</tt> method as is, but let\u2019s assume that we have strict requirements for who can add and delete contacts. Assuming that only registered users can add contacts, we add the <tt>login_required</tt> decorator to the <tt>post</tt> method. We don\u2019t mind if any our members add new contacts, but we don\u2019t want a contact to be accidentally deleted from our database, so let\u2019s decorate that one differently with the <tt>admin_required</tt> decorator. <tt>admin_required</tt> simply makes sure that the user is logged in and is also a super user before they will be granted access to the decorated view method.</p>\n<p>Now, this can get a bit tedious if we have lots of resources and they all tend to have the same authentication requirements. To make a little less tedious, the authentication decorators work on both classes and methods. In the example below we\u2019re adding a superuser requirement to every method offered by the resource simply by decorating the resource class:</p>\n<pre># ====================\n# phonebook/views.py\n# ====================\n\nfrom django.http import HttpResponse\nfrom django.core import serializers\n\nfrom simple_rest import Resource\nfrom simple_rest.auth.decorators import admin_required\n\nfrom .models import Contact\n\n\n@admin_required\nclass Contacts(Resource):\n\n    def get(self, request, contact_id=None, **kwargs):\n        json_serializer = serializers.get_serializer('json')()\n        if contact_id:\n            contacts = json_serializer.serialize(Contact.objects.filter(pk=contact_id))\n        else:\n            contacts = json_serializer.serialize(Contact.objects.all())\n        return HttpResponse(contacts, content_type='application/json', status=200)\n\n    def post(self, request, *args, **kwargs):\n        Contact.objects.create(\n            fname=request.POST.get('fname'),\n            lname=request.POST.get('lname'),\n            phone_number=request.POST.get('phone_number'))\n        return HttpResponse(status=201)\n\n    def delete(self, request, contact_id):\n        contact = Contact.objects.get(pk=contact_id)\n        contact.delete()\n        return HttpResponse(status=200)\n</pre>\n<p>Before we leave the topic of authentication decorators there are two more items to take a look at.</p>\n<p>First, when using the framework\u2019s authentication decorators, the correct RESTful response is returned whenever authentication fails. The typical Django authentication decorators will try to redirect the user to the login page. While this is great when you\u2019re on a webpage, when accessing the resource from any other type of client, receiving a 401 (Unauthorized) is the preferred response and the one that is returned when using Simple REST authentication decorators. For that reason alone, you should prefer the Simple REST authentication decorators over Django\u2019s built in ones when creating a RESTful API.</p>\n<p>The other item to discuss is the <tt>signature_required</tt> authentication decorator. Many APIs use a secure signature to identify and the Simple REST framework provides an authentication decorator that you can use to add that functionality to your resources. The <tt>signature_required</tt> decorator will expect that an <a href=\"http://en.wikipedia.org/wiki/Hash-based_message_authentication_code\" rel=\"nofollow\">HMAC</a>, as defined by <a href=\"http://tools.ietf.org/html/rfc2104\" rel=\"nofollow\">RFC 2104</a>, is sent with the HTTP request in order to authenticate the user. An HMAC is built around a user\u2019s secret key and so there needs to be a way for the <tt>signature_required</tt> decorator to get that secret key and that is done by providing the decorator with a function that takes a Django <a href=\"https://docs.djangoproject.com/en/dev/ref/request-response/#httprequest-objects\" rel=\"nofollow\">HttpRequest</a> object and any number of positional and keyword arguments as defined by the URLconf. Let\u2019s take a look at an example of using the <tt>signature_required</tt> decorator with our sample resource code:</p>\n<pre># ====================\n# phonebook/views.py\n# ====================\n\nfrom django.http import HttpResponse\nfrom django.core import serializers\n\nfrom simple_rest import Resource\nfrom simple_rest.auth.decorators import signature_required\n\nfrom .models import Contact\n\n\ndef secret_key(request, *args, **kwargs):\n    return 'test'\n\n@signature_required(secret_key)\nclass Contacts(Resource):\n\n    def get(self, request, contact_id=None, **kwargs):\n        json_serializer = serializers.get_serializer('json')()\n        if contact_id:\n            contacts = json_serializer.serialize(Contact.objects.filter(pk=contact_id))\n        else:\n            contacts = json_serializer.serialize(Contact.objects.all())\n        return HttpResponse(contacts, content_type='application/json', status=200)\n\n    def post(self, request, *args, **kwargs):\n        Contact.objects.create(\n            fname=request.POST.get('fname'),\n            lname=request.POST.get('lname'),\n            phone_number=request.POST.get('phone_number'))\n        return HttpResponse(status=201)\n\n    def delete(self, request, contact_id):\n        contact = Contact.objects.get(pk=contact_id)\n        contact.delete()\n        return HttpResponse(status=200)\n</pre>\n<p>The <tt>signature_required</tt> decorator takes one argument, a function that, when called with an HttpRequest object and any number of positional and keyword arguments as defined by the URLconf entry for the resource, will return a string representing the secret key for the user making the request. In the example above, we created a function that returns the string \u2018test\u2019 no matter what arguments are passed into the function. Obviously, you don\u2019t want to use a secret key function like this in production, but for our purposes it will suffice.</p>\n<p>To test out the <tt>signature_required</tt> decorator, you can hit any of the URLs for the Contacts resource with a <tt>t</tt> value representing a UTC POSIX timestamp for the current time and a <tt>sig</tt> value representing the HMAC signature generated from the data being sent, the timestamp, and the secret key (in this case, \u2018test\u2019). If you\u2019ve added \u2018simple_rest\u2019 to your list of <tt>INSTALLED_APPS</tt>, you can use the handy <tt>urlencode</tt> command to calculate the signature and timestamp for testing your resources. The command line below shows how to generate the timestamp and signature values for a simple GET request. To test the GET call, just enter the line below into your command line and copy and paste the response to the querystring part of the URL:</p>\n<pre>% manage.py urlencode --secret-key=test\n</pre>\n<p>To URL encode the request body as well, just include each piece of data as a key=value pair in the call to the <tt>urlencode</tt> command. As an example of how to do so, let\u2019s test the <tt>POST</tt> call. Run the following command in your terminal and copy the results into either the request body or the querystring portion of the URL:</p>\n<pre>% manage.py urlencode --secret-key fname=Winston lname=Smith phone_number=555-555-5555\n</pre>\n<p>Simple REST provides one more decorator that\u2019s sort of a mashup of two other decorators. The decorator <tt>auth_required</tt> works in the same manner as the <tt>signature_required</tt> (meaning that it takes a function that returns a secret key) but it requires that the user is either logged in or has a valid signature before granting them access to the resource.</p>\n<p>Finally, you can create your own authentication decorators with relative ease. The Simple REST framework provides two functions to help out with this task. First, the <tt>request_passes_test</tt> function can be used to create a new decorator function. Then the <tt>wrap_object</tt> function can be used to properly decorate either an entire class or a specific method within. The code below shows a sample of how you would create a decorator that makes sure a user has the proper permission to access a resource:</p>\n<pre>from simple_rest.auth.decorators import request_passes_test\nfrom simple_rest.utils.decorators import wrap_object\n\n\ndef has_permission(request, *args, **kwargs):\n    return False # Make sure the user has the proper permission here\n\ndef permission_required(obj):\n    decorator = request_passes_test(has_permission,\n        message=\"You don't have permission to access this resource\",\n        status=403\n    )\n    return wrap_object(obj, decorator)\n</pre>\n</div>\n<div id=\"form-validation\">\n<h2>Form Validation</h2>\n<p>If you want to use a form to validate the data in a REST request (e.g., a POST to create a new resource) you can run into some problems using Django\u2019s ModelForm class. Specifically, let\u2019s assume that you have a model that has several optional attributes with default values specified. If you send a request to create a new instance of this class but only include data for a handful of the optional attributes, you\u2019d expect that the form object you create would not fail validation since saving the object would mean that the new record would simply end up with the default values for the missing attributes. This is, however, not the case with Django\u2019s ModelForm class. It is expecting to see all of the data in every request and will fail if any is missing.</p>\n<p>To solve this issue, the Simple REST framework provides a <tt>ModelForm</tt> class in <tt>simple_rest.forms</tt> that inherits from Django\u2019s <tt>ModelForm</tt> and initializes the incoming request with the default values from the underlying model object for any missing attributes. This allows the form validation to work correctly and for the new object to be saved with only a portion of the full set of attributes sent within the request. To use the class, simply import it instead of the normal Django <tt>ModelForm</tt> and have your form class inherit from it instead of Django\u2019s.</p>\n<p>To give it a try, let\u2019s add another field to the <tt>Contact</tt> model class in <tt>phonebook/models.py</tt> to hold an honorific for a contact. We\u2019ll make this field optional and make the default title be \u2018(no title)\u2019. With these new changes, the <tt>models.py</tt> file should match the one listed below:</p>\n<pre># ====================\n# phonebook/models.py\n# ====================\n\nfrom django.db import models\n\nclass Contact(models.Model):\n    title = models.CharField(max_length=10, default='(no title)')\n    fname = models.CharField(max_length=30)\n    lname = models.CharField(max_length=30)\n    phone_number = models.CharField(max_length=12)\n</pre>\n<p>Once, you\u2019ve updated the <tt>models.py</tt> file, either delete and rerun <tt>syncdb</tt> or add the new column to the phonebook_contact table by hand. Then, create a new form class called <tt>ContactForm</tt> in the <tt>phonebook/views.py</tt> file and set its model to <tt>Contact</tt>. Then you can remove the code to create a new contact in the <tt>post</tt> method and replace it with code that uses the new <tt>Contactform</tt> class. The result should be similar to the following:</p>\n<pre># ====================\n# phonebook/views.py\n# ====================\n\nfrom django.http import HttpResponse\nfrom django.core import serializers\n\nfrom simple_rest import Resource\nfrom simple_rest.auth.decorators import signature_required\nfrom simple_rest.forms import ModelForm\n\nfrom .models import Contact\n\n\ndef secret_key(request, *args, **kwargs):\n    return 'test'\n\n\nclass ContactForm(ModelForm):\n    class Meta:\n        model = Contact\n\n\n@signature_required(secret_key)\nclass Contacts(Resource):\n\n    def get(self, request, contact_id=None, **kwargs):\n        json_serializer = serializers.get_serializer('json')()\n        if contact_id:\n            contacts = json_serializer.serialize(Contact.objects.filter(pk=contact_id))\n        else:\n            contacts = json_serializer.serialize(Contact.objects.all())\n        return HttpResponse(contacts, content_type='application/json', status=200)\n\n    def post(self, request, *args, **kwargs):\n        form = ContactForm(request.POST)\n        if not form.is_valid():\n            return HttpResponse(status=409)\n        form.save()\n        return HttpResponse(status=201)\n\n    def delete(self, request, contact_id):\n        contact = Contact.objects.get(pk=contact_id)\n        contact.delete()\n        return HttpResponse(status=200)\n</pre>\n</div>\n<div id=\"content-negotiation\">\n<h2>Content Negotiation</h2>\n<p>A key factor to having a truly RESTful API is the decoupling of your resources from their representation. In other words, whether or not a resource is delivered as XML or JSON shouldn\u2019t be part of the resource itself. This is where <a href=\"#content-negotiation\" rel=\"nofollow\">content negotiation</a> comes into play. It provides a standardized way for a single URI to serve a resource while still allowing the user to request several different representations of that resource. Content negotiation is part of the HTTP specification and the mechanism it provides the client for requesting a representation is through the Accept header. In the Accept header the client gives a list of acceptable representations and the server works out the best possible representation of the resource to deliver according to what is available on the server and desired representations requested.</p>\n<p>The Simple Rest framework provides a mechanism by which you can add content negotiation to your resources. This functionality is provided in the <a href=\"https://raw.github.com/freshplum/django-simple-rest/master/simple_rest/response.py\" rel=\"nofollow\">RESTfulResponse</a> class. The <tt>RESTfulResponse</tt> class is an implementation of the method described by James Bennett in his article \u201c<a href=\"http://www.b-list.org/weblog/2008/nov/29/multiresponse/\" rel=\"nofollow\">Another take on content negotiation</a>\u201d. The way it works is simple, create an instance of the class and use it as a decorator on your resource. The rest of this section will take a look at a few examples to show the different options available to you when using the <tt>RESTfulResonse</tt> class to provide multiple representations of your resource.</p>\n<p>The first example below shows the absolute simplest way to use the <tt>RESTfulResponse</tt> class. By default, the RESTfulResponse provides JSON, HTML, and plain text formats. JSON is one of the most popular resource representations (arguably the most popular, at least for APIs being created today) and so the <tt>RESTfulResponse</tt> class provides support for it right out of the box. The HTML format is mainly provided to make it easy to view the data in a browser and also to allow the <a href=\"https://github.com/django-debug-toolbar/django-debug-toolbar\" rel=\"nofollow\">Django Debug Toolbar</a> to function properly when testing RESTful APIs. The HTML representation will format the data as JSON and, if you have <a href=\"http://pygments.org\" rel=\"nofollow\">pygments</a> installed, the data will syntax highlighted as well.</p>\n<p>To provide a JSON representation of your resource using the RESTfulResponse class, you simply create an instance of it and decorate your resource just like the example shows below:</p>\n<pre># ====================\n# phonebook/views.py\n# ====================\n\nfrom django.http import HttpResponse\n\nfrom simple_rest import Resource\nfrom simple_rest.auth.decorators import signature_required\nfrom simple_rest.forms import ModelForm\nfrom simple_rest.response import RESTfulResponse\n\nfrom .models import Contact\n\n\ndef secret_key(request, *args, **kwargs):\n    return 'test'\n\n\nclass ContactForm(ModelForm):\n    class Meta:\n        model = Contact\n\n\n@signature_required(secret_key)\nclass Contacts(Resource):\n\n    @RESTfulResponse()\n    def get(self, request, contact_id=None, **kwargs):\n        if contact_id:\n            contacts = Contact.objects.filter(pk=contact_id)\n        else:\n            contacts = Contact.objects.all()\n        return contacts\n\n    def post(self, request, *args, **kwargs):\n        form = ContactForm(request.POST)\n        if not form.is_valid():\n            return HttpResponse(status=409)\n        form.save()\n        return HttpResponse(status=201)\n\n    def delete(self, request, contact_id):\n        contact = Contact.objects.get(pk=contact_id)\n        contact.delete()\n        return HttpResponse(status=200)\n</pre>\n<p>Notice that in the <tt>get</tt> method above we are no longer returning an HttpResponse object, instead we return the <tt>QuerySet</tt> of the contacts that matched the GET request. When using content negotiation on your resources, simple serializable python objects are the typical response. If you return an HttpResponse object it will simply bypass the content negotiation and just return the response object as is.</p>\n<p>In the example above we only decorated the <tt>get</tt> method, but an instance of RESTfulResponse works just as the authentication decorators we saw earlier in that they can be used to decorate methods or full classes. In the next example we decorate the entire resource and, though we can continue to return an HttpResponse object, if we want all of our methods to enjoy the benefits provided by the RESTfulResponse decorator, we need to change what they return from an HttpResponse object to a serializable python object. The code below shows how you can do that for the simple example we saw above:</p>\n<pre># ====================\n# phonebook/views.py\n# ====================\n\nfrom django.http import HttpResponse\n\nfrom simple_rest import Resource\nfrom simple_rest.auth.decorators import signature_required\nfrom simple_rest.forms import ModelForm\nfrom simple_rest.response import RESTfulResponse\n\nfrom .models import Contact\n\n\ndef secret_key(request, *args, **kwargs):\n    return 'test'\n\n\nclass ContactForm(ModelForm):\n    class Meta:\n        model = Contact\n\n\n@RESTfulResponse()\n@signature_required(secret_key)\nclass Contacts(Resource):\n\n    def get(self, request, contact_id=None, **kwargs):\n        if contact_id:\n            contacts = Contact.objects.filter(pk=contact_id)\n        else:\n            contacts = Contact.objects.all()\n        return contacts\n\n    def post(self, request, *args, **kwargs):\n        form = ContactForm(request.POST)\n        if not form.is_valid():\n            return HttpResponse(status=409)\n        form.save()\n        return None, 201\n\n    def delete(self, request, contact_id):\n        contact = Contact.objects.get(pk=contact_id)\n        contact.delete()\n        return None, 200\n</pre>\n<p>One thing to notice in the code above is that the <tt>post</tt> method returns a tuple. That\u2019s because when we use the <tt>RESTfulResponse</tt> decorator it\u2019s expected that we are returning a tuple the first element of which is the object to be serialized and returned to the client. The second (optional) element of the response tuple is the status code of the response. If only a serializable object is returned (as we\u2019ve done in the <tt>get</tt> method), the default status code of 200 (OK) is used. If, on the other hand, you\u2019d like to return an empty response with just the HTTP Response Code set to signify the success or failure of the operation, you can simply return <tt>None</tt> for the data object and the desired status code as the second element in the tuple. In the <tt>post</tt> method in the code sample above we see an example of this. Since performing a POST on our resource creates a new instance of that resource we want to return a 201 (Created) signifying that a new resource was succesfully created and the response body can be empty.</p>\n<p>Finally, content negotiation doesn\u2019t really do much if you only provide a single representation of your resource. The question then becomes: how do we provide more than just the default JSON representation? The answer is that we pass into the <tt>RESTfulResponse</tt> constructor a dict that maps mime types to either a python callable that can be called on the data object to transform it into the designated representation or a string that points to a template that will be used to produce the desired representation. In this example we\u2019ll be using a template to transform the resource into an XML representation.</p>\n<p>The first step is to create our XML template. Create a new folder in the phonebook application\u2019s directory called <tt>templates</tt> and add a file called <tt>phonebook.xml</tt> to it. Make sure that the <tt>django.template.loaders.app_directories.Loader</tt> line is included, and uncommented, in the <tt>TEMPLATE_LOADERS</tt> tuple in <tt>simple_rest_example/settings.py</tt>. This will ensure that Django will pick up templates within the apps that you\u2019ve registered in the <tt>INSTALLED_APPS</tt> tuple.</p>\n<p>Now we just need to add some XML/code to turn our response data into proper XML. The <tt>RESTfulResponse</tt> decorator will automatically provide any data returned from the resource to the template under the name <tt>context</tt>. In the exmaple code below we sort the contacts in the <tt>context</tt> variable according to last name and return a contact element that has fname, lname, phone_number, and title subelements:</p>\n<pre>&lt;?xml version=\"1.0\"?&gt;\n{% with contacts=context.values|dictsort:\"lname\" %}\n&lt;phonebook&gt;\n  {% for contact in contacts %}\n      &lt;contact&gt;\n        &lt;fname&gt;{{ contact.fname }}&lt;/fname&gt;\n        &lt;lname&gt;{{ contact.lname }}&lt;/lname&gt;\n        &lt;phone_number&gt;{{ contact.phone_number }}&lt;/phone_number&gt;\n        &lt;title&gt;{{ contact.title }}&lt;/title&gt;\n      &lt;/contact&gt;\n  {% endfor %}\n&lt;/phonebook&gt;\n{% endwith %}\n</pre>\n<p>Once we\u2019ve got the template created, we just need to create a new RESTfulResponse decorator with the correct mime type mapped to the template. The code below shows how to do that by passing a dictionary that maps supported mimetypes to either a function or a template filename. The RESTFulResponse class also inherits from the <a href=\"http://bit.ly/TXcyXV\" rel=\"nofollow\">collections.MutableMapping</a> Abstract Base Class, so you could have just as easily added the mimetype to function/template mapping like you would with any ordinary python dict. Also keep in mind that JSON, HTML, and plain text are provided by default, so our mime type mapping dict doesn\u2019t need to contain an entry for any of those\u2014unless you want to override the default behavior:</p>\n<pre># ====================\n# phonebook/views.py\n# ====================\n\nfrom django.http import HttpResponse\n\nfrom simple_rest import Resource\nfrom simple_rest.auth.decorators import signature_required\nfrom simple_rest.forms import ModelForm\nfrom simple_rest.response import RESTfulResponse\n\nfrom .models import Contact\n\n\ndef secret_key(request, *args, **kwargs):\n    return 'test'\n\njson_or_xml = RESTfulResponse({'application/xml': 'phonebook.xml'})\n# Since RESTfulResponse inherits from collections.MutableMapping, we could\n# have also done the following instead of passing a dict to the constructor\n# json_or_xml = RESTfulResponse()\n# json_or_xml['application/xml'] = 'phonebook.xml'\n\n\nclass ContactForm(ModelForm):\n    class Meta:\n        model = Contact\n\n\n@json_or_xml\n@signature_required(secret_key)\nclass Contacts(Resource):\n\n    def get(self, request, contact_id=None, **kwargs):\n        if contact_id:\n            contacts = Contact.objects.filter(pk=contact_id)\n        else:\n            contacts = Contact.objects.all()\n        return contacts\n\n    def post(self, request, *args, **kwargs):\n        form = ContactForm(request.POST)\n        if not form.is_valid():\n            return HttpResponse(status=409)\n        form.save()\n        return None, 201\n\n    def delete(self, request, contact_id):\n        contact = Contact.objects.get(pk=contact_id)\n        contact.delete()\n        return None, 200\n</pre>\n<p>With the new changes in place, you can get either XML or JSON just by changing the Accept header in your request. The only problem with this scenario though is that you can\u2019t always simply change the Accept header. For example, a simple HTML form (no JavaScript) will always send a request with Accept headers set to HTML (or XHTML) and probably some form of XML. If you want to specify the format of the response, and you don\u2019t have access to the Accept header, you can either append a file extension to the URL or pass a <cite>_format</cite> attribute in the request\u2019s querystring or message body. If either a file extension or an override attribute is used, the response format will be determined using it, otherwise, if neither is present, it will fallback on the Accept header to determine the requested format.</p>\n<p>Using the <cite>_format</cite> override attribute is easy, simply add the attribute to the HTTP call in either the querystring or the message body and it just works. there\u2019s absolutely nothing that needs to be done on the backend to get the override attribute working. If, on the other hand, you want to use the file extension override, you will need to alter your URL patterns to accept an optional named pattern. The name you should use for the optional file extenstion is the same as the name for the override attribute. The example below shows the newly altered <tt>phonebook/urls.py</tt> file with the optional file extension:</p>\n<pre># ===================\n# phonebook/urls.py\n# ===================\n\nfrom django.conf.urls import patterns, include, url\n\nfrom .views import Contacts\n\nurlpatterns = patterns('',\n    # Allow access to the contacts resource collection\n    url(r'^contacts(\\.(?P&lt;_format&gt;[a-zA-Z]+))?/?$', Contacts.as_view()),\n\n    # # Allow access to a single contact resource\n    url(r'^contacts/(?P&lt;contact_id&gt;[0-9]+)(\\.(?P&lt;_format&gt;[a-zA-Z]+))?/?$',\n        Contacts.as_view()),\n)\n</pre>\n<p>Keep in mind that the example above will be passing a new keyword argument into your view methods, so you\u2019ll need to make sure that the last parameter on your view methods is the catch all parameter for keyword arguments (<cite>**kwargs</cite>).</p>\n<p>With the addition above made to the URLconf, you can now request differnt response formats using either a file extension on the URL, a <cite>_format</cite> attribute in querystring or message body, or by specifying the desired format in the Accept header. The order of precedence is override attribute, then file extension, and finally the HTTP Accept header.</p>\n</div>\n\n          </div>"}, "last_serial": 790640, "releases": {"0.3.1": [{"comment_text": "", "digests": {"md5": "683986f4c31644a192d14f72d37255ee", "sha256": "45db52ca1e13614fd2a3f00e889fa44b8044528f36b021544b9da336eb8f26f9"}, "downloads": -1, "filename": "django-simple-rest-0.3.1.tar.gz", "has_sig": false, "md5_digest": "683986f4c31644a192d14f72d37255ee", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 10329, "upload_time": "2012-08-03T01:25:27", "upload_time_iso_8601": "2012-08-03T01:25:27.709297Z", "url": "https://files.pythonhosted.org/packages/b1/d1/a88c40b1a15a7bbfac2aa3898bec226c19dcaf1f15edf50b69204c6b8c49/django-simple-rest-0.3.1.tar.gz", "yanked": false}], "0.3.2": [{"comment_text": "", "digests": {"md5": "e1a3c2b4b5e34cfced616cf36d95bb85", "sha256": "bb70d6e6353caca1afbb53be89254f01b1869ad5420fbe976b1b644b7d10ebb3"}, "downloads": -1, "filename": "django-simple-rest-0.3.2.tar.gz", "has_sig": false, "md5_digest": "e1a3c2b4b5e34cfced616cf36d95bb85", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 10225, "upload_time": "2012-08-03T01:36:58", "upload_time_iso_8601": "2012-08-03T01:36:58.818592Z", "url": "https://files.pythonhosted.org/packages/57/a2/34b50ecccf6054dc475a4158560eaa9fe8ca5fae39e3f6011e986c611aa6/django-simple-rest-0.3.2.tar.gz", "yanked": false}], "0.3.3": [{"comment_text": "", "digests": {"md5": "a73d6b244d30b04284bac4be9fe52865", "sha256": "7c33cf1241f85e24a01fbd68a723270554ddf8e78fdc73abd710d18420b942a2"}, "downloads": -1, "filename": "django-simple-rest-0.3.3.tar.gz", "has_sig": false, "md5_digest": "a73d6b244d30b04284bac4be9fe52865", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 15364, "upload_time": "2012-08-03T02:10:09", "upload_time_iso_8601": "2012-08-03T02:10:09.490173Z", "url": "https://files.pythonhosted.org/packages/df/19/f895a241ac1e1f8267f56d4d6435a4ed8caa46d98ea8cffc53b56bdf8176/django-simple-rest-0.3.3.tar.gz", "yanked": false}], "0.3.4": [{"comment_text": "", "digests": {"md5": "a12a891bc6922cb19e781a6c38ab39c1", "sha256": "4b5adbcea83fb7083f62127580c67926b4553e4af1782b22433200c52f0b5bdb"}, "downloads": -1, "filename": "django-simple-rest-0.3.4.tar.gz", "has_sig": false, "md5_digest": "a12a891bc6922cb19e781a6c38ab39c1", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 15360, "upload_time": "2012-08-03T02:41:16", "upload_time_iso_8601": "2012-08-03T02:41:16.284647Z", "url": "https://files.pythonhosted.org/packages/a2/26/f772de267e2aa7cde357e78e97b875091842d4f8ec585252cb81a9eebc4e/django-simple-rest-0.3.4.tar.gz", "yanked": false}], "0.4.5": [{"comment_text": "", "digests": {"md5": "217833c3c91fac03674ac9ba9d9abccc", "sha256": "94fb8ee174c248494329ad30c34bc74eadad66e5285bb220239d3e2ce7eea2ff"}, "downloads": -1, "filename": "django-simple-rest-0.4.5.tar.gz", "has_sig": false, "md5_digest": "217833c3c91fac03674ac9ba9d9abccc", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 11782, "upload_time": "2012-08-27T20:19:58", "upload_time_iso_8601": "2012-08-27T20:19:58.562175Z", "url": "https://files.pythonhosted.org/packages/8b/a4/417630dfe291797b9fc69b4dd60e0ccbe2f24be27ba4ac7eb3f7b7e9cd9e/django-simple-rest-0.4.5.tar.gz", "yanked": false}], "0.4.6": [{"comment_text": "", "digests": {"md5": "7434210210c86ffaa55c099aaa25e750", "sha256": "c7d8e43e9d9366c80f91e34b474388c58d034880886c5624fb73f5f6936f685f"}, "downloads": -1, "filename": "django-simple-rest-0.4.6.tar.gz", "has_sig": false, "md5_digest": "7434210210c86ffaa55c099aaa25e750", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 12475, "upload_time": "2012-08-27T20:24:59", "upload_time_iso_8601": "2012-08-27T20:24:59.758422Z", "url": "https://files.pythonhosted.org/packages/d8/c4/59d5ff88eb3330570bad386ba1c75acfcfc1b314504ebed5bd184cd288db/django-simple-rest-0.4.6.tar.gz", "yanked": false}], "0.4.7": [{"comment_text": "", "digests": {"md5": "d30f7f603749bde2aeb694bc56ba3ef1", "sha256": "31ff35754f3d810ff77370df41bce2035b923089629bac9e881724720a368598"}, "downloads": -1, "filename": "django-simple-rest-0.4.7.tar.gz", "has_sig": false, "md5_digest": "d30f7f603749bde2aeb694bc56ba3ef1", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 12474, "upload_time": "2012-08-27T20:43:18", "upload_time_iso_8601": "2012-08-27T20:43:18.566739Z", "url": "https://files.pythonhosted.org/packages/ac/c4/89b2e37ca153bf6037cd77874b74b584ba8c9260d7a24e5f48d039dc4d76/django-simple-rest-0.4.7.tar.gz", "yanked": false}], "1.0.0": [{"comment_text": "", "digests": {"md5": "d29a7f0bf3e511e086ec68d204789e0a", "sha256": "d17b87ffb07f4007e0b4098d09be23e5a0145ae3b1bd3471f35b932e4be5566a"}, "downloads": -1, "filename": "django-simple-rest-1.0.0.tar.gz", "has_sig": false, "md5_digest": "d29a7f0bf3e511e086ec68d204789e0a", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 33384, "upload_time": "2012-09-07T20:33:11", "upload_time_iso_8601": "2012-09-07T20:33:11.361768Z", "url": "https://files.pythonhosted.org/packages/65/27/2fe2027ddf3b9d778049b13a65f8efe65983fc7181f0564ccfe7419cd74b/django-simple-rest-1.0.0.tar.gz", "yanked": false}], "1.0.1": [{"comment_text": "", "digests": {"md5": "a3031e60e24ad9ec8ef3778bd29fde91", "sha256": "52e2f9ba390458f630af371e2428f24f872bb71ad77373a324b84bcd284a2423"}, "downloads": -1, "filename": "django-simple-rest-1.0.1.tar.gz", "has_sig": false, "md5_digest": "a3031e60e24ad9ec8ef3778bd29fde91", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 33388, "upload_time": "2012-09-07T20:36:47", "upload_time_iso_8601": "2012-09-07T20:36:47.678528Z", "url": "https://files.pythonhosted.org/packages/26/06/7edfbdde8ec4b73399807a6b0c375ad748084854be0c33c9bbf20b756029/django-simple-rest-1.0.1.tar.gz", "yanked": false}], "1.1.0": [{"comment_text": "", "digests": {"md5": "6af1cc80c25a66095dd2e12876c8df18", "sha256": "3781450955b7f5daf109440b0a91c4761a9ac1750f53a405628ed88ca8b37466"}, "downloads": -1, "filename": "django-simple-rest-1.1.0.tar.gz", "has_sig": false, "md5_digest": "6af1cc80c25a66095dd2e12876c8df18", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 33674, "upload_time": "2012-09-10T07:59:33", "upload_time_iso_8601": "2012-09-10T07:59:33.177029Z", "url": "https://files.pythonhosted.org/packages/9d/08/1fd543288b8f1ab0f9ba9117f389bfb57ec10721248287cb2a0693f333cd/django-simple-rest-1.1.0.tar.gz", "yanked": false}], "1.3.0": [{"comment_text": "", "digests": {"md5": "9d9bb091d9a426b0ca29c83a7ead4645", "sha256": "a933f766ab03f49e5a7858c2e3ccdbde7ff2b95c666e4131b934c58d78dd912e"}, "downloads": -1, "filename": "django-simple-rest-1.3.0.tar.gz", "has_sig": false, "md5_digest": "9d9bb091d9a426b0ca29c83a7ead4645", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 35137, "upload_time": "2012-09-13T01:38:17", "upload_time_iso_8601": "2012-09-13T01:38:17.441137Z", "url": "https://files.pythonhosted.org/packages/66/a1/e956eeef1daddc4bfab6a1354299667b04e90d9466cba4dcf02b3fec108d/django-simple-rest-1.3.0.tar.gz", "yanked": false}], "1.3.1": [{"comment_text": "", "digests": {"md5": "c667b14ff4436b29eb60e1c3a6f580ab", "sha256": "15fcc15d71e896340ee4e61a3d971ba8769a396753d9c77d407522deb3d12153"}, "downloads": -1, "filename": "django-simple-rest-1.3.1.tar.gz", "has_sig": false, "md5_digest": "c667b14ff4436b29eb60e1c3a6f580ab", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 35127, "upload_time": "2012-10-12T09:14:13", "upload_time_iso_8601": "2012-10-12T09:14:13.011691Z", "url": "https://files.pythonhosted.org/packages/09/c5/820a57d57f35fe491fc0beb49483bf4451793de48f5726de7649099f8dde/django-simple-rest-1.3.1.tar.gz", "yanked": false}], "1.4.0": [{"comment_text": "", "digests": {"md5": "a9e5997a5e3f70e819574b6a5a6f02f9", "sha256": "f6b8a36a3f57709a5b0f602a3d5f0ab7de51c0dbf276cb6632edc74517b09846"}, "downloads": -1, "filename": "django-simple-rest-1.4.0.tar.gz", "has_sig": false, "md5_digest": "a9e5997a5e3f70e819574b6a5a6f02f9", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 36299, "upload_time": "2012-10-16T07:52:26", "upload_time_iso_8601": "2012-10-16T07:52:26.982699Z", "url": "https://files.pythonhosted.org/packages/96/ce/90898b9a92043492f772a0abd90971bc9acaa3e5f0a90e866f710eecab55/django-simple-rest-1.4.0.tar.gz", "yanked": false}], "1.4.1": [{"comment_text": "", "digests": {"md5": "b9612809296e488422c3ae327059c1d6", "sha256": "29caf6e132fda80d4aa7105eb4423a2d1e700f3e1be861e750c18a884b8d01a0"}, "downloads": -1, "filename": "django-simple-rest-1.4.1.tar.gz", "has_sig": false, "md5_digest": "b9612809296e488422c3ae327059c1d6", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 36303, "upload_time": "2012-10-16T08:16:17", "upload_time_iso_8601": "2012-10-16T08:16:17.072664Z", "url": "https://files.pythonhosted.org/packages/05/bf/e7ecfe74bb69945c3d52644e1de9b2ae1ca2d6716627c671813116ee1371/django-simple-rest-1.4.1.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "b9612809296e488422c3ae327059c1d6", "sha256": "29caf6e132fda80d4aa7105eb4423a2d1e700f3e1be861e750c18a884b8d01a0"}, "downloads": -1, "filename": "django-simple-rest-1.4.1.tar.gz", "has_sig": false, "md5_digest": "b9612809296e488422c3ae327059c1d6", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 36303, "upload_time": "2012-10-16T08:16:17", "upload_time_iso_8601": "2012-10-16T08:16:17.072664Z", "url": "https://files.pythonhosted.org/packages/05/bf/e7ecfe74bb69945c3d52644e1de9b2ae1ca2d6716627c671813116ee1371/django-simple-rest-1.4.1.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:53:21 2020"}